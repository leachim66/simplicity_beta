/**********************
D E C L A R A T I O N S
**********************/

#ifndef IMPORT
  #define IMPORT extern
#endif

#ifndef EXPORT
  #define EXPORT
#endif

#ifndef NULL
  #define NULL ((void *)0)
#endif
#define false 0
#define true 1
typedef __INT8_TYPE__ int8_t;
typedef __INT16_TYPE__ int16_t;
typedef __INT32_TYPE__ int32_t;
typedef __INT64_TYPE__ int64_t;
typedef __INTPTR_TYPE__ intptr_t;

#ifdef __UINT8_TYPE__
  typedef __UINT8_TYPE__ uint8_t;
#else
  typedef unsigned __INT8_TYPE__ uint8_t;
#endif

#ifdef __UINT16_TYPE__
  typedef __UINT16_TYPE__ uint16_t;
#else
  typedef unsigned __INT16_TYPE__ uint16_t;
#endif

#ifdef __UINT32_TYPE__
  typedef __UINT32_TYPE__ uint32_t;
#else
  typedef unsigned __INT32_TYPE__ uint32_t;
#endif

#ifdef __UINT64_TYPE__
  typedef __UINT64_TYPE__ uint64_t;
#else
  typedef unsigned __INT64_TYPE__ uint64_t;
#endif

#ifdef __UINTPTR_TYPE__
  typedef __UINTPTR_TYPE__ uintptr_t;
#else
  typedef unsigned __INTPTR_TYPE__ uintptr_t;
#endif
typedef __SIZE_TYPE__ size_t;
typedef union NODE NODE;
IMPORT void *coll_node_buf;
IMPORT void *coll_node_buf_end;
typedef void (*DESTRUCTOR)(void *);
typedef struct MEMORY_BLOCK {
  struct MEMORY_BLOCK *link;
  long mark;
  DESTRUCTOR destructor;
} MEMORY_BLOCK;
IMPORT long current_mark;
typedef void (*FUNC)(void);
typedef NODE *(*NODE_GETTER)(void);
typedef void (*NODE_SETTER)(NODE *);
IMPORT char *to_c_string(NODE *node);
IMPORT NODE *get_dynamic_slot(int id);
IMPORT void define_dynamic_slot(int id, NODE *node);
IMPORT NODE *get_dynamic_cell(int id);
IMPORT void set_dynamic_cell(int id, NODE *node);
IMPORT void define_dynamic_cell(int id, NODE *node);
typedef struct FRAME_INFO {
  int var_count;
  const char *var_names[];
} FRAME_INFO;
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define REGISTER register
#else
  #define REGISTER IMPORT
#endif
typedef struct FRAME {
  FUNC cont;
  struct FRAME *caller_frame;
  long caller_result_count;
  long slot_count;
  NODE *slots[0];
} FRAME;
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define ASM(x) asm(x)
#else
  #define ASM(x)
#endif
REGISTER FRAME *arguments ASM("r12");
IMPORT int result_count;
typedef struct CONTINUATION_INFO {
  FUNC continuation;
  struct FRAME_INFO *frame_info;
  uint16_t first_line;
  uint16_t last_line;
  uint8_t first_column;
  uint8_t last_column;
  uint8_t submodule_index;
  uint8_t unused;
} CONTINUATION_INFO;
typedef void *COLLECTOR(void *);
IMPORT uint32_t to_int8(NODE *node);
IMPORT uint64_t to_int16(NODE *node);
IMPORT uint32_t to_int32(NODE *node);
IMPORT uint64_t to_int64(NODE *node);
IMPORT uint32_t to_uint8(NODE *node);
IMPORT uint64_t to_uint16(NODE *node);
IMPORT uint32_t to_uint32(NODE *node);
IMPORT uint64_t to_uint64(NODE *node);
IMPORT uint32_t to_uchar32(NODE *node);
IMPORT int to_bool(NODE *node);
IMPORT int to_int(NODE *node);
IMPORT long to_long(NODE *node);
IMPORT double to_double(NODE *node);
IMPORT uint8_t *to_octets(NODE *node, long *size_p);
IMPORT NODE *get_item_of(NODE *node, long idx);
IMPORT long length_of(NODE *node);
IMPORT void unfold(NODE *node);
IMPORT long debug_string(NODE *node, int indent, int max_depth, char *buf);
typedef struct VTABLE {
  size_t size;
  COLLECTOR *collect;
  int8_t (*to_int8)(NODE *);
  int16_t (*to_int16)(NODE *);
  int32_t (*to_int32)(NODE *);
  int64_t (*to_int64)(NODE *);
  uint8_t (*to_uint8)(NODE *);
  uint16_t (*to_uint16)(NODE *);
  uint32_t (*to_uint32)(NODE *);
  uint64_t (*to_uint64)(NODE *);
  uint32_t (*to_uchar32)(NODE *);
  int (*to_bool)(NODE *);
  int (*to_int)(NODE *);
  long (*to_long)(NODE *);
  double (*to_double)(NODE *);
  char *(*to_c_string)(NODE *);
  uint8_t *(*to_octets)(NODE *, long *size_p);
  NODE *(*get_item_of)(NODE *, long idx);
  long (*length_of)(NODE *);
  void (*unfold)(NODE *);
  long (*debug_string)(NODE *, int indent, int max_depth, char *buf);
} VTABLE;
typedef struct OCTREE {
  struct OCTREE *nodes[8];
} OCTREE;
typedef struct ATTRIBUTES {
  struct VTABLE *vtable;
  struct OCTREE *nodes[7];
} ATTRIBUTES;
typedef struct DYNAMICS {
  struct OCTREE *nodes[8];
} DYNAMICS;
typedef struct CONTINUATION {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int result_count;
  struct FRAME *frame;
  struct DYNAMICS *dynamics;
  struct FRAME *exit_frame; // used by exit-functions
} CONTINUATION;
typedef struct CLOSURE {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int parameter_count;
  struct FRAME *frame;
} CLOSURE;
REGISTER NODE *myself ASM("r13");
IMPORT NODE *get_attribute(NODE *node, int idx);
REGISTER int argument_count ASM("ebx");
IMPORT void invalid_arguments_error(void);
IMPORT NODE *clone_object_and_attributes(NODE *node);
IMPORT void *update_start_p;
IMPORT void *node_p;
IMPORT void set_attribute_value(ATTRIBUTES *attributes, int idx, void *attr);
REGISTER FUNC func ASM("r14");
REGISTER FRAME *frame ASM("r15");
typedef struct MODULE_INFO {
  struct MODULE_INFO *link;
  const char *name;
  struct CONTINUATION_INFO *continuation_info;
  int continuation_count;
  NODE **var_tab;
  const char **var_names;
  int top_level_count;
  const char **used_namespaces;
  const char *filenames[];
} MODULE_INFO;
IMPORT void allocate_initialized_frame_gc(int slot_idx, int slot_count);
IMPORT NODE *undefined;
IMPORT void initialize_maybe_future(NODE *var, NODE *val);
IMPORT void invalid_results_error(void);
IMPORT NODE *create_closure(FUNC type, int par_count);
IMPORT NODE *empty_string;
IMPORT NODE *create_cell(void);
typedef struct CELL {
  FUNC type;
  struct ATTRIBUTES *attributes;
  NODE *contents;
} CELL;
IMPORT NODE *create_continuation(void);
IMPORT NODE *create_future(void);
IMPORT void initialize_future(NODE *var, NODE *val);
IMPORT void allocate_arguments(void);
IMPORT NODE *from_arguments(int first_idx, int count);
IMPORT void optional_item(NODE *item);
IMPORT void too_few_arguments_error(void);
IMPORT void too_many_arguments_error(void);
IMPORT NODE *create_cell_with_contents(NODE *contents);
IMPORT NODE *create_continuation_with_exit(FUNC exit_func);
IMPORT void def_attribute(NODE **var_p, int idx, void *attr);
IMPORT void continuation_trampoline(void);
IMPORT void continuation_type_function(void);
IMPORT __attribute__ ((noreturn)) void invalid_continuation_error(void);
IMPORT void assign_value(NODE **dest, NODE *val);
IMPORT NODE *create_function(FUNC func, int par_count);
IMPORT NODE *collect_node(NODE *node);
IMPORT NODE *from_latin_1_string(const char *str, long len);
IMPORT NODE *from_uint32_string(const uint32_t *str, long len);
IMPORT NODE *register_unique_item(const char *name);
IMPORT void assign_variable(NODE **dest, NODE **var_p);
IMPORT void maybe_initialize_future(NODE *var, NODE *val);
IMPORT void register_dynamic(int *id_p);
IMPORT void define_single_assign_static(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE **var_p
);
IMPORT void define_multi_assign_static(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER setter
);
IMPORT void define_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER definer,
  int *id_p
);
IMPORT void define_multi_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER setter, NODE_SETTER definer,
  int *id_p
);
IMPORT void define_attribute(
  const char *namespace, const char *name,
  int id, NODE *attribute
);
IMPORT void define_method(
  const char *namespace, const char *name,
  int id, NODE *method
);
IMPORT void define_type_function(
  const char *namespace, const char *name, FUNC type, int par_cnt
);
IMPORT void define_privileged_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER getter, int id,
  NODE **var_p
);
IMPORT void define_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER getter, int *id_p,
  NODE **var_p
);
IMPORT void register_polymorphic_function(const char *name, int *id_p);
typedef struct SIMPLE_NODE {
  FUNC type;
  struct ATTRIBUTES *attributes;
} SIMPLE_NODE;
IMPORT void *allocate(long size);
IMPORT ATTRIBUTES *collect_attributes(ATTRIBUTES *attributes);
IMPORT void no_such_function(void);
IMPORT OCTREE no_attributes_level_1;
IMPORT OCTREE no_attributes_level_2;
IMPORT OCTREE no_attributes_level_3;
IMPORT OCTREE no_attributes_level_4;
IMPORT OCTREE no_attributes_level_5;
IMPORT OCTREE no_attributes_level_6;
IMPORT OCTREE no_attributes_level_7;
IMPORT OCTREE undefined_attributes_level_1;
IMPORT OCTREE undefined_attributes_level_2;
IMPORT OCTREE undefined_attributes_level_3;
IMPORT OCTREE undefined_attributes_level_4;
IMPORT OCTREE undefined_attributes_level_5;
IMPORT OCTREE undefined_attributes_level_6;
IMPORT OCTREE undefined_attributes_level_7;
IMPORT void collect_static_attributes(ATTRIBUTES *attributes);
IMPORT void define_c_function(const char *name, void *func);
IMPORT NODE *create_future_with_prototype(NODE *prototype);
IMPORT void set_attribute(ATTRIBUTES *attributes, int idx, void *attr);
IMPORT void register_module_info(MODULE_INFO *info);
IMPORT void set_module(const char *name);
IMPORT void set_used_namespaces(const char **namespaces);
IMPORT void use_read_only(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_GETTER *get_value_or_future
);
IMPORT void use_read_write(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *setter
);
IMPORT void use_multi_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *setter, NODE_SETTER *definer
);
IMPORT void use_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER *getter, int *id
);
IMPORT void use_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *definer
);
IMPORT NODE *from_uchar32(unsigned int chr);
IMPORT NODE *from_uint32(uint32_t val);
IMPORT void register_collector(FUNC collector);


#if UINTPTR_MAX == 0xffffffffffffffff
  #define FIRST_INVALID_ADDRESS 0xc000000000000000UL
  #define SAMPLE_POINTER ((void *)0x123456789abcdef0UL)
#else
  #define FIRST_INVALID_ADDRESS 0xc0000000
  #define SAMPLE_POINTER ((void *)0x12345678)
#endif

#define MAKE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)+1))
#define RETRIEVE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)-1))
#define CONTAINS_AN_ATTRIBUTE_VALUE(node) (((uintptr_t)node)&1)

#define ENCODE_ADDRESS(addr) ((void *)(FIRST_INVALID_ADDRESS|(uintptr_t)(addr) >> 2))
#define DECODE_ADDRESS(addr) ((void *)((uintptr_t)(addr) << 2))
#define IS_AN_INVALID_ADDRESS(addr) ((void *)(addr) >= (void *)FIRST_INVALID_ADDRESS)

#define IS_COLLECTED(addr) (((void *)(addr)) >= coll_node_buf && ((void *)(addr)) < coll_node_buf_end)
#define IS_OLD(addr) false
#define MARK(addr) (((MEMORY_BLOCK *)(addr))-1)->mark = current_mark;

#define ALLOCATION_SIZE(size) (((size)+sizeof(void *)-1)&-sizeof(void *))
#define TYPEOF(node) (node)->type
#define SIZEOF(node) (node)->attributes->vtable->size

#ifdef WITHIN_LIBRARY
  #define DEBUG_FILENAME(filename) filename
#else
  #define DEBUG_FILENAME(filename) "./" filename
#endif

#ifdef __CYGWIN__
  extern FUNC invalid_continuation;
#else
  extern void invalid_continuation(void);
#endif
static NODE_GETTER get__ATTRIBUTE_KIND;
static NODE_GETTER get_value_or_future__ATTRIBUTE_KIND;
static NODE_GETTER get__CONTINUATION_PARAMETER;
static NODE_GETTER get_value_or_future__CONTINUATION_PARAMETER;
static NODE_GETTER get__DYNAMIC_MULTI;
static NODE_GETTER get_value_or_future__DYNAMIC_MULTI;
static NODE_GETTER get__DYNAMIC_SINGLE;
static NODE_GETTER get_value_or_future__DYNAMIC_SINGLE;
static NODE_GETTER get__Error;
static NODE_GETTER get_value_or_future__Error;
static NODE_GETTER get__IN_OUT_PARAMETER;
static NODE_GETTER get_value_or_future__IN_OUT_PARAMETER;
static NODE_GETTER get__METHOD_KIND;
static NODE_GETTER get_value_or_future__METHOD_KIND;
static NODE_GETTER get__MYSELF_PARAMETER;
static NODE_GETTER get_value_or_future__MYSELF_PARAMETER;
static NODE_GETTER get__NONE;
static NODE_GETTER get_value_or_future__NONE;
static NODE_GETTER get__OUT_PARAMETER;
static NODE_GETTER get_value_or_future__OUT_PARAMETER;
static NODE_GETTER get__POLYMORPHIC;
static NODE_GETTER get_value_or_future__POLYMORPHIC;
static NODE_GETTER get__STATIC_MULTI;
static NODE_GETTER get_value_or_future__STATIC_MULTI;
static NODE_GETTER get__STATIC_SINGLE;
static NODE_GETTER get_value_or_future__STATIC_SINGLE;
static NODE_GETTER get__SyntaxError;
static NODE_GETTER get_value_or_future__SyntaxError;
static NODE_GETTER get__alt;
static NODE_GETTER get_value_or_future__alt;
static NODE_GETTER get__append;
static NODE_GETTER get_value_or_future__append;
static NODE_GETTER get__arguments_of;
static NODE_GETTER get_value_or_future__arguments_of;
static NODE_GETTER get__assignment_to_c;
static NODE_GETTER get_value_or_future__assignment_to_c;
static NODE_GETTER get__attribute_kind_of;
static NODE_GETTER get_value_or_future__attribute_kind_of;
static NODE_GETTER get__attribute_of;
static NODE_GETTER get_value_or_future__attribute_of;
static NODE_GETTER get__base_of;
static NODE_GETTER get_value_or_future__base_of;
static NODE_GETTER get__before;
static NODE_GETTER get_value_or_future__before;
static NODE_GETTER get__begin_continuation;
static NODE_GETTER get_value_or_future__begin_continuation;
static NODE_GETTER get__behind;
static NODE_GETTER get_value_or_future__behind;
static NODE_GETTER get__between;
static NODE_GETTER get_value_or_future__between;
static NODE_GETTER get__case;
static NODE_GETTER get_value_or_future__case;
static NODE_GETTER get__collect_output;
static NODE_GETTER get_value_or_future__collect_output;
static NODE_GETTER get__cond;
static NODE_GETTER get_value_or_future__cond;
static NODE_GETTER get__contains;
static NODE_GETTER get_value_or_future__contains;
static NODE_GETTER get__continuation_of;
static NODE_GETTER get_value_or_future__continuation_of;
static NODE_GETTER get__converted;
static NODE_GETTER get_value_or_future__converted;
static NODE_GETTER get__count_character_occurrences;
static NODE_GETTER get_value_or_future__count_character_occurrences;
static NODE_GETTER get__current_continuation_info;
static NODE_SETTER set__current_continuation_info;
static NODE_GETTER get__dec;
static NODE_GETTER get_value_or_future__dec;
static NODE_GETTER get__default_value;
static NODE_GETTER get_value_or_future__default_value;
static NODE_GETTER get__default_value_of;
static NODE_GETTER get_value_or_future__default_value_of;
static NODE_GETTER get__defined_functions;
static NODE_GETTER get_value_or_future__defined_functions;
static NODE_GETTER get__defined_names_of;
static NODE_GETTER get_value_or_future__defined_names_of;
static NODE_GETTER get__defined_nodes;
static NODE_GETTER get_value_or_future__defined_nodes;
static NODE_GETTER get__defined_structs;
static NODE_GETTER get_value_or_future__defined_structs;
static NODE_GETTER get__defines_a_dynamic;
static NODE_GETTER get_value_or_future__defines_a_dynamic;
static NODE_GETTER get__definitions_of;
static NODE_GETTER get_value_or_future__definitions_of;
static NODE_GETTER get__delayed_code;
static NODE_SETTER set__delayed_code;
static NODE_GETTER get__do;
static NODE_GETTER get_value_or_future__do;
static NODE_GETTER get__do_show_compiler_debug_infos;
static NODE_GETTER get_value_or_future__do_show_compiler_debug_infos;
static NODE_GETTER get__do_use_goto;
static NODE_GETTER get_value_or_future__do_use_goto;
static NODE_GETTER get__dup;
static NODE_GETTER get_value_or_future__dup;
static NODE_GETTER get__empty_insert_order_table;
static NODE_GETTER get_value_or_future__empty_insert_order_table;
static NODE_GETTER get__empty_list;
static NODE_GETTER get_value_or_future__empty_list;
static NODE_GETTER get__empty_set;
static NODE_GETTER get_value_or_future__empty_set;
static NODE_GETTER get__empty_table;
static NODE_GETTER get_value_or_future__empty_table;
static NODE_GETTER get__end_continuation;
static NODE_GETTER get_value_or_future__end_continuation;
static NODE_GETTER get__end_position_of;
static NODE_GETTER get_value_or_future__end_position_of;
static NODE_GETTER get__ewriteln;
static NODE_GETTER get_value_or_future__ewriteln;
static NODE_GETTER get__exported_names;
static NODE_GETTER get_value_or_future__exported_names;
static NODE_GETTER get__false;
static NODE_GETTER get_value_or_future__false;
static NODE_GETTER get__for_each;
static NODE_GETTER get_value_or_future__for_each;
static NODE_GETTER get__for_each_from_to;
static NODE_GETTER get_value_or_future__for_each_from_to;
static NODE_GETTER get__for_each_line;
static NODE_GETTER get_value_or_future__for_each_line;
static NODE_GETTER get__fragment_of;
static NODE_GETTER get_value_or_future__fragment_of;
static NODE_GETTER get__from;
static NODE_GETTER get_value_or_future__from;
static NODE_GETTER get__from_down_to;
static NODE_GETTER get_value_or_future__from_down_to;
static NODE_GETTER get__from_to;
static NODE_GETTER get_value_or_future__from_to;
static NODE_GETTER get__functor_of;
static NODE_GETTER get_value_or_future__functor_of;
static NODE_GETTER get__generate_dispatcher_function;
static NODE_GETTER get_value_or_future__generate_dispatcher_function;
static NODE_GETTER get__generate_statement;
static NODE_GETTER get_value_or_future__generate_statement;
static NODE_GETTER get__global_names;
static NODE_GETTER get_value_or_future__global_names;
static NODE_GETTER get__has_prefix;
static NODE_GETTER get_value_or_future__has_prefix;
static NODE_GETTER get__has_suffix;
static NODE_GETTER get_value_or_future__has_suffix;
static NODE_GETTER get__hex;
static NODE_GETTER get_value_or_future__hex;
static NODE_GETTER get__identifier_of;
static NODE_GETTER get_value_or_future__identifier_of;
static NODE_GETTER get__if;
static NODE_GETTER get_value_or_future__if;
static NODE_GETTER get__inc;
static NODE_GETTER get_value_or_future__inc;
static NODE_GETTER get__indent_marker;
static NODE_GETTER get_value_or_future__indent_marker;
static NODE_GETTER get__indented;
static NODE_GETTER get_value_or_future__indented;
static NODE_GETTER get__indents_of;
static NODE_GETTER get_value_or_future__indents_of;
static NODE_GETTER get__index;
static NODE_SETTER set__index;
static NODE_GETTER get__inherited_names_of;
static NODE_GETTER get_value_or_future__inherited_names_of;
static NODE_GETTER get__is_a_constant;
static NODE_GETTER get_value_or_future__is_a_constant;
static NODE_GETTER get__is_a_definition;
static NODE_GETTER get_value_or_future__is_a_definition;
static NODE_GETTER get__is_a_function_call;
static NODE_GETTER get_value_or_future__is_a_function_call;
static NODE_GETTER get__is_a_key_value_pair;
static NODE_GETTER get_value_or_future__is_a_key_value_pair;
static NODE_GETTER get__is_a_latin_1_string;
static NODE_GETTER get_value_or_future__is_a_latin_1_string;
static NODE_GETTER get__is_a_multi_assign_definition;
static NODE_GETTER get_value_or_future__is_a_multi_assign_definition;
static NODE_GETTER get__is_a_parameter;
static NODE_GETTER get_value_or_future__is_a_parameter;
static NODE_GETTER get__is_a_procedure_call;
static NODE_GETTER get_value_or_future__is_a_procedure_call;
static NODE_GETTER get__is_a_return;
static NODE_GETTER get_value_or_future__is_a_return;
static NODE_GETTER get__is_a_single_assign_definition;
static NODE_GETTER get_value_or_future__is_a_single_assign_definition;
static NODE_GETTER get__is_a_static_definition;
static NODE_GETTER get_value_or_future__is_a_static_definition;
static NODE_GETTER get__is_a_temporary;
static NODE_GETTER get_value_or_future__is_a_temporary;
static NODE_GETTER get__is_an_assignment;
static NODE_GETTER get_value_or_future__is_an_assignment;
static NODE_GETTER get__is_an_attribute_function_pair;
static NODE_GETTER get_value_or_future__is_an_attribute_function_pair;
static NODE_GETTER get__is_an_attribute_value_pair;
static NODE_GETTER get_value_or_future__is_an_attribute_value_pair;
static NODE_GETTER get__is_an_expanded_item;
static NODE_GETTER get_value_or_future__is_an_expanded_item;
static NODE_GETTER get__is_an_identifier;
static NODE_GETTER get_value_or_future__is_an_identifier;
static NODE_GETTER get__is_an_initialization;
static NODE_GETTER get_value_or_future__is_an_initialization;
static NODE_GETTER get__is_an_optional_item;
static NODE_GETTER get_value_or_future__is_an_optional_item;
static NODE_GETTER get__is_defined;
static NODE_GETTER get_value_or_future__is_defined;
static NODE_GETTER get__is_empty;
static NODE_GETTER get_value_or_future__is_empty;
static NODE_GETTER get__is_undefined;
static NODE_GETTER get_value_or_future__is_undefined;
static NODE_GETTER get__key_of;
static NODE_GETTER get_value_or_future__key_of;
static NODE_GETTER get__kind_of;
static NODE_GETTER get_value_or_future__kind_of;
static NODE_GETTER get__length_of;
static NODE_GETTER get_value_or_future__length_of;
static NODE_GETTER get__line_no_of;
static NODE_GETTER get_value_or_future__line_no_of;
static NODE_GETTER get__mangled_name_of;
static NODE_GETTER get_value_or_future__mangled_name_of;
static NODE_GETTER get__max;
static NODE_GETTER get_value_or_future__max;
static NODE_GETTER get__might_be_constant;
static NODE_GETTER get_value_or_future__might_be_constant;
static NODE_GETTER get__module_name;
static NODE_GETTER get_value_or_future__module_name;
static NODE_GETTER get__name_of;
static NODE_GETTER get_value_or_future__name_of;
static NODE_GETTER get__namespace_of;
static NODE_GETTER get_value_or_future__namespace_of;
static NODE_GETTER get__needed_names;
static NODE_GETTER get_value_or_future__needed_names;
static NODE_GETTER get__newline;
static NODE_GETTER get_value_or_future__newline;
static NODE_GETTER get__next_continuation;
static NODE_GETTER get_value_or_future__next_continuation;
static NODE_GETTER get__node__text_of;
static NODE_GETTER get_value_or_future__node__text_of;
static NODE_GETTER get__node__type_of;
static NODE_GETTER get_value_or_future__node__type_of;
static NODE_GETTER get__node__value_of;
static NODE_GETTER get_value_or_future__node__value_of;
static NODE_GETTER get__node_of;
static NODE_GETTER get_value_or_future__node_of;
static NODE_GETTER get__normalize;
static NODE_GETTER get_value_or_future__normalize;
static NODE_GETTER get__not;
static NODE_GETTER get_value_or_future__not;
static NODE_GETTER get__oct;
static NODE_GETTER get_value_or_future__oct;
static NODE_GETTER get__outdent_marker;
static NODE_GETTER get_value_or_future__outdent_marker;
static NODE_GETTER get__output_arguments_of;
static NODE_GETTER get_value_or_future__output_arguments_of;
static NODE_GETTER get__pad_left;
static NODE_GETTER get_value_or_future__pad_left;
static NODE_GETTER get__parameter_count_of;
static NODE_GETTER get_value_or_future__parameter_count_of;
static NODE_GETTER get__parameter_kind_of;
static NODE_GETTER get_value_or_future__parameter_kind_of;
static NODE_GETTER get__parameters_of;
static NODE_GETTER get_value_or_future__parameters_of;
static NODE_GETTER get__plus;
static NODE_GETTER get_value_or_future__plus;
static NODE_GETTER get__privileged_polymorphic_functions;
static NODE_GETTER get_value_or_future__privileged_polymorphic_functions;
static NODE_GETTER get__push;
static NODE_GETTER get_value_or_future__push;
static NODE_GETTER get__range;
static NODE_GETTER get_value_or_future__range;
static NODE_GETTER get__replace_all;
static NODE_GETTER get_value_or_future__replace_all;
static NODE_GETTER get__result_count_of;
static NODE_GETTER get_value_or_future__result_count_of;
static NODE_GETTER get__scope_of;
static NODE_GETTER get_value_or_future__scope_of;
static NODE_GETTER get__show_compiler_debug_info;
static NODE_GETTER get_value_or_future__show_compiler_debug_info;
static NODE_GETTER get__sim2c__attribute_function_pair;
static NODE_GETTER get_value_or_future__sim2c__attribute_function_pair;
static NODE_GETTER get__sim2c__attribute_value_pair;
static NODE_GETTER get_value_or_future__sim2c__attribute_value_pair;
static NODE_GETTER get__sim2c__body;
static NODE_GETTER get_value_or_future__sim2c__body;
static NODE_GETTER get__sim2c__c_body;
static NODE_GETTER get_value_or_future__sim2c__c_body;
static NODE_GETTER get__sim2c__character_literal;
static NODE_GETTER get_value_or_future__sim2c__character_literal;
static NODE_GETTER get__sim2c__current_continuation_info;
static NODE_SETTER set__sim2c__current_continuation_info;
static NODE_SETTER define__sim2c__current_continuation_info;
static NODE_GETTER get__sim2c__definition;
static NODE_GETTER get_value_or_future__sim2c__definition;
static NODE_GETTER get__sim2c__identifier;
static NODE_GETTER get_value_or_future__sim2c__identifier;
static NODE_GETTER get__sim2c__numeric_literal;
static NODE_GETTER get_value_or_future__sim2c__numeric_literal;
static NODE_GETTER get__sim2c__string_literal;
static NODE_GETTER get_value_or_future__sim2c__string_literal;
static NODE_GETTER get__sim2c__unique_item;
static NODE_GETTER get_value_or_future__sim2c__unique_item;
static NODE_GETTER get__source_of;
static NODE_GETTER get_value_or_future__source_of;
static NODE_GETTER get__source_position_of;
static NODE_GETTER get_value_or_future__source_position_of;
static NODE_GETTER get__statements_of;
static NODE_GETTER get_value_or_future__statements_of;
static NODE_GETTER get__std__and;
static NODE_GETTER get_value_or_future__std__and;
static NODE_GETTER get__std__equal;
static NODE_GETTER get_value_or_future__std__equal;
static NODE_GETTER get__std__key_value_pair;
static NODE_GETTER get_value_or_future__std__key_value_pair;
static NODE_GETTER get__std__less;
static NODE_GETTER get_value_or_future__std__less;
static NODE_GETTER get__std__minus;
static NODE_GETTER get_value_or_future__std__minus;
static NODE_GETTER get__std__negate;
static NODE_GETTER get_value_or_future__std__negate;
static NODE_GETTER get__std__not;
static NODE_GETTER get_value_or_future__std__not;
static NODE_GETTER get__std__or;
static NODE_GETTER get_value_or_future__std__or;
static NODE_GETTER get__std__plus;
static NODE_GETTER get_value_or_future__std__plus;
static NODE_GETTER get__std__sequence;
static NODE_GETTER get_value_or_future__std__sequence;
static NODE_GETTER get__std__string;
static NODE_GETTER get_value_or_future__std__string;
static NODE_GETTER get__std__value_of;
static NODE_GETTER get_value_or_future__std__value_of;
static NODE_GETTER get__string;
static NODE_GETTER get_value_or_future__string;
static NODE_GETTER get__submodule_no_of;
static NODE_GETTER get_value_or_future__submodule_no_of;
static NODE_GETTER get__suffix;
static NODE_GETTER get_value_or_future__suffix;
static NODE_GETTER get__temporary_count_of;
static NODE_GETTER get_value_or_future__temporary_count_of;
static int poly_idx__to_c;
static NODE_GETTER get__to_c;
static NODE_GETTER get__to_integer;
static NODE_GETTER get_value_or_future__to_integer;
static NODE_GETTER get__to_lower_case;
static NODE_GETTER get_value_or_future__to_lower_case;
static NODE_GETTER get__to_string;
static NODE_GETTER get_value_or_future__to_string;
static NODE_GETTER get__trim;
static NODE_GETTER get_value_or_future__trim;
static NODE_GETTER get__true;
static NODE_GETTER get_value_or_future__true;
static NODE_GETTER get__truncate_behind;
static NODE_GETTER get_value_or_future__truncate_behind;
static NODE_GETTER get__truncate_from;
static NODE_GETTER get_value_or_future__truncate_from;
static NODE_GETTER get__truncate_until;
static NODE_GETTER get_value_or_future__truncate_until;
static NODE_GETTER get__types__grammar_node;
static NODE_GETTER get_value_or_future__types__grammar_node;
static NODE_GETTER get__undefined;
static NODE_GETTER get_value_or_future__undefined;
static NODE_GETTER get__unless;
static NODE_GETTER get_value_or_future__unless;
static NODE_GETTER get__until;
static NODE_GETTER get_value_or_future__until;
static NODE_GETTER get__use_literal;
static NODE_GETTER get_value_or_future__use_literal;
static NODE_GETTER get__variable_kind_of;
static NODE_GETTER get_value_or_future__variable_kind_of;
static NODE_GETTER get__vtable_entries;
static NODE_GETTER get_value_or_future__vtable_entries;
static NODE_GETTER get__while;
static NODE_GETTER get_value_or_future__while;
static NODE_GETTER get__without_suffix;
static NODE_GETTER get_value_or_future__without_suffix;
static NODE_GETTER get__write;
static NODE_GETTER get_value_or_future__write;
static NODE_GETTER get__write_source_as_remark;
static NODE_GETTER get_value_or_future__write_source_as_remark;
static NODE_GETTER get__write_to;
static NODE_GETTER get_value_or_future__write_to;
static NODE_GETTER get__write_to_continuation_table;
static NODE_SETTER define__write_to_continuation_table;
static NODE_GETTER get__write_to_declarations;
static NODE_GETTER get_value_or_future__write_to_declarations;
static NODE_GETTER get__write_to_delayed_continuation_table;
static NODE_GETTER get_value_or_future__write_to_delayed_continuation_table;
static NODE_GETTER get__write_to_generated_collections;
static NODE_GETTER get_value_or_future__write_to_generated_collections;
static NODE_GETTER get__write_to_global_variable_declarations;
static NODE_GETTER get_value_or_future__write_to_global_variable_declarations;
static NODE_GETTER get__write_to_phase_1;
static NODE_GETTER get_value_or_future__write_to_phase_1;
static NODE_GETTER get__write_to_phase_2;
static NODE_GETTER get_value_or_future__write_to_phase_2;
static NODE_GETTER get__write_to_phase_3;
static NODE_GETTER get_value_or_future__write_to_phase_3;
static NODE_GETTER get__write_to_phase_4;
static NODE_GETTER get_value_or_future__write_to_phase_4;
static NODE_GETTER get__write_to_phase_5;
static NODE_GETTER get_value_or_future__write_to_phase_5;
static NODE_GETTER get__write_to_top_level_variable_declarations;
static NODE_GETTER get_value_or_future__write_to_top_level_variable_declarations;
static NODE_GETTER get__write_to_top_level_variable_names;
static NODE_GETTER get_value_or_future__write_to_top_level_variable_names;
static NODE_GETTER get__writeln;
static NODE_GETTER get_value_or_future__writeln;
static struct {
  NODE *_var_name;
  NODE *_var_entry;
  NODE *_insert_delayed;
  NODE *_delayed;
  NODE *_count_arguments;
  NODE *_generate_c_arguments;
  NODE *_get_func_and_myself;
  NODE *_assign_argument_or_result;
  NODE *_extract;
  NODE *_write_as_remark;
  NODE *_compute_column_no;
  NODE *_compute_source_text_info;
  NODE *_EARLY;
  NODE *_STANDARD;
  NODE *_UNKNOWN;
  NODE *_get_kind;
  NODE *_to_c_string;
  NODE *_register_string;
  NODE *_extract_destination;
  NODE *_assign;
  NODE *_namespace_argument;
  NODE *_assign_attributes;
  NODE *sim2c__to_c;
  NODE *sim2c__begin_continuation;
  NODE *sim2c__end_continuation;
  NODE *sim2c__next_continuation;
  NODE *sim2c__assignment_to_c;
  NODE *sim2c__write_source_as_remark;
  NODE *sim2c__is_single_assign;
  NODE *sim2c__might_be_constant;
  NODE *sim2c__define_variable;
  NODE *sim2c__define_attribute;
  NODE *sim2c__define_method;
  NODE *sim2c__define_type_function;
  NODE *sim2c__define_polymorphic_function;
  NODE *sim2c__define_c_code;
  NODE *sim2c__generate_statement;
} var;
static const char *var_names[] = {
  "var_name",
  "var_entry",
  "insert_delayed",
  "delayed",
  "count_arguments",
  "generate_c_arguments",
  "get_func_and_myself",
  "assign_argument_or_result",
  "extract",
  "write_as_remark",
  "compute_column_no",
  "compute_source_text_info",
  "EARLY",
  "STANDARD",
  "UNKNOWN",
  "get_kind",
  "to_c_string",
  "register_string",
  "extract_destination",
  "assign",
  "namespace_argument",
  "assign_attributes"
};
static int poly_idx__sim2c__to_c;
static void type__sim2c__to_c(void);
static NODE *get__sim2c__to_c(void) {
  return var.sim2c__to_c;
}
static int dyna_idx__sim2c__suffix;
static NODE *get__sim2c__suffix(void) {
  return get_dynamic_slot(dyna_idx__sim2c__suffix);
}
static void define__sim2c__suffix(NODE *node) {
  define_dynamic_slot(dyna_idx__sim2c__suffix, node);
}
static int dyna_idx__level;
static NODE *get__level(void) {
  return get_dynamic_slot(dyna_idx__level);
}
static void define__level(NODE *node) {
  define_dynamic_slot(dyna_idx__level, node);
}
static int dyna_idx__current_locals;
static NODE *get__current_locals(void) {
  return get_dynamic_slot(dyna_idx__current_locals);
}
static void define__current_locals(NODE *node) {
  define_dynamic_slot(dyna_idx__current_locals, node);
}
static int dyna_idx__current_frame;
static NODE *get__current_frame(void) {
  return get_dynamic_slot(dyna_idx__current_frame);
}
static void define__current_frame(NODE *node) {
  define_dynamic_slot(dyna_idx__current_frame, node);
}
static int dyna_idx__is_a_shared_local;
static NODE *get__is_a_shared_local(void) {
  return get_dynamic_slot(dyna_idx__is_a_shared_local);
}
static void define__is_a_shared_local(NODE *node) {
  define_dynamic_slot(dyna_idx__is_a_shared_local, node);
}
static int dyna_idx__temporary_offset;
static NODE *get__temporary_offset(void) {
  return get_dynamic_slot(dyna_idx__temporary_offset);
}
static void define__temporary_offset(NODE *node) {
  define_dynamic_slot(dyna_idx__temporary_offset, node);
}
static int dyna_idx__sim2c__delayed_code;
static NODE *get__sim2c__delayed_code(void) {
  return get_dynamic_cell(dyna_idx__sim2c__delayed_code);
}
static void set__sim2c__delayed_code(NODE *node) {
  set_dynamic_cell(dyna_idx__sim2c__delayed_code, node);
}
static void define__sim2c__delayed_code(NODE *node) {
  define_dynamic_cell(dyna_idx__sim2c__delayed_code, node);
}
static NODE *func__9_1;
static void entry__9_1(void);
static FRAME_INFO frame__9_1 = {1, {"name"}};
static NODE *string__9_2;
static void cont__9_3(void);
static NODE *func__9_4;
static void entry__9_4(void);
static FRAME_INFO frame__9_4 = {1, {"name"}};
static NODE *func__9_5;
static void entry__9_5(void);
static FRAME_INFO frame__9_5 = {1, {"name"}};
static void cont__9_6(void);
static NODE *func__10_1;
static void entry__10_1(void);
static FRAME_INFO frame__10_1 = {1, {"name"}};
static NODE *string__10_2;
static void cont__10_3(void);
static NODE *func__10_4;
static void entry__10_4(void);
static FRAME_INFO frame__10_4 = {1, {"name"}};
static NODE *string__10_5;
static void cont__10_6(void);
static NODE *func__10_7;
static void entry__10_7(void);
static FRAME_INFO frame__10_7 = {1, {"name"}};
static NODE *string__10_8;
static void cont__10_9(void);
static NODE *func__11_1;
static void entry__11_1(void);
static FRAME_INFO frame__11_1 = {0, {}};
static void cont__11_2(void);
static NODE *func__12_1;
static void entry__12_1(void);
static FRAME_INFO frame__12_1 = {2, {"body", "cont_tab_entries"}};
static NODE *func__12_2;
static void entry__12_2(void);
static FRAME_INFO frame__12_2 = {4, {"return__1", "cont_tab_entries", "body", "output"}};
static NODE *func__12_3;
static void entry__12_3(void);
static FRAME_INFO frame__12_3 = {2, {"args", "cont_tab_entries"}};
static void cont__12_4(void);
static void cont__12_5(void);
static void cont__12_6(void);
static void cont__12_7(void);
static NODE *func__13_1;
static void entry__13_1(void);
static FRAME_INFO frame__13_1 = {1, {"name"}};
static NODE *string__13_2;
static NODE *string__13_3;
static void cont__13_4(void);
static void cont__13_5(void);
static void cont__13_6(void);
static NODE *string__13_7;
static NODE *string__13_8;
static void cont__13_9(void);
static void cont__13_10(void);
static NODE *string__13_11;
static NODE *string__13_12;
static void cont__13_13(void);
static void cont__13_14(void);
static void cont__13_15(void);
static NODE *func__13_16;
static void entry__13_16(void);
static FRAME_INFO frame__13_16 = {0, {}};
static NODE *string__13_17;
static NODE *string__13_18;
static void cont__13_19(void);
static NODE *func__13_20;
static void entry__13_20(void);
static FRAME_INFO frame__13_20 = {0, {}};
static NODE *string__13_21;
static void cont__13_22(void);
static NODE *get__sim2c__begin_continuation(void) {
  return var.sim2c__begin_continuation;
}
static NODE *func__14_1;
static void entry__14_1(void);
static FRAME_INFO frame__14_1 = {0, {}};
static void cont__14_2(void);
static NODE *func__14_3;
static void entry__14_3(void);
static FRAME_INFO frame__14_3 = {0, {}};
static NODE *string__14_4;
static void cont__14_5(void);
static void cont__14_6(void);
static NODE *func__14_7;
static void entry__14_7(void);
static FRAME_INFO frame__14_7 = {0, {}};
static NODE *string__14_8;
static NODE *get__sim2c__end_continuation(void) {
  return var.sim2c__end_continuation;
}
static NODE *func__15_1;
static void entry__15_1(void);
static FRAME_INFO frame__15_1 = {1, {"name"}};
static void cont__15_2(void);
static NODE *get__sim2c__next_continuation(void) {
  return var.sim2c__next_continuation;
}
static NODE *func__16_1;
static void entry__16_1(void);
static FRAME_INFO frame__16_1 = {3, {"arguments", "return", "inputs_count"}};
static NODE *func__16_2;
static void entry__16_2(void);
static FRAME_INFO frame__16_2 = {3, {"argument", "return", "inputs_count"}};
static void cont__16_3(void);
static NODE *func__16_4;
static void entry__16_4(void);
static FRAME_INFO frame__16_4 = {1, {"argument"}};
static void cont__16_5(void);
static void cont__16_6(void);
static NODE *func__16_7;
static void entry__16_7(void);
static FRAME_INFO frame__16_7 = {1, {"return"}};
static NODE *func__16_8;
static void entry__16_8(void);
static FRAME_INFO frame__16_8 = {1, {"inputs_count"}};
static void cont__16_9(void);
static void cont__16_10(void);
static NODE *func__17_1;
static void entry__17_1(void);
static FRAME_INFO frame__17_1 = {4, {"arguments", "within_exit_function", "inputs_count", "idx"}};
static void cont__17_2(void);
static NODE *func__17_3;
static void entry__17_3(void);
static FRAME_INFO frame__17_3 = {1, {"inputs_count"}};
static void cont__17_4(void);
static NODE *func__17_5;
static void entry__17_5(void);
static FRAME_INFO frame__17_5 = {1, {"inputs_count"}};
static NODE *string__17_6;
static NODE *string__17_7;
static void cont__17_8(void);
static NODE *func__17_9;
static void entry__17_9(void);
static FRAME_INFO frame__17_9 = {1, {"inputs_count"}};
static void cont__17_10(void);
static NODE *string__17_11;
static NODE *string__17_12;
static void cont__17_13(void);
static void cont__17_14(void);
static NODE *func__17_15;
static void entry__17_15(void);
static FRAME_INFO frame__17_15 = {4, {"argument", "inputs_count", "idx", "src"}};
static void cont__17_16(void);
static NODE *func__17_17;
static void entry__17_17(void);
static FRAME_INFO frame__17_17 = {2, {"argument", "src"}};
static void cont__17_18(void);
static NODE *func__17_19;
static void entry__17_19(void);
static FRAME_INFO frame__17_19 = {1, {"src"}};
static NODE *string__17_20;
static NODE *string__17_21;
static void cont__17_22(void);
static NODE *func__17_23;
static void entry__17_23(void);
static FRAME_INFO frame__17_23 = {2, {"argument", "src"}};
static void cont__17_24(void);
static NODE *func__17_25;
static void entry__17_25(void);
static FRAME_INFO frame__17_25 = {1, {"src"}};
static NODE *string__17_26;
static NODE *string__17_27;
static void cont__17_28(void);
static NODE *func__17_29;
static void entry__17_29(void);
static FRAME_INFO frame__17_29 = {4, {"inputs_count", "idx", "src", "slot_idx"}};
static void cont__17_30(void);
static NODE *func__17_31;
static void entry__17_31(void);
static FRAME_INFO frame__17_31 = {1, {"idx"}};
static NODE *func__17_32;
static void entry__17_32(void);
static FRAME_INFO frame__17_32 = {0, {}};
static NODE *string__17_33;
static void cont__17_34(void);
static NODE *string__17_35;
static NODE *string__17_36;
static NODE *string__17_37;
static void cont__17_38(void);
static void cont__17_39(void);
static void cont__17_40(void);
static NODE *func__18_1;
static void entry__18_1(void);
static FRAME_INFO frame__18_1 = {4, {"functor", "cont", "insertion_line", "insertion"}};
static NODE *func__18_2;
static void entry__18_2(void);
static FRAME_INFO frame__18_2 = {2, {"indent", "insertion_line"}};
static void cont__18_3(void);
static NODE *func__18_4;
static void entry__18_4(void);
static FRAME_INFO frame__18_4 = {2, {"indent", "insertion_line"}};
static void cont__18_5(void);
static void cont__18_6(void);
static NODE *func__18_7;
static void entry__18_7(void);
static FRAME_INFO frame__18_7 = {0, {}};
static void cont__18_8(void);
static NODE *func__18_9;
static void entry__18_9(void);
static FRAME_INFO frame__18_9 = {0, {}};
static void cont__18_10(void);
static void cont__18_11(void);
static void cont__18_12(void);
static NODE *string__18_13;
static NODE *string__18_14;
static NODE *string__18_15;
static NODE *string__18_16;
static void cont__18_17(void);
static NODE *func__19_1;
static void entry__19_1(void);
static FRAME_INFO frame__19_1 = {5, {"prefix", "destination", "src", "return", "dest"}};
static NODE *string__19_2;
static void cont__19_3(void);
static NODE *func__19_4;
static void entry__19_4(void);
static FRAME_INFO frame__19_4 = {4, {"destination", "return", "prefix", "src"}};
static void cont__19_5(void);
static NODE *func__19_6;
static void entry__19_6(void);
static FRAME_INFO frame__19_6 = {4, {"destination", "return", "prefix", "src"}};
static void cont__19_7(void);
static NODE *func__19_8;
static void entry__19_8(void);
static FRAME_INFO frame__19_8 = {4, {"return", "prefix", "destination", "src"}};
static void cont__19_9(void);
static NODE *string__19_10;
static NODE *string__19_11;
static NODE *string__19_12;
static void cont__19_13(void);
static NODE *func__19_14;
static void entry__19_14(void);
static FRAME_INFO frame__19_14 = {4, {"return", "prefix", "destination", "src"}};
static void cont__19_15(void);
static NODE *string__19_16;
static NODE *string__19_17;
static void cont__19_18(void);
static NODE *func__19_19;
static void entry__19_19(void);
static FRAME_INFO frame__19_19 = {4, {"destination", "return", "prefix", "src"}};
static void cont__19_20(void);
static NODE *func__19_21;
static void entry__19_21(void);
static FRAME_INFO frame__19_21 = {4, {"return", "prefix", "destination", "src"}};
static void cont__19_22(void);
static NODE *string__19_23;
static NODE *string__19_24;
static NODE *string__19_25;
static void cont__19_26(void);
static NODE *func__19_27;
static void entry__19_27(void);
static FRAME_INFO frame__19_27 = {5, {"destination", "return", "prefix", "src", "mangled_name"}};
static void cont__19_28(void);
static void cont__19_29(void);
static NODE *string__19_30;
static NODE *string__19_31;
static NODE *string__19_32;
static void cont__19_33(void);
static NODE *func__19_34;
static void entry__19_34(void);
static FRAME_INFO frame__19_34 = {5, {"destination", "return", "prefix", "src", "mangled_name"}};
static void cont__19_35(void);
static void cont__19_36(void);
static void cont__19_37(void);
static NODE *func__19_38;
static void entry__19_38(void);
static FRAME_INFO frame__19_38 = {4, {"return", "prefix", "mangled_name", "src"}};
static NODE *string__19_39;
static NODE *string__19_40;
static NODE *string__19_41;
static void cont__19_42(void);
static NODE *func__19_43;
static void entry__19_43(void);
static FRAME_INFO frame__19_43 = {4, {"return", "prefix", "mangled_name", "src"}};
static NODE *string__19_44;
static NODE *string__19_45;
static NODE *string__19_46;
static void cont__19_47(void);
static void cont__19_48(void);
static void cont__19_49(void);
static NODE *string__19_50;
static void cont__19_51(void);
static NODE *func__19_52;
static void entry__19_52(void);
static FRAME_INFO frame__19_52 = {3, {"prefix", "dest", "src"}};
static void cont__19_53(void);
static void cont__19_54(void);
static NODE *string__19_55;
static NODE *string__19_56;
static NODE *string__19_57;
static void cont__19_58(void);
static NODE *func__19_59;
static void entry__19_59(void);
static FRAME_INFO frame__19_59 = {3, {"prefix", "dest", "src"}};
static NODE *string__19_60;
static NODE *string__19_61;
static void cont__19_62(void);
static void cont__19_63(void);
static NODE *get__sim2c__assignment_to_c(void) {
  return var.sim2c__assignment_to_c;
}
static NODE *func__20_1;
static void entry__20_1(void);
static FRAME_INFO frame__20_1 = {4, {"prefix", "kind", "destination", "src"}};
static NODE *string__20_2;
static void cont__20_3(void);
static NODE *func__20_4;
static void entry__20_4(void);
static FRAME_INFO frame__20_4 = {1, {"kind"}};
static NODE *string__20_5;
static void cont__20_6(void);
static void cont__20_7(void);
static NODE *func__20_8;
static void entry__20_8(void);
static FRAME_INFO frame__20_8 = {4, {"destination", "prefix", "src", "name"}};
static void cont__20_9(void);
static void cont__20_10(void);
static void cont__20_11(void);
static NODE *string__20_12;
static NODE *string__20_13;
static NODE *string__20_14;
static NODE *string__20_15;
static void cont__20_16(void);
static NODE *func__20_17;
static void entry__20_17(void);
static FRAME_INFO frame__20_17 = {3, {"prefix", "destination", "src"}};
static void cont__20_18(void);
static NODE *func__21_1;
static void entry__21_1(void);
static FRAME_INFO frame__21_1 = {7, {"kind", "outputs", "fixed_count", "total_count", "right_count", "unlimited", "has_complex_default_values"}};
static NODE *func__21_2;
static void entry__21_2(void);
static FRAME_INFO frame__21_2 = {6, {"output", "total_count", "has_complex_default_values", "unlimited", "fixed_count", "right_count"}};
static NODE *func__21_3;
static void entry__21_3(void);
static FRAME_INFO frame__21_3 = {3, {"output", "total_count", "has_complex_default_values"}};
static void cont__21_4(void);
static NODE *func__21_5;
static void entry__21_5(void);
static FRAME_INFO frame__21_5 = {4, {"total_count", "output", "has_complex_default_values", "default_value"}};
static void cont__21_6(void);
static void cont__21_7(void);
static void cont__21_8(void);
static NODE *func__21_9;
static void entry__21_9(void);
static FRAME_INFO frame__21_9 = {1, {"default_value"}};
static void cont__21_10(void);
static void cont__21_11(void);
static NODE *func__21_12;
static void entry__21_12(void);
static FRAME_INFO frame__21_12 = {1, {"has_complex_default_values"}};
static NODE *func__21_13;
static void entry__21_13(void);
static FRAME_INFO frame__21_13 = {2, {"output", "unlimited"}};
static void cont__21_14(void);
static NODE *func__21_15;
static void entry__21_15(void);
static FRAME_INFO frame__21_15 = {1, {"unlimited"}};
static NODE *func__21_16;
static void entry__21_16(void);
static FRAME_INFO frame__21_16 = {4, {"fixed_count", "total_count", "unlimited", "right_count"}};
static void cont__21_17(void);
static void cont__21_18(void);
static NODE *func__21_19;
static void entry__21_19(void);
static FRAME_INFO frame__21_19 = {2, {"fixed_count", "total_count"}};
static void cont__21_20(void);
static void cont__21_21(void);
static NODE *func__21_22;
static void entry__21_22(void);
static FRAME_INFO frame__21_22 = {1, {"right_count"}};
static void cont__21_23(void);
static void cont__21_24(void);
static NODE *func__21_25;
static void entry__21_25(void);
static FRAME_INFO frame__21_25 = {2, {"fixed_count", "total_count"}};
static void cont__21_26(void);
static void cont__21_27(void);
static NODE *func__21_28;
static void entry__21_28(void);
static FRAME_INFO frame__21_28 = {4, {"fixed_count", "kind", "unlimited", "total_count"}};
static void cont__21_29(void);
static NODE *func__21_30;
static void entry__21_30(void);
static FRAME_INFO frame__21_30 = {2, {"fixed_count", "kind"}};
static NODE *string__21_31;
static NODE *string__21_32;
static NODE *string__21_33;
static void cont__21_34(void);
static void cont__21_35(void);
static NODE *func__21_36;
static void entry__21_36(void);
static FRAME_INFO frame__21_36 = {2, {"total_count", "kind"}};
static NODE *string__21_37;
static NODE *string__21_38;
static NODE *string__21_39;
static void cont__21_40(void);
static NODE *func__21_41;
static void entry__21_41(void);
static FRAME_INFO frame__21_41 = {2, {"fixed_count", "kind"}};
static NODE *string__21_42;
static NODE *string__21_43;
static NODE *string__21_44;
static void cont__21_45(void);
static void cont__21_46(void);
static NODE *string__21_47;
static void cont__21_48(void);
static NODE *func__21_49;
static void entry__21_49(void);
static FRAME_INFO frame__21_49 = {1, {"unlimited"}};
static void cont__21_50(void);
static NODE *func__21_51;
static void entry__21_51(void);
static FRAME_INFO frame__21_51 = {0, {}};
static NODE *string__21_52;
static void cont__21_53(void);
static void cont__21_54(void);
static NODE *func__21_55;
static void entry__21_55(void);
static FRAME_INFO frame__21_55 = {6, {"idx", "outputs", "kind", "unlimited", "has_complex_default_values", "output"}};
static void cont__21_56(void);
static NODE *string__21_57;
static void cont__21_58(void);
static NODE *func__21_59;
static void entry__21_59(void);
static FRAME_INFO frame__21_59 = {3, {"output", "unlimited", "has_complex_default_values"}};
static void cont__21_60(void);
static NODE *func__21_61;
static void entry__21_61(void);
static FRAME_INFO frame__21_61 = {2, {"unlimited", "has_complex_default_values"}};
static NODE *func__21_62;
static void entry__21_62(void);
static FRAME_INFO frame__21_62 = {1, {"has_complex_default_values"}};
static void cont__21_63(void);
static void cont__21_64(void);
static void cont__21_65(void);
static NODE *func__21_66;
static void entry__21_66(void);
static FRAME_INFO frame__21_66 = {3, {"kind", "output", "idx"}};
static void cont__21_67(void);
static NODE *string__21_68;
static NODE *string__21_69;
static void cont__21_70(void);
static void cont__21_71(void);
static NODE *func__21_72;
static void entry__21_72(void);
static FRAME_INFO frame__21_72 = {3, {"idx", "kind", "outputs"}};
static void cont__21_73(void);
static void cont__21_74(void);
static void cont__21_75(void);
static NODE *string__21_76;
static NODE *string__21_77;
static void cont__21_78(void);
static void cont__21_79(void);
static NODE *func__21_80;
static void entry__21_80(void);
static FRAME_INFO frame__21_80 = {4, {"kind", "outputs", "total_count", "right_count"}};
static void cont__21_81(void);
static void cont__21_82(void);
static void cont__21_83(void);
static void cont__21_84(void);
static NODE *string__21_85;
static NODE *string__21_86;
static NODE *string__21_87;
static void cont__21_88(void);
static void cont__21_89(void);
static void cont__21_90(void);
static NODE *func__21_91;
static void entry__21_91(void);
static FRAME_INFO frame__21_91 = {7, {"total_count", "right_count", "fixed_count", "kind", "outputs", "has_complex_default_values", "indices"}};
static NODE *string__21_92;
static void cont__21_93(void);
static void cont__21_94(void);
static void cont__21_95(void);
static void cont__21_96(void);
static NODE *func__21_97;
static void entry__21_97(void);
static FRAME_INFO frame__21_97 = {7, {"idx", "right_count", "total_count", "kind", "outputs", "n", "cnt"}};
static void cont__21_98(void);
static void cont__21_99(void);
static NODE *func__21_100;
static void entry__21_100(void);
static FRAME_INFO frame__21_100 = {1, {"n"}};
static NODE *string__21_101;
static void cont__21_102(void);
static NODE *func__21_103;
static void entry__21_103(void);
static FRAME_INFO frame__21_103 = {0, {}};
static NODE *string__21_104;
static void cont__21_105(void);
static NODE *string__21_106;
static NODE *string__21_107;
static void cont__21_108(void);
static void cont__21_109(void);
static void cont__21_110(void);
static NODE *string__21_111;
static NODE *string__21_112;
static void cont__21_113(void);
static void cont__21_114(void);
static NODE *string__21_115;
static NODE *string__21_116;
static void cont__21_117(void);
static void cont__21_118(void);
static NODE *func__21_119;
static void entry__21_119(void);
static FRAME_INFO frame__21_119 = {6, {"total_count", "right_count", "fixed_count", "indices", "outputs", "kind"}};
static void cont__21_120(void);
static void cont__21_121(void);
static void cont__21_122(void);
static NODE *func__21_123;
static void entry__21_123(void);
static FRAME_INFO frame__21_123 = {6, {"idx", "right_count", "total_count", "indices", "n", "cnt"}};
static void cont__21_124(void);
static void cont__21_125(void);
static NODE *func__21_126;
static void entry__21_126(void);
static FRAME_INFO frame__21_126 = {1, {"n"}};
static NODE *string__21_127;
static void cont__21_128(void);
static NODE *func__21_129;
static void entry__21_129(void);
static FRAME_INFO frame__21_129 = {0, {}};
static NODE *string__21_130;
static void cont__21_131(void);
static void cont__21_132(void);
static void cont__21_133(void);
static NODE *string__21_134;
static NODE *string__21_135;
static NODE *string__21_136;
static NODE *string__21_137;
static void cont__21_138(void);
static void cont__21_139(void);
static NODE *string__21_140;
static NODE *string__21_141;
static void cont__21_142(void);
static void cont__21_143(void);
static void cont__21_144(void);
static void cont__21_145(void);
static void cont__21_146(void);
static NODE *func__21_147;
static void entry__21_147(void);
static FRAME_INFO frame__21_147 = {8, {"idx", "outputs", "kind", "indices", "right_count", "output", "default_value", "cont_idx"}};
static void cont__21_148(void);
static void cont__21_149(void);
static void cont__21_150(void);
static NODE *func__21_151;
static void entry__21_151(void);
static FRAME_INFO frame__21_151 = {3, {"default_value", "output", "kind"}};
static void cont__21_152(void);
static NODE *func__21_153;
static void entry__21_153(void);
static FRAME_INFO frame__21_153 = {1, {"output"}};
static void cont__21_154(void);
static NODE *func__21_155;
static void entry__21_155(void);
static FRAME_INFO frame__21_155 = {1, {"statement"}};
static NODE *func__21_156;
static void entry__21_156(void);
static FRAME_INFO frame__21_156 = {3, {"kind", "output", "default_value"}};
static void cont__21_157(void);
static NODE *func__21_158;
static void entry__21_158(void);
static FRAME_INFO frame__21_158 = {2, {"kind", "output"}};
static NODE *string__21_159;
static void cont__21_160(void);
static void cont__21_161(void);
static void cont__21_162(void);
static NODE *string__21_163;
static NODE *string__21_164;
static NODE *string__21_165;
static void cont__21_166(void);
static void cont__21_167(void);
static NODE *string__21_168;
static NODE *string__21_169;
static void cont__21_170(void);
static NODE *func__21_171;
static void entry__21_171(void);
static FRAME_INFO frame__21_171 = {5, {"fixed_count", "right_count", "total_count", "outputs", "kind"}};
static void cont__21_172(void);
static void cont__21_173(void);
static void cont__21_174(void);
static NODE *func__21_175;
static void entry__21_175(void);
static FRAME_INFO frame__21_175 = {7, {"idx", "outputs", "right_count", "kind", "output", "default_value", "value"}};
static void cont__21_176(void);
static void cont__21_177(void);
static void cont__21_178(void);
static NODE *func__21_179;
static void entry__21_179(void);
static FRAME_INFO frame__21_179 = {1, {"default_value"}};
static void cont__21_180(void);
static NODE *func__21_181;
static void entry__21_181(void);
static FRAME_INFO frame__21_181 = {0, {}};
static NODE *string__21_182;
static void cont__21_183(void);
static void cont__21_184(void);
static void cont__21_185(void);
static NODE *string__21_186;
static NODE *string__21_187;
static void cont__21_188(void);
static void cont__21_189(void);
static NODE *string__21_190;
static NODE *func__22_1;
static void entry__22_1(void);
static FRAME_INFO frame__22_1 = {1, {"str"}};
static NODE *string__22_2;
static void cont__22_3(void);
static void cont__22_4(void);
static NODE *string__22_5;
static NODE *func__23_1;
static void entry__23_1(void);
static FRAME_INFO frame__23_1 = {2, {"str", "i"}};
static void cont__23_2(void);
static NODE *func__23_3;
static void entry__23_3(void);
static FRAME_INFO frame__23_3 = {2, {"str", "i"}};
static void cont__23_4(void);
static void cont__23_5(void);
static void cont__23_6(void);
static NODE *func__23_7;
static void entry__23_7(void);
static FRAME_INFO frame__23_7 = {2, {"str", "i"}};
static void cont__23_8(void);
static void cont__23_9(void);
static void cont__23_10(void);
static void cont__23_11(void);
static NODE *func__23_12;
static void entry__23_12(void);
static FRAME_INFO frame__23_12 = {1, {"i"}};
static void cont__23_13(void);
static void cont__23_14(void);
static void cont__23_15(void);
static NODE *func__24_1;
static void entry__24_1(void);
static FRAME_INFO frame__24_1 = {17, {"node", "print_remark", "is_an_exit", "fragment", "fragment_source", "offset", "pos", "prefix", "fragment_line_no", "indents", "line_no", "column_no", "source", "last_line_no", "last_column_no", "submodule_no", "continuation_info"}};
static void cont__24_2(void);
static void cont__24_3(void);
static void cont__24_4(void);
static void cont__24_5(void);
static void cont__24_6(void);
static void cont__24_7(void);
static void cont__24_8(void);
static void cont__24_9(void);
static void cont__24_10(void);
static void cont__24_11(void);
static void cont__24_12(void);
static void cont__24_13(void);
static void cont__24_14(void);
static void cont__24_15(void);
static NODE *func__24_16;
static void entry__24_16(void);
static FRAME_INFO frame__24_16 = {3, {"prefix", "indents", "line_no"}};
static void cont__24_17(void);
static void cont__24_18(void);
static void cont__24_19(void);
static NODE *func__24_20;
static void entry__24_20(void);
static FRAME_INFO frame__24_20 = {1, {"prefix"}};
static void cont__24_21(void);
static void cont__24_22(void);
static void cont__24_23(void);
static void cont__24_24(void);
static void cont__24_25(void);
static void cont__24_26(void);
static void cont__24_27(void);
static void cont__24_28(void);
static void cont__24_29(void);
static void cont__24_30(void);
static void cont__24_31(void);
static void cont__24_32(void);
static void cont__24_33(void);
static void cont__24_34(void);
static void cont__24_35(void);
static NODE *func__24_36;
static void entry__24_36(void);
static FRAME_INFO frame__24_36 = {3, {"source", "indents", "last_line_no"}};
static void cont__24_37(void);
static void cont__24_38(void);
static void cont__24_39(void);
static void cont__24_40(void);
static NODE *func__24_41;
static void entry__24_41(void);
static FRAME_INFO frame__24_41 = {2, {"column_no", "source"}};
static void cont__24_42(void);
static void cont__24_43(void);
static void cont__24_44(void);
static void cont__24_45(void);
static void cont__24_46(void);
static void cont__24_47(void);
static void cont__24_48(void);
static NODE *func__24_49;
static void entry__24_49(void);
static FRAME_INFO frame__24_49 = {4, {"line_no", "last_line_no", "column_no", "last_column_no"}};
static void cont__24_50(void);
static void cont__24_51(void);
static void cont__24_52(void);
static NODE *func__24_53;
static void entry__24_53(void);
static FRAME_INFO frame__24_53 = {1, {"fragment"}};
static void cont__24_54(void);
static NODE *string__24_55;
static void cont__24_56(void);
static NODE *func__24_57;
static void entry__24_57(void);
static FRAME_INFO frame__24_57 = {0, {}};
static void cont__24_58(void);
static NODE *string__24_59;
static NODE *string__24_60;
static NODE *string__24_61;
static void cont__24_62(void);
static NODE *func__24_63;
static void entry__24_63(void);
static FRAME_INFO frame__24_63 = {8, {"line_no", "last_line_no", "prefix", "source", "indent", "do_print_dots", "width", "write_line_start"}};
static NODE *func__24_64;
static void entry__24_64(void);
static FRAME_INFO frame__24_64 = {3, {"line_no", "width", "indent"}};
static void cont__24_65(void);
static NODE *string__24_66;
static NODE *string__24_67;
static void cont__24_68(void);
static void cont__24_69(void);
static NODE *string__24_70;
static void cont__24_71(void);
static void cont__24_72(void);
static void cont__24_73(void);
static void cont__24_74(void);
static void cont__24_75(void);
static NODE *func__24_76;
static void entry__24_76(void);
static FRAME_INFO frame__24_76 = {3, {"last_line_no", "line_no", "do_print_dots"}};
static void cont__24_77(void);
static void cont__24_78(void);
static void cont__24_79(void);
static void cont__24_80(void);
static void cont__24_81(void);
static void cont__24_82(void);
static NODE *func__24_83;
static void entry__24_83(void);
static FRAME_INFO frame__24_83 = {1, {"prefix"}};
static void cont__24_84(void);
static void cont__24_85(void);
static void cont__24_86(void);
static void cont__24_87(void);
static NODE *func__24_88;
static void entry__24_88(void);
static FRAME_INFO frame__24_88 = {1, {"prefix"}};
static void cont__24_89(void);
static void cont__24_90(void);
static void cont__24_91(void);
static void cont__24_92(void);
static void cont__24_93(void);
static void cont__24_94(void);
static NODE *func__24_95;
static void entry__24_95(void);
static FRAME_INFO frame__24_95 = {1, {"source"}};
static NODE *string__24_96;
static void cont__24_97(void);
static void cont__24_98(void);
static void cont__24_99(void);
static void cont__24_100(void);
static void cont__24_101(void);
static NODE *func__24_102;
static void entry__24_102(void);
static FRAME_INFO frame__24_102 = {1, {"source"}};
static void cont__24_103(void);
static void cont__24_104(void);
static void cont__24_105(void);
static NODE *func__24_106;
static void entry__24_106(void);
static FRAME_INFO frame__24_106 = {7, {"break", "source", "indent", "last_line_no", "line_no", "write_line_start", "do_print_dots"}};
static NODE *func__24_107;
static void entry__24_107(void);
static FRAME_INFO frame__24_107 = {8, {"idx", "chr", "indent", "last_line_no", "line_no", "write_line_start", "do_print_dots", "break"}};
static void cont__24_108(void);
static NODE *func__24_109;
static void entry__24_109(void);
static FRAME_INFO frame__24_109 = {7, {"chr", "indent", "last_line_no", "line_no", "write_line_start", "do_print_dots", "break"}};
static void cont__24_110(void);
static NODE *func__24_111;
static void entry__24_111(void);
static FRAME_INFO frame__24_111 = {1, {"indent"}};
static void cont__24_112(void);
static void cont__24_113(void);
static void cont__24_114(void);
static void cont__24_115(void);
static void cont__24_116(void);
static NODE *func__24_117;
static void entry__24_117(void);
static FRAME_INFO frame__24_117 = {1, {"write_line_start"}};
static NODE *func__24_118;
static void entry__24_118(void);
static FRAME_INFO frame__24_118 = {2, {"do_print_dots", "break"}};
static NODE *func__24_119;
static void entry__24_119(void);
static FRAME_INFO frame__24_119 = {0, {}};
static NODE *string__24_120;
static void cont__24_121(void);
static NODE *func__24_122;
static void entry__24_122(void);
static FRAME_INFO frame__24_122 = {1, {"indent"}};
static void cont__24_123(void);
static NODE *func__24_124;
static void entry__24_124(void);
static FRAME_INFO frame__24_124 = {1, {"chr"}};
static void cont__24_125(void);
static void cont__24_126(void);
static NODE *func__25_1;
static void entry__25_1(void);
static FRAME_INFO frame__25_1 = {1, {"node"}};
static void cont__25_2(void);
static void cont__25_3(void);
static NODE *func__25_4;
static void entry__25_4(void);
static FRAME_INFO frame__25_4 = {1, {"node"}};
static void cont__25_5(void);
static NODE *get__sim2c__write_source_as_remark(void) {
  return var.sim2c__write_source_as_remark;
}
static NODE *unique__26_1;
static NODE *unique__27_1;
static NODE *unique__28_1;
static NODE *func__29_1;
static void entry__29_1(void);
static FRAME_INFO frame__29_1 = {2, {"source", "return"}};
static NODE *func__29_2;
static void entry__29_2(void);
static FRAME_INFO frame__29_2 = {2, {"source", "return"}};
static void cont__29_3(void);
static NODE *func__29_4;
static void entry__29_4(void);
static FRAME_INFO frame__29_4 = {1, {"return"}};
static NODE *func__29_5;
static void entry__29_5(void);
static FRAME_INFO frame__29_5 = {2, {"source", "return"}};
static void cont__29_6(void);
static NODE *func__29_7;
static void entry__29_7(void);
static FRAME_INFO frame__29_7 = {1, {"return"}};
static NODE *func__29_8;
static void entry__29_8(void);
static FRAME_INFO frame__29_8 = {3, {"source", "return", "name"}};
static void cont__29_9(void);
static NODE *func__29_10;
static void entry__29_10(void);
static FRAME_INFO frame__29_10 = {2, {"name", "return"}};
static void cont__29_11(void);
static void cont__29_12(void);
static NODE *func__29_13;
static void entry__29_13(void);
static FRAME_INFO frame__29_13 = {2, {"return", "name"}};
static void cont__29_14(void);
static NODE *func__29_15;
static void entry__29_15(void);
static FRAME_INFO frame__29_15 = {0, {}};
static NODE *func__29_16;
static void entry__29_16(void);
static FRAME_INFO frame__29_16 = {0, {}};
static void cont__29_17(void);
static NODE *func__29_18;
static void entry__29_18(void);
static FRAME_INFO frame__29_18 = {2, {"name", "return"}};
static void cont__29_19(void);
static void cont__29_20(void);
static NODE *func__29_21;
static void entry__29_21(void);
static FRAME_INFO frame__29_21 = {2, {"name", "return"}};
static void cont__29_22(void);
static void cont__29_23(void);
static NODE *func__29_24;
static void entry__29_24(void);
static FRAME_INFO frame__29_24 = {1, {"return"}};
static void cont__29_25(void);
static NODE *func__29_26;
static void entry__29_26(void);
static FRAME_INFO frame__29_26 = {1, {"return"}};
static NODE *func__29_27;
static void entry__29_27(void);
static FRAME_INFO frame__29_27 = {1, {"return"}};
static NODE *func__29_28;
static void entry__29_28(void);
static FRAME_INFO frame__29_28 = {4, {"source", "name", "return", "variable_kind"}};
static void cont__29_29(void);
static void cont__29_30(void);
static NODE *func__29_31;
static void entry__29_31(void);
static FRAME_INFO frame__29_31 = {1, {"source"}};
static void cont__29_32(void);
static void cont__29_33(void);
static void cont__29_34(void);
static void cont__29_35(void);
static void cont__29_36(void);
static NODE *func__29_37;
static void entry__29_37(void);
static FRAME_INFO frame__29_37 = {1, {"name"}};
static void cont__29_38(void);
static void cont__29_39(void);
static void cont__29_40(void);
static void cont__29_41(void);
static NODE *func__29_42;
static void entry__29_42(void);
static FRAME_INFO frame__29_42 = {1, {"return"}};
static NODE *func__29_43;
static void entry__29_43(void);
static FRAME_INFO frame__29_43 = {1, {"return"}};
static void cont__29_44(void);
static NODE *func__30_1;
static void entry__30_1(void);
static FRAME_INFO frame__30_1 = {1, {"self"}};
static NODE *string__30_2;
static void cont__30_3(void);
static NODE *string__30_4;
static NODE *func__31_1;
static void entry__31_1(void);
static FRAME_INFO frame__31_1 = {7, {"self", "return", "outer_level", "parent_locals", "is_an_inherited_shared_local", "body_suffix", "par_count"}};
static NODE *string__31_2;
static void cont__31_3(void);
static void cont__31_4(void);
static void cont__31_5(void);
static NODE *func__31_6;
static void entry__31_6(void);
static FRAME_INFO frame__31_6 = {26, {"return__2", "outer_level", "self", "par_count", "is_an_inherited_shared_local", "body_suffix", "parent_locals", "slot_idx", "locals", "is_shared", "min_par_cnt", "max_par_cnt", "right_par_cnt", "has_rest_parameter", "has_complex_default_values", "myself_parameter", "continuation_parameter", "input_parameters", "output_parameters", "implicit_parameters", "locals_idx", "total_slots", "extract_destination_and_source", "extract_source_or_create_future", "statements", "generate_exit"}};
static NODE *func__31_7;
static void entry__31_7(void);
static FRAME_INFO frame__31_7 = {3, {"definition", "destination", "source"}};
static void cont__31_8(void);
static NODE *func__31_9;
static void entry__31_9(void);
static FRAME_INFO frame__31_9 = {1, {"definition"}};
static void cont__31_10(void);
static NODE *func__31_11;
static void entry__31_11(void);
static FRAME_INFO frame__31_11 = {1, {"definition"}};
static void cont__31_12(void);
static void cont__31_13(void);
static NODE *func__31_14;
static void entry__31_14(void);
static FRAME_INFO frame__31_14 = {1, {"definition"}};
static void cont__31_15(void);
static NODE *func__31_16;
static void entry__31_16(void);
static FRAME_INFO frame__31_16 = {0, {}};
static void cont__31_17(void);
static NODE *func__31_18;
static void entry__31_18(void);
static FRAME_INFO frame__31_18 = {1, {"source"}};
static void cont__31_19(void);
static NODE *func__31_20;
static void entry__31_20(void);
static FRAME_INFO frame__31_20 = {1, {"source"}};
static void cont__31_21(void);
static NODE *func__31_22;
static void entry__31_22(void);
static FRAME_INFO frame__31_22 = {1, {"source"}};
static void cont__31_23(void);
static NODE *string__31_24;
static NODE *string__31_25;
static void cont__31_26(void);
static NODE *func__31_27;
static void entry__31_27(void);
static FRAME_INFO frame__31_27 = {1, {"source"}};
static void cont__31_28(void);
static NODE *func__31_29;
static void entry__31_29(void);
static FRAME_INFO frame__31_29 = {0, {}};
static NODE *string__31_30;
static NODE *func__31_31;
static void entry__31_31(void);
static FRAME_INFO frame__31_31 = {0, {}};
static NODE *string__31_32;
static NODE *func__31_33;
static void entry__31_33(void);
static FRAME_INFO frame__31_33 = {3, {"self", "continuation_parameter", "output_parameters"}};
static void cont__31_34(void);
static NODE *func__31_35;
static void entry__31_35(void);
static FRAME_INFO frame__31_35 = {1, {"continuation_parameter"}};
static void cont__31_36(void);
static NODE *func__31_37;
static void entry__31_37(void);
static FRAME_INFO frame__31_37 = {1, {"continuation_parameter"}};
static void cont__31_38(void);
static void cont__31_39(void);
static void cont__31_40(void);
static void cont__31_41(void);
static NODE *func__31_42;
static void entry__31_42(void);
static FRAME_INFO frame__31_42 = {1, {"continuation_parameter"}};
static void cont__31_43(void);
static NODE *string__31_44;
static NODE *string__31_45;
static void cont__31_46(void);
static NODE *func__31_47;
static void entry__31_47(void);
static FRAME_INFO frame__31_47 = {2, {"self", "output_parameters"}};
static void cont__31_48(void);
static void cont__31_49(void);
static NODE *string__31_50;
static void cont__31_51(void);
static void cont__31_52(void);
static NODE *func__31_53;
static void entry__31_53(void);
static FRAME_INFO frame__31_53 = {7, {"parameter", "has_complex_default_values", "output_parameters", "input_parameters", "implicit_parameters", "kind", "default_value"}};
static void cont__31_54(void);
static void cont__31_55(void);
static void cont__31_56(void);
static NODE *func__31_57;
static void entry__31_57(void);
static FRAME_INFO frame__31_57 = {1, {"default_value"}};
static void cont__31_58(void);
static void cont__31_59(void);
static NODE *func__31_60;
static void entry__31_60(void);
static FRAME_INFO frame__31_60 = {1, {"has_complex_default_values"}};
static void cont__31_61(void);
static NODE *func__31_62;
static void entry__31_62(void);
static FRAME_INFO frame__31_62 = {2, {"output_parameters", "parameter"}};
static void cont__31_63(void);
static NODE *func__31_64;
static void entry__31_64(void);
static FRAME_INFO frame__31_64 = {3, {"input_parameters", "parameter", "output_parameters"}};
static void cont__31_65(void);
static void cont__31_66(void);
static void cont__31_67(void);
static NODE *func__31_68;
static void entry__31_68(void);
static FRAME_INFO frame__31_68 = {2, {"implicit_parameters", "parameter"}};
static void cont__31_69(void);
static NODE *func__31_70;
static void entry__31_70(void);
static FRAME_INFO frame__31_70 = {2, {"input_parameters", "parameter"}};
static void cont__31_71(void);
static void cont__31_72(void);
static NODE *func__31_73;
static void entry__31_73(void);
static FRAME_INFO frame__31_73 = {9, {"parameter", "max_par_cnt", "has_rest_parameter", "min_par_cnt", "right_par_cnt", "locals", "slot_idx", "is_shared", "name"}};
static void cont__31_74(void);
static void cont__31_75(void);
static NODE *func__31_76;
static void entry__31_76(void);
static FRAME_INFO frame__31_76 = {2, {"parameter", "max_par_cnt"}};
static void cont__31_77(void);
static NODE *func__31_78;
static void entry__31_78(void);
static FRAME_INFO frame__31_78 = {1, {"max_par_cnt"}};
static void cont__31_79(void);
static NODE *func__31_80;
static void entry__31_80(void);
static FRAME_INFO frame__31_80 = {2, {"parameter", "has_rest_parameter"}};
static void cont__31_81(void);
static NODE *func__31_82;
static void entry__31_82(void);
static FRAME_INFO frame__31_82 = {1, {"has_rest_parameter"}};
static NODE *func__31_83;
static void entry__31_83(void);
static FRAME_INFO frame__31_83 = {3, {"min_par_cnt", "max_par_cnt", "right_par_cnt"}};
static void cont__31_84(void);
static void cont__31_85(void);
static void cont__31_86(void);
static NODE *func__31_87;
static void entry__31_87(void);
static FRAME_INFO frame__31_87 = {1, {"right_par_cnt"}};
static void cont__31_88(void);
static void cont__31_89(void);
static void cont__31_90(void);
static void cont__31_91(void);
static void cont__31_92(void);
static void cont__31_93(void);
static void cont__31_94(void);
static NODE *func__31_95;
static void entry__31_95(void);
static FRAME_INFO frame__31_95 = {7, {"parameter", "myself_parameter", "continuation_parameter", "locals", "slot_idx", "is_shared", "name"}};
static void cont__31_96(void);
static void cont__31_97(void);
static void cont__31_98(void);
static NODE *func__31_99;
static void entry__31_99(void);
static FRAME_INFO frame__31_99 = {2, {"myself_parameter", "parameter"}};
static NODE *func__31_100;
static void entry__31_100(void);
static FRAME_INFO frame__31_100 = {2, {"continuation_parameter", "parameter"}};
static void cont__31_101(void);
static void cont__31_102(void);
static void cont__31_103(void);
static void cont__31_104(void);
static void cont__31_105(void);
static void cont__31_106(void);
static NODE *func__31_107;
static void entry__31_107(void);
static FRAME_INFO frame__31_107 = {2, {"max_par_cnt", "min_par_cnt"}};
static void cont__31_108(void);
static void cont__31_109(void);
static void cont__31_110(void);
static NODE *func__31_111;
static void entry__31_111(void);
static FRAME_INFO frame__31_111 = {1, {"max_par_cnt"}};
static NODE *func__31_112;
static void entry__31_112(void);
static FRAME_INFO frame__31_112 = {0, {}};
static void cont__31_113(void);
static void cont__31_114(void);
static void cont__31_115(void);
static NODE *func__31_116;
static void entry__31_116(void);
static FRAME_INFO frame__31_116 = {6, {"name", "info", "locals", "slot_idx", "is_shared", "is_an_inherited_shared_local"}};
static void cont__31_117(void);
static void cont__31_118(void);
static void cont__31_119(void);
static void cont__31_120(void);
static void cont__31_121(void);
static void cont__31_122(void);
static NODE *func__31_123;
static void entry__31_123(void);
static FRAME_INFO frame__31_123 = {5, {"name", "info", "locals", "slot_idx", "is_shared"}};
static void cont__31_124(void);
static NODE *func__31_125;
static void entry__31_125(void);
static FRAME_INFO frame__31_125 = {1, {"info"}};
static void cont__31_126(void);
static void cont__31_127(void);
static void cont__31_128(void);
static void cont__31_129(void);
static NODE *func__31_130;
static void entry__31_130(void);
static FRAME_INFO frame__31_130 = {5, {"locals", "name", "slot_idx", "is_shared", "info"}};
static void cont__31_131(void);
static void cont__31_132(void);
static void cont__31_133(void);
static void cont__31_134(void);
static void cont__31_135(void);
static void cont__31_136(void);
static void cont__31_137(void);
static NODE *string__31_138;
static NODE *string__31_139;
static void cont__31_140(void);
static void cont__31_141(void);
static NODE *func__31_142;
static void entry__31_142(void);
static FRAME_INFO frame__31_142 = {2, {"return__1", "body_suffix"}};
static NODE *string__31_143;
static void cont__31_144(void);
static void cont__31_145(void);
static void cont__31_146(void);
static NODE *func__31_147;
static void entry__31_147(void);
static FRAME_INFO frame__31_147 = {1, {"has_complex_default_values"}};
static void cont__31_148(void);
static NODE *func__31_149;
static void entry__31_149(void);
static FRAME_INFO frame__31_149 = {0, {}};
static NODE *string__31_150;
static void cont__31_151(void);
static void cont__31_152(void);
static NODE *func__31_153;
static void entry__31_153(void);
static FRAME_INFO frame__31_153 = {1, {"continuation_parameter"}};
static void cont__31_154(void);
static void cont__31_155(void);
static NODE *func__31_156;
static void entry__31_156(void);
static FRAME_INFO frame__31_156 = {0, {}};
static NODE *string__31_157;
static void cont__31_158(void);
static NODE *string__31_159;
static NODE *string__31_160;
static NODE *string__31_161;
static void cont__31_162(void);
static void cont__31_163(void);
static NODE *string__31_164;
static void cont__31_165(void);
static void cont__31_166(void);
static NODE *string__31_167;
static NODE *string__31_168;
static NODE *string__31_169;
static void cont__31_170(void);
static void cont__31_171(void);
static NODE *func__31_172;
static void entry__31_172(void);
static FRAME_INFO frame__31_172 = {2, {"name", "slot"}};
static NODE *string__31_173;
static NODE *string__31_174;
static void cont__31_175(void);
static void cont__31_176(void);
static void cont__31_177(void);
static void cont__31_178(void);
static NODE *func__31_179;
static void entry__31_179(void);
static FRAME_INFO frame__31_179 = {0, {}};
static NODE *string__31_180;
static void cont__31_181(void);
static NODE *string__31_182;
static NODE *string__31_183;
static void cont__31_184(void);
static void cont__31_185(void);
static NODE *string__31_186;
static void cont__31_187(void);
static NODE *string__31_188;
static void cont__31_189(void);
static void cont__31_190(void);
static NODE *func__31_191;
static void entry__31_191(void);
static FRAME_INFO frame__31_191 = {3, {"continuation_parameter", "output_parameters", "body_suffix"}};
static void cont__31_192(void);
static NODE *func__31_193;
static void entry__31_193(void);
static FRAME_INFO frame__31_193 = {1, {"body_suffix"}};
static NODE *string__31_194;
static NODE *string__31_195;
static void cont__31_196(void);
static void cont__31_197(void);
static NODE *string__31_198;
static NODE *string__31_199;
static void cont__31_200(void);
static NODE *func__31_201;
static void entry__31_201(void);
static FRAME_INFO frame__31_201 = {0, {}};
static NODE *string__31_202;
static void cont__31_203(void);
static NODE *string__31_204;
static void cont__31_205(void);
static void cont__31_206(void);
static NODE *func__31_207;
static void entry__31_207(void);
static FRAME_INFO frame__31_207 = {3, {"name", "info", "parent_locals"}};
static void cont__31_208(void);
static void cont__31_209(void);
static NODE *string__31_210;
static NODE *string__31_211;
static NODE *string__31_212;
static NODE *string__31_213;
static void cont__31_214(void);
static void cont__31_215(void);
static void cont__31_216(void);
static NODE *func__31_217;
static void entry__31_217(void);
static FRAME_INFO frame__31_217 = {6, {"definition", "extract_destination_and_source", "extract_source_or_create_future", "locals", "destination", "source"}};
static void cont__31_218(void);
static void cont__31_219(void);
static NODE *func__31_220;
static void entry__31_220(void);
static FRAME_INFO frame__31_220 = {1, {"definition"}};
static void cont__31_221(void);
static void cont__31_222(void);
static NODE *string__31_223;
static NODE *string__31_224;
static void cont__31_225(void);
static void cont__31_226(void);
static void cont__31_227(void);
static void cont__31_228(void);
static NODE *func__31_229;
static void entry__31_229(void);
static FRAME_INFO frame__31_229 = {3, {"destination", "extract_source_or_create_future", "source"}};
static void cont__31_230(void);
static void cont__31_231(void);
static NODE *func__31_232;
static void entry__31_232(void);
static FRAME_INFO frame__31_232 = {4, {"extract_source_or_create_future", "source", "destination", "src"}};
static void cont__31_233(void);
static void cont__31_234(void);
static NODE *func__31_235;
static void entry__31_235(void);
static FRAME_INFO frame__31_235 = {3, {"destination", "locals", "name"}};
static void cont__31_236(void);
static void cont__31_237(void);
static void cont__31_238(void);
static NODE *string__31_239;
static NODE *string__31_240;
static NODE *string__31_241;
static void cont__31_242(void);
static NODE *func__31_243;
static void entry__31_243(void);
static FRAME_INFO frame__31_243 = {1, {"destination"}};
static NODE *string__31_244;
static void cont__31_245(void);
static void cont__31_246(void);
static void cont__31_247(void);
static NODE *func__31_248;
static void entry__31_248(void);
static FRAME_INFO frame__31_248 = {5, {"definition", "extract_destination_and_source", "extract_source_or_create_future", "destination", "source"}};
static void cont__31_249(void);
static void cont__31_250(void);
static void cont__31_251(void);
static NODE *func__31_252;
static void entry__31_252(void);
static FRAME_INFO frame__31_252 = {1, {"destination"}};
static void cont__31_253(void);
static void cont__31_254(void);
static void cont__31_255(void);
static void cont__31_256(void);
static NODE *func__31_257;
static void entry__31_257(void);
static FRAME_INFO frame__31_257 = {3, {"destination", "extract_source_or_create_future", "source"}};
static void cont__31_258(void);
static NODE *func__31_259;
static void entry__31_259(void);
static FRAME_INFO frame__31_259 = {6, {"extract_source_or_create_future", "source", "destination", "src", "attribute_name", "dest"}};
static void cont__31_260(void);
static void cont__31_261(void);
static void cont__31_262(void);
static void cont__31_263(void);
static void cont__31_264(void);
static NODE *string__31_265;
static NODE *string__31_266;
static NODE *string__31_267;
static NODE *string__31_268;
static void cont__31_269(void);
static NODE *func__31_270;
static void entry__31_270(void);
static FRAME_INFO frame__31_270 = {3, {"destination", "extract_source_or_create_future", "source"}};
static void cont__31_271(void);
static void cont__31_272(void);
static NODE *func__31_273;
static void entry__31_273(void);
static FRAME_INFO frame__31_273 = {6, {"extract_source_or_create_future", "source", "destination", "src", "attribute_name", "dest"}};
static void cont__31_274(void);
static void cont__31_275(void);
static void cont__31_276(void);
static void cont__31_277(void);
static void cont__31_278(void);
static NODE *string__31_279;
static NODE *string__31_280;
static NODE *string__31_281;
static NODE *string__31_282;
static void cont__31_283(void);
static NODE *func__31_284;
static void entry__31_284(void);
static FRAME_INFO frame__31_284 = {5, {"source", "destination", "entry", "fun_par_count", "dest"}};
static void cont__31_285(void);
static void cont__31_286(void);
static void cont__31_287(void);
static NODE *string__31_288;
static NODE *string__31_289;
static NODE *string__31_290;
static void cont__31_291(void);
static void cont__31_292(void);
static NODE *func__31_293;
static void entry__31_293(void);
static FRAME_INFO frame__31_293 = {2, {"input_parameters", "code"}};
static NODE *func__31_294;
static void entry__31_294(void);
static FRAME_INFO frame__31_294 = {1, {"input_parameters"}};
static NODE *string__31_295;
static void cont__31_296(void);
static void cont__31_297(void);
static void cont__31_298(void);
static NODE *func__31_299;
static void entry__31_299(void);
static FRAME_INFO frame__31_299 = {1, {"myself_parameter"}};
static NODE *string__31_300;
static NODE *string__31_301;
static void cont__31_302(void);
static NODE *func__31_303;
static void entry__31_303(void);
static FRAME_INFO frame__31_303 = {2, {"parameter", "locals"}};
static void cont__31_304(void);
static void cont__31_305(void);
static NODE *func__31_306;
static void entry__31_306(void);
static FRAME_INFO frame__31_306 = {3, {"parameter", "locals", "name"}};
static void cont__31_307(void);
static void cont__31_308(void);
static void cont__31_309(void);
static NODE *string__31_310;
static NODE *string__31_311;
static NODE *string__31_312;
static void cont__31_313(void);
static void cont__31_314(void);
static void cont__31_315(void);
static void cont__31_316(void);
static NODE *func__31_317;
static void entry__31_317(void);
static FRAME_INFO frame__31_317 = {1, {"statement"}};
static void cont__31_318(void);
static void cont__31_319(void);
static NODE *func__31_320;
static void entry__31_320(void);
static FRAME_INFO frame__31_320 = {1, {"generate_exit"}};
static NODE *func__31_321;
static void entry__31_321(void);
static FRAME_INFO frame__31_321 = {5, {"statements", "continuation_parameter", "output_parameters", "generate_exit", "statement"}};
static void cont__31_322(void);
static void cont__31_323(void);
static NODE *func__31_324;
static void entry__31_324(void);
static FRAME_INFO frame__31_324 = {3, {"statement", "continuation_parameter", "output_parameters"}};
static void cont__31_325(void);
static NODE *func__31_326;
static void entry__31_326(void);
static FRAME_INFO frame__31_326 = {3, {"statement", "continuation_parameter", "output_parameters"}};
static void cont__31_327(void);
static void cont__31_328(void);
static NODE *func__31_329;
static void entry__31_329(void);
static FRAME_INFO frame__31_329 = {2, {"statement", "continuation_parameter"}};
static void cont__31_330(void);
static void cont__31_331(void);
static void cont__31_332(void);
static NODE *string__31_333;
static NODE *string__31_334;
static void cont__31_335(void);
static NODE *func__31_336;
static void entry__31_336(void);
static FRAME_INFO frame__31_336 = {2, {"output_parameters", "statement"}};
static void cont__31_337(void);
static void cont__31_338(void);
static void cont__31_339(void);
static NODE *string__31_340;
static NODE *func__31_341;
static void entry__31_341(void);
static FRAME_INFO frame__31_341 = {3, {"statement", "output_parameters", "continuation_parameter"}};
static void cont__31_342(void);
static NODE *func__31_343;
static void entry__31_343(void);
static FRAME_INFO frame__31_343 = {1, {"statement"}};
static void cont__31_344(void);
static void cont__31_345(void);
static void cont__31_346(void);
static NODE *func__31_347;
static void entry__31_347(void);
static FRAME_INFO frame__31_347 = {6, {"statement", "output_parameters", "continuation_parameter", "functor", "input_arguments", "result_count"}};
static void cont__31_348(void);
static void cont__31_349(void);
static void cont__31_350(void);
static void cont__31_351(void);
static void cont__31_352(void);
static void cont__31_353(void);
static void cont__31_354(void);
static NODE *func__31_355;
static void entry__31_355(void);
static FRAME_INFO frame__31_355 = {2, {"functor", "statement"}};
static NODE *string__31_356;
static void cont__31_357(void);
static void cont__31_358(void);
static void cont__31_359(void);
static NODE *string__31_360;
static NODE *string__31_361;
static void cont__31_362(void);
static NODE *func__31_363;
static void entry__31_363(void);
static FRAME_INFO frame__31_363 = {5, {"result_count", "continuation_parameter", "functor", "statement", "output_parameters"}};
static NODE *func__31_364;
static void entry__31_364(void);
static FRAME_INFO frame__31_364 = {1, {"result_count"}};
static NODE *string__31_365;
static NODE *string__31_366;
static NODE *string__31_367;
static void cont__31_368(void);
static NODE *func__31_369;
static void entry__31_369(void);
static FRAME_INFO frame__31_369 = {0, {}};
static NODE *string__31_370;
static NODE *func__31_371;
static void entry__31_371(void);
static FRAME_INFO frame__31_371 = {0, {}};
static NODE *string__31_372;
static void cont__31_373(void);
static NODE *func__31_374;
static void entry__31_374(void);
static FRAME_INFO frame__31_374 = {3, {"continuation_parameter", "functor", "statement"}};
static void cont__31_375(void);
static NODE *func__31_376;
static void entry__31_376(void);
static FRAME_INFO frame__31_376 = {3, {"functor", "statement", "continuation_parameter"}};
static void cont__31_377(void);
static NODE *string__31_378;
static NODE *string__31_379;
static void cont__31_380(void);
static void cont__31_381(void);
static NODE *string__31_382;
static void cont__31_383(void);
static NODE *string__31_384;
static NODE *string__31_385;
static void cont__31_386(void);
static void cont__31_387(void);
static void cont__31_388(void);
static void cont__31_389(void);
static NODE *string__31_390;
static NODE *string__31_391;
static void cont__31_392(void);
static NODE *func__31_393;
static void entry__31_393(void);
static FRAME_INFO frame__31_393 = {2, {"output_parameters", "functor"}};
static void cont__31_394(void);
static void cont__31_395(void);
static NODE *func__31_396;
static void entry__31_396(void);
static FRAME_INFO frame__31_396 = {3, {"functor", "output_parameters", "n"}};
static void cont__31_397(void);
static NODE *string__31_398;
static NODE *string__31_399;
static void cont__31_400(void);
static void cont__31_401(void);
static NODE *string__31_402;
static void cont__31_403(void);
static NODE *string__31_404;
static NODE *string__31_405;
static void cont__31_406(void);
static void cont__31_407(void);
static void cont__31_408(void);
static void cont__31_409(void);
static NODE *func__31_410;
static void entry__31_410(void);
static FRAME_INFO frame__31_410 = {2, {"n", "output_parameters"}};
static NODE *string__31_411;
static NODE *string__31_412;
static void cont__31_413(void);
static void cont__31_414(void);
static NODE *func__31_415;
static void entry__31_415(void);
static FRAME_INFO frame__31_415 = {1, {"output_parameters"}};
static NODE *string__31_416;
static void cont__31_417(void);
static void cont__31_418(void);
static NODE *string__31_419;
static void cont__31_420(void);
static NODE *string__31_421;
static NODE *func__31_422;
static void entry__31_422(void);
static FRAME_INFO frame__31_422 = {1, {"functor"}};
static NODE *string__31_423;
static NODE *string__31_424;
static NODE *func__31_425;
static void entry__31_425(void);
static FRAME_INFO frame__31_425 = {2, {"statement", "generate_exit"}};
static void cont__31_426(void);
static void cont__31_427(void);
static NODE *string__31_428;
static void cont__31_429(void);
static void cont__31_430(void);
static void cont__31_431(void);
static NODE *func__31_432;
static void entry__31_432(void);
static FRAME_INFO frame__31_432 = {1, {"output_parameters"}};
static void cont__31_433(void);
static void cont__31_434(void);
static void cont__31_435(void);
static NODE *func__31_436;
static void entry__31_436(void);
static FRAME_INFO frame__31_436 = {3, {"body_suffix", "output_parameters", "n"}};
static NODE *string__31_437;
static NODE *string__31_438;
static void cont__31_439(void);
static void cont__31_440(void);
static void cont__31_441(void);
static void cont__31_442(void);
static NODE *func__31_443;
static void entry__31_443(void);
static FRAME_INFO frame__31_443 = {2, {"n", "output_parameters"}};
static NODE *string__31_444;
static NODE *string__31_445;
static void cont__31_446(void);
static void cont__31_447(void);
static NODE *func__31_448;
static void entry__31_448(void);
static FRAME_INFO frame__31_448 = {1, {"output_parameters"}};
static NODE *string__31_449;
static void cont__31_450(void);
static void cont__31_451(void);
static NODE *string__31_452;
static void cont__31_453(void);
static NODE *string__31_454;
static void cont__31_455(void);
static void cont__31_456(void);
static void cont__31_457(void);
static void cont__31_458(void);
static NODE *func__31_459;
static void entry__31_459(void);
static FRAME_INFO frame__31_459 = {3, {"return", "body_suffix", "par_count"}};
static NODE *string__31_460;
static void cont__31_461(void);
static void cont__31_462(void);
static void cont__31_463(void);
static void cont__31_464(void);
static NODE *func__31_465;
static void entry__31_465(void);
static FRAME_INFO frame__31_465 = {3, {"body_suffix", "par_count", "return"}};
static NODE *string__31_466;
static NODE *string__31_467;
static void cont__31_468(void);
static void cont__31_469(void);
static NODE *string__31_470;
static NODE *string__31_471;
static NODE *string__31_472;
static NODE *string__31_473;
static void cont__31_474(void);
static void cont__31_475(void);
static NODE *string__31_476;
static NODE *string__31_477;
static NODE *string__31_478;
static void cont__31_479(void);
static void cont__31_480(void);
static NODE *string__31_481;
static void cont__31_482(void);
static NODE *func__31_483;
static void entry__31_483(void);
static FRAME_INFO frame__31_483 = {3, {"return", "body_suffix", "par_count"}};
static NODE *string__31_484;
static NODE *string__31_485;
static NODE *string__31_486;
static void cont__31_487(void);
static void cont__31_488(void);
static NODE *func__32_1;
static void entry__32_1(void);
static FRAME_INFO frame__32_1 = {2, {"self", "return"}};
static NODE *string__32_2;
static void cont__32_3(void);
static void cont__32_4(void);
static void cont__32_5(void);
static void cont__32_6(void);
static NODE *func__32_7;
static void entry__32_7(void);
static FRAME_INFO frame__32_7 = {2, {"return", "self"}};
static void cont__32_8(void);
static void cont__32_9(void);
static void cont__32_10(void);
static void cont__32_11(void);
static NODE *string__32_12;
static NODE *string__32_13;
static void cont__32_14(void);
static void cont__32_15(void);
static void cont__32_16(void);
static void cont__32_17(void);
static NODE *func__33_1;
static void entry__33_1(void);
static FRAME_INFO frame__33_1 = {1, {"self"}};
static NODE *string__33_2;
static void cont__33_3(void);
static void cont__33_4(void);
static void cont__33_5(void);
static NODE *func__34_1;
static void entry__34_1(void);
static FRAME_INFO frame__34_1 = {1, {"self"}};
static NODE *string__34_2;
static void cont__34_3(void);
static void cont__34_4(void);
static void cont__34_5(void);
static NODE *func__35_1;
static void entry__35_1(void);
static FRAME_INFO frame__35_1 = {2, {"self", "name"}};
static NODE *string__35_2;
static void cont__35_3(void);
static void cont__35_4(void);
static NODE *string__35_5;
static void cont__35_6(void);
static void cont__35_7(void);
static NODE *func__36_1;
static void entry__36_1(void);
static FRAME_INFO frame__36_1 = {2, {"self", "name"}};
static NODE *string__36_2;
static void cont__36_3(void);
static void cont__36_4(void);
static void cont__36_5(void);
static NODE *string__36_6;
static void cont__36_7(void);
static void cont__36_8(void);
static NODE *func__37_1;
static void entry__37_1(void);
static FRAME_INFO frame__37_1 = {3, {"str", "buf", "s"}};
static NODE *func__37_2;
static void entry__37_2(void);
static FRAME_INFO frame__37_2 = {5, {"idx", "chr", "buf", "str", "s"}};
static void cont__37_3(void);
static NODE *func__37_4;
static void entry__37_4(void);
static FRAME_INFO frame__37_4 = {1, {"chr"}};
static void cont__37_5(void);
static NODE *func__37_6;
static void entry__37_6(void);
static FRAME_INFO frame__37_6 = {1, {"chr"}};
static void cont__37_7(void);
static NODE *func__37_8;
static void entry__37_8(void);
static FRAME_INFO frame__37_8 = {1, {"chr"}};
static void cont__37_9(void);
static void cont__37_10(void);
static void cont__37_11(void);
static void cont__37_12(void);
static NODE *func__37_13;
static void entry__37_13(void);
static FRAME_INFO frame__37_13 = {5, {"buf", "str", "s", "idx", "chr"}};
static void cont__37_14(void);
static void cont__37_15(void);
static void cont__37_16(void);
static void cont__37_17(void);
static void cont__37_18(void);
static NODE *string__37_19;
static void cont__37_20(void);
static NODE *string__37_21;
static void cont__37_22(void);
static void cont__37_23(void);
static void cont__37_24(void);
static void cont__37_25(void);
static void cont__37_26(void);
static void cont__37_27(void);
static NODE *func__37_28;
static void entry__37_28(void);
static FRAME_INFO frame__37_28 = {3, {"buf", "str", "s"}};
static void cont__37_29(void);
static void cont__37_30(void);
static void cont__37_31(void);
static void cont__37_32(void);
static NODE *func__38_1;
static void entry__38_1(void);
static FRAME_INFO frame__38_1 = {2, {"str", "len"}};
static void cont__38_2(void);
static void cont__38_3(void);
static NODE *func__38_4;
static void entry__38_4(void);
static FRAME_INFO frame__38_4 = {3, {"str", "len", "name"}};
static void cont__38_5(void);
static NODE *string__38_6;
static NODE *string__38_7;
static void cont__38_8(void);
static NODE *string__38_9;
static NODE *string__38_10;
static void cont__38_11(void);
static void cont__38_12(void);
static void cont__38_13(void);
static NODE *func__38_14;
static void entry__38_14(void);
static FRAME_INFO frame__38_14 = {3, {"name", "str", "len"}};
static void cont__38_15(void);
static NODE *string__38_16;
static NODE *string__38_17;
static NODE *string__38_18;
static NODE *string__38_19;
static void cont__38_20(void);
static NODE *func__38_21;
static void entry__38_21(void);
static FRAME_INFO frame__38_21 = {3, {"name", "len", "str"}};
static NODE *string__38_22;
static NODE *string__38_23;
static NODE *string__38_24;
static void cont__38_25(void);
static void cont__38_26(void);
static NODE *func__38_27;
static void entry__38_27(void);
static FRAME_INFO frame__38_27 = {1, {"chr"}};
static void cont__38_28(void);
static void cont__38_29(void);
static NODE *func__38_30;
static void entry__38_30(void);
static FRAME_INFO frame__38_30 = {1, {"chr"}};
static void cont__38_31(void);
static void cont__38_32(void);
static NODE *func__38_33;
static void entry__38_33(void);
static FRAME_INFO frame__38_33 = {1, {"chr"}};
static void cont__38_34(void);
static void cont__38_35(void);
static NODE *func__38_36;
static void entry__38_36(void);
static FRAME_INFO frame__38_36 = {1, {"chr"}};
static void cont__38_37(void);
static void cont__38_38(void);
static NODE *func__38_39;
static void entry__38_39(void);
static FRAME_INFO frame__38_39 = {1, {"chr"}};
static void cont__38_40(void);
static void cont__38_41(void);
static void cont__38_42(void);
static void cont__38_43(void);
static void cont__38_44(void);
static void cont__38_45(void);
static NODE *func__38_46;
static void entry__38_46(void);
static FRAME_INFO frame__38_46 = {1, {"chr"}};
static void cont__38_47(void);
static void cont__38_48(void);
static NODE *func__38_49;
static void entry__38_49(void);
static FRAME_INFO frame__38_49 = {1, {"chr"}};
static void cont__38_50(void);
static void cont__38_51(void);
static void cont__38_52(void);
static void cont__38_53(void);
static NODE *func__38_54;
static void entry__38_54(void);
static FRAME_INFO frame__38_54 = {1, {"chr"}};
static NODE *func__38_55;
static void entry__38_55(void);
static FRAME_INFO frame__38_55 = {1, {"chr"}};
static void cont__38_56(void);
static void cont__38_57(void);
static NODE *string__38_58;
static NODE *func__38_59;
static void entry__38_59(void);
static FRAME_INFO frame__38_59 = {0, {}};
static NODE *string__38_60;
static void cont__38_61(void);
static NODE *string__38_62;
static void cont__38_63(void);
static NODE *string__38_64;
static NODE *string__38_65;
static NODE *string__38_66;
static NODE *string__38_67;
static void cont__38_68(void);
static void cont__38_69(void);
static NODE *string__38_70;
static NODE *string__38_71;
static NODE *string__38_72;
static void cont__38_73(void);
static void cont__38_74(void);
static NODE *func__38_75;
static void entry__38_75(void);
static FRAME_INFO frame__38_75 = {0, {}};
static NODE *string__38_76;
static NODE *func__39_1;
static void entry__39_1(void);
static FRAME_INFO frame__39_1 = {1, {"self"}};
static NODE *string__39_2;
static void cont__39_3(void);
static void cont__39_4(void);
static void cont__39_5(void);
static NODE *func__40_1;
static void entry__40_1(void);
static FRAME_INFO frame__40_1 = {3, {"self", "name", "reg_name"}};
static NODE *string__40_2;
static void cont__40_3(void);
static void cont__40_4(void);
static NODE *string__40_5;
static NODE *string__40_6;
static void cont__40_7(void);
static void cont__40_8(void);
static void cont__40_9(void);
static NODE *func__40_10;
static void entry__40_10(void);
static FRAME_INFO frame__40_10 = {1, {"self"}};
static void cont__40_11(void);
static NODE *func__40_12;
static void entry__40_12(void);
static FRAME_INFO frame__40_12 = {1, {"name"}};
static void cont__40_13(void);
static NODE *string__40_14;
static NODE *string__40_15;
static void cont__40_16(void);
static void cont__40_17(void);
static NODE *string__40_18;
static NODE *string__40_19;
static NODE *string__40_20;
static void cont__40_21(void);
static void cont__40_22(void);
static NODE *string__40_23;
static NODE *string__40_24;
static NODE *string__40_25;
static void cont__40_26(void);
static void cont__40_27(void);
static NODE *func__41_1;
static void entry__41_1(void);
static FRAME_INFO frame__41_1 = {2, {"self", "name"}};
static NODE *string__41_2;
static void cont__41_3(void);
static void cont__41_4(void);
static NODE *func__41_5;
static void entry__41_5(void);
static FRAME_INFO frame__41_5 = {2, {"self", "name"}};
static void cont__41_6(void);
static NODE *func__41_7;
static void entry__41_7(void);
static FRAME_INFO frame__41_7 = {1, {"name"}};
static void cont__41_8(void);
static NODE *func__41_9;
static void entry__41_9(void);
static FRAME_INFO frame__41_9 = {2, {"name", "idx"}};
static NODE *string__41_10;
static void cont__41_11(void);
static void cont__41_12(void);
static void cont__41_13(void);
static void cont__41_14(void);
static NODE *string__41_15;
static NODE *string__41_16;
static NODE *string__41_17;
static void cont__41_18(void);
static NODE *func__41_19;
static void entry__41_19(void);
static FRAME_INFO frame__41_19 = {1, {"name"}};
static void cont__41_20(void);
static NODE *func__41_21;
static void entry__41_21(void);
static FRAME_INFO frame__41_21 = {1, {"name"}};
static void cont__41_22(void);
static void cont__41_23(void);
static NODE *func__41_24;
static void entry__41_24(void);
static FRAME_INFO frame__41_24 = {1, {"name"}};
static void cont__41_25(void);
static NODE *func__41_26;
static void entry__41_26(void);
static FRAME_INFO frame__41_26 = {1, {"name"}};
static void cont__41_27(void);
static NODE *string__41_28;
static NODE *string__41_29;
static NODE *string__41_30;
static void cont__41_31(void);
static NODE *func__41_32;
static void entry__41_32(void);
static FRAME_INFO frame__41_32 = {1, {"name"}};
static void cont__41_33(void);
static NODE *string__41_34;
static NODE *string__41_35;
static NODE *string__41_36;
static void cont__41_37(void);
static void cont__41_38(void);
static NODE *func__41_39;
static void entry__41_39(void);
static FRAME_INFO frame__41_39 = {1, {"name"}};
static void cont__41_40(void);
static void cont__41_41(void);
static NODE *func__41_42;
static void entry__41_42(void);
static FRAME_INFO frame__41_42 = {1, {"name"}};
static NODE *string__41_43;
static NODE *string__41_44;
static void cont__41_45(void);
static NODE *func__41_46;
static void entry__41_46(void);
static FRAME_INFO frame__41_46 = {2, {"self", "name"}};
static NODE *func__41_47;
static void entry__41_47(void);
static FRAME_INFO frame__41_47 = {3, {"self", "name", "variable_kind"}};
static void cont__41_48(void);
static void cont__41_49(void);
static NODE *func__41_50;
static void entry__41_50(void);
static FRAME_INFO frame__41_50 = {1, {"self"}};
static void cont__41_51(void);
static void cont__41_52(void);
static void cont__41_53(void);
static void cont__41_54(void);
static void cont__41_55(void);
static NODE *func__41_56;
static void entry__41_56(void);
static FRAME_INFO frame__41_56 = {1, {"name"}};
static void cont__41_57(void);
static void cont__41_58(void);
static void cont__41_59(void);
static void cont__41_60(void);
static NODE *func__41_61;
static void entry__41_61(void);
static FRAME_INFO frame__41_61 = {1, {"name"}};
static NODE *string__41_62;
static NODE *string__41_63;
static void cont__41_64(void);
static NODE *func__41_65;
static void entry__41_65(void);
static FRAME_INFO frame__41_65 = {1, {"name"}};
static void cont__41_66(void);
static void cont__41_67(void);
static NODE *func__42_1;
static void entry__42_1(void);
static FRAME_INFO frame__42_1 = {3, {"self", "body_suffix", "continuation_info"}};
static NODE *string__42_2;
static void cont__42_3(void);
static void cont__42_4(void);
static void cont__42_5(void);
static void cont__42_6(void);
static void cont__42_7(void);
static NODE *func__42_8;
static void entry__42_8(void);
static FRAME_INFO frame__42_8 = {2, {"continuation_info", "self"}};
static void cont__42_9(void);
static void cont__42_10(void);
static NODE *func__42_11;
static void entry__42_11(void);
static FRAME_INFO frame__42_11 = {4, {"self", "body_suffix", "continuation_info", "par_count"}};
static void cont__42_12(void);
static NODE *string__42_13;
static void cont__42_14(void);
static NODE *func__42_15;
static void entry__42_15(void);
static FRAME_INFO frame__42_15 = {1, {"self"}};
static void cont__42_16(void);
static void cont__42_17(void);
static NODE *func__42_18;
static void entry__42_18(void);
static FRAME_INFO frame__42_18 = {0, {}};
static void cont__42_19(void);
static void cont__42_20(void);
static NODE *string__42_21;
static NODE *string__42_22;
static NODE *string__42_23;
static void cont__42_24(void);
static void cont__42_25(void);
static void cont__42_26(void);
static NODE *func__42_27;
static void entry__42_27(void);
static FRAME_INFO frame__42_27 = {2, {"body_suffix", "continuation_info"}};
static NODE *string__42_28;
static NODE *string__42_29;
static NODE *string__42_30;
static void cont__42_31(void);
static void cont__42_32(void);
static void cont__42_33(void);
static void cont__42_34(void);
static void cont__42_35(void);
static NODE *string__42_36;
static NODE *string__42_37;
static NODE *string__42_38;
static void cont__42_39(void);
static void cont__42_40(void);
static NODE *string__42_41;
static NODE *string__42_42;
static void cont__42_43(void);
static void cont__42_44(void);
static NODE *string__42_45;
static NODE *string__42_46;
static NODE *string__42_47;
static NODE *string__42_48;
static void cont__42_49(void);
static void cont__42_50(void);
static NODE *string__42_51;
static void cont__42_52(void);
static NODE *func__43_1;
static void entry__43_1(void);
static FRAME_INFO frame__43_1 = {2, {"destination", "identifier"}};
static void cont__43_2(void);
static void cont__43_3(void);
static void cont__43_4(void);
static void cont__43_5(void);
static NODE *func__44_1;
static void entry__44_1(void);
static FRAME_INFO frame__44_1 = {3, {"expr", "return", "info"}};
static void cont__44_2(void);
static NODE *func__44_3;
static void entry__44_3(void);
static FRAME_INFO frame__44_3 = {1, {"expr"}};
static void cont__44_4(void);
static void cont__44_5(void);
static void cont__44_6(void);
static NODE *func__44_7;
static void entry__44_7(void);
static FRAME_INFO frame__44_7 = {1, {"return"}};
static void cont__44_8(void);
static void cont__44_9(void);
static void cont__44_10(void);
static NODE *func__44_11;
static void entry__44_11(void);
static FRAME_INFO frame__44_11 = {2, {"expr", "namespaces"}};
static void cont__44_12(void);
static void cont__44_13(void);
static void cont__44_14(void);
static NODE *func__44_15;
static void entry__44_15(void);
static FRAME_INFO frame__44_15 = {2, {"namespaces", "expr"}};
static void cont__44_16(void);
static void cont__44_17(void);
static NODE *func__44_18;
static void entry__44_18(void);
static FRAME_INFO frame__44_18 = {0, {}};
static void cont__44_19(void);
static NODE *func__44_20;
static void entry__44_20(void);
static FRAME_INFO frame__44_20 = {1, {"expr"}};
static void cont__44_21(void);
static void cont__44_22(void);
static void cont__44_23(void);
static void cont__44_24(void);
static NODE *func__44_25;
static void entry__44_25(void);
static FRAME_INFO frame__44_25 = {1, {"info"}};
static void cont__44_26(void);
static void cont__44_27(void);
static NODE *get__sim2c__is_single_assign(void) {
  return var.sim2c__is_single_assign;
}
static NODE *func__45_1;
static void entry__45_1(void);
static FRAME_INFO frame__45_1 = {3, {"expr", "return", "info"}};
static void cont__45_2(void);
static NODE *func__45_3;
static void entry__45_3(void);
static FRAME_INFO frame__45_3 = {1, {"expr"}};
static void cont__45_4(void);
static void cont__45_5(void);
static void cont__45_6(void);
static NODE *func__45_7;
static void entry__45_7(void);
static FRAME_INFO frame__45_7 = {1, {"return"}};
static void cont__45_8(void);
static void cont__45_9(void);
static void cont__45_10(void);
static NODE *func__45_11;
static void entry__45_11(void);
static FRAME_INFO frame__45_11 = {2, {"expr", "namespaces"}};
static void cont__45_12(void);
static void cont__45_13(void);
static void cont__45_14(void);
static NODE *func__45_15;
static void entry__45_15(void);
static FRAME_INFO frame__45_15 = {2, {"namespaces", "expr"}};
static void cont__45_16(void);
static void cont__45_17(void);
static NODE *func__45_18;
static void entry__45_18(void);
static FRAME_INFO frame__45_18 = {0, {}};
static void cont__45_19(void);
static NODE *func__45_20;
static void entry__45_20(void);
static FRAME_INFO frame__45_20 = {1, {"expr"}};
static void cont__45_21(void);
static void cont__45_22(void);
static void cont__45_23(void);
static void cont__45_24(void);
static NODE *get__sim2c__might_be_constant(void) {
  return var.sim2c__might_be_constant;
}
static NODE *func__46_1;
static void entry__46_1(void);
static FRAME_INFO frame__46_1 = {2, {"dest", "src"}};
static NODE *func__46_2;
static void entry__46_2(void);
static FRAME_INFO frame__46_2 = {2, {"src", "dest"}};
static NODE *string__46_3;
static NODE *string__46_4;
static void cont__46_5(void);
static void cont__46_6(void);
static NODE *func__46_7;
static void entry__46_7(void);
static FRAME_INFO frame__46_7 = {2, {"dest", "src"}};
static NODE *string__46_8;
static NODE *string__46_9;
static NODE *string__46_10;
static void cont__46_11(void);
static NODE *func__46_12;
static void entry__46_12(void);
static FRAME_INFO frame__46_12 = {2, {"src", "dest"}};
static NODE *string__46_13;
static void cont__46_14(void);
static NODE *func__46_15;
static void entry__46_15(void);
static FRAME_INFO frame__46_15 = {2, {"dest", "src"}};
static NODE *string__46_16;
static NODE *string__46_17;
static NODE *string__46_18;
static void cont__46_19(void);
static NODE *func__46_20;
static void entry__46_20(void);
static FRAME_INFO frame__46_20 = {2, {"dest", "src"}};
static NODE *string__46_21;
static NODE *string__46_22;
static NODE *string__46_23;
static void cont__46_24(void);
static NODE *func__47_1;
static void entry__47_1(void);
static FRAME_INFO frame__47_1 = {6, {"definition", "source", "namespace", "name", "mangled_name", "kind"}};
static void cont__47_2(void);
static void cont__47_3(void);
static NODE *func__47_4;
static void entry__47_4(void);
static FRAME_INFO frame__47_4 = {1, {"mangled_name"}};
static void cont__47_5(void);
static void cont__47_6(void);
static NODE *string__47_7;
static NODE *string__47_8;
static NODE *string__47_9;
static void cont__47_10(void);
static void cont__47_11(void);
static void cont__47_12(void);
static void cont__47_13(void);
static NODE *func__47_14;
static void entry__47_14(void);
static FRAME_INFO frame__47_14 = {1, {"kind"}};
static void cont__47_15(void);
static void cont__47_16(void);
static NODE *func__47_17;
static void entry__47_17(void);
static FRAME_INFO frame__47_17 = {2, {"mangled_name", "source"}};
static void cont__47_18(void);
static void cont__47_19(void);
static void cont__47_20(void);
static void cont__47_21(void);
static NODE *func__47_22;
static void entry__47_22(void);
static FRAME_INFO frame__47_22 = {4, {"kind", "mangled_name", "namespace", "name"}};
static NODE *func__47_23;
static void entry__47_23(void);
static FRAME_INFO frame__47_23 = {3, {"mangled_name", "namespace", "name"}};
static NODE *string__47_24;
static NODE *string__47_25;
static void cont__47_26(void);
static void cont__47_27(void);
static NODE *string__47_28;
static NODE *string__47_29;
static NODE *string__47_30;
static NODE *string__47_31;
static NODE *string__47_32;
static void cont__47_33(void);
static void cont__47_34(void);
static void cont__47_35(void);
static NODE *string__47_36;
static NODE *string__47_37;
static NODE *string__47_38;
static NODE *string__47_39;
static NODE *string__47_40;
static void cont__47_41(void);
static NODE *func__47_42;
static void entry__47_42(void);
static FRAME_INFO frame__47_42 = {3, {"mangled_name", "namespace", "name"}};
static NODE *string__47_43;
static NODE *string__47_44;
static void cont__47_45(void);
static void cont__47_46(void);
static NODE *string__47_47;
static NODE *string__47_48;
static NODE *string__47_49;
static NODE *string__47_50;
static NODE *string__47_51;
static NODE *string__47_52;
static NODE *string__47_53;
static NODE *string__47_54;
static NODE *string__47_55;
static void cont__47_56(void);
static void cont__47_57(void);
static NODE *string__47_58;
static NODE *string__47_59;
static NODE *string__47_60;
static NODE *string__47_61;
static NODE *string__47_62;
static void cont__47_63(void);
static NODE *func__47_64;
static void entry__47_64(void);
static FRAME_INFO frame__47_64 = {3, {"mangled_name", "namespace", "name"}};
static NODE *string__47_65;
static NODE *string__47_66;
static NODE *string__47_67;
static NODE *string__47_68;
static NODE *string__47_69;
static NODE *string__47_70;
static void cont__47_71(void);
static void cont__47_72(void);
static NODE *string__47_73;
static NODE *string__47_74;
static NODE *string__47_75;
static NODE *string__47_76;
static NODE *string__47_77;
static NODE *string__47_78;
static void cont__47_79(void);
static NODE *func__47_80;
static void entry__47_80(void);
static FRAME_INFO frame__47_80 = {3, {"mangled_name", "namespace", "name"}};
static NODE *string__47_81;
static NODE *string__47_82;
static NODE *string__47_83;
static NODE *string__47_84;
static NODE *string__47_85;
static NODE *string__47_86;
static NODE *string__47_87;
static NODE *string__47_88;
static void cont__47_89(void);
static void cont__47_90(void);
static NODE *string__47_91;
static NODE *string__47_92;
static NODE *string__47_93;
static NODE *string__47_94;
static NODE *string__47_95;
static NODE *string__47_96;
static NODE *string__47_97;
static NODE *string__47_98;
static void cont__47_99(void);
static NODE *func__47_100;
static void entry__47_100(void);
static FRAME_INFO frame__47_100 = {4, {"kind", "mangled_name", "source", "name"}};
static NODE *func__47_101;
static void entry__47_101(void);
static FRAME_INFO frame__47_101 = {3, {"mangled_name", "source", "name"}};
static NODE *string__47_102;
static NODE *string__47_103;
static void cont__47_104(void);
static void cont__47_105(void);
static void cont__47_106(void);
static NODE *string__47_107;
static NODE *string__47_108;
static void cont__47_109(void);
static void cont__47_110(void);
static void cont__47_111(void);
static NODE *func__47_112;
static void entry__47_112(void);
static FRAME_INFO frame__47_112 = {1, {"name"}};
static void cont__47_113(void);
static NODE *string__47_114;
static NODE *string__47_115;
static void cont__47_116(void);
static NODE *func__47_117;
static void entry__47_117(void);
static FRAME_INFO frame__47_117 = {1, {"mangled_name"}};
static NODE *string__47_118;
static NODE *string__47_119;
static void cont__47_120(void);
static void cont__47_121(void);
static void cont__47_122(void);
static NODE *string__47_123;
static NODE *string__47_124;
static void cont__47_125(void);
static NODE *func__47_126;
static void entry__47_126(void);
static FRAME_INFO frame__47_126 = {2, {"name", "source"}};
static NODE *string__47_127;
static NODE *string__47_128;
static NODE *string__47_129;
static NODE *string__47_130;
static NODE *string__47_131;
static NODE *string__47_132;
static void cont__47_133(void);
static void cont__47_134(void);
static NODE *string__47_135;
static NODE *string__47_136;
static void cont__47_137(void);
static void cont__47_138(void);
static void cont__47_139(void);
static NODE *func__47_140;
static void entry__47_140(void);
static FRAME_INFO frame__47_140 = {1, {"name"}};
static NODE *string__47_141;
static NODE *string__47_142;
static void cont__47_143(void);
static NODE *func__47_144;
static void entry__47_144(void);
static FRAME_INFO frame__47_144 = {1, {"name"}};
static NODE *string__47_145;
static NODE *string__47_146;
static NODE *string__47_147;
static NODE *string__47_148;
static NODE *string__47_149;
static NODE *string__47_150;
static NODE *string__47_151;
static NODE *string__47_152;
static void cont__47_153(void);
static void cont__47_154(void);
static NODE *string__47_155;
static NODE *string__47_156;
static NODE *string__47_157;
static void cont__47_158(void);
static void cont__47_159(void);
static void cont__47_160(void);
static NODE *func__47_161;
static void entry__47_161(void);
static FRAME_INFO frame__47_161 = {1, {"kind"}};
static void cont__47_162(void);
static void cont__47_163(void);
static NODE *func__47_164;
static void entry__47_164(void);
static FRAME_INFO frame__47_164 = {2, {"source", "mangled_name"}};
static void cont__47_165(void);
static NODE *func__47_166;
static void entry__47_166(void);
static FRAME_INFO frame__47_166 = {2, {"mangled_name", "source"}};
static void cont__47_167(void);
static NODE *string__47_168;
static NODE *string__47_169;
static NODE *string__47_170;
static void cont__47_171(void);
static NODE *func__47_172;
static void entry__47_172(void);
static FRAME_INFO frame__47_172 = {2, {"source", "mangled_name"}};
static void cont__47_173(void);
static NODE *func__47_174;
static void entry__47_174(void);
static FRAME_INFO frame__47_174 = {2, {"mangled_name", "source"}};
static NODE *string__47_175;
static NODE *string__47_176;
static void cont__47_177(void);
static void cont__47_178(void);
static void cont__47_179(void);
static NODE *func__47_180;
static void entry__47_180(void);
static FRAME_INFO frame__47_180 = {2, {"mangled_name", "source"}};
static void cont__47_181(void);
static NODE *string__47_182;
static NODE *string__47_183;
static NODE *string__47_184;
static void cont__47_185(void);
static NODE *func__47_186;
static void entry__47_186(void);
static FRAME_INFO frame__47_186 = {2, {"mangled_name", "source"}};
static void cont__47_187(void);
static NODE *string__47_188;
static NODE *string__47_189;
static NODE *string__47_190;
static void cont__47_191(void);
static NODE *get__sim2c__define_variable(void) {
  return var.sim2c__define_variable;
}
static NODE *func__48_1;
static void entry__48_1(void);
static FRAME_INFO frame__48_1 = {1, {"namespace"}};
static void cont__48_2(void);
static NODE *func__48_3;
static void entry__48_3(void);
static FRAME_INFO frame__48_3 = {1, {"namespace"}};
static NODE *string__48_4;
static NODE *string__48_5;
static void cont__48_6(void);
static NODE *func__48_7;
static void entry__48_7(void);
static FRAME_INFO frame__48_7 = {0, {}};
static NODE *string__48_8;
static NODE *func__49_1;
static void entry__49_1(void);
static FRAME_INFO frame__49_1 = {7, {"definition", "source", "namespace", "name", "mangled_name", "attribute_name", "src"}};
static void cont__49_2(void);
static void cont__49_3(void);
static void cont__49_4(void);
static void cont__49_5(void);
static NODE *func__49_6;
static void entry__49_6(void);
static FRAME_INFO frame__49_6 = {2, {"src", "source"}};
static void cont__49_7(void);
static NODE *func__49_8;
static void entry__49_8(void);
static FRAME_INFO frame__49_8 = {3, {"src", "mangled_name", "attribute_name"}};
static NODE *string__49_9;
static NODE *string__49_10;
static void cont__49_11(void);
static NODE *string__49_12;
static NODE *string__49_13;
static void cont__49_14(void);
static void cont__49_15(void);
static void cont__49_16(void);
static NODE *func__49_17;
static void entry__49_17(void);
static FRAME_INFO frame__49_17 = {1, {"name"}};
static void cont__49_18(void);
static void cont__49_19(void);
static void cont__49_20(void);
static NODE *func__49_21;
static void entry__49_21(void);
static FRAME_INFO frame__49_21 = {4, {"namespace", "name", "attribute_name", "src"}};
static void cont__49_22(void);
static NODE *string__49_23;
static NODE *string__49_24;
static NODE *string__49_25;
static NODE *string__49_26;
static NODE *string__49_27;
static void cont__49_28(void);
static NODE *func__49_29;
static void entry__49_29(void);
static FRAME_INFO frame__49_29 = {3, {"name", "attribute_name", "src"}};
static void cont__49_30(void);
static NODE *string__49_31;
static NODE *string__49_32;
static NODE *string__49_33;
static NODE *string__49_34;
static void cont__49_35(void);
static NODE *get__sim2c__define_attribute(void) {
  return var.sim2c__define_attribute;
}
static NODE *func__50_1;
static void entry__50_1(void);
static FRAME_INFO frame__50_1 = {7, {"definition", "source", "namespace", "name", "mangled_name", "attribute_name", "src"}};
static void cont__50_2(void);
static void cont__50_3(void);
static void cont__50_4(void);
static void cont__50_5(void);
static NODE *func__50_6;
static void entry__50_6(void);
static FRAME_INFO frame__50_6 = {2, {"src", "source"}};
static void cont__50_7(void);
static NODE *func__50_8;
static void entry__50_8(void);
static FRAME_INFO frame__50_8 = {3, {"src", "mangled_name", "attribute_name"}};
static NODE *string__50_9;
static NODE *string__50_10;
static void cont__50_11(void);
static NODE *string__50_12;
static NODE *string__50_13;
static void cont__50_14(void);
static void cont__50_15(void);
static void cont__50_16(void);
static NODE *func__50_17;
static void entry__50_17(void);
static FRAME_INFO frame__50_17 = {1, {"name"}};
static void cont__50_18(void);
static void cont__50_19(void);
static void cont__50_20(void);
static NODE *func__50_21;
static void entry__50_21(void);
static FRAME_INFO frame__50_21 = {4, {"namespace", "name", "attribute_name", "src"}};
static void cont__50_22(void);
static NODE *string__50_23;
static NODE *string__50_24;
static NODE *string__50_25;
static NODE *string__50_26;
static NODE *string__50_27;
static void cont__50_28(void);
static NODE *func__50_29;
static void entry__50_29(void);
static FRAME_INFO frame__50_29 = {3, {"name", "attribute_name", "src"}};
static void cont__50_30(void);
static NODE *string__50_31;
static NODE *string__50_32;
static NODE *string__50_33;
static NODE *string__50_34;
static void cont__50_35(void);
static NODE *get__sim2c__define_method(void) {
  return var.sim2c__define_method;
}
static NODE *func__51_1;
static void entry__51_1(void);
static FRAME_INFO frame__51_1 = {7, {"definition", "source", "namespace", "name", "mangled_name", "entry", "par_count"}};
static void cont__51_2(void);
static void cont__51_3(void);
static void cont__51_4(void);
static NODE *func__51_5;
static void entry__51_5(void);
static FRAME_INFO frame__51_5 = {1, {"name"}};
static void cont__51_6(void);
static void cont__51_7(void);
static void cont__51_8(void);
static NODE *func__51_9;
static void entry__51_9(void);
static FRAME_INFO frame__51_9 = {4, {"namespace", "name", "entry", "par_count"}};
static void cont__51_10(void);
static NODE *string__51_11;
static NODE *string__51_12;
static NODE *string__51_13;
static NODE *string__51_14;
static NODE *string__51_15;
static void cont__51_16(void);
static NODE *func__51_17;
static void entry__51_17(void);
static FRAME_INFO frame__51_17 = {2, {"name", "entry"}};
static void cont__51_18(void);
static NODE *string__51_19;
static NODE *string__51_20;
static NODE *string__51_21;
static void cont__51_22(void);
static NODE *get__sim2c__define_type_function(void) {
  return var.sim2c__define_type_function;
}
static NODE *func__52_1;
static void entry__52_1(void);
static FRAME_INFO frame__52_1 = {8, {"definition", "is_a_setter", "with_setter", "namespace", "name", "mangled_name", "id", "info"}};
static NODE *func__52_2;
static void entry__52_2(void);
static FRAME_INFO frame__52_2 = {1, {"is_a_setter"}};
static NODE *func__52_3;
static void entry__52_3(void);
static FRAME_INFO frame__52_3 = {0, {}};
static NODE *string__52_4;
static NODE *func__52_5;
static void entry__52_5(void);
static FRAME_INFO frame__52_5 = {0, {}};
static void cont__52_6(void);
static void cont__52_7(void);
static NODE *func__52_8;
static void entry__52_8(void);
static FRAME_INFO frame__52_8 = {1, {"mangled_name"}};
static NODE *string__52_9;
static NODE *string__52_10;
static void cont__52_11(void);
static NODE *func__52_12;
static void entry__52_12(void);
static FRAME_INFO frame__52_12 = {1, {"mangled_name"}};
static NODE *string__52_13;
static NODE *string__52_14;
static void cont__52_15(void);
static void cont__52_16(void);
static void cont__52_17(void);
static NODE *string__52_18;
static NODE *string__52_19;
static void cont__52_20(void);
static void cont__52_21(void);
static void cont__52_22(void);
static void cont__52_23(void);
static NODE *func__52_24;
static void entry__52_24(void);
static FRAME_INFO frame__52_24 = {1, {"id"}};
static NODE *string__52_25;
static void cont__52_26(void);
static NODE *func__52_27;
static void entry__52_27(void);
static FRAME_INFO frame__52_27 = {0, {}};
static void cont__52_28(void);
static NODE *string__52_29;
static NODE *string__52_30;
static void cont__52_31(void);
static void cont__52_32(void);
static void cont__52_33(void);
static void cont__52_34(void);
static NODE *string__52_35;
static NODE *string__52_36;
static NODE *string__52_37;
static void cont__52_38(void);
static void cont__52_39(void);
static void cont__52_40(void);
static void cont__52_41(void);
static NODE *string__52_42;
static NODE *string__52_43;
static NODE *string__52_44;
static void cont__52_45(void);
static void cont__52_46(void);
static void cont__52_47(void);
static void cont__52_48(void);
static NODE *string__52_49;
static NODE *string__52_50;
static NODE *string__52_51;
static void cont__52_52(void);
static void cont__52_53(void);
static void cont__52_54(void);
static NODE *func__52_55;
static void entry__52_55(void);
static FRAME_INFO frame__52_55 = {5, {"namespace", "name", "id", "mangled_name", "with_setter"}};
static NODE *string__52_56;
static NODE *string__52_57;
static NODE *string__52_58;
static NODE *string__52_59;
static NODE *string__52_60;
static void cont__52_61(void);
static void cont__52_62(void);
static void cont__52_63(void);
static NODE *func__52_64;
static void entry__52_64(void);
static FRAME_INFO frame__52_64 = {4, {"namespace", "name", "mangled_name", "id"}};
static void cont__52_65(void);
static NODE *string__52_66;
static NODE *string__52_67;
static NODE *string__52_68;
static NODE *string__52_69;
static NODE *string__52_70;
static NODE *string__52_71;
static void cont__52_72(void);
static NODE *func__52_73;
static void entry__52_73(void);
static FRAME_INFO frame__52_73 = {4, {"with_setter", "namespace", "name", "mangled_name"}};
static void cont__52_74(void);
static void cont__52_75(void);
static NODE *string__52_76;
static NODE *string__52_77;
static NODE *string__52_78;
static NODE *string__52_79;
static NODE *string__52_80;
static NODE *string__52_81;
static NODE *string__52_82;
static void cont__52_83(void);
static NODE *func__52_84;
static void entry__52_84(void);
static FRAME_INFO frame__52_84 = {2, {"with_setter", "name"}};
static void cont__52_85(void);
static NODE *string__52_86;
static NODE *string__52_87;
static NODE *string__52_88;
static NODE *string__52_89;
static NODE *string__52_90;
static void cont__52_91(void);
static NODE *get__sim2c__define_polymorphic_function(void) {
  return var.sim2c__define_polymorphic_function;
}
static NODE *func__53_1;
static void entry__53_1(void);
static FRAME_INFO frame__53_1 = {1, {"self"}};
static NODE *string__53_2;
static void cont__53_3(void);
static NODE *func__53_4;
static void entry__53_4(void);
static FRAME_INFO frame__53_4 = {10, {"self", "kind", "source", "scope", "identifier", "namespace", "name", "mangled_name", "type", "initialize_object"}};
static NODE *func__53_5;
static void entry__53_5(void);
static FRAME_INFO frame__53_5 = {6, {"obj_type", "as_a_future", "self", "mangled_name", "namespace", "arguments"}};
static void cont__53_6(void);
static NODE *func__53_7;
static void entry__53_7(void);
static FRAME_INFO frame__53_7 = {2, {"argument", "arguments"}};
static void cont__53_8(void);
static NODE *func__53_9;
static void entry__53_9(void);
static FRAME_INFO frame__53_9 = {1, {"arguments"}};
static NODE *string__53_10;
static void cont__53_11(void);
static void cont__53_12(void);
static NODE *string__53_13;
static void cont__53_14(void);
static NODE *func__53_15;
static void entry__53_15(void);
static FRAME_INFO frame__53_15 = {1, {"mangled_name"}};
static NODE *string__53_16;
static NODE *string__53_17;
static void cont__53_18(void);
static NODE *func__53_19;
static void entry__53_19(void);
static FRAME_INFO frame__53_19 = {1, {"mangled_name"}};
static NODE *string__53_20;
static NODE *string__53_21;
static void cont__53_22(void);
static void cont__53_23(void);
static void cont__53_24(void);
static NODE *string__53_25;
static NODE *string__53_26;
static void cont__53_27(void);
static void cont__53_28(void);
static void cont__53_29(void);
static void cont__53_30(void);
static NODE *string__53_31;
static NODE *string__53_32;
static NODE *string__53_33;
static void cont__53_34(void);
static void cont__53_35(void);
static NODE *func__53_36;
static void entry__53_36(void);
static FRAME_INFO frame__53_36 = {3, {"mangled_name", "obj_type", "arguments"}};
static void cont__53_37(void);
static NODE *string__53_38;
static NODE *string__53_39;
static NODE *string__53_40;
static NODE *string__53_41;
static void cont__53_42(void);
static NODE *func__53_43;
static void entry__53_43(void);
static FRAME_INFO frame__53_43 = {3, {"mangled_name", "obj_type", "arguments"}};
static void cont__53_44(void);
static NODE *string__53_45;
static NODE *string__53_46;
static NODE *string__53_47;
static NODE *string__53_48;
static void cont__53_49(void);
static void cont__53_50(void);
static void cont__53_51(void);
static NODE *func__53_52;
static void entry__53_52(void);
static FRAME_INFO frame__53_52 = {1, {"mangled_name"}};
static void cont__53_53(void);
static NODE *string__53_54;
static NODE *string__53_55;
static NODE *string__53_56;
static void cont__53_57(void);
static void cont__53_58(void);
static void cont__53_59(void);
static void cont__53_60(void);
static NODE *string__53_61;
static NODE *func__53_62;
static void entry__53_62(void);
static FRAME_INFO frame__53_62 = {0, {}};
static NODE *string__53_63;
static NODE *func__53_64;
static void entry__53_64(void);
static FRAME_INFO frame__53_64 = {0, {}};
static NODE *string__53_65;
static NODE *func__53_66;
static void entry__53_66(void);
static FRAME_INFO frame__53_66 = {0, {}};
static NODE *string__53_67;
static NODE *func__53_68;
static void entry__53_68(void);
static FRAME_INFO frame__53_68 = {0, {}};
static NODE *string__53_69;
static void cont__53_70(void);
static void cont__53_71(void);
static void cont__53_72(void);
static NODE *func__53_73;
static void entry__53_73(void);
static FRAME_INFO frame__53_73 = {1, {"identifier"}};
static void cont__53_74(void);
static NODE *func__53_75;
static void entry__53_75(void);
static FRAME_INFO frame__53_75 = {0, {}};
static void cont__53_76(void);
static void cont__53_77(void);
static NODE *func__53_78;
static void entry__53_78(void);
static FRAME_INFO frame__53_78 = {1, {"identifier"}};
static void cont__53_79(void);
static NODE *func__53_80;
static void entry__53_80(void);
static FRAME_INFO frame__53_80 = {0, {}};
static void cont__53_81(void);
static void cont__53_82(void);
static NODE *func__53_83;
static void entry__53_83(void);
static FRAME_INFO frame__53_83 = {1, {"self"}};
static void cont__53_84(void);
static void cont__53_85(void);
static NODE *func__53_86;
static void entry__53_86(void);
static FRAME_INFO frame__53_86 = {0, {}};
static void cont__53_87(void);
static void cont__53_88(void);
static void cont__53_89(void);
static NODE *func__53_90;
static void entry__53_90(void);
static FRAME_INFO frame__53_90 = {1, {"self"}};
static void cont__53_91(void);
static void cont__53_92(void);
static NODE *func__53_93;
static void entry__53_93(void);
static FRAME_INFO frame__53_93 = {0, {}};
static void cont__53_94(void);
static NODE *func__53_95;
static void entry__53_95(void);
static FRAME_INFO frame__53_95 = {2, {"mangled_name", "source"}};
static void cont__53_96(void);
static NODE *string__53_97;
static NODE *string__53_98;
static NODE *string__53_99;
static NODE *string__53_100;
static NODE *string__53_101;
static void cont__53_102(void);
static NODE *func__53_103;
static void entry__53_103(void);
static FRAME_INFO frame__53_103 = {4, {"source", "mangled_name", "scope", "collector_name"}};
static void cont__53_104(void);
static NODE *string__53_105;
static NODE *string__53_106;
static NODE *string__53_107;
static void cont__53_108(void);
static void cont__53_109(void);
static void cont__53_110(void);
static NODE *string__53_111;
static void cont__53_112(void);
static void cont__53_113(void);
static NODE *func__53_114;
static void entry__53_114(void);
static FRAME_INFO frame__53_114 = {4, {"scope", "collector_name", "mangled_name", "source"}};
static NODE *string__53_115;
static NODE *string__53_116;
static NODE *string__53_117;
static NODE *string__53_118;
static NODE *string__53_119;
static void cont__53_120(void);
static void cont__53_121(void);
static NODE *func__53_122;
static void entry__53_122(void);
static FRAME_INFO frame__53_122 = {4, {"line", "field_type", "field_name", "base_type"}};
static NODE *string__53_123;
static void cont__53_124(void);
static void cont__53_125(void);
static void cont__53_126(void);
static void cont__53_127(void);
static void cont__53_128(void);
static void cont__53_129(void);
static void cont__53_130(void);
static void cont__53_131(void);
static void cont__53_132(void);
static void cont__53_133(void);
static void cont__53_134(void);
static NODE *func__53_135;
static void entry__53_135(void);
static FRAME_INFO frame__53_135 = {1, {"field_type"}};
static NODE *string__53_136;
static void cont__53_137(void);
static NODE *func__53_138;
static void entry__53_138(void);
static FRAME_INFO frame__53_138 = {1, {"field_type"}};
static void cont__53_139(void);
static void cont__53_140(void);
static NODE *func__53_141;
static void entry__53_141(void);
static FRAME_INFO frame__53_141 = {1, {"field_type"}};
static void cont__53_142(void);
static NODE *func__53_143;
static void entry__53_143(void);
static FRAME_INFO frame__53_143 = {1, {"field_type"}};
static void cont__53_144(void);
static void cont__53_145(void);
static NODE *func__53_146;
static void entry__53_146(void);
static FRAME_INFO frame__53_146 = {0, {}};
static NODE *func__53_147;
static void entry__53_147(void);
static FRAME_INFO frame__53_147 = {0, {}};
static void cont__53_148(void);
static void cont__53_149(void);
static NODE *func__53_150;
static void entry__53_150(void);
static FRAME_INFO frame__53_150 = {1, {"base_type"}};
static void cont__53_151(void);
static void cont__53_152(void);
static NODE *func__53_153;
static void entry__53_153(void);
static FRAME_INFO frame__53_153 = {2, {"field_name", "base_type"}};
static void cont__53_154(void);
static NODE *string__53_155;
static NODE *string__53_156;
static NODE *string__53_157;
static NODE *string__53_158;
static void cont__53_159(void);
static NODE *func__53_160;
static void entry__53_160(void);
static FRAME_INFO frame__53_160 = {1, {"field_name"}};
static NODE *string__53_161;
static NODE *string__53_162;
static NODE *string__53_163;
static void cont__53_164(void);
static void cont__53_165(void);
static NODE *string__53_166;
static NODE *func__53_167;
static void entry__53_167(void);
static FRAME_INFO frame__53_167 = {13, {"self", "initialize_object", "mangled_name", "namespace", "name", "scope", "source", "node_name", "node", "arguments", "initializers", "attributes_declaration", "constructor_name"}};
static void cont__53_168(void);
static void cont__53_169(void);
static void cont__53_170(void);
static NODE *func__53_171;
static void entry__53_171(void);
static FRAME_INFO frame__53_171 = {1, {"node_name"}};
static NODE *string__53_172;
static NODE *string__53_173;
static void cont__53_174(void);
static void cont__53_175(void);
static void cont__53_176(void);
static void cont__53_177(void);
static NODE *func__53_178;
static void entry__53_178(void);
static FRAME_INFO frame__53_178 = {3, {"initialize_object", "mangled_name", "self"}};
static void cont__53_179(void);
static void cont__53_180(void);
static void cont__53_181(void);
static void cont__53_182(void);
static NODE *func__53_183;
static void entry__53_183(void);
static FRAME_INFO frame__53_183 = {2, {"initialize_object", "mangled_name"}};
static void cont__53_184(void);
static void cont__53_185(void);
static NODE *func__53_186;
static void entry__53_186(void);
static FRAME_INFO frame__53_186 = {3, {"namespace", "name", "mangled_name"}};
static void cont__53_187(void);
static NODE *string__53_188;
static NODE *string__53_189;
static NODE *string__53_190;
static NODE *string__53_191;
static NODE *string__53_192;
static void cont__53_193(void);
static void cont__53_194(void);
static void cont__53_195(void);
static NODE *func__53_196;
static void entry__53_196(void);
static FRAME_INFO frame__53_196 = {6, {"line", "arguments", "initializers", "node_name", "field_type", "field_name"}};
static NODE *string__53_197;
static void cont__53_198(void);
static void cont__53_199(void);
static void cont__53_200(void);
static void cont__53_201(void);
static void cont__53_202(void);
static void cont__53_203(void);
static void cont__53_204(void);
static void cont__53_205(void);
static void cont__53_206(void);
static void cont__53_207(void);
static void cont__53_208(void);
static void cont__53_209(void);
static void cont__53_210(void);
static NODE *func__53_211;
static void entry__53_211(void);
static FRAME_INFO frame__53_211 = {1, {"arguments"}};
static void cont__53_212(void);
static void cont__53_213(void);
static void cont__53_214(void);
static void cont__53_215(void);
static NODE *string__53_216;
static NODE *string__53_217;
static NODE *string__53_218;
static NODE *string__53_219;
static void cont__53_220(void);
static void cont__53_221(void);
static NODE *func__53_222;
static void entry__53_222(void);
static FRAME_INFO frame__53_222 = {1, {"arguments"}};
static NODE *string__53_223;
static void cont__53_224(void);
static void cont__53_225(void);
static void cont__53_226(void);
static void cont__53_227(void);
static void cont__53_228(void);
static NODE *string__53_229;
static NODE *string__53_230;
static NODE *string__53_231;
static NODE *string__53_232;
static void cont__53_233(void);
static NODE *func__53_234;
static void entry__53_234(void);
static FRAME_INFO frame__53_234 = {6, {"entry", "namespace", "name", "attributes_declaration", "mangled_name", "func_name"}};
static void cont__53_235(void);
static NODE *func__53_236;
static void entry__53_236(void);
static FRAME_INFO frame__53_236 = {1, {"namespace"}};
static NODE *string__53_237;
static void cont__53_238(void);
static NODE *func__53_239;
static void entry__53_239(void);
static FRAME_INFO frame__53_239 = {0, {}};
static void cont__53_240(void);
static void cont__53_241(void);
static void cont__53_242(void);
static NODE *func__53_243;
static void entry__53_243(void);
static FRAME_INFO frame__53_243 = {3, {"attributes_declaration", "mangled_name", "entry"}};
static NODE *string__53_244;
static NODE *string__53_245;
static void cont__53_246(void);
static NODE *func__53_247;
static void entry__53_247(void);
static FRAME_INFO frame__53_247 = {1, {"attributes_declaration"}};
static NODE *string__53_248;
static void cont__53_249(void);
static NODE *func__53_250;
static void entry__53_250(void);
static FRAME_INFO frame__53_250 = {1, {"attributes_declaration"}};
static NODE *string__53_251;
static void cont__53_252(void);
static void cont__53_253(void);
static NODE *string__53_254;
static void cont__53_255(void);
static NODE *string__53_256;
static void cont__53_257(void);
static NODE *func__53_258;
static void entry__53_258(void);
static FRAME_INFO frame__53_258 = {1, {"attributes_declaration"}};
static NODE *string__53_259;
static void cont__53_260(void);
static NODE *func__53_261;
static void entry__53_261(void);
static FRAME_INFO frame__53_261 = {2, {"attributes_declaration", "mangled_name"}};
static NODE *string__53_262;
static NODE *string__53_263;
static NODE *string__53_264;
static void cont__53_265(void);
static void cont__53_266(void);
static void cont__53_267(void);
static void cont__53_268(void);
static NODE *string__53_269;
static NODE *string__53_270;
static void cont__53_271(void);
static void cont__53_272(void);
static void cont__53_273(void);
static void cont__53_274(void);
static NODE *string__53_275;
static NODE *string__53_276;
static NODE *string__53_277;
static NODE *string__53_278;
static void cont__53_279(void);
static void cont__53_280(void);
static NODE *string__53_281;
static void cont__53_282(void);
static void cont__53_283(void);
static NODE *func__53_284;
static void entry__53_284(void);
static FRAME_INFO frame__53_284 = {6, {"scope", "constructor_name", "arguments", "node_name", "mangled_name", "initializers"}};
static NODE *string__53_285;
static NODE *string__53_286;
static NODE *string__53_287;
static void cont__53_288(void);
static void cont__53_289(void);
static NODE *string__53_290;
static void cont__53_291(void);
static NODE *func__53_292;
static void entry__53_292(void);
static FRAME_INFO frame__53_292 = {4, {"mangled_name", "scope", "constructor_name", "arguments"}};
static NODE *string__53_293;
static NODE *string__53_294;
static NODE *string__53_295;
static NODE *string__53_296;
static NODE *string__53_297;
static NODE *string__53_298;
static NODE *string__53_299;
static NODE *string__53_300;
static void cont__53_301(void);
static NODE *func__53_302;
static void entry__53_302(void);
static FRAME_INFO frame__53_302 = {6, {"scope", "constructor_name", "arguments", "node_name", "mangled_name", "initializers"}};
static NODE *string__53_303;
static NODE *string__53_304;
static NODE *string__53_305;
static NODE *string__53_306;
static NODE *string__53_307;
static NODE *string__53_308;
static NODE *string__53_309;
static void cont__53_310(void);
static NODE *func__53_311;
static void entry__53_311(void);
static FRAME_INFO frame__53_311 = {5, {"initialize_object", "type", "namespace", "name", "mangled_name"}};
static void cont__53_312(void);
static void cont__53_313(void);
static NODE *func__53_314;
static void entry__53_314(void);
static FRAME_INFO frame__53_314 = {3, {"namespace", "name", "mangled_name"}};
static void cont__53_315(void);
static NODE *string__53_316;
static NODE *string__53_317;
static NODE *string__53_318;
static NODE *string__53_319;
static NODE *string__53_320;
static void cont__53_321(void);
static NODE *func__53_322;
static void entry__53_322(void);
static FRAME_INFO frame__53_322 = {10, {"source", "self", "scope", "raw_declaration", "type_and_name", "function_name", "mangled_function_name", "function_type", "arguments", "declaration"}};
static void cont__53_323(void);
static void cont__53_324(void);
static void cont__53_325(void);
static void cont__53_326(void);
static void cont__53_327(void);
static void cont__53_328(void);
static NODE *string__53_329;
static void cont__53_330(void);
static NODE *func__53_331;
static void entry__53_331(void);
static FRAME_INFO frame__53_331 = {1, {"function_name"}};
static NODE *string__53_332;
static void cont__53_333(void);
static NODE *func__53_334;
static void entry__53_334(void);
static FRAME_INFO frame__53_334 = {1, {"function_name"}};
static void cont__53_335(void);
static void cont__53_336(void);
static void cont__53_337(void);
static void cont__53_338(void);
static void cont__53_339(void);
static void cont__53_340(void);
static NODE *string__53_341;
static void cont__53_342(void);
static NODE *func__53_343;
static void entry__53_343(void);
static FRAME_INFO frame__53_343 = {0, {}};
static NODE *string__53_344;
static NODE *func__53_345;
static void entry__53_345(void);
static FRAME_INFO frame__53_345 = {0, {}};
static void cont__53_346(void);
static NODE *string__53_347;
static NODE *string__53_348;
static void cont__53_349(void);
static NODE *string__53_350;
static void cont__53_351(void);
static void cont__53_352(void);
static void cont__53_353(void);
static void cont__53_354(void);
static NODE *string__53_355;
static void cont__53_356(void);
static NODE *func__53_357;
static void entry__53_357(void);
static FRAME_INFO frame__53_357 = {2, {"function_name", "mangled_function_name"}};
static NODE *string__53_358;
static NODE *string__53_359;
static NODE *string__53_360;
static void cont__53_361(void);
static NODE *func__53_362;
static void entry__53_362(void);
static FRAME_INFO frame__53_362 = {2, {"scope", "declaration"}};
static NODE *string__53_363;
static NODE *string__53_364;
static void cont__53_365(void);
static void cont__53_366(void);
static void cont__53_367(void);
static void cont__53_368(void);
static NODE *string__53_369;
static NODE *string__53_370;
static void cont__53_371(void);
static NODE *func__53_372;
static void entry__53_372(void);
static FRAME_INFO frame__53_372 = {2, {"source", "scope"}};
static void cont__53_373(void);
static NODE *func__53_374;
static void entry__53_374(void);
static FRAME_INFO frame__53_374 = {2, {"line", "scope"}};
static void cont__53_375(void);
static NODE *func__53_376;
static void entry__53_376(void);
static FRAME_INFO frame__53_376 = {1, {"line"}};
static void cont__53_377(void);
static void cont__53_378(void);
static void cont__53_379(void);
static NODE *func__53_380;
static void entry__53_380(void);
static FRAME_INFO frame__53_380 = {2, {"line", "scope"}};
static NODE *string__53_381;
static NODE *string__53_382;
static NODE *string__53_383;
static void cont__53_384(void);
static void cont__53_385(void);
static NODE *func__53_386;
static void entry__53_386(void);
static FRAME_INFO frame__53_386 = {1, {"scope"}};
static void cont__53_387(void);
static void cont__53_388(void);
static NODE *func__53_389;
static void entry__53_389(void);
static FRAME_INFO frame__53_389 = {1, {"kind"}};
static NODE *string__53_390;
static NODE *string__53_391;
static void cont__53_392(void);
static NODE *string__53_393;
static NODE *string__53_394;
static NODE *string__53_395;
static NODE *string__53_396;
static NODE *string__53_397;
static NODE *get__sim2c__define_c_code(void) {
  return var.sim2c__define_c_code;
}
static NODE *func__54_1;
static void entry__54_1(void);
static FRAME_INFO frame__54_1 = {4, {"destination", "source", "attributes", "code"}};
static void cont__54_2(void);
static NODE *string__54_3;
static NODE *string__54_4;
static void cont__54_5(void);
static void cont__54_6(void);
static NODE *func__54_7;
static void entry__54_7(void);
static FRAME_INFO frame__54_7 = {3, {"attribute", "identifier", "value"}};
static void cont__54_8(void);
static void cont__54_9(void);
static void cont__54_10(void);
static void cont__54_11(void);
static void cont__54_12(void);
static NODE *func__54_13;
static void entry__54_13(void);
static FRAME_INFO frame__54_13 = {4, {"attribute", "identifier", "value", "kind"}};
static void cont__54_14(void);
static NODE *func__54_15;
static void entry__54_15(void);
static FRAME_INFO frame__54_15 = {0, {}};
static NODE *func__54_16;
static void entry__54_16(void);
static FRAME_INFO frame__54_16 = {0, {}};
static NODE *string__54_17;
static void cont__54_18(void);
static void cont__54_19(void);
static NODE *string__54_20;
static NODE *string__54_21;
static NODE *string__54_22;
static NODE *string__54_23;
static void cont__54_24(void);
static NODE *func__54_25;
static void entry__54_25(void);
static FRAME_INFO frame__54_25 = {1, {"value"}};
static NODE *string__54_26;
static NODE *string__54_27;
static void cont__54_28(void);
static void cont__54_29(void);
static NODE *string__54_30;
static void cont__54_31(void);
static NODE *string__54_32;
static NODE *string__54_33;
static void cont__54_34(void);
static NODE *func__55_1;
static void entry__55_1(void);
static FRAME_INFO frame__55_1 = {4, {"statement", "functor", "input_arguments", "output_arguments"}};
static NODE *func__55_2;
static void entry__55_2(void);
static FRAME_INFO frame__55_2 = {1, {"statement"}};
static NODE *func__55_3;
static void entry__55_3(void);
static FRAME_INFO frame__55_3 = {1, {"statement"}};
static void cont__55_4(void);
static NODE *func__55_5;
static void entry__55_5(void);
static FRAME_INFO frame__55_5 = {0, {}};
static NODE *string__55_6;
static NODE *func__55_7;
static void entry__55_7(void);
static FRAME_INFO frame__55_7 = {1, {"statement"}};
static void cont__55_8(void);
static NODE *func__55_9;
static void entry__55_9(void);
static FRAME_INFO frame__55_9 = {0, {}};
static NODE *string__55_10;
static NODE *func__55_11;
static void entry__55_11(void);
static FRAME_INFO frame__55_11 = {0, {}};
static NODE *string__55_12;
static void cont__55_13(void);
static void cont__55_14(void);
static void cont__55_15(void);
static void cont__55_16(void);
static void cont__55_17(void);
static void cont__55_18(void);
static void cont__55_19(void);
static void cont__55_20(void);
static NODE *func__55_21;
static void entry__55_21(void);
static FRAME_INFO frame__55_21 = {1, {"input_arguments"}};
static void cont__55_22(void);
static void cont__55_23(void);
static void cont__55_24(void);
static void cont__55_25(void);
static NODE *func__55_26;
static void entry__55_26(void);
static FRAME_INFO frame__55_26 = {5, {"statement", "functor", "input_arguments", "destination", "source"}};
static void cont__55_27(void);
static void cont__55_28(void);
static void cont__55_29(void);
static NODE *func__55_30;
static void entry__55_30(void);
static FRAME_INFO frame__55_30 = {1, {"functor"}};
static NODE *func__55_31;
static void entry__55_31(void);
static FRAME_INFO frame__55_31 = {1, {"destination"}};
static void cont__55_32(void);
static NODE *func__55_33;
static void entry__55_33(void);
static FRAME_INFO frame__55_33 = {4, {"functor", "input_arguments", "statement", "output_arguments"}};
static void cont__55_34(void);
static NODE *func__55_35;
static void entry__55_35(void);
static FRAME_INFO frame__55_35 = {4, {"input_arguments", "statement", "output_arguments", "functor"}};
static void cont__55_36(void);
static NODE *func__55_37;
static void entry__55_37(void);
static FRAME_INFO frame__55_37 = {1, {"statement"}};
static void cont__55_38(void);
static void cont__55_39(void);
static NODE *func__55_40;
static void entry__55_40(void);
static FRAME_INFO frame__55_40 = {1, {"statement"}};
static void cont__55_41(void);
static void cont__55_42(void);
static NODE *string__55_43;
static NODE *string__55_44;
static void cont__55_45(void);
static NODE *func__55_46;
static void entry__55_46(void);
static FRAME_INFO frame__55_46 = {1, {"statement"}};
static void cont__55_47(void);
static void cont__55_48(void);
static NODE *func__55_49;
static void entry__55_49(void);
static FRAME_INFO frame__55_49 = {1, {"statement"}};
static NODE *string__55_50;
static NODE *func__55_51;
static void entry__55_51(void);
static FRAME_INFO frame__55_51 = {2, {"output_arguments", "result_count"}};
static void cont__55_52(void);
static NODE *func__55_53;
static void entry__55_53(void);
static FRAME_INFO frame__55_53 = {1, {"result_count"}};
static NODE *string__55_54;
static NODE *string__55_55;
static void cont__55_56(void);
static NODE *func__55_57;
static void entry__55_57(void);
static FRAME_INFO frame__55_57 = {0, {}};
static NODE *string__55_58;
static void cont__55_59(void);
static void cont__55_60(void);
static NODE *string__55_61;
static NODE *string__55_62;
static void cont__55_63(void);
static void cont__55_64(void);
static NODE *func__55_65;
static void entry__55_65(void);
static FRAME_INFO frame__55_65 = {0, {}};
static NODE *string__55_66;
static void cont__55_67(void);
static NODE *string__55_68;
static void cont__55_69(void);
static NODE *string__55_70;
static NODE *string__55_71;
static void cont__55_72(void);
static void cont__55_73(void);
static NODE *string__55_74;
static NODE *func__55_75;
static void entry__55_75(void);
static FRAME_INFO frame__55_75 = {4, {"output_arguments", "input_arguments", "destination", "source"}};
static void cont__55_76(void);
static void cont__55_77(void);
static void cont__55_78(void);
static NODE *func__55_79;
static void entry__55_79(void);
static FRAME_INFO frame__55_79 = {1, {"source"}};
static void cont__55_80(void);
static void cont__55_81(void);
static NODE *func__55_82;
static void entry__55_82(void);
static FRAME_INFO frame__55_82 = {2, {"destination", "source"}};
static void cont__55_83(void);
static void cont__55_84(void);
static NODE *string__55_85;
static NODE *string__55_86;
static NODE *string__55_87;
static void cont__55_88(void);
static NODE *func__55_89;
static void entry__55_89(void);
static FRAME_INFO frame__55_89 = {2, {"destination", "source"}};
static void cont__55_90(void);
static void cont__55_91(void);
static NODE *get__sim2c__generate_statement(void) {
  return var.sim2c__generate_statement;
}
void run__c_code_generator(void);

static CONTINUATION_INFO continuation_info[] = {
  {type__sim2c__to_c, NULL, 32, 32, 2, 12},
  {run__c_code_generator, NULL, 40, 40, 1, 31},
  {entry__9_4, NULL, 42, 42, 44, 50},
  {entry__9_5, NULL, 42, 42, 56, 71},
  {cont__9_6, &frame__9_5, 42, 42, 53, 71},
  {entry__9_1, NULL, 42, 42, 22, 41},
  {cont__9_3, &frame__9_1, 42, 42, 19, 71},
  {entry__10_4, NULL, 45, 45, 31, 49},
  {cont__10_6, &frame__10_4, 45, 45, 28, 49},
  {entry__10_7, NULL, 45, 45, 55, 74},
  {cont__10_9, &frame__10_7, 45, 45, 52, 74},
  {entry__10_1, NULL, 45, 45, 6, 25},
  {cont__10_3, &frame__10_1, 45, 45, 3, 74},
  {entry__11_1, NULL, 48, 48, 3, 20},
  {cont__11_2, &frame__11_1, 49, 49, 18, 18},
  {entry__12_3, NULL, 56, 56, 43, 74},
  {cont__12_4, &frame__12_3, 56, 56, 74, 74},
  {entry__12_2, NULL, 58, 58, 5, 31},
  {cont__12_5, &frame__12_2, 59, 59, 5, 31},
  {cont__12_6, &frame__12_2, },
  {entry__12_1, NULL, 53, 59, 3, 31},
  {cont__12_7, &frame__12_1, 60, 60, 3, 54},
  {entry__13_16, NULL, 70, 70, 37, 57},
  {cont__13_19, &frame__13_16, 70, 70, 34, 57},
  {entry__13_20, NULL, 70, 70, 60, 70},
  {entry__13_1, NULL, 63, 64, 25, 30},
  {cont__13_4, &frame__13_1, 63, 64, 3, 30},
  {cont__13_5, &frame__13_1, 65, 65, 3, 16},
  {cont__13_6, &frame__13_1, 66, 67, 9, 31},
  {cont__13_9, &frame__13_1, 66, 67, 3, 31},
  {cont__13_10, &frame__13_1, 68, 68, 31, 44},
  {cont__13_13, &frame__13_1, 68, 68, 3, 44},
  {cont__13_14, &frame__13_1, 70, 70, 8, 31},
  {cont__13_15, &frame__13_1, 70, 70, 5, 71},
  {cont__13_22, &frame__13_1, 69, 70, 3, 71},
  {entry__14_3, NULL, 75, 75, 35, 70},
  {cont__14_5, &frame__14_3, 75, 75, 7, 70},
  {cont__14_6, &frame__14_3, 76, 76, 42, 42},
  {entry__14_7, NULL, 78, 78, 7, 42},
  {entry__14_1, NULL, 74, 74, 5, 40},
  {cont__14_2, &frame__14_1, 73, 78, 3, 43},
  {entry__15_1, NULL, 81, 81, 3, 18},
  {cont__15_2, &frame__15_1, 82, 82, 3, 25},
  {entry__16_4, NULL, 92, 92, 39, 66},
  {cont__16_5, &frame__16_4, 92, 92, 39, 66},
  {entry__16_7, NULL, 93, 93, 9, 24},
  {entry__16_8, NULL, 95, 95, 9, 25},
  {cont__16_9, &frame__16_8, 95, 95, 25, 25},
  {entry__16_2, NULL, 92, 92, 7, 34},
  {cont__16_3, &frame__16_2, 92, 92, 7, 66},
  {cont__16_6, &frame__16_2, 91, 95, 5, 26},
  {entry__16_1, NULL, 90, 95, 3, 27},
  {cont__16_10, &frame__16_1, 96, 96, 3, 17},
  {entry__17_5, NULL, 107, 107, 15, 56},
  {cont__17_8, &frame__17_5, 107, 107, 9, 56},
  {entry__17_3, NULL, 106, 106, 10, 32},
  {cont__17_4, &frame__17_3, 106, 107, 7, 56},
  {entry__17_9, NULL, 111, 111, 32, 60},
  {cont__17_10, &frame__17_9, 109, 112, 13, 31},
  {cont__17_13, &frame__17_9, 109, 112, 7, 31},
  {entry__17_19, NULL, 117, 117, 46, 75},
  {cont__17_22, &frame__17_19, 117, 117, 40, 75},
  {entry__17_17, NULL, 117, 117, 10, 37},
  {cont__17_18, &frame__17_17, 117, 117, 7, 75},
  {entry__17_25, NULL, 118, 118, 46, 68},
  {cont__17_28, &frame__17_25, 118, 118, 40, 68},
  {entry__17_23, NULL, 118, 118, 10, 37},
  {cont__17_24, &frame__17_23, 118, 118, 7, 68},
  {entry__17_31, NULL, 120, 120, 47, 52},
  {entry__17_32, NULL, 120, 120, 55, 75},
  {entry__17_29, NULL, 120, 120, 22, 44},
  {cont__17_30, &frame__17_29, 120, 120, 9, 76},
  {cont__17_34, &frame__17_29, 121, 121, 15, 61},
  {cont__17_38, &frame__17_29, 121, 121, 9, 61},
  {cont__17_39, &frame__17_29, 122, 122, 9, 16},
  {cont__17_40, &frame__17_29, 122, 122, 16, 16},
  {entry__17_15, NULL, 115, 115, 5, 22},
  {cont__17_16, &frame__17_15, 116, 122, 5, 17},
  {entry__17_1, NULL, 103, 103, 3, 42},
  {cont__17_2, &frame__17_1, 104, 112, 3, 33},
  {cont__17_14, &frame__17_1, 114, 122, 3, 18},
  {entry__18_4, NULL, 128, 128, 26, 54},
  {cont__18_5, &frame__18_4, 128, 128, 10, 55},
  {cont__18_6, &frame__18_4, 128, 128, 7, 55},
  {entry__18_7, NULL, 129, 129, 7, 11},
  {entry__18_2, NULL, 127, 127, 7, 31},
  {cont__18_3, &frame__18_2, 126, 129, 5, 11},
  {entry__18_9, NULL, 156, 156, 13, 13},
  {entry__18_1, NULL, 131, 131, 6, 29},
  {cont__18_8, &frame__18_1, 131, 156, 3, 13},
  {cont__18_10, &frame__18_1, 159, 159, 20, 31},
  {cont__18_11, &frame__18_1, 160, 160, 31, 42},
  {cont__18_12, &frame__18_1, 157, 161, 9, 30},
  {cont__18_17, &frame__18_1, 157, 161, 3, 30},
  {entry__19_8, NULL, 177, 177, 45, 60},
  {cont__19_9, &frame__19_8, 177, 177, 15, 76},
  {cont__19_13, &frame__19_8, 176, 177, 13, 76},
  {entry__19_14, NULL, 179, 179, 32, 47},
  {cont__19_15, &frame__19_14, 179, 179, 20, 63},
  {cont__19_18, &frame__19_14, 179, 179, 13, 63},
  {entry__19_6, NULL, 175, 175, 11, 42},
  {cont__19_7, &frame__19_6, 174, 179, 9, 64},
  {entry__19_21, NULL, 184, 184, 45, 60},
  {cont__19_22, &frame__19_21, 184, 184, 15, 76},
  {cont__19_26, &frame__19_21, 183, 184, 13, 76},
  {entry__19_27, NULL, 186, 186, 43, 68},
  {cont__19_28, &frame__19_27, 186, 186, 13, 69},
  {cont__19_29, &frame__19_27, 187, 187, 20, 66},
  {cont__19_33, &frame__19_27, 187, 187, 13, 66},
  {entry__19_19, NULL, 182, 182, 11, 42},
  {cont__19_20, &frame__19_19, 181, 187, 9, 67},
  {entry__19_38, NULL, 192, 192, 20, 63},
  {cont__19_42, &frame__19_38, 192, 192, 13, 63},
  {entry__19_43, NULL, 194, 194, 20, 66},
  {cont__19_47, &frame__19_43, 194, 194, 13, 66},
  {entry__19_34, NULL, 189, 189, 39, 64},
  {cont__19_35, &frame__19_34, 189, 189, 9, 65},
  {cont__19_36, &frame__19_34, 191, 191, 11, 42},
  {cont__19_37, &frame__19_34, 190, 194, 9, 67},
  {entry__19_4, NULL, 172, 172, 7, 35},
  {cont__19_5, &frame__19_4, 171, 194, 5, 69},
  {entry__19_52, NULL, 198, 198, 38, 38},
  {cont__19_53, &frame__19_52, 198, 198, 24, 39},
  {cont__19_54, &frame__19_52, 198, 198, 8, 54},
  {cont__19_58, &frame__19_52, 198, 198, 5, 54},
  {entry__19_59, NULL, 199, 199, 8, 39},
  {cont__19_62, &frame__19_59, 199, 199, 5, 39},
  {entry__19_1, NULL, 170, 170, 6, 32},
  {cont__19_3, &frame__19_1, 170, 194, 3, 70},
  {cont__19_48, &frame__19_1, 195, 195, 3, 24},
  {cont__19_49, &frame__19_1, 197, 197, 5, 28},
  {cont__19_51, &frame__19_1, 196, 199, 3, 39},
  {cont__19_63, &frame__19_1, 199, 199, 39, 39},
  {entry__20_4, NULL, 209, 209, 49, 67},
  {cont__20_6, &frame__20_4, 209, 209, 49, 67},
  {entry__20_8, NULL, 210, 210, 21, 46},
  {cont__20_9, &frame__20_8, 210, 210, 7, 47},
  {cont__20_10, &frame__20_8, 212, 212, 33, 52},
  {cont__20_11, &frame__20_8, 211, 213, 13, 47},
  {cont__20_16, &frame__20_8, 211, 213, 7, 47},
  {entry__20_17, NULL, 215, 215, 13, 51},
  {cont__20_18, &frame__20_17, 215, 215, 7, 51},
  {entry__20_1, NULL, 209, 209, 5, 44},
  {cont__20_3, &frame__20_1, 209, 209, 5, 67},
  {cont__20_7, &frame__20_1, 208, 215, 3, 52},
  {entry__21_9, NULL, 232, 232, 40, 71},
  {cont__21_10, &frame__21_9, 232, 232, 40, 71},
  {entry__21_12, NULL, 233, 233, 42, 42},
  {entry__21_5, NULL, 230, 230, 9, 24},
  {cont__21_6, &frame__21_5, 231, 231, 9, 47},
  {cont__21_7, &frame__21_5, 232, 232, 12, 35},
  {cont__21_8, &frame__21_5, 232, 232, 12, 71},
  {cont__21_11, &frame__21_5, 232, 233, 9, 42},
  {entry__21_3, NULL, 229, 229, 10, 35},
  {cont__21_4, &frame__21_3, 229, 233, 7, 43},
  {entry__21_15, NULL, 234, 234, 52, 52},
  {entry__21_13, NULL, 234, 234, 10, 35},
  {cont__21_14, &frame__21_13, 234, 234, 7, 52},
  {entry__21_19, NULL, 238, 238, 25, 49},
  {cont__21_20, &frame__21_19, 238, 238, 25, 49},
  {entry__21_22, NULL, 238, 238, 52, 67},
  {cont__21_23, &frame__21_22, 238, 238, 67, 67},
  {entry__21_16, NULL, 236, 236, 9, 24},
  {cont__21_17, &frame__21_16, 237, 237, 9, 24},
  {cont__21_18, &frame__21_16, 238, 238, 12, 49},
  {cont__21_21, &frame__21_16, 238, 238, 9, 67},
  {entry__21_2, NULL, 228, 238, 5, 68},
  {entry__21_25, NULL, 240, 240, 18, 42},
  {cont__21_26, &frame__21_25, 240, 240, 18, 42},
  {entry__21_30, NULL, 242, 247, 15, 15},
  {cont__21_34, &frame__21_30, 242, 247, 9, 15},
  {entry__21_36, NULL, 249, 254, 15, 15},
  {cont__21_40, &frame__21_36, 249, 254, 9, 15},
  {entry__21_28, NULL, 241, 241, 10, 24},
  {cont__21_29, &frame__21_28, 241, 247, 7, 16},
  {cont__21_35, &frame__21_28, 248, 254, 7, 16},
  {entry__21_41, NULL, 256, 261, 13, 13},
  {cont__21_45, &frame__21_41, 256, 261, 7, 13},
  {entry__21_49, NULL, 262, 262, 27, 35},
  {entry__21_51, NULL, 262, 262, 38, 70},
  {entry__21_62, NULL, 273, 273, 9, 34},
  {entry__21_61, NULL, 273, 273, 9, 34},
  {cont__21_63, &frame__21_61, },
  {entry__21_59, NULL, 271, 271, 9, 43},
  {cont__21_60, &frame__21_59, },
  {cont__21_64, &frame__21_59, },
  {entry__21_66, NULL, 275, 275, 67, 71},
  {cont__21_67, &frame__21_66, 275, 275, 47, 74},
  {cont__21_70, &frame__21_66, 275, 275, 9, 74},
  {entry__21_55, NULL, 267, 267, 5, 24},
  {cont__21_56, &frame__21_55, 270, 270, 9, 25},
  {cont__21_58, &frame__21_55, },
  {cont__21_65, &frame__21_55, 268, 275, 5, 75},
  {entry__21_72, NULL, 282, 282, 16, 18},
  {cont__21_73, &frame__21_72, 282, 282, 7, 19},
  {cont__21_74, &frame__21_72, 283, 283, 42, 44},
  {cont__21_75, &frame__21_72, 283, 283, 7, 47},
  {cont__21_78, &frame__21_72, 280, 283, 5, 47},
  {entry__21_80, NULL, 288, 288, 44, 66},
  {cont__21_81, &frame__21_80, 288, 288, 44, 68},
  {cont__21_82, &frame__21_80, 288, 288, 36, 69},
  {cont__21_83, &frame__21_80, 289, 289, 24, 46},
  {cont__21_84, &frame__21_80, 288, 289, 71, 80},
  {cont__21_88, &frame__21_80, 288, 289, 5, 80},
  {entry__21_100, NULL, 299, 299, 50, 60},
  {cont__21_102, &frame__21_100, 299, 299, 47, 60},
  {entry__21_103, NULL, 299, 299, 33, 44},
  {entry__21_97, NULL, 298, 298, 7, 24},
  {cont__21_98, &frame__21_97, 299, 299, 15, 30},
  {cont__21_99, &frame__21_97, 299, 299, 7, 61},
  {cont__21_105, &frame__21_97, 301, 301, 9, 22},
  {cont__21_108, &frame__21_97, 303, 303, 9, 20},
  {cont__21_109, &frame__21_97, 304, 304, 29, 33},
  {cont__21_110, &frame__21_97, 304, 304, 9, 36},
  {cont__21_113, &frame__21_97, 300, 304, 7, 36},
  {entry__21_126, NULL, 315, 315, 54, 64},
  {cont__21_128, &frame__21_126, 315, 315, 51, 64},
  {entry__21_129, NULL, 315, 315, 37, 48},
  {entry__21_123, NULL, 314, 314, 11, 28},
  {cont__21_124, &frame__21_123, 315, 315, 19, 34},
  {cont__21_125, &frame__21_123, 315, 315, 11, 65},
  {cont__21_131, &frame__21_123, 316, 316, 11, 20},
  {cont__21_132, &frame__21_123, 317, 317, 11, 21},
  {cont__21_133, &frame__21_123, 318, 322, 17, 31},
  {cont__21_138, &frame__21_123, 318, 322, 11, 31},
  {entry__21_155, NULL, 335, 335, 21, 48},
  {entry__21_153, NULL, 334, 334, 28, 48},
  {cont__21_154, &frame__21_153, 334, 335, 19, 48},
  {entry__21_156, NULL, 337, 337, 57, 74},
  {cont__21_157, &frame__21_156, 337, 337, 19, 74},
  {entry__21_151, NULL, 333, 333, 17, 48},
  {cont__21_152, &frame__21_151, 332, 337, 15, 75},
  {entry__21_158, NULL, 339, 339, 15, 63},
  {entry__21_147, NULL, 328, 328, 11, 30},
  {cont__21_148, &frame__21_147, 329, 329, 11, 49},
  {cont__21_149, &frame__21_147, 331, 331, 13, 36},
  {cont__21_150, &frame__21_147, 330, 339, 11, 64},
  {cont__21_160, &frame__21_147, 340, 340, 29, 43},
  {cont__21_161, &frame__21_147, 340, 340, 11, 44},
  {cont__21_162, &frame__21_147, 341, 343, 17, 13},
  {cont__21_166, &frame__21_147, 341, 343, 11, 13},
  {cont__21_167, &frame__21_147, 344, 344, 29, 55},
  {cont__21_170, &frame__21_147, 344, 344, 11, 55},
  {entry__21_119, NULL, 313, 313, 22, 44},
  {cont__21_120, &frame__21_119, 313, 313, 46, 68},
  {cont__21_121, &frame__21_119, 313, 313, 46, 70},
  {cont__21_122, &frame__21_119, 313, 322, 9, 32},
  {cont__21_139, &frame__21_119, 323, 326, 15, 15},
  {cont__21_142, &frame__21_119, 323, 326, 9, 15},
  {cont__21_143, &frame__21_119, 327, 327, 17, 39},
  {cont__21_144, &frame__21_119, 327, 327, 17, 41},
  {cont__21_145, &frame__21_119, 327, 327, 43, 65},
  {cont__21_146, &frame__21_119, 327, 344, 9, 55},
  {entry__21_179, NULL, 351, 351, 45, 62},
  {cont__21_180, &frame__21_179, 351, 351, 42, 62},
  {entry__21_181, NULL, 351, 351, 65, 78},
  {entry__21_175, NULL, 347, 347, 11, 30},
  {cont__21_176, &frame__21_175, 348, 348, 11, 49},
  {cont__21_177, &frame__21_175, 351, 351, 16, 39},
  {cont__21_178, &frame__21_175, 350, 351, 11, 79},
  {cont__21_183, &frame__21_175, 354, 354, 25, 39},
  {cont__21_184, &frame__21_175, 354, 354, 25, 41},
  {cont__21_185, &frame__21_175, 354, 354, 13, 45},
  {cont__21_188, &frame__21_175, 353, 357, 11, 17},
  {entry__21_171, NULL, 346, 346, 17, 39},
  {cont__21_172, &frame__21_171, 346, 346, 17, 41},
  {cont__21_173, &frame__21_171, 346, 346, 43, 65},
  {cont__21_174, &frame__21_171, 346, 357, 9, 18},
  {cont__21_189, &frame__21_171, 358, 360, 9, 15},
  {entry__21_91, NULL, 294, 296, 5, 34},
  {cont__21_93, &frame__21_91, 297, 297, 18, 40},
  {cont__21_94, &frame__21_91, 297, 297, 42, 64},
  {cont__21_95, &frame__21_91, 297, 297, 42, 66},
  {cont__21_96, &frame__21_91, 297, 304, 5, 37},
  {cont__21_114, &frame__21_91, 305, 309, 11, 34},
  {cont__21_117, &frame__21_91, 305, 309, 5, 34},
  {cont__21_118, &frame__21_91, 311, 360, 5, 17},
  {entry__21_1, NULL, 227, 238, 3, 69},
  {cont__21_24, &frame__21_1, 240, 240, 5, 42},
  {cont__21_27, &frame__21_1, 239, 261, 3, 15},
  {cont__21_46, &frame__21_1, 262, 262, 6, 22},
  {cont__21_48, &frame__21_1, 262, 262, 6, 35},
  {cont__21_50, &frame__21_1, 262, 262, 3, 70},
  {cont__21_53, &frame__21_1, 266, 266, 13, 35},
  {cont__21_54, &frame__21_1, 266, 275, 3, 76},
  {cont__21_71, &frame__21_1, 279, 283, 3, 48},
  {cont__21_79, &frame__21_1, 287, 289, 3, 81},
  {cont__21_89, &frame__21_1, 293, 293, 6, 30},
  {cont__21_90, &frame__21_1, 293, 360, 3, 18},
  {entry__22_1, NULL, 367, 372, 7, 18},
  {cont__22_3, &frame__22_1, 365, 372, 5, 19},
  {cont__22_4, &frame__22_1, 363, 372, 3, 21},
  {entry__23_7, NULL, 376, 376, 33, 38},
  {cont__23_8, &frame__23_7, 376, 376, 33, 55},
  {cont__23_9, &frame__23_7, 376, 376, 33, 55},
  {cont__23_10, &frame__23_7, 376, 376, 33, 55},
  {entry__23_12, NULL, 376, 376, 58, 63},
  {cont__23_13, &frame__23_12, 376, 376, 63, 63},
  {entry__23_3, NULL, 376, 376, 12, 17},
  {cont__23_4, &frame__23_3, 376, 376, 12, 28},
  {cont__23_5, &frame__23_3, 376, 376, 12, 28},
  {cont__23_6, &frame__23_3, 376, 376, 12, 55},
  {cont__23_11, &frame__23_3, 376, 376, 9, 63},
  {entry__23_1, NULL, 375, 375, 3, 8},
  {cont__23_2, &frame__23_1, 376, 376, 3, 63},
  {cont__23_14, &frame__23_1, 377, 377, 7, 7},
  {cont__23_15, &frame__23_1, 377, 377, 3, 7},
  {entry__24_16, NULL, 401, 401, 10, 34},
  {cont__24_17, &frame__24_16, 401, 401, 36, 51},
  {cont__24_18, &frame__24_16, 401, 401, 10, 51},
  {cont__24_19, &frame__24_16, 401, 401, 7, 51},
  {entry__24_20, NULL, 402, 402, 10, 26},
  {cont__24_21, &frame__24_20, 402, 402, 10, 28},
  {cont__24_22, &frame__24_20, 402, 402, 7, 28},
  {entry__24_36, NULL, 417, 417, 12, 36},
  {cont__24_37, &frame__24_36, 417, 417, 38, 58},
  {cont__24_38, &frame__24_36, 417, 417, 12, 58},
  {cont__24_39, &frame__24_36, 417, 417, 12, 60},
  {cont__24_40, &frame__24_36, 417, 417, 9, 60},
  {entry__24_41, NULL, 418, 418, 22, 38},
  {cont__24_42, &frame__24_41, 418, 418, 12, 38},
  {cont__24_43, &frame__24_41, 418, 418, 9, 38},
  {entry__24_49, NULL, 426, 426, 29, 29},
  {entry__24_53, NULL, 430, 430, 37, 61},
  {cont__24_54, &frame__24_53, 430, 430, 32, 63},
  {cont__24_56, &frame__24_53, 430, 430, 29, 63},
  {entry__24_57, NULL, 430, 430, 66, 70},
  {entry__24_64, NULL, 449, 449, 21, 43},
  {cont__24_65, &frame__24_64, 449, 449, 13, 47},
  {cont__24_68, &frame__24_64, 449, 449, 58, 70},
  {cont__24_69, &frame__24_64, 449, 449, 49, 71},
  {cont__24_71, &frame__24_64, 449, 449, 7, 71},
  {cont__24_72, &frame__24_64, 450, 450, 7, 18},
  {cont__24_73, &frame__24_64, 450, 450, 18, 18},
  {entry__24_76, NULL, 436, 436, 7, 29},
  {cont__24_77, &frame__24_76, 437, 437, 25, 25},
  {entry__24_88, NULL, 443, 443, 17, 17},
  {cont__24_89, &frame__24_88, 443, 443, 9, 18},
  {cont__24_90, &frame__24_88, 443, 443, 9, 35},
  {cont__24_91, &frame__24_88, 443, 443, 9, 35},
  {cont__24_92, &frame__24_88, 443, 443, 9, 35},
  {entry__24_83, NULL, 442, 442, 17, 17},
  {cont__24_84, &frame__24_83, 442, 442, 9, 18},
  {cont__24_85, &frame__24_83, 442, 442, 9, 29},
  {cont__24_86, &frame__24_83, 442, 442, 9, 29},
  {cont__24_87, &frame__24_83, 443, 443, 9, 35},
  {cont__24_93, &frame__24_83, },
  {entry__24_95, NULL, 445, 445, 9, 29},
  {cont__24_97, &frame__24_95, 445, 445, 29, 29},
  {entry__24_102, NULL, 446, 446, 35, 54},
  {cont__24_103, &frame__24_102, 446, 446, 54, 54},
  {entry__24_111, NULL, 458, 458, 38, 48},
  {cont__24_112, &frame__24_111, 458, 458, 48, 48},
  {entry__24_117, NULL, 462, 462, 17, 32},
  {entry__24_119, NULL, 464, 464, 35, 52},
  {entry__24_118, NULL, 464, 464, 17, 52},
  {cont__24_121, &frame__24_118, 465, 465, 17, 21},
  {entry__24_109, NULL, 458, 458, 16, 35},
  {cont__24_110, &frame__24_109, 458, 458, 13, 48},
  {cont__24_113, &frame__24_109, 459, 459, 13, 19},
  {cont__24_114, &frame__24_109, 461, 461, 15, 37},
  {cont__24_115, &frame__24_109, 461, 461, 15, 37},
  {cont__24_116, &frame__24_109, 460, 465, 13, 22},
  {entry__24_122, NULL, 467, 467, 13, 23},
  {cont__24_123, &frame__24_122, 467, 467, 23, 23},
  {entry__24_124, NULL, 469, 469, 13, 21},
  {entry__24_107, NULL, 457, 457, 11, 32},
  {cont__24_108, &frame__24_107, 455, 469, 9, 22},
  {entry__24_106, NULL, 454, 469, 7, 23},
  {cont__24_125, &frame__24_106, 469, 469, 23, 23},
  {entry__24_63, NULL, 435, 435, 23, 31},
  {cont__24_74, &frame__24_63, 435, 435, 8, 31},
  {cont__24_75, &frame__24_63, 435, 437, 5, 25},
  {cont__24_78, &frame__24_63, 438, 438, 22, 44},
  {cont__24_79, &frame__24_63, 438, 438, 5, 45},
  {cont__24_80, &frame__24_63, 441, 441, 9, 25},
  {cont__24_81, &frame__24_63, 441, 441, 9, 29},
  {cont__24_82, &frame__24_63, },
  {cont__24_94, &frame__24_63, 439, 445, 5, 30},
  {cont__24_98, &frame__24_63, 446, 446, 20, 20},
  {cont__24_99, &frame__24_63, 446, 446, 12, 21},
  {cont__24_100, &frame__24_63, 446, 446, 12, 32},
  {cont__24_101, &frame__24_63, 446, 446, 5, 54},
  {cont__24_104, &frame__24_63, 452, 452, 5, 20},
  {cont__24_105, &frame__24_63, 453, 469, 5, 24},
  {entry__24_1, NULL, 385, 385, 3, 29},
  {cont__24_2, &frame__24_1, 386, 386, 3, 38},
  {cont__24_3, &frame__24_1, 387, 387, 3, 34},
  {cont__24_4, &frame__24_1, 388, 388, 8, 33},
  {cont__24_5, &frame__24_1, 388, 388, 8, 40},
  {cont__24_6, &frame__24_1, 388, 388, 3, 42},
  {cont__24_7, &frame__24_1, 389, 389, 35, 39},
  {cont__24_8, &frame__24_1, 389, 389, 3, 40},
  {cont__24_9, &frame__24_1, 390, 390, 3, 40},
  {cont__24_10, &frame__24_1, 391, 391, 3, 31},
  {cont__24_11, &frame__24_1, 395, 395, 7, 49},
  {cont__24_12, &frame__24_1, 396, 396, 7, 55},
  {cont__24_13, &frame__24_1, 393, 396, 3, 56},
  {cont__24_14, &frame__24_1, 400, 400, 7, 17},
  {cont__24_15, &frame__24_1, 398, 402, 3, 29},
  {cont__24_23, &frame__24_1, 404, 404, 35, 40},
  {cont__24_24, &frame__24_1, 404, 404, 43, 43},
  {cont__24_25, &frame__24_1, 404, 404, 3, 44},
  {cont__24_26, &frame__24_1, 405, 405, 23, 43},
  {cont__24_27, &frame__24_1, 405, 405, 21, 43},
  {cont__24_28, &frame__24_1, 405, 405, 21, 44},
  {cont__24_29, &frame__24_1, 405, 405, 3, 44},
  {cont__24_30, &frame__24_1, 410, 410, 7, 49},
  {cont__24_31, &frame__24_1, },
  {cont__24_32, &frame__24_1, 411, 411, 7, 55},
  {cont__24_33, &frame__24_1, 407, 411, 3, 56},
  {cont__24_34, &frame__24_1, 416, 416, 9, 30},
  {cont__24_35, &frame__24_1, 415, 418, 7, 37},
  {cont__24_44, &frame__24_1, 413, 419, 3, 8},
  {cont__24_45, &frame__24_1, 421, 421, 3, 32},
  {cont__24_46, &frame__24_1, 422, 422, 3, 37},
  {cont__24_47, &frame__24_1, 423, 423, 3, 41},
  {cont__24_48, &frame__24_1, 424, 426, 3, 29},
  {cont__24_50, &frame__24_1, 430, 430, 10, 26},
  {cont__24_51, &frame__24_1, 430, 430, 10, 26},
  {cont__24_52, &frame__24_1, 430, 430, 7, 71},
  {cont__24_58, &frame__24_1, 428, 430, 3, 73},
  {cont__24_62, &frame__24_1, 432, 469, 3, 25},
  {cont__24_126, &frame__24_1, 470, 470, 3, 22},
  {entry__25_4, NULL, 474, 474, 5, 65},
  {cont__25_5, &frame__25_4, 474, 474, 65, 65},
  {entry__25_1, NULL, 473, 473, 6, 26},
  {cont__25_2, &frame__25_1, 473, 473, 6, 37},
  {cont__25_3, &frame__25_1, 473, 474, 3, 65},
  {entry__29_4, NULL, 486, 486, 30, 41},
  {entry__29_2, NULL, 486, 486, 8, 27},
  {cont__29_3, &frame__29_2, 486, 486, 5, 41},
  {entry__29_7, NULL, 487, 487, 31, 45},
  {entry__29_5, NULL, 487, 487, 8, 28},
  {cont__29_6, &frame__29_5, 487, 487, 5, 45},
  {entry__29_15, NULL, 492, 492, 45, 55},
  {entry__29_16, NULL, 492, 492, 58, 65},
  {entry__29_13, NULL, 492, 492, 21, 42},
  {cont__29_14, &frame__29_13, 492, 492, 18, 66},
  {cont__29_17, &frame__29_13, 492, 492, 11, 66},
  {entry__29_10, NULL, 491, 491, 12, 31},
  {cont__29_11, &frame__29_10, 491, 491, 12, 42},
  {cont__29_12, &frame__29_10, 491, 492, 9, 66},
  {entry__29_24, NULL, 497, 497, 15, 28},
  {entry__29_26, NULL, 499, 499, 15, 26},
  {entry__29_27, NULL, 501, 501, 15, 29},
  {entry__29_21, NULL, 495, 495, 30, 47},
  {cont__29_22, &frame__29_21, 495, 495, 13, 48},
  {cont__29_23, &frame__29_21, 498, 498, 13, 39},
  {cont__29_25, &frame__29_21, 494, 501, 11, 30},
  {entry__29_18, NULL, 493, 493, 12, 29},
  {cont__29_19, &frame__29_18, 493, 493, 12, 40},
  {cont__29_20, &frame__29_18, 493, 501, 9, 31},
  {entry__29_31, NULL, 508, 508, 51, 70},
  {cont__29_32, &frame__29_31, 508, 508, 34, 48},
  {cont__29_33, &frame__29_31, 508, 508, 19, 49},
  {cont__29_34, &frame__29_31, 508, 508, 19, 71},
  {cont__29_35, &frame__29_31, 507, 508, 17, 70},
  {cont__29_36, &frame__29_31, 506, 508, 15, 72},
  {entry__29_37, NULL, 509, 509, 35, 52},
  {cont__29_38, &frame__29_37, 509, 509, 18, 53},
  {cont__29_39, &frame__29_37, 509, 509, 15, 53},
  {entry__29_42, NULL, 514, 514, 15, 29},
  {entry__29_43, NULL, 516, 516, 15, 26},
  {entry__29_28, NULL, 505, 505, 15, 34},
  {cont__29_29, &frame__29_28, 505, 505, 15, 45},
  {cont__29_30, &frame__29_28, 503, 509, 11, 54},
  {cont__29_40, &frame__29_28, 513, 513, 13, 39},
  {cont__29_41, &frame__29_28, 511, 516, 11, 27},
  {entry__29_8, NULL, 489, 489, 7, 35},
  {cont__29_9, &frame__29_8, 490, 516, 7, 29},
  {entry__29_1, NULL, 485, 516, 3, 31},
  {cont__29_44, &frame__29_1, 517, 517, 3, 12},
  {entry__30_1, NULL, 523, 523, 3, 48},
  {cont__30_3, &frame__30_1, 524, 524, 3, 10},
  {entry__31_9, NULL, 666, 666, 47, 64},
  {cont__31_10, &frame__31_9, 666, 666, 44, 64},
  {entry__31_11, NULL, 666, 666, 67, 79},
  {entry__31_14, NULL, 671, 671, 14, 38},
  {cont__31_15, &frame__31_14, 671, 671, 11, 38},
  {entry__31_16, NULL, 672, 672, 11, 22},
  {entry__31_7, NULL, 666, 666, 12, 41},
  {cont__31_8, &frame__31_7, 665, 666, 7, 80},
  {cont__31_12, &frame__31_7, 670, 670, 11, 40},
  {cont__31_13, &frame__31_7, 668, 672, 7, 23},
  {cont__31_17, &frame__31_7, 674, 674, 7, 27},
  {entry__31_22, NULL, 681, 681, 38, 60},
  {cont__31_23, &frame__31_22, 681, 681, 14, 64},
  {cont__31_26, &frame__31_22, 681, 681, 11, 64},
  {entry__31_27, NULL, 684, 684, 14, 24},
  {cont__31_28, &frame__31_27, 684, 684, 11, 24},
  {entry__31_29, NULL, 683, 683, 11, 30},
  {entry__31_20, NULL, 679, 679, 11, 26},
  {cont__31_21, &frame__31_20, 678, 684, 9, 24},
  {entry__31_31, NULL, 677, 677, 31, 50},
  {entry__31_18, NULL, 677, 677, 10, 28},
  {cont__31_19, &frame__31_18, 677, 684, 7, 25},
  {entry__31_37, NULL, 762, 762, 13, 52},
  {cont__31_38, &frame__31_37, 762, 762, 13, 68},
  {cont__31_39, &frame__31_37, 762, 762, 13, 68},
  {entry__31_35, NULL, 761, 761, 13, 45},
  {cont__31_36, &frame__31_35, 760, 762, 11, 67},
  {cont__31_40, &frame__31_35, 760, 762, 11, 67},
  {entry__31_42, NULL, 768, 768, 28, 54},
  {cont__31_43, &frame__31_42, 764, 770, 17, 51},
  {cont__31_46, &frame__31_42, 764, 770, 11, 51},
  {entry__31_47, NULL, 772, 772, 11, 77},
  {cont__31_48, &frame__31_47, 773, 773, 11, 48},
  {cont__31_49, &frame__31_47, 774, 778, 11, 51},
  {entry__31_33, NULL, 759, 759, 11, 32},
  {cont__31_34, &frame__31_33, 758, 762, 9, 68},
  {cont__31_41, &frame__31_33, 757, 778, 7, 53},
  {entry__31_57, NULL, 559, 559, 38, 69},
  {cont__31_58, &frame__31_57, 559, 559, 38, 69},
  {entry__31_60, NULL, 560, 560, 40, 40},
  {entry__31_62, NULL, 564, 564, 11, 43},
  {cont__31_63, &frame__31_62, 564, 564, 43, 43},
  {entry__31_64, NULL, 566, 566, 11, 42},
  {cont__31_65, &frame__31_64, 567, 567, 11, 43},
  {cont__31_66, &frame__31_64, 567, 567, 43, 43},
  {entry__31_68, NULL, 569, 569, 11, 45},
  {cont__31_69, &frame__31_68, 569, 569, 45, 45},
  {entry__31_70, NULL, 571, 571, 11, 42},
  {cont__31_71, &frame__31_70, 571, 571, 42, 42},
  {entry__31_53, NULL, 557, 557, 7, 40},
  {cont__31_54, &frame__31_53, 558, 558, 7, 48},
  {cont__31_55, &frame__31_53, 559, 559, 10, 33},
  {cont__31_56, &frame__31_53, 559, 559, 10, 69},
  {cont__31_59, &frame__31_53, 559, 560, 7, 40},
  {cont__31_61, &frame__31_53, 568, 568, 9, 48},
  {cont__31_67, &frame__31_53, 561, 571, 7, 43},
  {entry__31_78, NULL, 578, 578, 43, 58},
  {cont__31_79, &frame__31_78, 578, 578, 58, 58},
  {entry__31_76, NULL, 578, 578, 12, 40},
  {cont__31_77, &frame__31_76, 578, 578, 9, 58},
  {entry__31_82, NULL, 579, 579, 66, 66},
  {entry__31_80, NULL, 579, 579, 12, 40},
  {cont__31_81, &frame__31_80, 579, 579, 9, 66},
  {entry__31_87, NULL, 583, 583, 41, 58},
  {cont__31_88, &frame__31_87, 583, 583, 58, 58},
  {entry__31_83, NULL, 581, 581, 11, 26},
  {cont__31_84, &frame__31_83, 582, 582, 11, 26},
  {cont__31_85, &frame__31_83, 583, 583, 14, 38},
  {cont__31_86, &frame__31_83, 583, 583, 11, 58},
  {entry__31_73, NULL, 576, 576, 21, 44},
  {cont__31_74, &frame__31_73, 576, 576, 7, 45},
  {cont__31_75, &frame__31_73, 577, 583, 7, 59},
  {cont__31_89, &frame__31_73, 584, 584, 7, 19},
  {cont__31_90, &frame__31_73, 585, 585, 7, 61},
  {cont__31_91, &frame__31_73, 585, 585, 7, 22},
  {cont__31_92, &frame__31_73, 586, 586, 7, 19},
  {cont__31_93, &frame__31_73, 586, 586, 19, 19},
  {entry__31_99, NULL, 592, 592, 37, 37},
  {entry__31_100, NULL, 594, 594, 43, 43},
  {entry__31_95, NULL, 588, 588, 21, 44},
  {cont__31_96, &frame__31_95, 588, 588, 7, 45},
  {cont__31_97, &frame__31_95, 590, 590, 9, 36},
  {cont__31_98, &frame__31_95, 589, 594, 7, 44},
  {cont__31_101, &frame__31_95, 595, 595, 7, 19},
  {cont__31_102, &frame__31_95, 596, 596, 7, 61},
  {cont__31_103, &frame__31_95, 596, 596, 7, 22},
  {cont__31_104, &frame__31_95, 597, 597, 7, 19},
  {cont__31_105, &frame__31_95, 597, 597, 19, 19},
  {entry__31_107, NULL, 599, 599, 32, 57},
  {cont__31_108, &frame__31_107, 599, 599, 32, 57},
  {cont__31_109, &frame__31_107, 599, 599, 32, 57},
  {entry__31_111, NULL, 599, 599, 67, 80},
  {entry__31_112, NULL, 599, 599, 64, 64},
  {cont__31_113, &frame__31_112, 599, 599, 60, 64},
  {entry__31_116, NULL, 604, 604, 7, 19},
  {cont__31_117, &frame__31_116, 605, 605, 7, 57},
  {cont__31_118, &frame__31_116, 605, 605, 7, 22},
  {cont__31_119, &frame__31_116, 606, 606, 7, 19},
  {cont__31_120, &frame__31_116, 606, 606, 19, 19},
  {entry__31_125, NULL, 612, 612, 37, 59},
  {cont__31_126, &frame__31_125, 612, 612, 37, 76},
  {cont__31_127, &frame__31_125, 612, 612, 37, 76},
  {cont__31_128, &frame__31_125, 612, 612, 37, 76},
  {entry__31_130, NULL, 613, 613, 9, 21},
  {cont__31_131, &frame__31_130, 614, 614, 9, 58},
  {cont__31_132, &frame__31_130, 614, 614, 9, 24},
  {cont__31_133, &frame__31_130, 615, 615, 9, 21},
  {cont__31_134, &frame__31_130, 615, 615, 21, 21},
  {entry__31_123, NULL, 612, 612, 14, 32},
  {cont__31_124, &frame__31_123, 612, 612, 14, 76},
  {cont__31_129, &frame__31_123, 612, 615, 7, 21},
  {entry__31_142, NULL, 623, 623, 26, 46},
  {cont__31_144, &frame__31_142, 623, 623, 7, 46},
  {cont__31_145, &frame__31_142, 623, 623, 46, 46},
  {entry__31_147, NULL, 624, 624, 30, 55},
  {entry__31_149, NULL, 625, 627, 7, 33},
  {entry__31_153, NULL, 631, 631, 9, 59},
  {cont__31_154, &frame__31_153, 631, 631, 9, 59},
  {entry__31_156, NULL, 633, 635, 9, 35},
  {entry__31_179, NULL, 642, 642, 21, 46},
  {entry__31_172, NULL, 641, 641, 15, 37},
  {cont__31_175, &frame__31_172, 641, 641, 7, 37},
  {cont__31_176, &frame__31_172, 642, 642, 10, 18},
  {cont__31_177, &frame__31_172, 642, 642, 10, 18},
  {cont__31_178, &frame__31_172, 642, 642, 7, 46},
  {cont__31_181, &frame__31_172, 643, 643, 29, 49},
  {cont__31_184, &frame__31_172, 643, 643, 7, 49},
  {entry__31_193, NULL, 655, 656, 35, 51},
  {cont__31_196, &frame__31_193, 655, 656, 13, 51},
  {cont__31_197, &frame__31_193, 657, 657, 16, 66},
  {cont__31_200, &frame__31_193, 657, 657, 13, 66},
  {entry__31_201, NULL, 653, 653, 11, 36},
  {entry__31_191, NULL, 652, 652, 11, 36},
  {cont__31_192, &frame__31_191, 651, 657, 9, 66},
  {cont__31_203, &frame__31_191, 648, 657, 7, 68},
  {entry__31_207, NULL, 661, 661, 28, 47},
  {cont__31_208, &frame__31_207, 662, 662, 40, 58},
  {cont__31_209, &frame__31_207, 659, 662, 13, 75},
  {cont__31_214, &frame__31_207, 659, 662, 7, 75},
  {entry__31_220, NULL, 690, 690, 22, 39},
  {cont__31_221, &frame__31_220, 690, 690, 44, 68},
  {cont__31_222, &frame__31_220, 690, 690, 11, 70},
  {cont__31_225, &frame__31_220, 689, 690, 9, 70},
  {entry__31_232, NULL, 695, 695, 13, 55},
  {cont__31_233, &frame__31_232, 696, 696, 19, 50},
  {cont__31_234, &frame__31_232, 696, 696, 13, 50},
  {entry__31_229, NULL, 694, 694, 14, 43},
  {cont__31_230, &frame__31_229, 694, 694, 14, 51},
  {cont__31_231, &frame__31_229, 694, 696, 11, 50},
  {entry__31_235, NULL, 698, 698, 25, 50},
  {cont__31_236, &frame__31_235, 698, 698, 11, 51},
  {cont__31_237, &frame__31_235, 701, 701, 32, 43},
  {cont__31_238, &frame__31_235, 699, 701, 17, 76},
  {cont__31_242, &frame__31_235, 699, 701, 11, 76},
  {entry__31_243, NULL, 703, 703, 17, 56},
  {cont__31_245, &frame__31_243, 703, 703, 11, 56},
  {entry__31_217, NULL, 687, 687, 7, 68},
  {cont__31_218, &frame__31_217, 688, 688, 10, 26},
  {cont__31_219, &frame__31_217, 688, 690, 7, 71},
  {cont__31_226, &frame__31_217, 692, 692, 9, 37},
  {cont__31_227, &frame__31_217, 693, 693, 9, 37},
  {cont__31_228, &frame__31_217, 691, 703, 7, 57},
  {entry__31_252, NULL, 709, 709, 11, 40},
  {cont__31_253, &frame__31_252, 709, 709, 11, 48},
  {cont__31_254, &frame__31_252, 709, 709, 11, 48},
  {cont__31_255, &frame__31_252, 709, 709, 11, 48},
  {entry__31_259, NULL, 714, 714, 15, 57},
  {cont__31_260, &frame__31_259, 715, 715, 47, 71},
  {cont__31_261, &frame__31_259, 715, 715, 15, 72},
  {cont__31_262, &frame__31_259, 716, 716, 21, 46},
  {cont__31_263, &frame__31_259, 716, 716, 15, 51},
  {cont__31_264, &frame__31_259, 717, 721, 21, 46},
  {cont__31_269, &frame__31_259, 717, 721, 15, 46},
  {entry__31_273, NULL, 725, 725, 19, 61},
  {cont__31_274, &frame__31_273, 726, 726, 51, 75},
  {cont__31_275, &frame__31_273, 726, 726, 19, 76},
  {cont__31_276, &frame__31_273, 727, 727, 25, 50},
  {cont__31_277, &frame__31_273, 727, 727, 19, 55},
  {cont__31_278, &frame__31_273, 728, 732, 25, 28},
  {cont__31_283, &frame__31_273, 728, 732, 19, 28},
  {entry__31_284, NULL, 734, 734, 19, 52},
  {cont__31_285, &frame__31_284, 738, 738, 25, 50},
  {cont__31_286, &frame__31_284, 738, 738, 19, 55},
  {cont__31_287, &frame__31_284, 739, 742, 25, 62},
  {cont__31_291, &frame__31_284, 739, 742, 19, 62},
  {entry__31_270, NULL, 724, 724, 17, 41},
  {cont__31_271, &frame__31_270, 724, 724, 17, 52},
  {cont__31_272, &frame__31_270, 723, 742, 15, 64},
  {entry__31_257, NULL, 712, 712, 13, 42},
  {cont__31_258, &frame__31_257, 711, 742, 11, 66},
  {entry__31_248, NULL, 705, 705, 7, 68},
  {cont__31_249, &frame__31_248, 708, 708, 11, 39},
  {cont__31_250, &frame__31_248, 708, 708, 11, 56},
  {cont__31_251, &frame__31_248, 707, 709, 9, 47},
  {cont__31_256, &frame__31_248, 706, 742, 7, 68},
  {entry__31_294, NULL, 744, 744, 29, 64},
  {entry__31_293, NULL, 744, 744, 7, 64},
  {cont__31_296, &frame__31_293, 745, 745, 7, 16},
  {entry__31_299, NULL, 747, 747, 7, 69},
  {entry__31_306, NULL, 750, 750, 23, 46},
  {cont__31_307, &frame__31_306, 750, 750, 9, 47},
  {cont__31_308, &frame__31_306, 753, 753, 30, 41},
  {cont__31_309, &frame__31_306, 751, 753, 15, 74},
  {cont__31_313, &frame__31_306, 751, 753, 9, 74},
  {entry__31_303, NULL, 749, 749, 14, 41},
  {cont__31_304, &frame__31_303, 749, 749, 14, 61},
  {cont__31_305, &frame__31_303, 749, 753, 7, 75},
  {entry__31_317, NULL, 780, 780, 51, 78},
  {entry__31_320, NULL, 783, 783, 9, 21},
  {entry__31_329, NULL, 799, 799, 38, 60},
  {cont__31_330, &frame__31_329, 799, 799, 17, 60},
  {cont__31_331, &frame__31_329, 802, 802, 34, 60},
  {cont__31_332, &frame__31_329, 800, 804, 23, 57},
  {cont__31_335, &frame__31_329, 800, 804, 17, 57},
  {entry__31_336, NULL, 807, 807, 44, 66},
  {cont__31_337, &frame__31_336, 807, 807, 19, 67},
  {cont__31_338, &frame__31_336, 806, 807, 17, 67},
  {cont__31_339, &frame__31_336, 808, 812, 17, 57},
  {entry__31_326, NULL, 788, 788, 13, 44},
  {cont__31_327, &frame__31_326, 798, 798, 15, 47},
  {cont__31_328, &frame__31_326, 797, 812, 13, 59},
  {entry__31_324, NULL, 787, 787, 14, 34},
  {cont__31_325, &frame__31_324, 787, 812, 11, 60},
  {entry__31_343, NULL, 816, 816, 15, 44},
  {cont__31_344, &frame__31_343, 816, 816, 15, 53},
  {cont__31_345, &frame__31_343, 816, 816, 15, 53},
  {entry__31_355, NULL, 825, 825, 19, 71},
  {cont__31_357, &frame__31_355, 828, 828, 45, 70},
  {cont__31_358, &frame__31_355, 828, 828, 45, 75},
  {cont__31_359, &frame__31_355, 826, 833, 25, 82},
  {cont__31_362, &frame__31_355, 826, 833, 19, 82},
  {entry__31_364, NULL, 846, 850, 29, 80},
  {cont__31_368, &frame__31_364, 846, 850, 23, 80},
  {entry__31_369, NULL, 838, 840, 23, 46},
  {entry__31_371, NULL, 842, 844, 23, 70},
  {entry__31_376, NULL, 853, 853, 23, 32},
  {cont__31_377, &frame__31_376, 854, 854, 51, 74},
  {cont__31_380, &frame__31_376, 854, 854, 23, 74},
  {cont__31_381, &frame__31_376, 855, 855, 23, 35},
  {cont__31_383, &frame__31_376, 856, 856, 41, 64},
  {cont__31_386, &frame__31_376, 856, 856, 23, 64},
  {cont__31_387, &frame__31_376, 857, 861, 23, 50},
  {cont__31_388, &frame__31_376, 864, 864, 40, 66},
  {cont__31_389, &frame__31_376, 862, 866, 29, 63},
  {cont__31_392, &frame__31_376, 862, 866, 23, 63},
  {entry__31_374, NULL, 852, 852, 24, 56},
  {cont__31_375, &frame__31_374, 852, 866, 21, 64},
  {entry__31_410, NULL, 875, 880, 33, 33},
  {cont__31_413, &frame__31_410, 875, 880, 27, 33},
  {cont__31_414, &frame__31_410, 881, 881, 27, 69},
  {entry__31_415, NULL, 883, 888, 27, 53},
  {cont__31_417, &frame__31_415, 889, 889, 27, 64},
  {cont__31_418, &frame__31_415, 890, 895, 27, 33},
  {entry__31_396, NULL, 868, 868, 23, 32},
  {cont__31_397, &frame__31_396, 869, 869, 51, 74},
  {cont__31_400, &frame__31_396, 869, 869, 23, 74},
  {cont__31_401, &frame__31_396, 870, 870, 23, 35},
  {cont__31_403, &frame__31_396, 871, 871, 41, 64},
  {cont__31_406, &frame__31_396, 871, 871, 23, 64},
  {cont__31_407, &frame__31_396, 872, 872, 23, 59},
  {cont__31_408, &frame__31_396, 874, 874, 25, 36},
  {cont__31_409, &frame__31_396, 873, 895, 23, 35},
  {cont__31_420, &frame__31_396, 896, 900, 23, 63},
  {entry__31_393, NULL, 867, 867, 28, 53},
  {cont__31_394, &frame__31_393, 867, 867, 24, 54},
  {cont__31_395, &frame__31_393, 867, 900, 21, 64},
  {entry__31_422, NULL, 902, 905, 23, 54},
  {entry__31_363, NULL, 835, 850, 19, 82},
  {cont__31_373, &frame__31_363, 851, 905, 19, 56},
  {entry__31_347, NULL, 818, 818, 15, 46},
  {cont__31_348, &frame__31_347, 819, 819, 15, 44},
  {cont__31_349, &frame__31_347, 820, 820, 15, 54},
  {cont__31_350, &frame__31_347, 821, 821, 15, 62},
  {cont__31_351, &frame__31_347, 822, 822, 15, 50},
  {cont__31_352, &frame__31_347, 824, 824, 17, 42},
  {cont__31_353, &frame__31_347, 824, 824, 17, 53},
  {cont__31_354, &frame__31_347, 823, 905, 15, 58},
  {entry__31_341, NULL, 815, 815, 15, 43},
  {cont__31_342, &frame__31_341, 814, 816, 13, 52},
  {cont__31_346, &frame__31_341, 813, 905, 11, 60},
  {entry__31_425, NULL, 907, 907, 13, 40},
  {cont__31_426, &frame__31_425, 908, 908, 13, 25},
  {entry__31_321, NULL, 785, 785, 32, 32},
  {cont__31_322, &frame__31_321, 785, 785, 9, 33},
  {cont__31_323, &frame__31_321, 786, 908, 9, 26},
  {entry__31_432, NULL, 911, 911, 49, 74},
  {cont__31_433, &frame__31_432, 911, 911, 45, 75},
  {cont__31_434, &frame__31_432, 911, 911, 45, 75},
  {entry__31_443, NULL, 920, 925, 17, 17},
  {cont__31_446, &frame__31_443, 920, 925, 11, 17},
  {cont__31_447, &frame__31_443, 926, 926, 11, 53},
  {entry__31_448, NULL, 928, 933, 11, 37},
  {cont__31_450, &frame__31_448, 934, 934, 11, 48},
  {cont__31_451, &frame__31_448, 935, 939, 11, 17},
  {entry__31_436, NULL, 914, 916, 13, 57},
  {cont__31_439, &frame__31_436, 914, 916, 7, 57},
  {cont__31_440, &frame__31_436, 917, 917, 7, 43},
  {cont__31_441, &frame__31_436, 919, 919, 9, 20},
  {cont__31_442, &frame__31_436, 918, 939, 7, 19},
  {cont__31_453, &frame__31_436, 940, 942, 7, 9},
  {entry__31_6, NULL, 542, 542, 5, 24},
  {cont__31_51, &frame__31_6, 556, 556, 14, 32},
  {cont__31_52, &frame__31_6, 556, 571, 5, 44},
  {cont__31_72, &frame__31_6, 575, 586, 5, 19},
  {cont__31_94, &frame__31_6, 587, 597, 5, 19},
  {cont__31_106, &frame__31_6, 599, 599, 10, 57},
  {cont__31_110, &frame__31_6, 598, 599, 5, 81},
  {cont__31_114, &frame__31_6, 603, 603, 14, 37},
  {cont__31_115, &frame__31_6, 603, 606, 5, 19},
  {cont__31_121, &frame__31_6, 611, 611, 14, 35},
  {cont__31_122, &frame__31_6, 611, 615, 5, 22},
  {cont__31_135, &frame__31_6, 616, 616, 27, 50},
  {cont__31_136, &frame__31_6, 616, 616, 5, 50},
  {cont__31_137, &frame__31_6, 620, 620, 27, 64},
  {cont__31_140, &frame__31_6, 620, 620, 5, 64},
  {cont__31_141, &frame__31_6, 621, 623, 5, 46},
  {cont__31_146, &frame__31_6, 624, 624, 8, 55},
  {cont__31_148, &frame__31_6, 624, 627, 5, 34},
  {cont__31_151, &frame__31_6, 630, 630, 9, 41},
  {cont__31_152, &frame__31_6, 629, 631, 7, 58},
  {cont__31_155, &frame__31_6, 628, 635, 5, 37},
  {cont__31_158, &frame__31_6, 636, 636, 11, 79},
  {cont__31_162, &frame__31_6, 636, 636, 5, 79},
  {cont__31_163, &frame__31_6, 637, 637, 5, 36},
  {cont__31_165, &frame__31_6, 639, 639, 51, 75},
  {cont__31_166, &frame__31_6, 639, 639, 7, 80},
  {cont__31_170, &frame__31_6, 638, 639, 5, 80},
  {cont__31_171, &frame__31_6, 640, 643, 5, 49},
  {cont__31_185, &frame__31_6, 644, 645, 5, 9},
  {cont__31_187, &frame__31_6, 646, 646, 5, 40},
  {cont__31_189, &frame__31_6, 647, 647, 8, 40},
  {cont__31_190, &frame__31_6, 647, 657, 5, 69},
  {cont__31_205, &frame__31_6, 658, 658, 14, 37},
  {cont__31_206, &frame__31_6, 658, 662, 5, 76},
  {cont__31_215, &frame__31_6, 686, 686, 14, 33},
  {cont__31_216, &frame__31_6, 686, 703, 5, 58},
  {cont__31_246, &frame__31_6, 704, 704, 14, 33},
  {cont__31_247, &frame__31_6, 704, 742, 5, 69},
  {cont__31_292, &frame__31_6, 743, 745, 5, 16},
  {cont__31_297, &frame__31_6, 746, 746, 8, 34},
  {cont__31_298, &frame__31_6, 746, 747, 5, 69},
  {cont__31_302, &frame__31_6, 748, 753, 5, 76},
  {cont__31_314, &frame__31_6, 754, 754, 5, 35},
  {cont__31_315, &frame__31_6, 780, 780, 36, 36},
  {cont__31_316, &frame__31_6, 780, 780, 5, 78},
  {cont__31_318, &frame__31_6, 782, 782, 7, 26},
  {cont__31_319, &frame__31_6, 781, 908, 5, 28},
  {cont__31_427, &frame__31_6, 909, 909, 5, 17},
  {cont__31_429, &frame__31_6, 910, 910, 5, 20},
  {cont__31_430, &frame__31_6, 911, 911, 8, 40},
  {cont__31_431, &frame__31_6, 911, 911, 8, 75},
  {cont__31_435, &frame__31_6, 911, 942, 5, 10},
  {cont__31_455, &frame__31_6, 942, 942, 10, 10},
  {entry__31_459, NULL, 944, 944, 12, 32},
  {cont__31_461, &frame__31_459, 944, 944, 5, 42},
  {entry__31_465, NULL, 947, 949, 24, 49},
  {cont__31_468, &frame__31_465, 947, 949, 7, 49},
  {cont__31_469, &frame__31_465, 950, 953, 24, 25},
  {cont__31_474, &frame__31_465, 950, 953, 7, 25},
  {cont__31_475, &frame__31_465, 955, 955, 9, 70},
  {cont__31_479, &frame__31_465, 954, 955, 7, 70},
  {cont__31_480, &frame__31_465, 956, 956, 14, 33},
  {cont__31_482, &frame__31_465, 956, 956, 7, 33},
  {entry__31_483, NULL, 958, 958, 14, 64},
  {cont__31_487, &frame__31_483, 958, 958, 7, 64},
  {entry__31_1, NULL, 534, 534, 3, 42},
  {cont__31_3, &frame__31_1, 538, 538, 3, 12},
  {cont__31_4, &frame__31_1, 539, 539, 3, 39},
  {cont__31_5, &frame__31_1, 541, 942, 3, 11},
  {cont__31_456, &frame__31_1, 943, 943, 6, 31},
  {cont__31_457, &frame__31_1, 943, 943, 6, 36},
  {cont__31_458, &frame__31_1, 943, 944, 3, 42},
  {cont__31_462, &frame__31_1, 946, 946, 5, 28},
  {cont__31_463, &frame__31_1, 946, 946, 5, 37},
  {cont__31_464, &frame__31_1, 945, 958, 3, 65},
  {cont__31_488, &frame__31_1, 958, 958, 65, 65},
  {entry__32_7, NULL, 973, 973, 25, 43},
  {cont__32_8, &frame__32_7, 973, 973, 9, 44},
  {cont__32_9, &frame__32_7, 975, 975, 25, 42},
  {cont__32_10, &frame__32_7, 975, 975, 9, 43},
  {cont__32_11, &frame__32_7, 971, 975, 7, 42},
  {cont__32_14, &frame__32_7, 970, 975, 5, 44},
  {entry__32_1, NULL, 968, 968, 3, 48},
  {cont__32_3, &frame__32_1, 969, 969, 6, 28},
  {cont__32_4, &frame__32_1, 969, 969, 6, 36},
  {cont__32_5, &frame__32_1, 969, 969, 6, 36},
  {cont__32_6, &frame__32_1, 969, 975, 3, 45},
  {cont__32_15, &frame__32_1, 976, 976, 6, 24},
  {cont__32_16, &frame__32_1, 976, 976, 6, 29},
  {cont__32_17, &frame__32_1, 976, 976, 3, 29},
  {entry__33_1, NULL, 982, 982, 3, 58},
  {cont__33_3, &frame__33_1, 983, 983, 27, 44},
  {cont__33_4, &frame__33_1, 983, 983, 6, 45},
  {cont__33_5, &frame__33_1, 983, 983, 3, 45},
  {entry__34_1, NULL, 989, 989, 3, 61},
  {cont__34_3, &frame__34_1, 990, 990, 27, 44},
  {cont__34_4, &frame__34_1, 990, 990, 6, 45},
  {cont__34_5, &frame__34_1, 990, 990, 3, 45},
  {entry__35_1, NULL, 996, 996, 3, 53},
  {cont__35_3, &frame__35_1, 997, 997, 20, 40},
  {cont__35_4, &frame__35_1, 997, 997, 3, 42},
  {cont__35_6, &frame__35_1, 998, 998, 3, 23},
  {cont__35_7, &frame__35_1, 999, 999, 3, 9},
  {entry__36_1, NULL, 1005, 1005, 3, 55},
  {cont__36_3, &frame__36_1, 1006, 1006, 23, 42},
  {cont__36_4, &frame__36_1, 1006, 1006, 23, 53},
  {cont__36_5, &frame__36_1, 1006, 1006, 3, 55},
  {cont__36_7, &frame__36_1, 1007, 1007, 3, 23},
  {cont__36_8, &frame__36_1, 1008, 1008, 3, 9},
  {entry__37_8, NULL, 1017, 1017, 53, 62},
  {cont__37_9, &frame__37_8, 1017, 1017, 53, 62},
  {entry__37_6, NULL, 1017, 1017, 34, 48},
  {cont__37_7, &frame__37_6, 1017, 1017, 34, 62},
  {cont__37_10, &frame__37_6, 1017, 1017, 34, 62},
  {entry__37_4, NULL, 1017, 1017, 21, 29},
  {cont__37_5, &frame__37_4, 1017, 1017, 21, 62},
  {cont__37_11, &frame__37_4, 1017, 1017, 21, 62},
  {entry__37_13, NULL, 1018, 1018, 31, 35},
  {cont__37_14, &frame__37_13, 1018, 1018, 19, 36},
  {cont__37_15, &frame__37_13, 1018, 1018, 7, 36},
  {cont__37_16, &frame__37_13, 1019, 1019, 38, 51},
  {cont__37_17, &frame__37_13, 1019, 1019, 34, 52},
  {cont__37_18, &frame__37_13, 1019, 1019, 25, 59},
  {cont__37_20, &frame__37_13, 1019, 1019, 7, 59},
  {cont__37_22, &frame__37_13, 1020, 1020, 7, 14},
  {cont__37_23, &frame__37_13, 1020, 1020, 14, 14},
  {entry__37_2, NULL, 1017, 1017, 8, 16},
  {cont__37_3, &frame__37_2, 1017, 1017, 8, 62},
  {cont__37_12, &frame__37_2, 1017, 1020, 5, 14},
  {entry__37_28, NULL, 1021, 1021, 52, 52},
  {cont__37_29, &frame__37_28, 1021, 1021, 39, 53},
  {cont__37_30, &frame__37_28, 1021, 1021, 27, 53},
  {cont__37_31, &frame__37_28, 1021, 1021, 53, 53},
  {entry__37_1, NULL, 1016, 1020, 3, 15},
  {cont__37_24, &frame__37_1, 1021, 1021, 11, 24},
  {cont__37_25, &frame__37_1, 1021, 1021, 6, 24},
  {cont__37_26, &frame__37_1, 1021, 1021, 6, 24},
  {cont__37_27, &frame__37_1, 1021, 1021, 3, 53},
  {cont__37_32, &frame__37_1, 1022, 1022, 3, 8},
  {entry__38_14, NULL, 1034, 1034, 48, 63},
  {cont__38_15, &frame__38_14, 1032, 1034, 26, 80},
  {cont__38_20, &frame__38_14, 1032, 1034, 9, 80},
  {entry__38_39, NULL, 1046, 1046, 19, 28},
  {cont__38_40, &frame__38_39, 1046, 1046, 19, 28},
  {cont__38_41, &frame__38_39, 1046, 1046, 19, 28},
  {entry__38_36, NULL, 1045, 1045, 19, 33},
  {cont__38_37, &frame__38_36, 1045, 1045, 19, 33},
  {cont__38_38, &frame__38_36, 1046, 1046, 19, 28},
  {cont__38_42, &frame__38_36, },
  {entry__38_33, NULL, 1044, 1044, 19, 33},
  {cont__38_34, &frame__38_33, 1044, 1044, 19, 33},
  {cont__38_35, &frame__38_33, },
  {cont__38_43, &frame__38_33, },
  {entry__38_30, NULL, 1043, 1043, 19, 28},
  {cont__38_31, &frame__38_30, 1043, 1043, 19, 28},
  {cont__38_32, &frame__38_30, },
  {cont__38_44, &frame__38_30, },
  {entry__38_49, NULL, 1047, 1047, 31, 40},
  {cont__38_50, &frame__38_49, 1047, 1047, 31, 40},
  {cont__38_51, &frame__38_49, 1047, 1047, 31, 40},
  {entry__38_46, NULL, 1047, 1047, 17, 26},
  {cont__38_47, &frame__38_46, 1047, 1047, 17, 26},
  {cont__38_48, &frame__38_46, 1047, 1047, 17, 40},
  {cont__38_52, &frame__38_46, 1047, 1047, 17, 40},
  {entry__38_54, NULL, 1049, 1049, 17, 54},
  {entry__38_55, NULL, 1051, 1051, 43, 56},
  {cont__38_56, &frame__38_55, 1051, 1051, 39, 57},
  {cont__38_57, &frame__38_55, 1051, 1051, 17, 57},
  {entry__38_27, NULL, 1042, 1042, 19, 28},
  {cont__38_28, &frame__38_27, 1042, 1042, 19, 28},
  {cont__38_29, &frame__38_27, },
  {cont__38_45, &frame__38_27, 1040, 1047, 15, 39},
  {cont__38_53, &frame__38_27, 1039, 1051, 13, 58},
  {entry__38_59, NULL, 1053, 1053, 13, 33},
  {entry__38_21, NULL, 1036, 1036, 26, 65},
  {cont__38_25, &frame__38_21, 1036, 1036, 9, 65},
  {cont__38_26, &frame__38_21, 1037, 1053, 9, 34},
  {cont__38_61, &frame__38_21, 1054, 1054, 9, 33},
  {cont__38_63, &frame__38_21, 1056, 1056, 11, 72},
  {cont__38_68, &frame__38_21, 1055, 1056, 9, 72},
  {entry__38_4, NULL, 1027, 1027, 5, 14},
  {cont__38_5, &frame__38_4, 1028, 1028, 5, 36},
  {cont__38_8, &frame__38_4, 1029, 1029, 27, 53},
  {cont__38_11, &frame__38_4, 1029, 1029, 5, 53},
  {cont__38_12, &frame__38_4, 1031, 1031, 7, 29},
  {cont__38_13, &frame__38_4, 1030, 1056, 5, 74},
  {cont__38_69, &frame__38_4, 1057, 1057, 36, 75},
  {cont__38_73, &frame__38_4, 1057, 1057, 5, 75},
  {cont__38_74, &frame__38_4, 1058, 1058, 5, 11},
  {entry__38_75, NULL, 1026, 1026, 16, 32},
  {entry__38_1, NULL, 1025, 1025, 3, 21},
  {cont__38_2, &frame__38_1, 1026, 1026, 6, 13},
  {cont__38_3, &frame__38_1, 1026, 1058, 3, 11},
  {entry__39_1, NULL, 1061, 1061, 3, 52},
  {cont__39_3, &frame__39_1, 1062, 1062, 22, 40},
  {cont__39_4, &frame__39_1, 1062, 1062, 6, 41},
  {cont__39_5, &frame__39_1, 1062, 1062, 3, 41},
  {entry__40_10, NULL, 1071, 1071, 45, 57},
  {cont__40_11, &frame__40_10, 1071, 1071, 42, 57},
  {entry__40_12, NULL, 1071, 1071, 60, 66},
  {entry__40_1, NULL, 1068, 1068, 3, 49},
  {cont__40_3, &frame__40_1, 1069, 1069, 3, 12},
  {cont__40_4, &frame__40_1, 1070, 1070, 3, 41},
  {cont__40_7, &frame__40_1, 1071, 1071, 16, 28},
  {cont__40_8, &frame__40_1, 1071, 1071, 16, 39},
  {cont__40_9, &frame__40_1, 1071, 1071, 3, 67},
  {cont__40_13, &frame__40_1, 1072, 1072, 25, 51},
  {cont__40_16, &frame__40_1, 1072, 1072, 3, 51},
  {cont__40_17, &frame__40_1, 1073, 1075, 20, 54},
  {cont__40_21, &frame__40_1, 1073, 1075, 3, 54},
  {cont__40_22, &frame__40_1, 1076, 1076, 34, 73},
  {cont__40_26, &frame__40_1, 1076, 1076, 3, 73},
  {cont__40_27, &frame__40_1, 1077, 1077, 3, 9},
  {entry__41_9, NULL, 1089, 1089, 33, 49},
  {cont__41_11, &frame__41_9, 1089, 1089, 33, 60},
  {cont__41_12, &frame__41_9, 1089, 1089, 16, 60},
  {cont__41_13, &frame__41_9, 1089, 1089, 11, 62},
  {cont__41_14, &frame__41_9, 1090, 1090, 14, 49},
  {cont__41_18, &frame__41_9, 1090, 1090, 11, 49},
  {entry__41_19, NULL, 1091, 1091, 9, 15},
  {entry__41_7, NULL, 1088, 1088, 9, 35},
  {cont__41_8, &frame__41_7, 1087, 1091, 7, 14},
  {cont__41_20, &frame__41_7, 1086, 1091, 28, 16},
  {entry__41_5, NULL, 1086, 1086, 8, 26},
  {cont__41_6, &frame__41_5, 1086, 1091, 5, 16},
  {entry__41_26, NULL, 1096, 1096, 35, 54},
  {cont__41_27, &frame__41_26, 1095, 1097, 12, 13},
  {cont__41_31, &frame__41_26, 1095, 1097, 9, 13},
  {entry__41_32, NULL, 1098, 1098, 28, 47},
  {cont__41_33, &frame__41_32, 1098, 1098, 12, 64},
  {cont__41_37, &frame__41_32, 1098, 1098, 9, 64},
  {entry__41_24, NULL, 1094, 1094, 9, 30},
  {cont__41_25, &frame__41_24, 1093, 1098, 7, 63},
  {cont__41_38, &frame__41_24, 1092, 1098, 40, 65},
  {entry__41_21, NULL, 1092, 1092, 8, 27},
  {cont__41_22, &frame__41_21, 1092, 1092, 8, 38},
  {cont__41_23, &frame__41_21, 1092, 1098, 5, 65},
  {entry__41_42, NULL, 1099, 1099, 41, 56},
  {cont__41_45, &frame__41_42, 1099, 1099, 38, 56},
  {entry__41_39, NULL, 1099, 1099, 8, 25},
  {cont__41_40, &frame__41_39, 1099, 1099, 8, 36},
  {cont__41_41, &frame__41_39, 1099, 1099, 5, 56},
  {entry__41_50, NULL, 1104, 1104, 61, 78},
  {cont__41_51, &frame__41_50, 1104, 1104, 46, 58},
  {cont__41_52, &frame__41_50, 1104, 1104, 31, 59},
  {cont__41_53, &frame__41_50, 1104, 1104, 31, 79},
  {cont__41_54, &frame__41_50, 1104, 1104, 14, 80},
  {cont__41_55, &frame__41_50, 1104, 1104, 11, 80},
  {entry__41_56, NULL, 1105, 1105, 31, 48},
  {cont__41_57, &frame__41_56, 1105, 1105, 14, 49},
  {cont__41_58, &frame__41_56, 1105, 1105, 11, 49},
  {entry__41_61, NULL, 1111, 1111, 14, 29},
  {cont__41_64, &frame__41_61, 1111, 1111, 11, 29},
  {entry__41_65, NULL, 1112, 1112, 14, 28},
  {cont__41_66, &frame__41_65, 1112, 1112, 11, 28},
  {entry__41_47, NULL, 1103, 1103, 11, 28},
  {cont__41_48, &frame__41_47, 1103, 1103, 11, 39},
  {cont__41_49, &frame__41_47, 1101, 1105, 7, 50},
  {cont__41_59, &frame__41_47, 1110, 1110, 11, 39},
  {cont__41_60, &frame__41_47, 1108, 1112, 9, 27},
  {cont__41_67, &frame__41_47, 1107, 1112, 7, 29},
  {entry__41_46, NULL, 1100, 1112, 5, 30},
  {entry__41_1, NULL, 1083, 1083, 3, 54},
  {cont__41_3, &frame__41_1, 1084, 1084, 3, 29},
  {cont__41_4, &frame__41_1, 1085, 1112, 3, 31},
  {entry__42_8, NULL, 1123, 1123, 5, 52},
  {cont__42_9, &frame__42_8, 1123, 1123, 52, 52},
  {entry__42_15, NULL, 1128, 1128, 20, 34},
  {cont__42_16, &frame__42_15, 1128, 1128, 12, 43},
  {cont__42_17, &frame__42_15, 1128, 1128, 9, 43},
  {entry__42_18, NULL, 1129, 1129, 13, 13},
  {cont__42_19, &frame__42_18, 1129, 1129, 9, 13},
  {entry__42_27, NULL, 1136, 1136, 9, 66},
  {cont__42_31, &frame__42_27, 1135, 1136, 7, 66},
  {entry__42_11, NULL, 1127, 1127, 9, 23},
  {cont__42_12, &frame__42_11, 1127, 1127, 9, 54},
  {cont__42_14, &frame__42_11, 1125, 1129, 5, 14},
  {cont__42_20, &frame__42_11, 1131, 1133, 27, 38},
  {cont__42_24, &frame__42_11, 1131, 1133, 5, 38},
  {cont__42_25, &frame__42_11, 1134, 1134, 8, 35},
  {cont__42_26, &frame__42_11, 1134, 1136, 5, 67},
  {cont__42_32, &frame__42_11, 1139, 1139, 20, 34},
  {cont__42_33, &frame__42_11, 1139, 1139, 20, 44},
  {cont__42_34, &frame__42_11, 1139, 1139, 9, 45},
  {cont__42_35, &frame__42_11, 1137, 1139, 11, 51},
  {cont__42_39, &frame__42_11, 1137, 1139, 5, 51},
  {cont__42_40, &frame__42_11, 1140, 1142, 22, 47},
  {cont__42_43, &frame__42_11, 1140, 1142, 5, 47},
  {cont__42_44, &frame__42_11, 1143, 1146, 22, 21},
  {cont__42_49, &frame__42_11, 1143, 1146, 5, 21},
  {entry__42_1, NULL, 1118, 1118, 3, 44},
  {cont__42_3, &frame__42_1, 1119, 1119, 3, 12},
  {cont__42_4, &frame__42_1, 1120, 1120, 3, 39},
  {cont__42_5, &frame__42_1, 1122, 1122, 6, 26},
  {cont__42_6, &frame__42_1, 1122, 1122, 6, 37},
  {cont__42_7, &frame__42_1, 1122, 1123, 3, 52},
  {cont__42_10, &frame__42_1, 1124, 1146, 3, 22},
  {cont__42_50, &frame__42_1, 1147, 1147, 6, 25},
  {cont__42_52, &frame__42_1, 1147, 1147, 3, 25},
  {entry__43_1, NULL, 1152, 1152, 3, 40},
  {cont__43_2, &frame__43_1, 1153, 1153, 6, 29},
  {cont__43_3, &frame__43_1, 1153, 1153, 31, 49},
  {cont__43_4, &frame__43_1, 1153, 1153, 51, 77},
  {cont__43_5, &frame__43_1, 1153, 1153, 3, 77},
  {entry__44_3, NULL, 1160, 1160, 39, 57},
  {cont__44_4, &frame__44_3, 1160, 1160, 35, 58},
  {cont__44_5, &frame__44_3, 1160, 1160, 35, 58},
  {entry__44_7, NULL, 1160, 1160, 61, 72},
  {entry__44_15, NULL, 1169, 1169, 27, 44},
  {cont__44_16, &frame__44_15, 1169, 1169, 16, 45},
  {cont__44_17, &frame__44_15, 1169, 1169, 13, 45},
  {entry__44_18, NULL, 1170, 1170, 13, 24},
  {entry__44_11, NULL, 1165, 1165, 36, 48},
  {cont__44_12, &frame__44_11, 1165, 1165, 9, 49},
  {cont__44_13, &frame__44_11, 1168, 1168, 13, 33},
  {cont__44_14, &frame__44_11, 1167, 1170, 11, 23},
  {cont__44_19, &frame__44_11, 1166, 1170, 9, 25},
  {entry__44_20, NULL, 1171, 1171, 23, 35},
  {cont__44_21, &frame__44_20, 1171, 1171, 10, 36},
  {cont__44_22, &frame__44_20, 1171, 1171, 7, 36},
  {entry__44_25, NULL, 1173, 1173, 25, 58},
  {cont__44_26, &frame__44_25, 1173, 1173, 25, 58},
  {entry__44_1, NULL, 1160, 1160, 10, 30},
  {cont__44_2, &frame__44_1, 1160, 1160, 10, 58},
  {cont__44_6, &frame__44_1, 1160, 1160, 3, 72},
  {cont__44_8, &frame__44_1, 1164, 1164, 7, 24},
  {cont__44_9, &frame__44_1, 1164, 1164, 7, 35},
  {cont__44_10, &frame__44_1, 1162, 1171, 3, 37},
  {cont__44_23, &frame__44_1, 1173, 1173, 6, 20},
  {cont__44_24, &frame__44_1, 1173, 1173, 6, 58},
  {cont__44_27, &frame__44_1, 1173, 1173, 3, 58},
  {entry__45_3, NULL, 1180, 1180, 39, 57},
  {cont__45_4, &frame__45_3, 1180, 1180, 35, 58},
  {cont__45_5, &frame__45_3, 1180, 1180, 35, 58},
  {entry__45_7, NULL, 1180, 1180, 61, 72},
  {entry__45_15, NULL, 1189, 1189, 27, 44},
  {cont__45_16, &frame__45_15, 1189, 1189, 16, 45},
  {cont__45_17, &frame__45_15, 1189, 1189, 13, 45},
  {entry__45_18, NULL, 1190, 1190, 13, 24},
  {entry__45_11, NULL, 1185, 1185, 36, 48},
  {cont__45_12, &frame__45_11, 1185, 1185, 9, 49},
  {cont__45_13, &frame__45_11, 1188, 1188, 13, 33},
  {cont__45_14, &frame__45_11, 1187, 1190, 11, 23},
  {cont__45_19, &frame__45_11, 1186, 1190, 9, 25},
  {entry__45_20, NULL, 1191, 1191, 23, 35},
  {cont__45_21, &frame__45_20, 1191, 1191, 10, 36},
  {cont__45_22, &frame__45_20, 1191, 1191, 7, 36},
  {entry__45_1, NULL, 1180, 1180, 10, 30},
  {cont__45_2, &frame__45_1, 1180, 1180, 10, 58},
  {cont__45_6, &frame__45_1, 1180, 1180, 3, 72},
  {cont__45_8, &frame__45_1, 1184, 1184, 7, 24},
  {cont__45_9, &frame__45_1, 1184, 1184, 7, 35},
  {cont__45_10, &frame__45_1, 1182, 1191, 3, 37},
  {cont__45_23, &frame__45_1, 1193, 1193, 6, 22},
  {cont__45_24, &frame__45_1, 1193, 1193, 3, 22},
  {entry__46_7, NULL, 1198, 1198, 24, 66},
  {cont__46_11, &frame__46_7, 1198, 1198, 7, 66},
  {entry__46_2, NULL, 1197, 1197, 25, 44},
  {cont__46_5, &frame__46_2, 1197, 1197, 8, 44},
  {cont__46_6, &frame__46_2, 1197, 1198, 5, 66},
  {entry__46_15, NULL, 1202, 1202, 24, 62},
  {cont__46_19, &frame__46_15, 1202, 1202, 7, 62},
  {entry__46_12, NULL, 1199, 1199, 8, 34},
  {cont__46_14, &frame__46_12, 1199, 1202, 5, 62},
  {entry__46_20, NULL, 1204, 1204, 24, 62},
  {cont__46_24, &frame__46_20, 1204, 1204, 7, 62},
  {entry__46_1, NULL, 1196, 1204, 3, 63},
  {entry__47_4, NULL, 1211, 1211, 13, 35},
  {cont__47_5, &frame__47_4, 1211, 1211, 55, 77},
  {cont__47_6, &frame__47_4, 1209, 1212, 36, 13},
  {cont__47_10, &frame__47_4, 1209, 1212, 5, 13},
  {entry__47_14, NULL, 1214, 1214, 27, 47},
  {cont__47_15, &frame__47_14, 1214, 1214, 27, 47},
  {entry__47_17, NULL, 1215, 1215, 12, 34},
  {cont__47_18, &frame__47_17, 1215, 1215, 36, 46},
  {cont__47_19, &frame__47_17, 1215, 1215, 5, 46},
  {entry__47_23, NULL, 1240, 1240, 13, 51},
  {cont__47_26, &frame__47_23, 1239, 1240, 11, 51},
  {cont__47_27, &frame__47_23, 1241, 1244, 33, 13},
  {cont__47_33, &frame__47_23, 1241, 1244, 11, 13},
  {cont__47_34, &frame__47_23, 1248, 1248, 38, 60},
  {cont__47_35, &frame__47_23, 1245, 1248, 28, 63},
  {cont__47_41, &frame__47_23, 1245, 1248, 11, 63},
  {entry__47_42, NULL, 1251, 1251, 13, 51},
  {cont__47_45, &frame__47_42, 1250, 1251, 11, 51},
  {cont__47_46, &frame__47_42, 1252, 1258, 33, 13},
  {cont__47_56, &frame__47_42, 1252, 1258, 11, 13},
  {cont__47_57, &frame__47_42, 1259, 1262, 28, 56},
  {cont__47_63, &frame__47_42, 1259, 1262, 11, 56},
  {entry__47_64, NULL, 1264, 1271, 33, 13},
  {cont__47_71, &frame__47_64, 1264, 1271, 11, 13},
  {cont__47_72, &frame__47_64, 1272, 1276, 28, 40},
  {cont__47_79, &frame__47_64, 1272, 1276, 11, 40},
  {entry__47_80, NULL, 1278, 1288, 33, 13},
  {cont__47_89, &frame__47_80, 1278, 1288, 11, 13},
  {cont__47_90, &frame__47_80, 1289, 1294, 28, 51},
  {cont__47_99, &frame__47_80, 1289, 1294, 11, 51},
  {entry__47_22, NULL, 1236, 1294, 7, 53},
  {entry__47_112, NULL, 1305, 1305, 21, 35},
  {cont__47_113, &frame__47_112, 1303, 1305, 30, 55},
  {cont__47_116, &frame__47_112, 1303, 1305, 13, 55},
  {entry__47_101, NULL, 1299, 1299, 45, 80},
  {cont__47_104, &frame__47_101, 1299, 1299, 11, 80},
  {cont__47_105, &frame__47_101, 1301, 1301, 31, 52},
  {cont__47_106, &frame__47_101, 1301, 1301, 13, 61},
  {cont__47_109, &frame__47_101, 1300, 1301, 11, 61},
  {cont__47_110, &frame__47_101, 1302, 1302, 18, 34},
  {cont__47_111, &frame__47_101, 1302, 1305, 11, 56},
  {entry__47_117, NULL, 1307, 1307, 45, 80},
  {cont__47_120, &frame__47_117, 1307, 1307, 11, 80},
  {cont__47_121, &frame__47_117, 1309, 1309, 31, 52},
  {cont__47_122, &frame__47_117, 1309, 1309, 13, 61},
  {cont__47_125, &frame__47_117, 1308, 1309, 11, 61},
  {entry__47_140, NULL, 1321, 1323, 30, 51},
  {cont__47_143, &frame__47_140, 1321, 1323, 13, 51},
  {entry__47_126, NULL, 1311, 1318, 33, 13},
  {cont__47_133, &frame__47_126, 1311, 1318, 11, 13},
  {cont__47_134, &frame__47_126, 1319, 1319, 28, 72},
  {cont__47_137, &frame__47_126, 1319, 1319, 11, 72},
  {cont__47_138, &frame__47_126, 1320, 1320, 18, 34},
  {cont__47_139, &frame__47_126, 1320, 1323, 11, 52},
  {entry__47_144, NULL, 1325, 1335, 33, 13},
  {cont__47_153, &frame__47_144, 1325, 1335, 11, 13},
  {cont__47_154, &frame__47_144, 1336, 1339, 28, 43},
  {cont__47_158, &frame__47_144, 1336, 1339, 11, 43},
  {entry__47_100, NULL, 1296, 1339, 7, 45},
  {entry__47_161, NULL, 1340, 1340, 27, 48},
  {cont__47_162, &frame__47_161, 1340, 1340, 27, 48},
  {entry__47_166, NULL, 1343, 1343, 55, 65},
  {cont__47_167, &frame__47_166, 1343, 1343, 26, 73},
  {cont__47_171, &frame__47_166, 1343, 1343, 9, 73},
  {entry__47_180, NULL, 1354, 1354, 19, 29},
  {cont__47_181, &frame__47_180, 1351, 1354, 32, 37},
  {cont__47_185, &frame__47_180, 1351, 1354, 15, 37},
  {entry__47_186, NULL, 1358, 1358, 65, 75},
  {cont__47_187, &frame__47_186, 1356, 1359, 32, 23},
  {cont__47_191, &frame__47_186, 1356, 1359, 15, 23},
  {entry__47_174, NULL, 1346, 1348, 28, 57},
  {cont__47_177, &frame__47_174, 1346, 1348, 11, 57},
  {cont__47_178, &frame__47_174, 1350, 1350, 13, 36},
  {cont__47_179, &frame__47_174, 1349, 1359, 11, 25},
  {entry__47_172, NULL, 1345, 1345, 12, 34},
  {cont__47_173, &frame__47_172, 1345, 1359, 9, 26},
  {entry__47_164, NULL, 1342, 1342, 7, 26},
  {cont__47_165, &frame__47_164, 1341, 1359, 5, 28},
  {entry__47_1, NULL, 1207, 1207, 3, 63},
  {cont__47_2, &frame__47_1, 1208, 1208, 6, 38},
  {cont__47_3, &frame__47_1, 1208, 1212, 3, 14},
  {cont__47_11, &frame__47_1, 1213, 1213, 3, 36},
  {cont__47_12, &frame__47_1, 1214, 1214, 6, 22},
  {cont__47_13, &frame__47_1, 1214, 1214, 6, 47},
  {cont__47_16, &frame__47_1, 1214, 1233, 3, 93},
  {cont__47_20, &frame__47_1, 1235, 1235, 5, 24},
  {cont__47_21, &frame__47_1, 1234, 1339, 3, 47},
  {cont__47_159, &frame__47_1, 1340, 1340, 6, 22},
  {cont__47_160, &frame__47_1, 1340, 1340, 6, 48},
  {cont__47_163, &frame__47_1, 1340, 1359, 3, 29},
  {entry__48_3, NULL, 1362, 1362, 31, 56},
  {cont__48_6, &frame__48_3, 1362, 1362, 28, 56},
  {entry__48_7, NULL, 1362, 1362, 59, 67},
  {entry__48_1, NULL, 1362, 1362, 6, 25},
  {cont__48_2, &frame__48_1, 1362, 1362, 3, 67},
  {entry__49_6, NULL, 1370, 1370, 7, 22},
  {cont__49_7, &frame__49_6, 1370, 1370, 22, 22},
  {entry__49_8, NULL, 1372, 1372, 7, 59},
  {cont__49_11, &frame__49_8, 1373, 1373, 29, 54},
  {cont__49_14, &frame__49_8, 1373, 1373, 7, 54},
  {entry__49_17, NULL, 1379, 1379, 29, 46},
  {cont__49_18, &frame__49_17, 1379, 1379, 29, 57},
  {cont__49_19, &frame__49_17, 1379, 1379, 29, 57},
  {entry__49_21, NULL, 1382, 1382, 32, 60},
  {cont__49_22, &frame__49_21, 1380, 1383, 24, 45},
  {cont__49_28, &frame__49_21, 1380, 1383, 7, 45},
  {entry__49_29, NULL, 1388, 1388, 30, 44},
  {cont__49_30, &frame__49_29, 1385, 1389, 24, 38},
  {cont__49_35, &frame__49_29, 1385, 1389, 7, 38},
  {entry__49_1, NULL, 1365, 1365, 3, 63},
  {cont__49_2, &frame__49_1, 1366, 1366, 35, 58},
  {cont__49_3, &frame__49_1, 1366, 1366, 3, 59},
  {cont__49_4, &frame__49_1, 1369, 1369, 5, 21},
  {cont__49_5, &frame__49_1, 1368, 1377, 3, 39},
  {cont__49_15, &frame__49_1, 1379, 1379, 5, 24},
  {cont__49_16, &frame__49_1, 1379, 1379, 5, 57},
  {cont__49_20, &frame__49_1, 1378, 1389, 3, 40},
  {entry__50_6, NULL, 1397, 1397, 7, 22},
  {cont__50_7, &frame__50_6, 1397, 1397, 22, 22},
  {entry__50_8, NULL, 1399, 1399, 7, 59},
  {cont__50_11, &frame__50_8, 1400, 1400, 29, 54},
  {cont__50_14, &frame__50_8, 1400, 1400, 7, 54},
  {entry__50_17, NULL, 1406, 1406, 29, 46},
  {cont__50_18, &frame__50_17, 1406, 1406, 29, 57},
  {cont__50_19, &frame__50_17, 1406, 1406, 29, 57},
  {entry__50_21, NULL, 1409, 1409, 29, 57},
  {cont__50_22, &frame__50_21, 1407, 1410, 24, 45},
  {cont__50_28, &frame__50_21, 1407, 1410, 7, 45},
  {entry__50_29, NULL, 1415, 1415, 30, 44},
  {cont__50_30, &frame__50_29, 1412, 1416, 24, 16},
  {cont__50_35, &frame__50_29, 1412, 1416, 7, 16},
  {entry__50_1, NULL, 1392, 1392, 3, 63},
  {cont__50_2, &frame__50_1, 1393, 1393, 35, 58},
  {cont__50_3, &frame__50_1, 1393, 1393, 3, 59},
  {cont__50_4, &frame__50_1, 1396, 1396, 5, 21},
  {cont__50_5, &frame__50_1, 1395, 1404, 3, 39},
  {cont__50_15, &frame__50_1, 1406, 1406, 5, 24},
  {cont__50_16, &frame__50_1, 1406, 1406, 5, 57},
  {cont__50_20, &frame__50_1, 1405, 1416, 3, 18},
  {entry__51_5, NULL, 1422, 1422, 29, 46},
  {cont__51_6, &frame__51_5, 1422, 1422, 29, 57},
  {cont__51_7, &frame__51_5, 1422, 1422, 29, 57},
  {entry__51_9, NULL, 1425, 1425, 36, 64},
  {cont__51_10, &frame__51_9, 1423, 1426, 24, 45},
  {cont__51_16, &frame__51_9, 1423, 1426, 7, 45},
  {entry__51_17, NULL, 1431, 1431, 30, 44},
  {cont__51_18, &frame__51_17, 1428, 1431, 24, 61},
  {cont__51_22, &frame__51_17, 1428, 1431, 7, 61},
  {entry__51_1, NULL, 1419, 1419, 3, 64},
  {cont__51_2, &frame__51_1, 1420, 1420, 3, 31},
  {cont__51_3, &frame__51_1, 1422, 1422, 5, 24},
  {cont__51_4, &frame__51_1, 1422, 1422, 5, 57},
  {cont__51_8, &frame__51_1, 1421, 1431, 3, 63},
  {entry__52_3, NULL, 1434, 1434, 33, 49},
  {entry__52_5, NULL, 1434, 1434, 52, 56},
  {entry__52_2, NULL, 1434, 1434, 17, 56},
  {entry__52_8, NULL, 1440, 1440, 9, 47},
  {cont__52_11, &frame__52_8, 1439, 1440, 7, 47},
  {entry__52_12, NULL, 1442, 1442, 41, 76},
  {cont__52_15, &frame__52_12, 1442, 1442, 7, 76},
  {cont__52_16, &frame__52_12, 1444, 1444, 27, 48},
  {cont__52_17, &frame__52_12, 1444, 1444, 9, 57},
  {cont__52_20, &frame__52_12, 1443, 1444, 7, 57},
  {entry__52_24, NULL, 1448, 1448, 28, 37},
  {cont__52_26, &frame__52_24, 1448, 1448, 25, 37},
  {entry__52_27, NULL, 1448, 1448, 40, 44},
  {entry__52_64, NULL, 1476, 1476, 48, 70},
  {cont__52_65, &frame__52_64, 1473, 1476, 28, 73},
  {cont__52_72, &frame__52_64, 1473, 1476, 11, 73},
  {entry__52_73, NULL, 1480, 1480, 46, 58},
  {cont__52_74, &frame__52_73, 1482, 1482, 16, 38},
  {cont__52_75, &frame__52_73, 1478, 1482, 28, 41},
  {cont__52_83, &frame__52_73, 1478, 1482, 11, 41},
  {entry__52_55, NULL, 1467, 1470, 29, 9},
  {cont__52_61, &frame__52_55, 1467, 1470, 7, 9},
  {cont__52_62, &frame__52_55, 1472, 1472, 9, 21},
  {cont__52_63, &frame__52_55, 1471, 1482, 7, 43},
  {entry__52_84, NULL, 1486, 1486, 44, 56},
  {cont__52_85, &frame__52_84, 1484, 1487, 24, 40},
  {cont__52_91, &frame__52_84, 1484, 1487, 7, 40},
  {entry__52_1, NULL, 1436, 1436, 3, 63},
  {cont__52_6, &frame__52_1, 1438, 1438, 5, 24},
  {cont__52_7, &frame__52_1, 1437, 1444, 3, 59},
  {cont__52_21, &frame__52_1, 1445, 1445, 3, 52},
  {cont__52_22, &frame__52_1, 1448, 1448, 10, 22},
  {cont__52_23, &frame__52_1, 1448, 1448, 7, 45},
  {cont__52_28, &frame__52_1, 1446, 1448, 25, 52},
  {cont__52_31, &frame__52_1, 1446, 1448, 3, 52},
  {cont__52_32, &frame__52_1, 1451, 1451, 11, 33},
  {cont__52_33, &frame__52_1, 1451, 1451, 53, 75},
  {cont__52_34, &frame__52_1, 1449, 1452, 34, 11},
  {cont__52_38, &frame__52_1, 1449, 1452, 3, 11},
  {cont__52_39, &frame__52_1, 1453, 1453, 34, 58},
  {cont__52_40, &frame__52_1, 1453, 1453, 3, 58},
  {cont__52_41, &frame__52_1, 1454, 1454, 31, 77},
  {cont__52_45, &frame__52_1, 1454, 1454, 3, 77},
  {cont__52_46, &frame__52_1, 1455, 1455, 3, 43},
  {cont__52_47, &frame__52_1, 1463, 1463, 25, 47},
  {cont__52_48, &frame__52_1, 1461, 1464, 20, 48},
  {cont__52_52, &frame__52_1, 1461, 1464, 3, 48},
  {cont__52_53, &frame__52_1, 1466, 1466, 5, 24},
  {cont__52_54, &frame__52_1, 1465, 1487, 3, 42},
  {entry__53_7, NULL, 1539, 1539, 11, 38},
  {cont__53_8, &frame__53_7, 1539, 1539, 38, 38},
  {entry__53_9, NULL, 1541, 1541, 11, 32},
  {cont__53_11, &frame__53_9, 1541, 1541, 32, 32},
  {entry__53_15, NULL, 1545, 1545, 13, 51},
  {cont__53_18, &frame__53_15, 1544, 1545, 11, 51},
  {entry__53_19, NULL, 1547, 1547, 45, 80},
  {cont__53_22, &frame__53_19, 1547, 1547, 11, 80},
  {cont__53_23, &frame__53_19, 1549, 1549, 31, 52},
  {cont__53_24, &frame__53_19, 1549, 1549, 13, 61},
  {cont__53_27, &frame__53_19, 1548, 1549, 11, 61},
  {entry__53_36, NULL, 1558, 1558, 19, 41},
  {cont__53_37, &frame__53_36, 1556, 1559, 28, 76},
  {cont__53_42, &frame__53_36, 1556, 1559, 11, 76},
  {entry__53_43, NULL, 1563, 1563, 19, 41},
  {cont__53_44, &frame__53_43, 1561, 1564, 28, 19},
  {cont__53_49, &frame__53_43, 1561, 1564, 11, 19},
  {entry__53_52, NULL, 1568, 1568, 24, 46},
  {cont__53_53, &frame__53_52, 1566, 1569, 31, 11},
  {cont__53_57, &frame__53_52, 1566, 1569, 9, 11},
  {entry__53_5, NULL, 1538, 1538, 9, 26},
  {cont__53_6, &frame__53_5, 1537, 1541, 7, 33},
  {cont__53_12, &frame__53_5, 1543, 1543, 9, 36},
  {cont__53_14, &frame__53_5, 1542, 1549, 7, 63},
  {cont__53_28, &frame__53_5, 1552, 1552, 15, 37},
  {cont__53_29, &frame__53_5, 1552, 1552, 57, 79},
  {cont__53_30, &frame__53_5, 1550, 1553, 38, 15},
  {cont__53_34, &frame__53_5, 1550, 1553, 7, 15},
  {cont__53_35, &frame__53_5, 1554, 1564, 7, 21},
  {cont__53_50, &frame__53_5, 1565, 1565, 10, 29},
  {cont__53_51, &frame__53_5, 1565, 1569, 7, 12},
  {entry__53_62, NULL, 1499, 1499, 9, 13},
  {entry__53_64, NULL, 1501, 1501, 9, 13},
  {entry__53_66, NULL, 1503, 1503, 9, 20},
  {entry__53_68, NULL, 1504, 1504, 9, 20},
  {entry__53_73, NULL, 1515, 1515, 36, 59},
  {cont__53_74, &frame__53_73, 1515, 1515, 33, 59},
  {entry__53_75, NULL, 1515, 1515, 62, 73},
  {entry__53_78, NULL, 1517, 1517, 40, 58},
  {cont__53_79, &frame__53_78, 1517, 1517, 37, 58},
  {entry__53_80, NULL, 1517, 1517, 61, 72},
  {entry__53_83, NULL, 1522, 1522, 28, 46},
  {cont__53_84, &frame__53_83, 1522, 1522, 12, 47},
  {cont__53_85, &frame__53_83, 1522, 1522, 9, 47},
  {entry__53_86, NULL, 1523, 1523, 9, 20},
  {entry__53_90, NULL, 1528, 1528, 28, 46},
  {cont__53_91, &frame__53_90, 1528, 1528, 12, 47},
  {cont__53_92, &frame__53_90, 1528, 1528, 9, 47},
  {entry__53_93, NULL, 1529, 1529, 9, 20},
  {entry__53_95, NULL, 1577, 1577, 41, 58},
  {cont__53_96, &frame__53_95, 1574, 1578, 31, 12},
  {cont__53_102, &frame__53_95, 1574, 1578, 9, 12},
  {entry__53_138, NULL, 1604, 1604, 72, 72},
  {cont__53_139, &frame__53_138, 1604, 1604, 52, 73},
  {cont__53_140, &frame__53_138, 1604, 1604, 49, 73},
  {entry__53_135, NULL, 1604, 1604, 20, 47},
  {cont__53_137, &frame__53_135, 1604, 1604, 17, 73},
  {entry__53_143, NULL, 1605, 1605, 71, 71},
  {cont__53_144, &frame__53_143, 1605, 1605, 51, 72},
  {cont__53_145, &frame__53_143, 1605, 1605, 48, 72},
  {entry__53_141, NULL, 1605, 1605, 20, 46},
  {cont__53_142, &frame__53_141, 1605, 1605, 17, 72},
  {entry__53_147, NULL, 1606, 1606, 25, 36},
  {entry__53_146, NULL, 1606, 1606, 17, 36},
  {entry__53_150, NULL, 1609, 1609, 39, 64},
  {cont__53_151, &frame__53_150, 1609, 1609, 39, 64},
  {entry__53_153, NULL, 1613, 1613, 29, 51},
  {cont__53_154, &frame__53_153, 1610, 1613, 23, 79},
  {cont__53_159, &frame__53_153, 1610, 1613, 17, 79},
  {entry__53_160, NULL, 1615, 1615, 23, 76},
  {cont__53_164, &frame__53_160, 1615, 1615, 17, 76},
  {entry__53_122, NULL, 1595, 1595, 13, 36},
  {cont__53_124, &frame__53_122, 1596, 1596, 13, 27},
  {cont__53_125, &frame__53_122, 1597, 1597, 51, 62},
  {cont__53_126, &frame__53_122, 1597, 1597, 65, 65},
  {cont__53_127, &frame__53_122, 1597, 1597, 30, 66},
  {cont__53_128, &frame__53_122, 1597, 1597, 13, 67},
  {cont__53_129, &frame__53_122, 1600, 1600, 40, 51},
  {cont__53_130, &frame__53_122, 1600, 1600, 54, 54},
  {cont__53_131, &frame__53_122, 1600, 1600, 20, 55},
  {cont__53_132, &frame__53_122, 1600, 1600, 20, 76},
  {cont__53_133, &frame__53_122, 1599, 1600, 13, 77},
  {cont__53_134, &frame__53_122, 1602, 1606, 13, 37},
  {cont__53_148, &frame__53_122, 1609, 1609, 15, 34},
  {cont__53_149, &frame__53_122, 1609, 1609, 15, 64},
  {cont__53_152, &frame__53_122, 1608, 1615, 13, 77},
  {entry__53_114, NULL, 1588, 1593, 17, 76},
  {cont__53_120, &frame__53_114, 1588, 1593, 11, 76},
  {cont__53_121, &frame__53_114, 1594, 1615, 11, 78},
  {cont__53_165, &frame__53_114, 1616, 1618, 11, 13},
  {entry__53_103, NULL, 1585, 1585, 13, 30},
  {cont__53_104, &frame__53_103, 1580, 1585, 31, 53},
  {cont__53_108, &frame__53_103, 1580, 1585, 9, 53},
  {cont__53_109, &frame__53_103, 1586, 1586, 36, 61},
  {cont__53_110, &frame__53_103, 1586, 1586, 9, 63},
  {cont__53_112, &frame__53_103, 1587, 1587, 16, 48},
  {cont__53_113, &frame__53_103, 1587, 1618, 9, 14},
  {entry__53_171, NULL, 1623, 1624, 17, 69},
  {cont__53_174, &frame__53_171, 1623, 1624, 11, 69},
  {entry__53_178, NULL, 1627, 1627, 13, 47},
  {cont__53_179, &frame__53_178, 1628, 1628, 20, 42},
  {cont__53_180, &frame__53_178, 1628, 1628, 44, 56},
  {cont__53_181, &frame__53_178, 1628, 1628, 44, 61},
  {cont__53_182, &frame__53_178, 1628, 1628, 13, 61},
  {entry__53_183, NULL, 1630, 1630, 13, 42},
  {entry__53_186, NULL, 1635, 1635, 38, 60},
  {cont__53_187, &frame__53_186, 1632, 1635, 28, 63},
  {cont__53_193, &frame__53_186, 1632, 1635, 11, 63},
  {entry__53_211, NULL, 1648, 1648, 49, 67},
  {cont__53_212, &frame__53_211, 1648, 1648, 67, 67},
  {entry__53_196, NULL, 1640, 1640, 13, 36},
  {cont__53_198, &frame__53_196, 1641, 1641, 13, 27},
  {cont__53_199, &frame__53_196, 1642, 1642, 51, 62},
  {cont__53_200, &frame__53_196, 1642, 1642, 65, 65},
  {cont__53_201, &frame__53_196, 1642, 1642, 30, 66},
  {cont__53_202, &frame__53_196, 1642, 1642, 13, 67},
  {cont__53_203, &frame__53_196, 1645, 1645, 40, 51},
  {cont__53_204, &frame__53_196, 1645, 1645, 54, 54},
  {cont__53_205, &frame__53_196, 1645, 1645, 20, 55},
  {cont__53_206, &frame__53_196, 1645, 1645, 20, 76},
  {cont__53_207, &frame__53_196, 1644, 1645, 13, 77},
  {cont__53_208, &frame__53_196, 1647, 1647, 13, 40},
  {cont__53_209, &frame__53_196, 1648, 1648, 20, 46},
  {cont__53_210, &frame__53_196, 1648, 1648, 13, 67},
  {cont__53_213, &frame__53_196, 1649, 1649, 13, 40},
  {cont__53_214, &frame__53_196, 1652, 1652, 27, 49},
  {cont__53_215, &frame__53_196, 1650, 1653, 36, 20},
  {cont__53_220, &frame__53_196, 1650, 1653, 13, 20},
  {cont__53_221, &frame__53_196, 1653, 1653, 21, 21},
  {entry__53_222, NULL, 1655, 1655, 13, 34},
  {cont__53_224, &frame__53_222, 1655, 1655, 34, 34},
  {entry__53_236, NULL, 1667, 1667, 45, 60},
  {cont__53_238, &frame__53_236, 1667, 1667, 42, 60},
  {entry__53_239, NULL, 1667, 1667, 63, 67},
  {entry__53_243, NULL, 1674, 1679, 17, 23},
  {cont__53_246, &frame__53_243, 1679, 1679, 24, 24},
  {entry__53_247, NULL, 1681, 1681, 17, 75},
  {cont__53_249, &frame__53_247, 1681, 1681, 75, 75},
  {entry__53_234, NULL, 1667, 1667, 20, 39},
  {cont__53_235, &frame__53_234, 1667, 1667, 17, 68},
  {cont__53_240, &frame__53_234, 1665, 1670, 13, 22},
  {cont__53_241, &frame__53_234, 1673, 1673, 15, 42},
  {cont__53_242, &frame__53_234, 1672, 1681, 13, 76},
  {entry__53_250, NULL, 1683, 1683, 13, 50},
  {cont__53_252, &frame__53_250, 1683, 1683, 50, 50},
  {entry__53_258, NULL, 1689, 1699, 13, 16},
  {cont__53_260, &frame__53_258, 1699, 1699, 17, 17},
  {entry__53_261, NULL, 1701, 1711, 44, 16},
  {cont__53_265, &frame__53_261, 1701, 1711, 13, 16},
  {cont__53_266, &frame__53_261, 1711, 1711, 17, 17},
  {entry__53_292, NULL, 1724, 1733, 21, 17},
  {cont__53_301, &frame__53_292, 1724, 1733, 15, 17},
  {entry__53_302, NULL, 1735, 1741, 21, 17},
  {cont__53_310, &frame__53_302, 1735, 1741, 15, 17},
  {entry__53_284, NULL, 1721, 1721, 13, 66},
  {cont__53_288, &frame__53_284, 1720, 1721, 11, 66},
  {cont__53_289, &frame__53_284, 1723, 1723, 13, 38},
  {cont__53_291, &frame__53_284, 1722, 1741, 11, 19},
  {entry__53_167, NULL, 1620, 1620, 9, 32},
  {cont__53_168, &frame__53_167, 1621, 1621, 9, 38},
  {cont__53_169, &frame__53_167, 1622, 1622, 16, 30},
  {cont__53_170, &frame__53_167, 1622, 1624, 9, 70},
  {cont__53_175, &frame__53_167, 1626, 1626, 11, 23},
  {cont__53_176, &frame__53_167, 1626, 1626, 11, 34},
  {cont__53_177, &frame__53_167, 1625, 1630, 9, 43},
  {cont__53_184, &frame__53_167, 1631, 1631, 12, 31},
  {cont__53_185, &frame__53_167, 1631, 1635, 9, 64},
  {cont__53_194, &frame__53_167, 1639, 1639, 11, 25},
  {cont__53_195, &frame__53_167, 1638, 1655, 9, 35},
  {cont__53_225, &frame__53_167, 1660, 1660, 24, 36},
  {cont__53_226, &frame__53_167, 1661, 1661, 39, 51},
  {cont__53_227, &frame__53_167, 1661, 1661, 39, 65},
  {cont__53_228, &frame__53_167, 1657, 1661, 9, 67},
  {cont__53_233, &frame__53_167, 1663, 1683, 9, 51},
  {cont__53_253, &frame__53_167, 1684, 1686, 9, 12},
  {cont__53_255, &frame__53_167, 1688, 1688, 11, 44},
  {cont__53_257, &frame__53_167, 1687, 1711, 9, 18},
  {cont__53_267, &frame__53_167, 1712, 1712, 9, 36},
  {cont__53_268, &frame__53_167, 1714, 1714, 11, 74},
  {cont__53_271, &frame__53_167, 1713, 1714, 9, 74},
  {cont__53_272, &frame__53_167, 1717, 1717, 24, 39},
  {cont__53_273, &frame__53_167, 1717, 1717, 13, 40},
  {cont__53_274, &frame__53_167, 1715, 1717, 15, 46},
  {cont__53_279, &frame__53_167, 1715, 1717, 9, 46},
  {cont__53_280, &frame__53_167, 1718, 1718, 9, 51},
  {cont__53_282, &frame__53_167, 1719, 1719, 16, 50},
  {cont__53_283, &frame__53_167, 1719, 1741, 9, 20},
  {entry__53_314, NULL, 1748, 1748, 38, 60},
  {cont__53_315, &frame__53_314, 1745, 1748, 28, 63},
  {cont__53_321, &frame__53_314, 1745, 1748, 11, 63},
  {entry__53_311, NULL, 1743, 1743, 9, 30},
  {cont__53_312, &frame__53_311, 1744, 1744, 12, 31},
  {cont__53_313, &frame__53_311, 1744, 1748, 9, 64},
  {entry__53_331, NULL, 1757, 1757, 16, 48},
  {cont__53_333, &frame__53_331, 1757, 1757, 13, 48},
  {entry__53_334, NULL, 1758, 1758, 13, 28},
  {entry__53_343, NULL, 1766, 1766, 47, 57},
  {entry__53_345, NULL, 1766, 1766, 60, 64},
  {entry__53_357, NULL, 1772, 1775, 30, 40},
  {cont__53_361, &frame__53_357, 1772, 1775, 13, 40},
  {entry__53_362, NULL, 1777, 1777, 35, 67},
  {cont__53_365, &frame__53_362, 1777, 1777, 13, 67},
  {entry__53_322, NULL, 1750, 1750, 9, 43},
  {cont__53_323, &frame__53_322, 1751, 1751, 9, 51},
  {cont__53_324, &frame__53_322, 1752, 1752, 45, 56},
  {cont__53_325, &frame__53_322, 1752, 1752, 59, 59},
  {cont__53_326, &frame__53_322, 1752, 1752, 9, 60},
  {cont__53_327, &frame__53_322, 1756, 1756, 13, 26},
  {cont__53_328, &frame__53_322, 1756, 1756, 13, 39},
  {cont__53_330, &frame__53_322, 1754, 1758, 9, 29},
  {cont__53_335, &frame__53_322, 1760, 1760, 47, 70},
  {cont__53_336, &frame__53_322, 1760, 1760, 47, 70},
  {cont__53_337, &frame__53_322, 1760, 1760, 47, 72},
  {cont__53_338, &frame__53_322, 1760, 1760, 9, 73},
  {cont__53_339, &frame__53_322, 1761, 1761, 9, 45},
  {cont__53_340, &frame__53_322, 1766, 1766, 16, 44},
  {cont__53_342, &frame__53_322, 1766, 1766, 13, 65},
  {cont__53_346, &frame__53_322, 1767, 1767, 47, 57},
  {cont__53_349, &frame__53_322, 1767, 1767, 59, 69},
  {cont__53_351, &frame__53_322, 1767, 1767, 13, 70},
  {cont__53_352, &frame__53_322, 1763, 1768, 9, 22},
  {cont__53_353, &frame__53_322, 1771, 1771, 11, 24},
  {cont__53_354, &frame__53_322, 1771, 1771, 11, 37},
  {cont__53_356, &frame__53_322, 1770, 1777, 9, 68},
  {cont__53_366, &frame__53_322, 1778, 1778, 45, 63},
  {cont__53_367, &frame__53_322, 1778, 1778, 45, 74},
  {cont__53_368, &frame__53_322, 1778, 1778, 15, 80},
  {cont__53_371, &frame__53_322, 1778, 1778, 9, 80},
  {entry__53_376, NULL, 1782, 1782, 39, 45},
  {cont__53_377, &frame__53_376, 1782, 1782, 39, 51},
  {cont__53_378, &frame__53_376, 1782, 1782, 39, 51},
  {entry__53_386, NULL, 1784, 1784, 15, 41},
  {entry__53_380, NULL, 1783, 1783, 38, 75},
  {cont__53_384, &frame__53_380, 1783, 1783, 20, 75},
  {cont__53_385, &frame__53_380, 1783, 1784, 13, 41},
  {entry__53_374, NULL, 1782, 1782, 14, 34},
  {cont__53_375, &frame__53_374, 1782, 1782, 14, 51},
  {cont__53_379, &frame__53_374, 1782, 1784, 11, 42},
  {cont__53_387, &frame__53_374, 1785, 1785, 33, 46},
  {cont__53_388, &frame__53_374, 1785, 1785, 11, 53},
  {entry__53_372, NULL, 1780, 1780, 9, 36},
  {cont__53_373, &frame__53_372, 1781, 1785, 9, 53},
  {entry__53_389, NULL, 1787, 1788, 15, 58},
  {cont__53_392, &frame__53_389, 1787, 1788, 9, 58},
  {entry__53_4, NULL, 1492, 1492, 5, 23},
  {cont__53_58, &frame__53_4, 1493, 1493, 5, 27},
  {cont__53_59, &frame__53_4, 1497, 1497, 9, 22},
  {cont__53_60, &frame__53_4, 1495, 1504, 5, 21},
  {cont__53_70, &frame__53_4, 1512, 1512, 5, 35},
  {cont__53_71, &frame__53_4, 1515, 1515, 10, 30},
  {cont__53_72, &frame__53_4, 1514, 1515, 5, 74},
  {cont__53_76, &frame__53_4, 1517, 1517, 14, 34},
  {cont__53_77, &frame__53_4, 1517, 1517, 5, 73},
  {cont__53_81, &frame__53_4, 1521, 1521, 9, 29},
  {cont__53_82, &frame__53_4, 1519, 1523, 5, 21},
  {cont__53_87, &frame__53_4, 1527, 1527, 9, 27},
  {cont__53_88, &frame__53_4, 1527, 1527, 9, 38},
  {cont__53_89, &frame__53_4, 1525, 1529, 5, 21},
  {cont__53_94, &frame__53_4, 1571, 1788, 5, 60},
  {entry__53_1, NULL, 1490, 1490, 3, 42},
  {cont__53_3, &frame__53_1, 1491, 1788, 3, 61},
  {entry__54_15, NULL, 1801, 1801, 59, 63},
  {entry__54_16, NULL, 1801, 1801, 66, 76},
  {entry__54_13, NULL, 1801, 1801, 18, 56},
  {cont__54_14, &frame__54_13, 1801, 1801, 9, 77},
  {cont__54_18, &frame__54_13, 1805, 1805, 23, 49},
  {cont__54_19, &frame__54_13, 1802, 1805, 15, 67},
  {cont__54_24, &frame__54_13, 1802, 1805, 9, 67},
  {entry__54_25, NULL, 1807, 1809, 15, 46},
  {cont__54_28, &frame__54_25, 1807, 1809, 9, 46},
  {entry__54_7, NULL, 1797, 1797, 5, 40},
  {cont__54_8, &frame__54_7, 1798, 1798, 12, 34},
  {cont__54_9, &frame__54_7, 1798, 1798, 12, 37},
  {cont__54_10, &frame__54_7, 1798, 1798, 5, 42},
  {cont__54_11, &frame__54_7, 1800, 1800, 7, 27},
  {cont__54_12, &frame__54_7, 1799, 1809, 5, 48},
  {entry__54_1, NULL, 1794, 1794, 56, 66},
  {cont__54_2, &frame__54_1, 1791, 1795, 9, 36},
  {cont__54_5, &frame__54_1, 1791, 1795, 3, 36},
  {cont__54_6, &frame__54_1, 1796, 1809, 3, 49},
  {cont__54_29, &frame__54_1, 1810, 1810, 3, 43},
  {cont__54_31, &frame__54_1, 1811, 1814, 9, 9},
  {cont__54_34, &frame__54_1, 1811, 1814, 3, 9},
  {entry__55_5, NULL, 1821, 1821, 41, 74},
  {entry__55_3, NULL, 1821, 1821, 10, 38},
  {cont__55_4, &frame__55_3, 1821, 1821, 7, 74},
  {entry__55_9, NULL, 1822, 1822, 38, 67},
  {entry__55_7, NULL, 1822, 1822, 10, 35},
  {cont__55_8, &frame__55_7, 1822, 1822, 7, 67},
  {entry__55_11, NULL, 1824, 1824, 9, 45},
  {entry__55_2, NULL, 1820, 1824, 5, 46},
  {entry__55_21, NULL, 1832, 1832, 24, 24},
  {cont__55_22, &frame__55_21, 1832, 1832, 7, 25},
  {cont__55_23, &frame__55_21, 1832, 1832, 7, 52},
  {cont__55_24, &frame__55_21, 1832, 1832, 7, 52},
  {entry__55_30, NULL, 1835, 1835, 38, 47},
  {entry__55_31, NULL, 1835, 1835, 50, 63},
  {entry__55_26, NULL, 1834, 1834, 20, 49},
  {cont__55_27, &frame__55_26, 1834, 1834, 7, 52},
  {cont__55_28, &frame__55_26, 1835, 1835, 18, 35},
  {cont__55_29, &frame__55_26, 1835, 1835, 7, 64},
  {cont__55_32, &frame__55_26, 1836, 1836, 7, 58},
  {entry__55_40, NULL, 1844, 1844, 44, 69},
  {cont__55_41, &frame__55_40, 1844, 1844, 44, 74},
  {cont__55_42, &frame__55_40, 1844, 1844, 17, 78},
  {cont__55_45, &frame__55_40, 1843, 1844, 15, 78},
  {entry__55_37, NULL, 1842, 1842, 16, 41},
  {cont__55_38, &frame__55_37, 1842, 1842, 16, 52},
  {cont__55_39, &frame__55_37, 1842, 1844, 13, 79},
  {entry__55_49, NULL, 1848, 1850, 15, 70},
  {entry__55_46, NULL, 1845, 1845, 16, 41},
  {cont__55_47, &frame__55_46, 1845, 1845, 16, 52},
  {cont__55_48, &frame__55_46, 1845, 1850, 13, 71},
  {entry__55_53, NULL, 1858, 1858, 27, 61},
  {cont__55_56, &frame__55_53, 1858, 1858, 19, 61},
  {entry__55_57, NULL, 1856, 1856, 19, 48},
  {entry__55_51, NULL, 1852, 1852, 15, 61},
  {cont__55_52, &frame__55_51, 1853, 1858, 15, 62},
  {entry__55_65, NULL, 1862, 1864, 13, 33},
  {entry__55_35, NULL, 1840, 1840, 11, 46},
  {cont__55_36, &frame__55_35, 1841, 1858, 11, 64},
  {cont__55_59, &frame__55_35, 1859, 1859, 11, 20},
  {cont__55_60, &frame__55_35, 1860, 1860, 39, 62},
  {cont__55_63, &frame__55_35, 1860, 1860, 11, 62},
  {cont__55_64, &frame__55_35, 1861, 1864, 11, 34},
  {cont__55_67, &frame__55_35, 1865, 1865, 11, 23},
  {cont__55_69, &frame__55_35, 1866, 1866, 29, 52},
  {cont__55_72, &frame__55_35, 1866, 1866, 11, 52},
  {cont__55_73, &frame__55_35, 1867, 1867, 11, 44},
  {entry__55_79, NULL, 1874, 1874, 15, 38},
  {cont__55_80, &frame__55_79, 1874, 1874, 15, 38},
  {entry__55_82, NULL, 1878, 1878, 47, 62},
  {cont__55_83, &frame__55_82, 1878, 1878, 68, 78},
  {cont__55_84, &frame__55_82, 1876, 1879, 21, 23},
  {cont__55_88, &frame__55_82, 1876, 1879, 15, 23},
  {entry__55_89, NULL, 1881, 1881, 49, 59},
  {cont__55_90, &frame__55_89, 1881, 1881, 21, 60},
  {cont__55_91, &frame__55_89, 1881, 1881, 15, 60},
  {entry__55_75, NULL, 1869, 1869, 11, 42},
  {cont__55_76, &frame__55_75, 1870, 1870, 11, 36},
  {cont__55_77, &frame__55_75, 1873, 1873, 15, 55},
  {cont__55_78, &frame__55_75, 1872, 1874, 13, 37},
  {cont__55_81, &frame__55_75, 1871, 1881, 11, 61},
  {entry__55_33, NULL, 1839, 1839, 9, 26},
  {cont__55_34, &frame__55_33, 1838, 1881, 7, 63},
  {entry__55_1, NULL, 1819, 1824, 3, 47},
  {cont__55_13, &frame__55_1, 1825, 1825, 3, 34},
  {cont__55_14, &frame__55_1, 1826, 1826, 3, 32},
  {cont__55_15, &frame__55_1, 1827, 1827, 3, 42},
  {cont__55_16, &frame__55_1, 1828, 1828, 3, 50},
  {cont__55_17, &frame__55_1, 1831, 1831, 7, 32},
  {cont__55_18, &frame__55_1, 1831, 1831, 7, 37},
  {cont__55_19, &frame__55_1, 1831, 1831, 7, 37},
  {cont__55_20, &frame__55_1, 1830, 1832, 5, 51},
  {cont__55_25, &frame__55_1, 1829, 1881, 3, 65}
};

union NODE {
  struct {
    FUNC type;
    ATTRIBUTES *attributes;
  };
  CONTINUATION continuation;
  CLOSURE closure;
};
static void type__sim2c__to_c(void) {
  myself = get_attribute(arguments->slots[0], poly_idx__sim2c__to_c);
  if (CONTAINS_AN_ATTRIBUTE_VALUE(myself)) {
    if (argument_count != 1) {
      if (argument_count != 2) invalid_arguments_error();
      NODE *attr = arguments->slots[1];
      NODE *temp = clone_object_and_attributes(arguments->slots[0]);
      update_start_p = node_p;
      set_attribute_value(temp->attributes, poly_idx__sim2c__to_c, attr);
      arguments = node_p;
      argument_count = 1;
      arguments->slots[0] = temp;
    } else {
      arguments = node_p;
      arguments->slots[0] = RETRIEVE_ATTRIBUTE_VALUE(myself);
    }
    func = frame->cont;
    frame->cont = invalid_continuation;
  } else {
    func = myself->type;
  }
}
static NODE *character__92;
static NODE *character__47;
static NODE *character__160;
static NODE *character__10;
static NODE *number__0;
static NODE *number__3;
static NODE *character__126;
static NODE *character__95;
static NODE *character__40;
static NODE *character__34;
static NODE *character__255;
static NODE *number__5;
static NODE *character__39;
static NODE *character__32;
static NODE *number__9;
static NODE *character__125;
static NODE *character__41;
static NODE *character__59;
static NODE *number__1;
static NODE *number__2;
static NODE *character__42;

static const char *used_namespaces[] = {
  "std",
  "sim2c",
  "node",
  NULL
};

static MODULE_INFO module_info = {
  NULL,
  "c_code_generator",
  continuation_info,
  sizeof(continuation_info)/sizeof(CONTINUATION_INFO),
  (NODE **)&var,
  var_names,
  sizeof(var_names)/sizeof(const char *),
  used_namespaces,
  {DEBUG_FILENAME("c_code_generator.sim")}
};

/******
C O D E
******/

static int already_run = false;

EXPORT void run__c_code_generator(void) {
  if (already_run) {
    func = frame->cont;
    frame->cont = invalid_continuation;
    return;
  }
  already_run = true;
  allocate_initialized_frame_gc(0, 0);
  // 34: %sim2c::suffix undefined
  initialize_maybe_future(get__sim2c__suffix(), get__undefined());
  // 36: %current_locals empty_table
  initialize_maybe_future(get__current_locals(), get__empty_table());
  // 37: %current_frame undefined
  initialize_maybe_future(get__current_frame(), get__undefined());
  // 38: %is_a_shared_local empty_set
  initialize_maybe_future(get__is_a_shared_local(), get__empty_set());
  // 39: %temporary_offset undefined
  initialize_maybe_future(get__temporary_offset(), get__undefined());
  // 40: %%sim2c::delayed_code undefined
  set__sim2c__delayed_code(get__undefined());
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__9_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 42: ... -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__9_5(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 42: ... string('_' name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__95;
  arguments->slots[1] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__9_6;
}
static void cont__9_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 42: ... -> string('_' name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__9_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 42: ... name .contains. "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__9_2;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__9_3;
}
static void cont__9_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 42: ... -> name
  frame->slots[2] /* temp__2 */ = create_closure(entry__9_4, 0);
  // 42: ... -> string('_' name)
  frame->slots[3] /* temp__3 */ = create_closure(entry__9_5, 0);
  // 42: ... if name .contains. "__" (-> name) -> string('_' name)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__10_4(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 45: ... string("var." name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__10_5;
  arguments->slots[1] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__10_6;
}
static void cont__10_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 45: ... -> string("var." name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__10_7(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 45: ... string("var._" name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__10_8;
  arguments->slots[1] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__10_9;
}
static void cont__10_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 45: ... -> string("var._" name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__10_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 45: ... name .contains. "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__10_2;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__10_3;
}
static void cont__10_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 45: ... -> string("var." name)
  frame->slots[2] /* temp__2 */ = create_closure(entry__10_4, 0);
  // 45: ... -> string("var._" name)
  frame->slots[3] /* temp__3 */ = create_closure(entry__10_7, 0);
  // 45: if name .contains. "__" (-> string("var." name)) -> string("var._" name)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__11_1(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 48: write delayed_code
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__delayed_code();
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__11_2;
}
static void cont__11_2(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 49: !delayed_code ""
  set__delayed_code(empty_string);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__12_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // body: 0
  // cont_tab_entries: 1
  frame->slots[1] /* cont_tab_entries */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 52: $$cont_tab_entries ""
  ((CELL *)frame->slots[1])->contents /* cont_tab_entries */ = empty_string;
  // 53: ... :
  // 54:   %%sim2c::current_continuation_info undefined
  // 55:   
  // 56:   %write_to_continuation_table: (args*) write_to &cont_tab_entries args*
  // 57:   
  // 58:   collect_output $output body
  // 59:   append &delayed_code output
  frame->slots[2] /* temp__1 */ = create_closure(entry__12_2, 0);
  // 53: do:
  // 54:   %%sim2c::current_continuation_info undefined
  // 55:   
  // 56:   %write_to_continuation_table: (args*) write_to &cont_tab_entries args*
  // 57:   
  // 58:   collect_output $output body
  // 59:   append &delayed_code output
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__12_7;
}
static void entry__12_2(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // return__1: 0
  // cont_tab_entries: 1
  // body: 2
  // output: 3
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* cont_tab_entries */
  frame->slots[2] = myself->closure.frame->slots[0]; /* body */
  define__sim2c__current_continuation_info(undefined);
  define__write_to_continuation_table(create_future());
  frame->slots[3] /* output */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 54: %%sim2c::current_continuation_info undefined
  set__sim2c__current_continuation_info(get__undefined());
  // 56: ... : (args*) write_to &cont_tab_entries args*
  frame->slots[4] /* temp__1 */ = create_closure(entry__12_3, -1);
  // 56: %write_to_continuation_table: (args*) write_to &cont_tab_entries args*
  initialize_future(get__write_to_continuation_table(), frame->slots[4] /* temp__1 */);
  // 58: collect_output $output body
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* body */;
  result_count = 1;
  myself = get__collect_output();
  func = myself->type;
  frame->cont = cont__12_5;
}
static void entry__12_3(void) {
  allocate_arguments();
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // args: 0
  // cont_tab_entries: 1
  frame->slots[1] = myself->closure.frame->slots[1]; /* cont_tab_entries */
  frame->slots[0] /* args */ = from_arguments(0, argument_count-0);
  // 56: ... write_to &cont_tab_entries args*
  argument_count = 0;
  arguments = node_p;
  arguments->slots[argument_count++] = ((CELL *)frame->slots[1])->contents /* cont_tab_entries */;
  unfold(frame->slots[0] /* args */);
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__12_4;
}
static void cont__12_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* cont_tab_entries */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__12_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* output */, arguments->slots[0]);
  // 59: append &delayed_code output
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__delayed_code();
  arguments->slots[1] = frame->slots[3] /* output */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__12_6;
}
static void cont__12_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__delayed_code(arguments->slots[0]);
  argument_count = 0;
  arguments = node_p;
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__12_7(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 60: write_to_delayed_continuation_table cont_tab_entries
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* cont_tab_entries */;
  result_count = frame->caller_result_count;
  myself = get__write_to_delayed_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__13_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 63: ... "
  // 64:   static void @(name)(void);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__13_2;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__13_3;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__13_4;
}
static void cont__13_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 63: write_to_declarations "
  // 64:   static void @(name)(void);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__13_5;
}
static void cont__13_5(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 65: insert_delayed
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = var._insert_delayed;
  func = myself->type;
  frame->cont = cont__13_6;
}
static void cont__13_6(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 66: ... "
  // 67:   static void @(name)(void) {
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__13_7;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__13_8;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__13_9;
}
static void cont__13_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 66: write "
  // 67:   static void @(name)(void) {
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__13_10;
}
static void cont__13_10(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 68: ... "  {@(name), "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__13_11;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__13_12;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__13_13;
}
static void cont__13_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 68: write_to_continuation_table "  {@(name), "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame->cont = cont__13_14;
}
static void cont__13_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 70: ... current_frame.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__current_frame();
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__13_15;
}
static void cont__13_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 70: if(current_frame.is_defined (-> "&@(current_frame), ") -> "NULL, ")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = func__13_16;
  arguments->slots[2] = func__13_20;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__13_22;
}
static void entry__13_16(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 70: ... "&@(current_frame), "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__13_17;
  arguments->slots[1] = get__current_frame();
  arguments->slots[2] = string__13_18;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__13_19;
}
static void cont__13_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 70: ... -> "&@(current_frame), "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__13_20(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 70: ... -> "NULL, "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__13_21;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__13_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 69: write_to_continuation_table
  // 70:   if(current_frame.is_defined (-> "&@(current_frame), ") -> "NULL, ")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__14_3(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 75: ... "@(current_continuation_info)},@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__current_continuation_info();
  arguments->slots[1] = string__14_4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__14_5;
}
static void cont__14_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 75: write_to_continuation_table "@(current_continuation_info)},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame->cont = cont__14_6;
}
static void cont__14_6(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 76: !current_continuation_info undefined
  set__current_continuation_info(get__undefined());
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__14_7(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 78: write_to_continuation_table "},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__14_8;
  result_count = frame->caller_result_count;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__14_1(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 74: current_continuation_info.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__current_continuation_info();
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__14_2;
}
static void cont__14_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 73: if
  // 74:   current_continuation_info.is_defined:
  // 75:     write_to_continuation_table "@(current_continuation_info)},@nl;"
  // 76:     !current_continuation_info undefined
  // 77:   :
  // 78:     write_to_continuation_table "},@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  arguments->slots[1] = func__14_3;
  arguments->slots[2] = func__14_7;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__15_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 81: end_continuation
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = get__end_continuation();
  func = myself->type;
  frame->cont = cont__15_2;
}
static void cont__15_2(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 82: begin_continuation name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = frame->caller_result_count;
  myself = get__begin_continuation();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__16_1(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // arguments: 0
  // return: 1
  // inputs_count: 2
  frame->slots[1] /* return */ = create_continuation();
  frame->slots[2] /* inputs_count */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 89: $$inputs_count 0
  ((CELL *)frame->slots[2])->contents /* inputs_count */ = number__0;
  // 90: ... : (argument)
  // 91:   if
  // 92:     argument.is_an_expanded_item || argument.is_an_optional_item:
  // 93:       return undefined
  // 94:     :
  // 95:       inc &inputs_count
  frame->slots[3] /* temp__1 */ = create_closure(entry__16_2, 1);
  // 90: for_each arguments: (argument)
  // 91:   if
  // 92:     argument.is_an_expanded_item || argument.is_an_optional_item:
  // 93:       return undefined
  // 94:     :
  // 95:       inc &inputs_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__16_10;
}
static void entry__16_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 93: return undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__16_8(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 95: inc &inputs_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* inputs_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__16_9;
}
static void cont__16_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* inputs_count */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__16_2(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // argument: 0
  // return: 1
  // inputs_count: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 92: argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__16_3;
}
static void cont__16_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 92: ... argument.is_an_optional_item
  frame->slots[5] /* temp__3 */ = create_closure(entry__16_4, 0);
  // 92: argument.is_an_expanded_item || argument.is_an_optional_item
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__16_6;
}
static void entry__16_4(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 92: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__16_5;
}
static void cont__16_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 92: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__16_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 92: ... :
  // 93:   return undefined
  frame->slots[6] /* temp__4 */ = create_closure(entry__16_7, 0);
  // 94: :
  // 95:   inc &inputs_count
  frame->slots[7] /* temp__5 */ = create_closure(entry__16_8, 0);
  // 91: if
  // 92:   argument.is_an_expanded_item || argument.is_an_optional_item:
  // 93:     return undefined
  // 94:   :
  // 95:     inc &inputs_count
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__16_10(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 96: -> inputs_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* inputs_count */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__17_25(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // src: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 118: ... "  unfold(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__17_26;
  arguments->slots[1] = frame->slots[0] /* src */;
  arguments->slots[2] = string__17_27;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__17_28;
}
static void cont__17_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 118: ... write "  unfold(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__17_19(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // src: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 117: ... "  optional_item(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__17_20;
  arguments->slots[1] = frame->slots[0] /* src */;
  arguments->slots[2] = string__17_21;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__17_22;
}
static void cont__17_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 117: ... write "  optional_item(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__17_17(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 117: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__17_18;
}
static void cont__17_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 117: ... : write "  optional_item(@(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__17_19, 0);
  // 117: -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__17_23(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 118: ... argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__17_24;
}
static void cont__17_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 118: ... : write "  unfold(@(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__17_25, 0);
  // 118: -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__17_29(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // inputs_count: 0
  // idx: 1
  // src: 2
  // slot_idx: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* inputs_count */
  frame->slots[1] = myself->closure.frame->slots[2]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[3]; /* src */
  frame->slots[3] /* slot_idx */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 120: ... inputs_count.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* inputs_count */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__17_30;
}
static void cont__17_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 120: ... -> idx
  frame->slots[5] /* temp__2 */ = create_closure(entry__17_31, 0);
  // 120: $slot_idx if(inputs_count.is_defined (-> idx) -> "argument_count++")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = func__17_32;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__17_34;
}
static void entry__17_31(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // idx: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 120: ... -> idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* idx */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__17_32(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 120: ... -> "argument_count++"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__17_33;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__17_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* slot_idx */, arguments->slots[0]);
  // 121: ... "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__17_35;
  arguments->slots[1] = frame->slots[3] /* slot_idx */;
  arguments->slots[2] = string__17_36;
  arguments->slots[3] = frame->slots[2] /* src */;
  arguments->slots[4] = string__17_37;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__17_38;
}
static void cont__17_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 121: write "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__17_39;
}
static void cont__17_39(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 122: inc &idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__17_40;
}
static void cont__17_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__17_15(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // argument: 0
  // inputs_count: 1
  // idx: 2
  // src: 3
  frame->slots[1] = myself->closure.frame->slots[2]; /* inputs_count */
  frame->slots[2] = myself->closure.frame->slots[3]; /* idx */
  frame->slots[3] /* src */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 115: $src argument.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__17_16;
}
static void cont__17_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 117: -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  frame->slots[4] /* temp__1 */ = create_closure(entry__17_17, 0);
  // 118: -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__17_23, 0);
  // 119: :
  // 120:   $slot_idx if(inputs_count.is_defined (-> idx) -> "argument_count++")
  // 121:   write "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  // 122:   inc &idx
  frame->slots[6] /* temp__3 */ = create_closure(entry__17_29, 0);
  // 116: cond
  // 117:   -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  // 118:   -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  // 119:   :
  // 120:     $slot_idx if(inputs_count.is_defined (-> idx) -> "argument_count++")
  // 121:     write "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  // 122:     inc &idx
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__17_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // arguments: 0
  // within_exit_function: 1
  // inputs_count: 2
  // idx: 3
  frame->slots[2] /* inputs_count */ = create_future();
  frame->slots[3] /* idx */ = create_cell();
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 2) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[1] /* within_exit_function */ = arguments->slots[1];
    case 1:;
  }
  switch(argument_count) {
    case 1: frame->slots[1] /* within_exit_function */ = get__false();
  }
  // 103: $inputs_count count_arguments(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  result_count = 1;
  myself = var._count_arguments;
  func = myself->type;
  frame->cont = cont__17_2;
}
static void cont__17_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* inputs_count */, arguments->slots[0]);
  // 105: ... :
  // 106:   if inputs_count.is_defined:
  // 107:     write "  argument_count += @(inputs_count);@nl;"
  frame->slots[4] /* temp__1 */ = create_closure(entry__17_3, 0);
  // 108: :
  // 109:   write "
  // 110:     @
  // 111:       argument_count = @(default_value(inputs_count 0));
  // 112:       arguments = node_p;
  frame->slots[5] /* temp__2 */ = create_closure(entry__17_9, 0);
  // 104: if
  // 105:   within_exit_function:
  // 106:     if inputs_count.is_defined:
  // 107:       write "  argument_count += @(inputs_count);@nl;"
  // 108:   :
  // 109:     write "
  // 110:       @
  // 111:         argument_count = @(default_value(inputs_count 0));
  // 112:         arguments = node_p;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* within_exit_function */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__17_14;
}
static void entry__17_5(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 107: ... "  argument_count += @(inputs_count);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__17_6;
  arguments->slots[1] = frame->slots[0] /* inputs_count */;
  arguments->slots[2] = string__17_7;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__17_8;
}
static void cont__17_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 107: write "  argument_count += @(inputs_count);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__17_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 106: ... inputs_count.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* inputs_count */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__17_4;
}
static void cont__17_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 106: ... :
  // 107:   write "  argument_count += @(inputs_count);@nl;"
  frame->slots[2] /* temp__2 */ = create_closure(entry__17_5, 0);
  // 106: if inputs_count.is_defined:
  // 107:   write "  argument_count += @(inputs_count);@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__17_9(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 111: ... default_value(inputs_count 0)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* inputs_count */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__default_value();
  func = myself->type;
  frame->cont = cont__17_10;
}
static void cont__17_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 109: ... "
  // 110:   @
  // 111:     argument_count = @(default_value(inputs_count 0));
  // 112:     arguments = node_p;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__17_11;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__17_12;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__17_13;
}
static void cont__17_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 109: write "
  // 110:   @
  // 111:     argument_count = @(default_value(inputs_count 0));
  // 112:     arguments = node_p;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__17_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 113: $$idx 0
  ((CELL *)frame->slots[3])->contents /* idx */ = number__0;
  // 114: ... : (argument)
  // 115:   $src argument.to_c
  // 116:   cond
  // 117:     -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  // 118:     -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  // 119:     :
  // 120:       $slot_idx if(inputs_count.is_defined (-> idx) -> "argument_count++")
  // 121:       write "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  // 122:       inc &idx
  frame->slots[4] /* temp__1 */ = create_closure(entry__17_15, 1);
  // 114: for_each arguments: (argument)
  // 115:   $src argument.to_c
  // 116:   cond
  // 117:     -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  // 118:     -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  // 119:     :
  // 120:       $slot_idx if(inputs_count.is_defined (-> idx) -> "argument_count++")
  // 121:       write "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  // 122:       inc &idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__18_1(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // functor: 0
  // cont: 1
  // insertion_line: 2
  // insertion: 3
  frame->slots[3] /* insertion */ = create_future();
  if (argument_count < 2) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[2] /* insertion_line */ = arguments->slots[2];
    case 2:;
  }
  switch(argument_count) {
    case 2: frame->slots[2] /* insertion_line */ = undefined;
  }
  // 125: ... : (indent)
  // 126:   if
  // 127:     insertion_line.is_defined
  // 128:     -> indented(indent string('@nl;' insertion_line))
  // 129:     -> ""
  frame->slots[4] /* temp__1 */ = create_closure(entry__18_2, 1);
  // 125: $insertion: (indent)
  // 126:   if
  // 127:     insertion_line.is_defined
  // 128:     -> indented(indent string('@nl;' insertion_line))
  // 129:     -> ""
  initialize_future(frame->slots[3] /* insertion */, frame->slots[4] /* temp__1 */);
  // 131: ... functor.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__18_8;
}
static void entry__18_4(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // indent: 0
  // insertion_line: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[1]; /* insertion_line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 128: ... string('@nl;' insertion_line)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* insertion_line */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__18_5;
}
static void cont__18_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 128: ... indented(indent string('@nl;' insertion_line))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__18_6;
}
static void cont__18_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 128: -> indented(indent string('@nl;' insertion_line))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__18_7(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 129: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__18_2(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // indent: 0
  // insertion_line: 1
  frame->slots[1] = myself->closure.frame->slots[2]; /* insertion_line */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 127: insertion_line.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* insertion_line */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__18_3;
}
static void cont__18_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 128: -> indented(indent string('@nl;' insertion_line))
  frame->slots[3] /* temp__2 */ = create_closure(entry__18_4, 0);
  // 126: if
  // 127:   insertion_line.is_defined
  // 128:   -> indented(indent string('@nl;' insertion_line))
  // 129:   -> ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = func__18_7;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__18_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 131: if functor.is_an_identifier:
  // 132:   #$id privileged_polymorphic_functions(mangled_name)
  // 133:   
  // 134:   # ATTENTION: do not optimize to get better error messages
  // 135:   
  // 136:   #if id.is_defined && id < 8:
  // 137:     write "
  // 138:       @
  // 139:         myself = (NODE @
  // 140:       *)arguments->slots[0]->attributes->nodes[0]->nodes[@(id)]; // @
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = func__18_9;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__18_10;
}
static void entry__18_9(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__18_10(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 159: ... functor.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__18_11;
}
static void cont__18_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 160: ... insertion(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[3] /* insertion */;
  func = myself->type;
  frame->cont = cont__18_12;
}
static void cont__18_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 157: ... "
  // 158:   @
  // 159:     myself = @(functor.to_c);
  // 160:     func = myself->type;@(insertion(2))
  // 161:     frame->cont = @(cont);
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__18_13;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__18_14;
  arguments->slots[3] = frame->slots[6] /* temp__3 */;
  arguments->slots[4] = string__18_15;
  arguments->slots[5] = frame->slots[1] /* cont */;
  arguments->slots[6] = string__18_16;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__18_17;
}
static void cont__18_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 157: write "
  // 158:   @
  // 159:     myself = @(functor.to_c);
  // 160:     func = myself->type;@(insertion(2))
  // 161:     frame->cont = @(cont);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_1(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // prefix: 0
  // destination: 1
  // src: 2
  // return: 3
  // dest: 4
  frame->slots[3] /* return */ = create_continuation();
  frame->slots[4] /* dest */ = create_future();
  if (argument_count < 2) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  frame->slots[2] /* src */ = arguments->slots[argument_count-1];
  frame->slots[1] /* destination */ = arguments->slots[argument_count-2];
  switch(argument_count) {
    default: frame->slots[0] /* prefix */ = arguments->slots[0];
    case 2:;
  }
  switch(argument_count) {
    case 2: frame->slots[0] /* prefix */ = string__19_2;
  }
  // 170: ... destination.is_a_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  result_count = 1;
  myself = get__is_a_definition();
  func = myself->type;
  frame->cont = cont__19_3;
}
static void cont__19_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 170: ... :
  // 171:   case
  // 172:     variable_kind_of(destination)
  // 173:     STATIC_SINGLE:
  // 174:       if
  // 175:         destination.is_an_initialization:
  // 176:           return
  // 177:             "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 178:         :
  // 179:           return "@(prefix)@(destination.to_c) = @(src);@nl;"
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__19_4, 0);
  // 170: if destination.is_a_definition:
  // 171:   case
  // 172:     variable_kind_of(destination)
  // 173:     STATIC_SINGLE:
  // 174:       if
  // 175:         destination.is_an_initialization:
  // 176:           return
  // 177:             "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 178:         :
  // 179:           return "@(prefix)@(destination.to_c) = @(src);@nl;"
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__19_48;
}
static void entry__19_38(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // return: 0
  // prefix: 1
  // mangled_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 192: ... "@(prefix)set__@(mangled_name)(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__19_39;
  arguments->slots[2] = frame->slots[2] /* mangled_name */;
  arguments->slots[3] = string__19_40;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__19_41;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_42;
}
static void cont__19_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 192: return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_43(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // return: 0
  // prefix: 1
  // mangled_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 194: ... "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__19_44;
  arguments->slots[2] = frame->slots[2] /* mangled_name */;
  arguments->slots[3] = string__19_45;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__19_46;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_47;
}
static void cont__19_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 194: return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_21(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // return: 0
  // prefix: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 184: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__19_22;
}
static void cont__19_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 184: "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__19_23;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = string__19_24;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__19_25;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_26;
}
static void cont__19_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 183: return
  // 184:   "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_27(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  // mangled_name: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  frame->slots[4] /* mangled_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 186: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__19_28;
}
static void cont__19_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 186: $mangled_name mangled_name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__19_29;
}
static void cont__19_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* mangled_name */, arguments->slots[0]);
  // 187: ... "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* prefix */;
  arguments->slots[1] = string__19_30;
  arguments->slots[2] = frame->slots[4] /* mangled_name */;
  arguments->slots[3] = string__19_31;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__19_32;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_33;
}
static void cont__19_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 187: return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_8(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // return: 0
  // prefix: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 177: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__19_9;
}
static void cont__19_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 177: "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__19_10;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = string__19_11;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__19_12;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_13;
}
static void cont__19_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 176: return
  // 177:   "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_14(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // return: 0
  // prefix: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 179: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__19_15;
}
static void cont__19_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 179: ... "@(prefix)@(destination.to_c) = @(src);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__19_16;
  arguments->slots[3] = frame->slots[3] /* src */;
  arguments->slots[4] = string__19_17;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_18;
}
static void cont__19_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 179: return "@(prefix)@(destination.to_c) = @(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_6(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 175: destination.is_an_initialization
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__is_an_initialization();
  func = myself->type;
  frame->cont = cont__19_7;
}
static void cont__19_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 175: ... :
  // 176:   return
  // 177:     "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__19_8, 0);
  // 178: :
  // 179:   return "@(prefix)@(destination.to_c) = @(src);@nl;"
  frame->slots[6] /* temp__3 */ = create_closure(entry__19_14, 0);
  // 174: if
  // 175:   destination.is_an_initialization:
  // 176:     return
  // 177:       "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 178:   :
  // 179:     return "@(prefix)@(destination.to_c) = @(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_19(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 182: destination.is_an_initialization
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__is_an_initialization();
  func = myself->type;
  frame->cont = cont__19_20;
}
static void cont__19_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 182: ... :
  // 183:   return
  // 184:     "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__19_21, 0);
  // 185: :
  // 186:   $mangled_name mangled_name_of(identifier_of(destination))
  // 187:   return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[6] /* temp__3 */ = create_closure(entry__19_27, 0);
  // 181: if
  // 182:   destination.is_an_initialization:
  // 183:     return
  // 184:       "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 185:   :
  // 186:     $mangled_name mangled_name_of(identifier_of(destination))
  // 187:     return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_34(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  // mangled_name: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  frame->slots[4] /* mangled_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 189: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__19_35;
}
static void cont__19_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 189: $mangled_name mangled_name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__19_36;
}
static void cont__19_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* mangled_name */, arguments->slots[0]);
  // 191: destination.is_an_initialization
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__is_an_initialization();
  func = myself->type;
  frame->cont = cont__19_37;
}
static void cont__19_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 191: ... :
  // 192:   return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  frame->slots[6] /* temp__2 */ = create_closure(entry__19_38, 0);
  // 193: :
  // 194:   return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[7] /* temp__3 */ = create_closure(entry__19_43, 0);
  // 190: if
  // 191:   destination.is_an_initialization:
  // 192:     return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  // 193:   :
  // 194:     return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__19_4(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* return */
  frame->slots[2] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[2]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 172: variable_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__19_5;
}
static void cont__19_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 173: ... :
  // 174:   if
  // 175:     destination.is_an_initialization:
  // 176:       return
  // 177:         "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 178:     :
  // 179:       return "@(prefix)@(destination.to_c) = @(src);@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__19_6, 0);
  // 180: ... :
  // 181:   if
  // 182:     destination.is_an_initialization:
  // 183:       return
  // 184:         "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 185:     :
  // 186:       $mangled_name mangled_name_of(identifier_of(destination))
  // 187:       return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[6] /* temp__3 */ = create_closure(entry__19_19, 0);
  // 188: ... :
  // 189:   $mangled_name mangled_name_of(identifier_of(destination))
  // 190:   if
  // 191:     destination.is_an_initialization:
  // 192:       return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  // 193:     :
  // 194:       return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[7] /* temp__4 */ = create_closure(entry__19_34, 0);
  // 171: case
  // 172:   variable_kind_of(destination)
  // 173:   STATIC_SINGLE:
  // 174:     if
  // 175:       destination.is_an_initialization:
  // 176:         return
  // 177:           "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 178:       :
  // 179:         return "@(prefix)@(destination.to_c) = @(src);@nl;"
  // 180:   DYNAMIC_SINGLE:
  // ...
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = get__DYNAMIC_SINGLE();
  arguments->slots[4] = frame->slots[6] /* temp__3 */;
  arguments->slots[5] = get__DYNAMIC_MULTI();
  arguments->slots[6] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__19_48(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 195: $dest destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__19_49;
}
static void cont__19_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* dest */, arguments->slots[0]);
  // 197: dest .has_prefix. "get_"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* dest */;
  arguments->slots[1] = string__19_50;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__19_51;
}
static void cont__19_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 198: -> "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  frame->slots[6] /* temp__2 */ = create_closure(entry__19_52, 0);
  // 199: -> "@(prefix)@(dest) = @(src);@nl;"
  frame->slots[7] /* temp__3 */ = create_closure(entry__19_59, 0);
  // 196: if
  // 197:   dest .has_prefix. "get_"
  // 198:   -> "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  // 199:   -> "@(prefix)@(dest) = @(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__19_63;
}
static void entry__19_52(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // prefix: 0
  // dest: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[4]; /* dest */
  frame->slots[2] = myself->closure.frame->slots[2]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 198: ... 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__3;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__19_53;
}
static void cont__19_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 198: ... range(dest 5 -3)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* dest */;
  arguments->slots[1] = number__5;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__19_54;
}
static void cont__19_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 198: ... "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  arguments->slots[1] = string__19_55;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  arguments->slots[3] = string__19_56;
  arguments->slots[4] = frame->slots[2] /* src */;
  arguments->slots[5] = string__19_57;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_58;
}
static void cont__19_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 198: -> "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__19_59(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // prefix: 0
  // dest: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[4]; /* dest */
  frame->slots[2] = myself->closure.frame->slots[2]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 199: ... "@(prefix)@(dest) = @(src);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  arguments->slots[1] = frame->slots[1] /* dest */;
  arguments->slots[2] = string__19_60;
  arguments->slots[3] = frame->slots[2] /* src */;
  arguments->slots[4] = string__19_61;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__19_62;
}
static void cont__19_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 199: -> "@(prefix)@(dest) = @(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__19_63(void) {
  myself = frame->slots[3] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__20_8(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // prefix: 1
  // src: 2
  // name: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[3]; /* src */
  frame->slots[3] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 210: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__20_9;
}
static void cont__20_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 210: $name name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__20_10;
}
static void cont__20_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* name */, arguments->slots[0]);
  // 212: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__20_11;
}
static void cont__20_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 211: ... "
  // 212:   @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 213:   create_cell_with_contents(@(src));@nl;@
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__20_12;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = string__20_13;
  arguments->slots[4] = frame->slots[3] /* name */;
  arguments->slots[5] = string__20_14;
  arguments->slots[6] = frame->slots[2] /* src */;
  arguments->slots[7] = string__20_15;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__20_16;
}
static void cont__20_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 211: write "
  // 212:   @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 213:   create_cell_with_contents(@(src));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__20_17(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // prefix: 0
  // destination: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[2] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 215: ... assignment_to_c(prefix destination src)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  arguments->slots[1] = frame->slots[1] /* destination */;
  arguments->slots[2] = frame->slots[2] /* src */;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__20_18;
}
static void cont__20_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 215: write assignment_to_c(prefix destination src)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__20_1(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // prefix: 0
  // kind: 1
  // destination: 2
  // src: 3
  if (argument_count < 3) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 4) {
    too_many_arguments_error();
    return;
  }
  frame->slots[3] /* src */ = arguments->slots[argument_count-1];
  frame->slots[2] /* destination */ = arguments->slots[argument_count-2];
  frame->slots[1] /* kind */ = arguments->slots[argument_count-3];
  switch(argument_count) {
    default: frame->slots[0] /* prefix */ = arguments->slots[0];
    case 3:;
  }
  switch(argument_count) {
    case 3: frame->slots[0] /* prefix */ = string__20_2;
  }
  // 209: destination.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__20_3;
}
static void cont__20_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 209: ... kind == "arguments"
  frame->slots[6] /* temp__3 */ = create_closure(entry__20_4, 0);
  // 209: destination.is_a_multi_assign_definition && kind == "arguments"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__20_7;
}
static void entry__20_4(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 209: ... kind == "arguments"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = string__20_5;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__20_6;
}
static void cont__20_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 209: ... kind == "arguments"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__20_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 209: ... :
  // 210:   $name name_of(identifier_of(destination))
  // 211:   write "
  // 212:     @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 213:     create_cell_with_contents(@(src));@nl;@
  frame->slots[7] /* temp__4 */ = create_closure(entry__20_8, 0);
  // 214: :
  // 215:   write assignment_to_c(prefix destination src)
  frame->slots[8] /* temp__5 */ = create_closure(entry__20_17, 0);
  // 208: if
  // 209:   destination.is_a_multi_assign_definition && kind == "arguments":
  // 210:     $name name_of(identifier_of(destination))
  // 211:     write "
  // 212:       @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 213:       create_cell_with_contents(@(src));@nl;@
  // 214:   :
  // 215:     write assignment_to_c(prefix destination src)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_147(void) {
  allocate_initialized_frame_gc(5, 11);
  // slot allocations:
  // idx: 0
  // outputs: 1
  // kind: 2
  // indices: 3
  // right_count: 4
  // output: 5
  // default_value: 6
  // cont_idx: 7
  frame->slots[1] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[5]; /* kind */
  frame->slots[3] = myself->closure.frame->slots[3]; /* indices */
  frame->slots[4] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[5] /* output */ = create_future();
  frame->slots[6] /* default_value */ = create_future();
  frame->slots[7] /* cont_idx */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 328: $output outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__21_148;
}
static void cont__21_148(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* output */, arguments->slots[0]);
  // 329: $default_value default_value_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* output */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__21_149;
}
static void cont__21_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* default_value */, arguments->slots[0]);
  // 331: default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__21_150;
}
static void cont__21_150(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 331: ... :
  // 332:   if
  // 333:     default_value.is_a_function_call:
  // 334:       for_each statements_of(output): (statement)
  // 335:         generate_statement statement
  // 336:     :
  // 337:       assign_argument_or_result kind output default_value.to_c
  frame->slots[9] /* temp__2 */ = create_closure(entry__21_151, 0);
  // 338: :
  // 339:   assign_argument_or_result kind output "undefined"
  frame->slots[10] /* temp__3 */ = create_closure(entry__21_158, 0);
  // 330: if
  // 331:   default_value.is_defined:
  // 332:     if
  // 333:       default_value.is_a_function_call:
  // 334:         for_each statements_of(output): (statement)
  // 335:           generate_statement statement
  // 336:       :
  // 337:         assign_argument_or_result kind output default_value.to_c
  // 338:   :
  // 339:     assign_argument_or_result kind output "undefined"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_160;
}
static void entry__21_155(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // statement: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 335: generate_statement statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = frame->caller_result_count;
  myself = get__generate_statement();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_153(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // output: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* output */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 334: ... statements_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__21_154;
}
static void cont__21_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 334: for_each statements_of(output): (statement)
  // 335:   generate_statement statement
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__21_155;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_156(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // kind: 0
  // output: 1
  // default_value: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output */
  frame->slots[2] = myself->closure.frame->slots[0]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 337: ... default_value.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* default_value */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__21_157;
}
static void cont__21_157(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 337: assign_argument_or_result kind output default_value.to_c
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[1] /* output */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_151(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // default_value: 0
  // output: 1
  // kind: 2
  frame->slots[0] = myself->closure.frame->slots[6]; /* default_value */
  frame->slots[1] = myself->closure.frame->slots[5]; /* output */
  frame->slots[2] = myself->closure.frame->slots[2]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 333: default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__21_152;
}
static void cont__21_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 333: ... :
  // 334:   for_each statements_of(output): (statement)
  // 335:     generate_statement statement
  frame->slots[4] /* temp__2 */ = create_closure(entry__21_153, 0);
  // 336: :
  // 337:   assign_argument_or_result kind output default_value.to_c
  frame->slots[5] /* temp__3 */ = create_closure(entry__21_156, 0);
  // 332: if
  // 333:   default_value.is_a_function_call:
  // 334:     for_each statements_of(output): (statement)
  // 335:       generate_statement statement
  // 336:   :
  // 337:     assign_argument_or_result kind output default_value.to_c
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_158(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // kind: 0
  // output: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[5]; /* output */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 339: assign_argument_or_result kind output "undefined"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[1] /* output */;
  arguments->slots[2] = string__21_159;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_160(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 340: ... idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[4])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_161;
}
static void cont__21_161(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 340: $cont_idx indices(idx+right_count)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* indices */;
  func = myself->type;
  frame->cont = cont__21_162;
}
static void cont__21_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* cont_idx */, arguments->slots[0]);
  // 341: ... "
  // 342:     func = cont@(suffix)_@(cont_idx);
  // 343:   }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__21_163;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__21_164;
  arguments->slots[3] = frame->slots[7] /* cont_idx */;
  arguments->slots[4] = string__21_165;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_166;
}
static void cont__21_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 341: write "
  // 342:     func = cont@(suffix)_@(cont_idx);
  // 343:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__21_167;
}
static void cont__21_167(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 344: ... "cont@(suffix)_@(cont_idx)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__21_168;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__21_169;
  arguments->slots[3] = frame->slots[7] /* cont_idx */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_170;
}
static void cont__21_170(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 344: next_continuation "cont@(suffix)_@(cont_idx)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__next_continuation();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_119(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // total_count: 0
  // right_count: 1
  // fixed_count: 2
  // indices: 3
  // outputs: 4
  // kind: 5
  frame->slots[0] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[3] = myself->closure.frame->slots[6]; /* indices */
  frame->slots[4] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[5] = myself->closure.frame->slots[3]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 313: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_120;
}
static void cont__21_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 313: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_121;
}
static void cont__21_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 313: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_122;
}
static void cont__21_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 313: ... : (idx)
  // 314:   $n idx+right_count
  // 315:   $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 316:   inc &index
  // 317:   !indices(n) index
  // 318:   write "
  // 319:     @
  // 320:         @(cnt):
  // 321:           func = cont@(suffix)_@(index);
  // 322:           return;
  frame->slots[9] /* temp__4 */ = create_closure(entry__21_123, 1);
  // 313: from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 314:   $n idx+right_count
  // 315:   $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 316:   inc &index
  // 317:   !indices(n) index
  // 318:   write "
  // 319:     @
  // 320:         @(cnt):
  // 321:           func = cont@(suffix)_@(index);
  // 322:           return;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = 0;
  myself = get__from_down_to();
  func = myself->type;
  frame->cont = cont__21_139;
}
static void entry__21_123(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // idx: 0
  // right_count: 1
  // total_count: 2
  // indices: 3
  // n: 4
  // cnt: 5
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[3]; /* indices */
  frame->slots[4] /* n */ = create_future();
  frame->slots[5] /* cnt */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 314: $n idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_124;
}
static void cont__21_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* n */, arguments->slots[0]);
  // 315: ... n == total_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* n */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_count */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__21_125;
}
static void cont__21_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 315: ... -> "case @(n)"
  frame->slots[7] /* temp__2 */ = create_closure(entry__21_126, 0);
  // 315: $cnt if(n == total_count (-> "default") -> "case @(n)")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = func__21_129;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_131;
}
static void entry__21_126(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // n: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 315: ... "case @(n)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__21_127;
  arguments->slots[1] = frame->slots[0] /* n */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_128;
}
static void cont__21_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 315: ... -> "case @(n)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_129(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 315: ... -> "default"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__21_130;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* cnt */, arguments->slots[0]);
  // 316: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__21_132;
}
static void cont__21_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 317: !indices(n) index
  frame->slots[6] /* temp__1 */ = get__index();
  // 317: !indices(n)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* n */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* indices */;
  func = myself->type;
  frame->cont = cont__21_133;
}
static void cont__21_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* indices */ = arguments->slots[0];
  // 318: ... "
  // 319:   @
  // 320:       @(cnt):
  // 321:         func = cont@(suffix)_@(index);
  // 322:         return;
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__21_134;
  arguments->slots[1] = frame->slots[5] /* cnt */;
  arguments->slots[2] = string__21_135;
  arguments->slots[3] = get__suffix();
  arguments->slots[4] = string__21_136;
  arguments->slots[5] = get__index();
  arguments->slots[6] = string__21_137;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_138;
}
static void cont__21_138(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 318: write "
  // 319:   @
  // 320:       @(cnt):
  // 321:         func = cont@(suffix)_@(index);
  // 322:         return;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_139(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 323: ... "
  // 324:   @
  // 325:       case @(fixed_count):;
  // 326:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__21_140;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[2] = string__21_141;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_142;
}
static void cont__21_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 323: write "
  // 324:   @
  // 325:       case @(fixed_count):;
  // 326:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__21_143;
}
static void cont__21_143(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 327: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_144;
}
static void cont__21_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 327: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_145;
}
static void cont__21_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 327: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_146;
}
static void cont__21_146(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 327: ... : (idx)
  // 328:   $output outputs(idx)
  // 329:   $default_value default_value_of(output)
  // 330:   if
  // 331:     default_value.is_defined:
  // 332:       if
  // 333:         default_value.is_a_function_call:
  // 334:           for_each statements_of(output): (statement)
  // 335:             generate_statement statement
  // 336:         :
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__21_147, 1);
  // 327: from_to fixed_count-right_count+1 total_count-right_count: (idx)
  // 328:   $output outputs(idx)
  // 329:   $default_value default_value_of(output)
  // 330:   if
  // 331:     default_value.is_defined:
  // 332:       if
  // 333:         default_value.is_a_function_call:
  // 334:           for_each statements_of(output): (statement)
  // 335:             generate_statement statement
  // 336:         :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__from_to();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_171(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // fixed_count: 0
  // right_count: 1
  // total_count: 2
  // outputs: 3
  // kind: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[4] = myself->closure.frame->slots[3]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 346: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_172;
}
static void cont__21_172(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 346: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_173;
}
static void cont__21_173(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 346: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_174;
}
static void cont__21_174(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 346: ... : (idx)
  // 347:   $output outputs(idx)
  // 348:   $default_value default_value_of(output)
  // 349:   
  // 350:   $value
  // 351:     if(default_value.is_defined (-> default_value.to_c) -> "undefined")
  // 352:   
  // 353:   assign_argument_or_result
  // 354:     "    case @(idx+right_count-1): "
  // 355:     kind
  // ...
  frame->slots[8] /* temp__4 */ = create_closure(entry__21_175, 1);
  // 346: from_to fixed_count-right_count+1 total_count-right_count: (idx)
  // 347:   $output outputs(idx)
  // 348:   $default_value default_value_of(output)
  // 349:   
  // 350:   $value
  // 351:     if(default_value.is_defined (-> default_value.to_c) -> "undefined")
  // 352:   
  // 353:   assign_argument_or_result
  // 354:     "    case @(idx+right_count-1): "
  // 355:     kind
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  arguments->slots[2] = frame->slots[8] /* temp__4 */;
  result_count = 0;
  myself = get__from_to();
  func = myself->type;
  frame->cont = cont__21_189;
}
static void entry__21_175(void) {
  allocate_initialized_frame_gc(4, 10);
  // slot allocations:
  // idx: 0
  // outputs: 1
  // right_count: 2
  // kind: 3
  // output: 4
  // default_value: 5
  // value: 6
  frame->slots[1] = myself->closure.frame->slots[3]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[3] = myself->closure.frame->slots[4]; /* kind */
  frame->slots[4] /* output */ = create_future();
  frame->slots[5] /* default_value */ = create_future();
  frame->slots[6] /* value */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 347: $output outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__21_176;
}
static void cont__21_176(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* output */, arguments->slots[0]);
  // 348: $default_value default_value_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* output */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__21_177;
}
static void cont__21_177(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* default_value */, arguments->slots[0]);
  // 351: ... default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__21_178;
}
static void cont__21_178(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 351: ... -> default_value.to_c
  frame->slots[8] /* temp__2 */ = create_closure(entry__21_179, 0);
  // 350: $value
  // 351:   if(default_value.is_defined (-> default_value.to_c) -> "undefined")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = func__21_181;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_183;
}
static void entry__21_179(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // default_value: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 351: ... default_value.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__21_180;
}
static void cont__21_180(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 351: ... -> default_value.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_181(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 351: ... -> "undefined"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__21_182;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_183(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* value */, arguments->slots[0]);
  // 354: ... idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_184;
}
static void cont__21_184(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 354: ... idx+right_count-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_185;
}
static void cont__21_185(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 354: "    case @(idx+right_count-1): "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__21_186;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = string__21_187;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_188;
}
static void cont__21_188(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 353: assign_argument_or_result
  // 354:   "    case @(idx+right_count-1): "
  // 355:   kind
  // 356:   output
  // 357:   value
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* kind */;
  arguments->slots[2] = frame->slots[4] /* output */;
  arguments->slots[3] = frame->slots[6] /* value */;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_189(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 358: write "
  // 359:   @
  // 360:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__21_190;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_91(void) {
  allocate_initialized_frame_gc(6, 11);
  // slot allocations:
  // total_count: 0
  // right_count: 1
  // fixed_count: 2
  // kind: 3
  // outputs: 4
  // has_complex_default_values: 5
  // indices: 6
  frame->slots[0] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[4]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[3] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[4] = myself->closure.frame->slots[1]; /* outputs */
  frame->slots[5] = myself->closure.frame->slots[6]; /* has_complex_default_values */
  frame->slots[6] /* indices */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 294: write "
  // 295:   @
  // 296:     switch(argument_count) {
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__21_92;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__21_93;
}
static void cont__21_93(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 297: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_94;
}
static void cont__21_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 297: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_95;
}
static void cont__21_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 297: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_96;
}
static void cont__21_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 297: ... : (idx)
  // 298:   $n idx+right_count
  // 299:   $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 300:   assign_argument_or_result
  // 301:     "    @(cnt): "
  // 302:     kind
  // 303:     outputs(idx)
  // 304:     "arguments->slots[@(idx-1)]"
  frame->slots[10] /* temp__4 */ = create_closure(entry__21_97, 1);
  // 297: from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 298:   $n idx+right_count
  // 299:   $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 300:   assign_argument_or_result
  // 301:     "    @(cnt): "
  // 302:     kind
  // 303:     outputs(idx)
  // 304:     "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__from_down_to();
  func = myself->type;
  frame->cont = cont__21_114;
}
static void entry__21_97(void) {
  allocate_initialized_frame_gc(5, 11);
  // slot allocations:
  // idx: 0
  // right_count: 1
  // total_count: 2
  // kind: 3
  // outputs: 4
  // n: 5
  // cnt: 6
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[3]; /* kind */
  frame->slots[4] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[5] /* n */ = create_future();
  frame->slots[6] /* cnt */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 298: $n idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_98;
}
static void cont__21_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* n */, arguments->slots[0]);
  // 299: ... n == total_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* n */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_count */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__21_99;
}
static void cont__21_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 299: ... -> "case @(n)"
  frame->slots[8] /* temp__2 */ = create_closure(entry__21_100, 0);
  // 299: $cnt if(n == total_count (-> "default") -> "case @(n)")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__21_103;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_105;
}
static void entry__21_100(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // n: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 299: ... "case @(n)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__21_101;
  arguments->slots[1] = frame->slots[0] /* n */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_102;
}
static void cont__21_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 299: ... -> "case @(n)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_103(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 299: ... -> "default"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__21_104;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* cnt */, arguments->slots[0]);
  // 301: "    @(cnt): "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__21_106;
  arguments->slots[1] = frame->slots[6] /* cnt */;
  arguments->slots[2] = string__21_107;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_108;
}
static void cont__21_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 303: outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[4] /* outputs */;
  func = myself->type;
  frame->cont = cont__21_109;
}
static void cont__21_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 304: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_110;
}
static void cont__21_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__4 */ = arguments->slots[0];
  // 304: "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__21_111;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = string__21_112;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_113;
}
static void cont__21_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 300: assign_argument_or_result
  // 301:   "    @(cnt): "
  // 302:   kind
  // 303:   outputs(idx)
  // 304:   "arguments->slots[@(idx-1)]"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* kind */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  arguments->slots[3] = frame->slots[9] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_114(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 305: ... "
  // 306:   @
  // 307:       case @(fixed_count):;
  // 308:     }
  // 309:     switch(argument_count) {
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__21_115;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[2] = string__21_116;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_117;
}
static void cont__21_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 305: write "
  // 306:   @
  // 307:       case @(fixed_count):;
  // 308:     }
  // 309:     switch(argument_count) {
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__21_118;
}
static void cont__21_118(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 310: $$indices empty_table
  ((CELL *)frame->slots[6])->contents /* indices */ = get__empty_table();
  // 312: ... :
  // 313:   from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 314:     $n idx+right_count
  // 315:     $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 316:     inc &index
  // 317:     !indices(n) index
  // 318:     write "
  // 319:       @
  // 320:           @(cnt):
  // 321:             func = cont@(suffix)_@(index);
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__21_119, 0);
  // 345: :
  // 346:   from_to fixed_count-right_count+1 total_count-right_count: (idx)
  // 347:     $output outputs(idx)
  // 348:     $default_value default_value_of(output)
  // 349:     
  // 350:     $value
  // 351:       if(default_value.is_defined (-> default_value.to_c) -> "undefined")
  // 352:     
  // 353:     assign_argument_or_result
  // 354:       "    case @(idx+right_count-1): "
  // ...
  frame->slots[8] /* temp__2 */ = create_closure(entry__21_171, 0);
  // 311: if
  // 312:   has_complex_default_values:
  // 313:     from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 314:       $n idx+right_count
  // 315:       $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 316:       inc &index
  // 317:       !indices(n) index
  // 318:       write "
  // 319:         @
  // 320:             @(cnt):
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* has_complex_default_values */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_1(void) {
  allocate_initialized_frame_gc(2, 11);
  // slot allocations:
  // kind: 0
  // outputs: 1
  // fixed_count: 2
  // total_count: 3
  // right_count: 4
  // unlimited: 5
  // has_complex_default_values: 6
  frame->slots[2] /* fixed_count */ = create_cell();
  frame->slots[3] /* total_count */ = create_cell();
  frame->slots[4] /* right_count */ = create_cell();
  frame->slots[5] /* unlimited */ = create_cell();
  frame->slots[6] /* has_complex_default_values */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 222: $$fixed_count 0
  ((CELL *)frame->slots[2])->contents /* fixed_count */ = number__0;
  // 223: $$total_count 0
  ((CELL *)frame->slots[3])->contents /* total_count */ = number__0;
  // 224: $$right_count 0
  ((CELL *)frame->slots[4])->contents /* right_count */ = number__0;
  // 225: $$unlimited false
  ((CELL *)frame->slots[5])->contents /* unlimited */ = get__false();
  // 226: $$has_complex_default_values false
  ((CELL *)frame->slots[6])->contents /* has_complex_default_values */ = get__false();
  // 227: ... : (output)
  // 228:   cond
  // 229:     -> output.is_an_optional_item:
  // 230:       inc &total_count
  // 231:       $default_value default_value_of(output)
  // 232:       if default_value.is_defined && default_value.is_a_function_call:
  // 233:         !has_complex_default_values true
  // 234:     -> output.is_an_expanded_item: !unlimited true
  // 235:     :
  // 236:       inc &fixed_count
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__21_2, 1);
  // 227: for_each outputs: (output)
  // 228:   cond
  // 229:     -> output.is_an_optional_item:
  // 230:       inc &total_count
  // 231:       $default_value default_value_of(output)
  // 232:       if default_value.is_defined && default_value.is_a_function_call:
  // 233:         !has_complex_default_values true
  // 234:     -> output.is_an_expanded_item: !unlimited true
  // 235:     :
  // 236:       inc &fixed_count
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* outputs */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__21_24;
}
static void entry__21_22(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // right_count: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* right_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 238: ... inc &right_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__21_23;
}
static void cont__21_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right_count */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_15(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // unlimited: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* unlimited */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 234: ... !unlimited true
  ((CELL *)frame->slots[0])->contents /* unlimited */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_12(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 233: !has_complex_default_values true
  ((CELL *)frame->slots[0])->contents /* has_complex_default_values */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_5(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // total_count: 0
  // output: 1
  // has_complex_default_values: 2
  // default_value: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[0]; /* output */
  frame->slots[2] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  frame->slots[3] /* default_value */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 230: inc &total_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__21_6;
}
static void cont__21_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_count */ = arguments->slots[0];
  // 231: $default_value default_value_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* output */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__21_7;
}
static void cont__21_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* default_value */, arguments->slots[0]);
  // 232: ... default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__21_8;
}
static void cont__21_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 232: ... default_value.is_a_function_call
  frame->slots[6] /* temp__3 */ = create_closure(entry__21_9, 0);
  // 232: ... default_value.is_defined && default_value.is_a_function_call
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__21_11;
}
static void entry__21_9(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // default_value: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 232: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__21_10;
}
static void cont__21_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 232: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 232: ... :
  // 233:   !has_complex_default_values true
  frame->slots[7] /* temp__4 */ = create_closure(entry__21_12, 0);
  // 232: if default_value.is_defined && default_value.is_a_function_call:
  // 233:   !has_complex_default_values true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_3(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // output: 0
  // total_count: 1
  // has_complex_default_values: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* output */
  frame->slots[1] = myself->closure.frame->slots[1]; /* total_count */
  frame->slots[2] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 229: ... output.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__21_4;
}
static void cont__21_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 229: ... :
  // 230:   inc &total_count
  // 231:   $default_value default_value_of(output)
  // 232:   if default_value.is_defined && default_value.is_a_function_call:
  // 233:     !has_complex_default_values true
  frame->slots[4] /* temp__2 */ = create_closure(entry__21_5, 0);
  // 229: -> output.is_an_optional_item:
  // 230:   inc &total_count
  // 231:   $default_value default_value_of(output)
  // 232:   if default_value.is_defined && default_value.is_a_function_call:
  // 233:     !has_complex_default_values true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_13(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // output: 0
  // unlimited: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* output */
  frame->slots[1] = myself->closure.frame->slots[3]; /* unlimited */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 234: ... output.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__21_14;
}
static void cont__21_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 234: ... : !unlimited true
  frame->slots[3] /* temp__2 */ = create_closure(entry__21_15, 0);
  // 234: -> output.is_an_expanded_item: !unlimited true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__21_16(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // fixed_count: 0
  // total_count: 1
  // unlimited: 2
  // right_count: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* total_count */
  frame->slots[2] = myself->closure.frame->slots[3]; /* unlimited */
  frame->slots[3] = myself->closure.frame->slots[5]; /* right_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 236: inc &fixed_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__21_17;
}
static void cont__21_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* fixed_count */ = arguments->slots[0];
  // 237: inc &total_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* total_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__21_18;
}
static void cont__21_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* total_count */ = arguments->slots[0];
  // 238: ... total_count > fixed_count
  frame->slots[5] /* temp__2 */ = create_closure(entry__21_19, 0);
  // 238: ... unlimited || total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__21_21;
}
static void entry__21_19(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // total_count: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* total_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 238: ... total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* total_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__21_20;
}
static void cont__21_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 238: ... total_count > fixed_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 238: ... : inc &right_count
  frame->slots[6] /* temp__3 */ = create_closure(entry__21_22, 0);
  // 238: if unlimited || total_count > fixed_count: inc &right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_2(void) {
  allocate_initialized_frame_gc(6, 9);
  // slot allocations:
  // output: 0
  // total_count: 1
  // has_complex_default_values: 2
  // unlimited: 3
  // fixed_count: 4
  // right_count: 5
  frame->slots[1] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[2] = myself->closure.frame->slots[6]; /* has_complex_default_values */
  frame->slots[3] = myself->closure.frame->slots[5]; /* unlimited */
  frame->slots[4] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[5] = myself->closure.frame->slots[4]; /* right_count */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 229: -> output.is_an_optional_item:
  // 230:   inc &total_count
  // 231:   $default_value default_value_of(output)
  // 232:   if default_value.is_defined && default_value.is_a_function_call:
  // 233:     !has_complex_default_values true
  frame->slots[6] /* temp__1 */ = create_closure(entry__21_3, 0);
  // 234: -> output.is_an_expanded_item: !unlimited true
  frame->slots[7] /* temp__2 */ = create_closure(entry__21_13, 0);
  // 235: :
  // 236:   inc &fixed_count
  // 237:   inc &total_count
  // 238:   if unlimited || total_count > fixed_count: inc &right_count
  frame->slots[8] /* temp__3 */ = create_closure(entry__21_16, 0);
  // 228: cond
  // 229:   -> output.is_an_optional_item:
  // 230:     inc &total_count
  // 231:     $default_value default_value_of(output)
  // 232:     if default_value.is_defined && default_value.is_a_function_call:
  // 233:       !has_complex_default_values true
  // 234:   -> output.is_an_expanded_item: !unlimited true
  // 235:   :
  // 236:     inc &fixed_count
  // 237:     inc &total_count
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_24(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 240: ... total_count > fixed_count
  frame->slots[8] /* temp__2 */ = create_closure(entry__21_25, 0);
  // 240: unlimited || total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__21_27;
}
static void entry__21_25(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // total_count: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[3]; /* total_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 240: ... total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* total_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__21_26;
}
static void cont__21_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 240: ... total_count > fixed_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 240: ... :
  // 241:   if fixed_count > 0:
  // 242:     write "
  // 243:       @
  // 244:         if (argument_count < @(fixed_count)) {
  // 245:           too_few_@(kind)_error();
  // 246:           return;
  // 247:         }
  // 248:   unless unlimited:
  // 249:     write "
  // ...
  frame->slots[9] /* temp__3 */ = create_closure(entry__21_28, 0);
  // 255: :
  // 256:   write "
  // 257:     @
  // 258:       if (argument_count != @(fixed_count)) {
  // 259:         invalid_@(kind)_error();
  // 260:         return;
  // 261:       }
  frame->slots[10] /* temp__4 */ = create_closure(entry__21_41, 0);
  // 239: if
  // 240:   unlimited || total_count > fixed_count:
  // 241:     if fixed_count > 0:
  // 242:       write "
  // 243:         @
  // 244:           if (argument_count < @(fixed_count)) {
  // 245:             too_few_@(kind)_error();
  // 246:             return;
  // 247:           }
  // 248:     unless unlimited:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_46;
}
static void entry__21_36(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // total_count: 0
  // kind: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 249: ... "
  // 250:   @
  // 251:     if (argument_count > @(total_count)) {
  // 252:       too_many_@(kind)_error();
  // 253:       return;
  // 254:     }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__21_37;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[2] = string__21_38;
  arguments->slots[3] = frame->slots[1] /* kind */;
  arguments->slots[4] = string__21_39;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_40;
}
static void cont__21_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 249: write "
  // 250:   @
  // 251:     if (argument_count > @(total_count)) {
  // 252:       too_many_@(kind)_error();
  // 253:       return;
  // 254:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_28(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // fixed_count: 0
  // kind: 1
  // unlimited: 2
  // total_count: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[2] = myself->closure.frame->slots[5]; /* unlimited */
  frame->slots[3] = myself->closure.frame->slots[3]; /* total_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 241: ... fixed_count > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__21_29;
}
static void cont__21_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 241: ... :
  // 242:   write "
  // 243:     @
  // 244:       if (argument_count < @(fixed_count)) {
  // 245:         too_few_@(kind)_error();
  // 246:         return;
  // 247:       }
  frame->slots[5] /* temp__2 */ = create_closure(entry__21_30, 0);
  // 241: if fixed_count > 0:
  // 242:   write "
  // 243:     @
  // 244:       if (argument_count < @(fixed_count)) {
  // 245:         too_few_@(kind)_error();
  // 246:         return;
  // 247:       }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_35;
}
static void entry__21_30(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // kind: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 242: ... "
  // 243:   @
  // 244:     if (argument_count < @(fixed_count)) {
  // 245:       too_few_@(kind)_error();
  // 246:       return;
  // 247:     }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__21_31;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[2] = string__21_32;
  arguments->slots[3] = frame->slots[1] /* kind */;
  arguments->slots[4] = string__21_33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_34;
}
static void cont__21_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 242: write "
  // 243:   @
  // 244:     if (argument_count < @(fixed_count)) {
  // 245:       too_few_@(kind)_error();
  // 246:       return;
  // 247:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_35(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 248: ... :
  // 249:   write "
  // 250:     @
  // 251:       if (argument_count > @(total_count)) {
  // 252:         too_many_@(kind)_error();
  // 253:         return;
  // 254:       }
  frame->slots[4] /* temp__1 */ = create_closure(entry__21_36, 0);
  // 248: unless unlimited:
  // 249:   write "
  // 250:     @
  // 251:       if (argument_count > @(total_count)) {
  // 252:         too_many_@(kind)_error();
  // 253:         return;
  // 254:       }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_41(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // kind: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[0]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 256: ... "
  // 257:   @
  // 258:     if (argument_count != @(fixed_count)) {
  // 259:       invalid_@(kind)_error();
  // 260:       return;
  // 261:     }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__21_42;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[2] = string__21_43;
  arguments->slots[3] = frame->slots[1] /* kind */;
  arguments->slots[4] = string__21_44;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_45;
}
static void cont__21_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 256: write "
  // 257:   @
  // 258:     if (argument_count != @(fixed_count)) {
  // 259:       invalid_@(kind)_error();
  // 260:       return;
  // 261:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_46(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 262: ... kind == "results"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = string__21_47;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__21_48;
}
static void cont__21_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 262: ... unlimited
  frame->slots[9] /* temp__3 */ = create_closure(entry__21_49, 0);
  // 262: ... kind == "results" && unlimited
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__21_50;
}
static void entry__21_49(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // unlimited: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* unlimited */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 262: ... unlimited
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* unlimited */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 262: if kind == "results" && unlimited: writeln "  allocate_arguments();"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__21_51;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_53;
}
static void entry__21_51(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 262: ... writeln "  allocate_arguments();"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__21_52;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_53(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 266: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[4])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_54;
}
static void cont__21_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 266: ... : (idx)
  // 267:   $output outputs(idx)
  // 268:   if
  // 269:     ||
  // 270:       kind == "results"
  // 271:       output.is_a_multi_assign_definition
  // 272:       unlimited
  // 273:       has_complex_default_values
  // 274:     :
  // 275:       assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  frame->slots[8] /* temp__2 */ = create_closure(entry__21_55, 1);
  // 266: from_to 1 fixed_count-right_count: (idx)
  // 267:   $output outputs(idx)
  // 268:   if
  // 269:     ||
  // 270:       kind == "results"
  // 271:       output.is_a_multi_assign_definition
  // 272:       unlimited
  // 273:       has_complex_default_values
  // 274:     :
  // 275:       assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__from_to();
  func = myself->type;
  frame->cont = cont__21_71;
}
static void entry__21_66(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // kind: 0
  // output: 1
  // idx: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[5]; /* output */
  frame->slots[2] = myself->closure.frame->slots[0]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 275: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_67;
}
static void cont__21_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 275: ... "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__21_68;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__21_69;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_70;
}
static void cont__21_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 275: assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[1] /* output */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__21_55(void) {
  allocate_initialized_frame_gc(5, 10);
  // slot allocations:
  // idx: 0
  // outputs: 1
  // kind: 2
  // unlimited: 3
  // has_complex_default_values: 4
  // output: 5
  frame->slots[1] = myself->closure.frame->slots[1]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[3] = myself->closure.frame->slots[5]; /* unlimited */
  frame->slots[4] = myself->closure.frame->slots[6]; /* has_complex_default_values */
  frame->slots[5] /* output */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 267: $output outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__21_56;
}
static void cont__21_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* output */, arguments->slots[0]);
  // 270: kind == "results"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* kind */;
  arguments->slots[1] = string__21_57;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__21_58;
}
static void cont__21_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  frame->slots[8] /* temp__3 */ = create_closure(entry__21_59, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__21_65;
}
static void entry__21_59(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // output: 0
  // unlimited: 1
  // has_complex_default_values: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* output */
  frame->slots[1] = myself->closure.frame->slots[3]; /* unlimited */
  frame->slots[2] = myself->closure.frame->slots[4]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 271: output.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__21_60;
}
static void cont__21_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__3 */ = create_closure(entry__21_61, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__21_64;
}
static void entry__21_61(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // unlimited: 0
  // has_complex_default_values: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* unlimited */
  frame->slots[1] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 273: has_complex_default_values
  frame->slots[3] /* temp__2 */ = create_closure(entry__21_62, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__21_63;
}
static void entry__21_62(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 273: has_complex_default_values
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* has_complex_default_values */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__21_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 274: :
  // 275:   assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  frame->slots[9] /* temp__4 */ = create_closure(entry__21_66, 0);
  // 268: if
  // 269:   ||
  // 270:     kind == "results"
  // 271:     output.is_a_multi_assign_definition
  // 272:     unlimited
  // 273:     has_complex_default_values
  // 274:   :
  // 275:     assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_71(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 279: ... : (idx)
  // 280:   assign_argument_or_result
  // 281:     kind
  // 282:     outputs(-idx)
  // 283:     "arguments->slots[argument_count@(-idx)]"
  frame->slots[7] /* temp__1 */ = create_closure(entry__21_72, 1);
  // 279: from_to 1 right_count: (idx)
  // 280:   assign_argument_or_result
  // 281:     kind
  // 282:     outputs(-idx)
  // 283:     "arguments->slots[argument_count@(-idx)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = ((CELL *)frame->slots[4])->contents /* right_count */;
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__from_to();
  func = myself->type;
  frame->cont = cont__21_79;
}
static void entry__21_72(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // idx: 0
  // kind: 1
  // outputs: 2
  frame->slots[1] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[2] = myself->closure.frame->slots[1]; /* outputs */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 282: ... idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__21_73;
}
static void cont__21_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 282: outputs(-idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[2] /* outputs */;
  func = myself->type;
  frame->cont = cont__21_74;
}
static void cont__21_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 283: ... idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__21_75;
}
static void cont__21_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 283: "arguments->slots[argument_count@(-idx)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__21_76;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = string__21_77;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_78;
}
static void cont__21_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 280: assign_argument_or_result
  // 281:   kind
  // 282:   outputs(-idx)
  // 283:   "arguments->slots[argument_count@(-idx)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* kind */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_79(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 287: ... :
  // 288:   assign_argument_or_result kind outputs(total_count-right_count+1) "
  // 289:     from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  frame->slots[7] /* temp__1 */ = create_closure(entry__21_80, 0);
  // 287: if unlimited:
  // 288:   assign_argument_or_result kind outputs(total_count-right_count+1) "
  // 289:     from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__21_89;
}
static void entry__21_80(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // kind: 0
  // outputs: 1
  // total_count: 2
  // right_count: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[1]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[4]; /* right_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 288: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_81;
}
static void cont__21_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 288: ... total_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__21_82;
}
static void cont__21_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 288: ... outputs(total_count-right_count+1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__21_83;
}
static void cont__21_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 289: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__21_84;
}
static void cont__21_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__5 */ = arguments->slots[0];
  // 288: ... "
  // 289:   from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__21_85;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  arguments->slots[2] = string__21_86;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[4] = string__21_87;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__21_88;
}
static void cont__21_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 288: assign_argument_or_result kind outputs(total_count-right_count+1) "
  // 289:   from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__21_89(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 293: ... total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* total_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__21_90;
}
static void cont__21_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 293: ... :
  // 294:   write "
  // 295:     @
  // 296:       switch(argument_count) {
  // 297:   from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 298:     $n idx+right_count
  // 299:     $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 300:     assign_argument_or_result
  // 301:       "    @(cnt): "
  // 302:       kind
  // ...
  frame->slots[8] /* temp__2 */ = create_closure(entry__21_91, 0);
  // 293: if total_count > fixed_count:
  // 294:   write "
  // 295:     @
  // 296:       switch(argument_count) {
  // 297:   from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 298:     $n idx+right_count
  // 299:     $cnt if(n == total_count (-> "default") -> "case @(n)")
  // 300:     assign_argument_or_result
  // 301:       "    @(cnt): "
  // 302:       kind
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__22_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 367: =
  // 368:   '@nl;'
  // 369:   "
  // 370:     @
  // 371:     
  // 372:       // @
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = string__22_2;
  result_count = 1;
  myself = get__std__key_value_pair();
  func = myself->type;
  frame->cont = cont__22_3;
}
static void cont__22_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 365: replace_all
  // 366:   str
  // 367:   =
  // 368:     '@nl;'
  // 369:     "
  // 370:       @
  // 371:       
  // 372:         // @
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__replace_all();
  func = myself->type;
  frame->cont = cont__22_4;
}
static void cont__22_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 363: writeln
  // 364:   "  // "
  // 365:   replace_all
  // 366:     str
  // 367:     =
  // 368:       '@nl;'
  // 369:       "
  // 370:         @
  // 371:         
  // 372:           // @
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__22_5;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__23_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  // i: 1
  frame->slots[1] /* i */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 375: $$i -1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__23_2;
}
static void cont__23_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* i */ = arguments->slots[0];
  // 376: ... -> str(i) != newline && str(i) != indent_marker: dec &i
  frame->slots[2] /* temp__1 */ = create_closure(entry__23_3, 0);
  // 376: while -> str(i) != newline && str(i) != indent_marker: dec &i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__23_14;
}
static void entry__23_12(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // i: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* i */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 376: ... dec &i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* i */;
  result_count = 1;
  myself = get__dec();
  func = myself->type;
  frame->cont = cont__23_13;
}
static void cont__23_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* i */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__23_3(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // str: 0
  // i: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* i */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 376: ... str(i)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* i */;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__23_4;
}
static void cont__23_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 376: ... str(i) != newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__23_5;
}
static void cont__23_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 376: ... str(i) != newline
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__23_6;
}
static void cont__23_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 376: ... str(i) != indent_marker
  frame->slots[6] /* temp__5 */ = create_closure(entry__23_7, 0);
  // 376: ... str(i) != newline && str(i) != indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__23_11;
}
static void entry__23_7(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // str: 0
  // i: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* i */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 376: ... str(i)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* i */;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__23_8;
}
static void cont__23_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 376: ... str(i) != indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__23_9;
}
static void cont__23_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 376: ... str(i) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__23_10;
}
static void cont__23_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 376: ... str(i) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__23_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 376: ... : dec &i
  frame->slots[7] /* temp__6 */ = create_closure(entry__23_12, 0);
  // 376: ... -> str(i) != newline && str(i) != indent_marker: dec &i
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__6 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__23_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 377: ... i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* i */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__23_15;
}
static void cont__23_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 377: -> -i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_1(void) {
  allocate_initialized_frame_gc(3, 21);
  // slot allocations:
  // node: 0
  // print_remark: 1
  // is_an_exit: 2
  // fragment: 3
  // fragment_source: 4
  // offset: 5
  // pos: 6
  // prefix: 7
  // fragment_line_no: 8
  // indents: 9
  // line_no: 10
  // column_no: 11
  // source: 12
  // last_line_no: 13
  // last_column_no: 14
  // submodule_no: 15
  // continuation_info: 16
  frame->slots[3] /* fragment */ = create_future();
  frame->slots[4] /* fragment_source */ = create_future();
  frame->slots[5] /* offset */ = create_future();
  frame->slots[6] /* pos */ = create_future();
  frame->slots[7] /* prefix */ = create_future();
  frame->slots[8] /* fragment_line_no */ = create_future();
  frame->slots[9] /* indents */ = create_future();
  frame->slots[10] /* line_no */ = create_cell();
  frame->slots[11] /* column_no */ = create_cell();
  frame->slots[12] /* source */ = create_cell();
  frame->slots[13] /* last_line_no */ = create_cell();
  frame->slots[14] /* last_column_no */ = create_future();
  frame->slots[15] /* submodule_no */ = create_future();
  frame->slots[16] /* continuation_info */ = create_future();
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[2] /* is_an_exit */ = arguments->slots[2];
    case 2: frame->slots[1] /* print_remark */ = arguments->slots[1];
    case 1:;
  }
  switch(argument_count) {
    case 1: frame->slots[1] /* print_remark */ = get__false();
    case 2: frame->slots[2] /* is_an_exit */ = get__false();
  }
  // 385: $fragment fragment_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__fragment_of();
  func = myself->type;
  frame->cont = cont__24_2;
}
static void cont__24_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* fragment */, arguments->slots[0]);
  // 386: $fragment_source source_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__24_3;
}
static void cont__24_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* fragment_source */, arguments->slots[0]);
  // 387: $offset source_position_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__source_position_of();
  func = myself->type;
  frame->cont = cont__24_4;
}
static void cont__24_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* offset */, arguments->slots[0]);
  // 388: ... length_of(fragment_source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* fragment_source */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__24_5;
}
static void cont__24_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 388: ... length_of(fragment_source)-offset
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* offset */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__24_6;
}
static void cont__24_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 388: $pos length_of(fragment_source)-offset+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_7;
}
static void cont__24_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* pos */, arguments->slots[0]);
  // 389: ... pos-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* pos */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__24_8;
}
static void cont__24_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 389: $prefix range(fragment_source 1 pos-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* fragment_source */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[17] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__24_9;
}
static void cont__24_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* prefix */, arguments->slots[0]);
  // 390: $fragment_line_no line_no_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__line_no_of();
  func = myself->type;
  frame->cont = cont__24_10;
}
static void cont__24_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* fragment_line_no */, arguments->slots[0]);
  // 391: $indents indents_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__indents_of();
  func = myself->type;
  frame->cont = cont__24_11;
}
static void cont__24_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[9] /* indents */, arguments->slots[0]);
  // 395: count_character_occurrences(prefix newline)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* prefix */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__24_12;
}
static void cont__24_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 396: count_character_occurrences(prefix indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* prefix */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__24_13;
}
static void cont__24_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 393: $$line_no
  // 394:   +
  // 395:     count_character_occurrences(prefix newline)
  // 396:     count_character_occurrences(prefix indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_14;
}
static void cont__24_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[10])->contents /* line_no */ = arguments->slots[0];
  // 400: line_no > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = ((CELL *)frame->slots[10])->contents /* line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__24_15;
}
static void cont__24_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 401: -> compute_column_no(prefix)+indents(line_no)
  frame->slots[18] /* temp__2 */ = create_closure(entry__24_16, 0);
  // 402: -> length_of(prefix)+1
  frame->slots[19] /* temp__3 */ = create_closure(entry__24_20, 0);
  // 398: $$column_no
  // 399:   if
  // 400:     line_no > 0
  // 401:     -> compute_column_no(prefix)+indents(line_no)
  // 402:     -> length_of(prefix)+1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = frame->slots[18] /* temp__2 */;
  arguments->slots[2] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_23;
}
static void entry__24_16(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // prefix: 0
  // indents: 1
  // line_no: 2
  frame->slots[0] = myself->closure.frame->slots[7]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[9]; /* indents */
  frame->slots[2] = myself->closure.frame->slots[10]; /* line_no */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 401: ... compute_column_no(prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  result_count = 1;
  myself = var._compute_column_no;
  func = myself->type;
  frame->cont = cont__24_17;
}
static void cont__24_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 401: ... indents(line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* line_no */;
  result_count = 1;
  myself = frame->slots[1] /* indents */;
  func = myself->type;
  frame->cont = cont__24_18;
}
static void cont__24_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 401: ... compute_column_no(prefix)+indents(line_no)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_19;
}
static void cont__24_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 401: -> compute_column_no(prefix)+indents(line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_20(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // prefix: 0
  frame->slots[0] = myself->closure.frame->slots[7]; /* prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 402: ... length_of(prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__24_21;
}
static void cont__24_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 402: ... length_of(prefix)+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_22;
}
static void cont__24_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 402: -> length_of(prefix)+1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[11])->contents /* column_no */ = arguments->slots[0];
  // 404: ... offset
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* offset */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__24_24;
}
static void cont__24_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 404: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__24_25;
}
static void cont__24_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 404: $$source range(fragment_source -offset -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* fragment_source */;
  arguments->slots[1] = frame->slots[17] /* temp__1 */;
  arguments->slots[2] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__24_26;
}
static void cont__24_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[12])->contents /* source */ = arguments->slots[0];
  // 405: ... end_position_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__end_position_of();
  func = myself->type;
  frame->cont = cont__24_27;
}
static void cont__24_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[19] /* temp__3 */ = arguments->slots[0];
  // 405: ... 1+end_position_of(node)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_28;
}
static void cont__24_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 405: ... 1+end_position_of(node))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__24_29;
}
static void cont__24_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 405: range &source 1 -(1+end_position_of(node))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* source */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[17] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__24_30;
}
static void cont__24_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[12])->contents /* source */ = arguments->slots[0];
  // 410: count_character_occurrences(source newline)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* source */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__24_31;
}
static void cont__24_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_32;
}
static void cont__24_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 411: count_character_occurrences(source indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* source */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__24_33;
}
static void cont__24_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[19] /* temp__3 */ = arguments->slots[0];
  // 407: $$last_line_no
  // 408:   +
  // 409:     line_no
  // 410:     count_character_occurrences(source newline)
  // 411:     count_character_occurrences(source indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_34;
}
static void cont__24_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[13])->contents /* last_line_no */ = arguments->slots[0];
  // 416: last_line_no > line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = ((CELL *)frame->slots[13])->contents /* last_line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__24_35;
}
static void cont__24_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 417: -> compute_column_no(source)+indents(last_line_no)-1
  frame->slots[19] /* temp__3 */ = create_closure(entry__24_36, 0);
  // 418: -> column_no+length_of(source)
  frame->slots[20] /* temp__4 */ = create_closure(entry__24_41, 0);
  // 415: if
  // 416:   last_line_no > line_no
  // 417:   -> compute_column_no(source)+indents(last_line_no)-1
  // 418:   -> column_no+length_of(source)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  arguments->slots[1] = frame->slots[19] /* temp__3 */;
  arguments->slots[2] = frame->slots[20] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_44;
}
static void entry__24_36(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // source: 0
  // indents: 1
  // last_line_no: 2
  frame->slots[0] = myself->closure.frame->slots[12]; /* source */
  frame->slots[1] = myself->closure.frame->slots[9]; /* indents */
  frame->slots[2] = myself->closure.frame->slots[13]; /* last_line_no */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 417: ... compute_column_no(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* source */;
  result_count = 1;
  myself = var._compute_column_no;
  func = myself->type;
  frame->cont = cont__24_37;
}
static void cont__24_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 417: ... indents(last_line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* last_line_no */;
  result_count = 1;
  myself = frame->slots[1] /* indents */;
  func = myself->type;
  frame->cont = cont__24_38;
}
static void cont__24_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 417: ... compute_column_no(source)+indents(last_line_no)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_39;
}
static void cont__24_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 417: ... compute_column_no(source)+indents(last_line_no)-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__24_40;
}
static void cont__24_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 417: -> compute_column_no(source)+indents(last_line_no)-1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_41(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // column_no: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[11]; /* column_no */
  frame->slots[1] = myself->closure.frame->slots[12]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 418: ... length_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* source */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__24_42;
}
static void cont__24_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 418: ... column_no+length_of(source)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* column_no */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_43;
}
static void cont__24_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 418: -> column_no+length_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 413: $last_column_no
  // 414:   -
  // 415:     if
  // 416:       last_line_no > line_no
  // 417:       -> compute_column_no(source)+indents(last_line_no)-1
  // 418:       -> column_no+length_of(source)
  // 419:     1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__24_45;
}
static void cont__24_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[14] /* last_column_no */, arguments->slots[0]);
  // 421: plus &line_no fragment_line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = frame->slots[8] /* fragment_line_no */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__24_46;
}
static void cont__24_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[10])->contents /* line_no */ = arguments->slots[0];
  // 422: plus &last_line_no fragment_line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[13])->contents /* last_line_no */;
  arguments->slots[1] = frame->slots[8] /* fragment_line_no */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__24_47;
}
static void cont__24_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[13])->contents /* last_line_no */ = arguments->slots[0];
  // 423: $submodule_no submodule_no_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__submodule_no_of();
  func = myself->type;
  frame->cont = cont__24_48;
}
static void cont__24_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[15] /* submodule_no */, arguments->slots[0]);
  // 424: ... :
  // 425:   !line_no last_line_no
  // 426:   !column_no last_column_no
  frame->slots[17] /* temp__1 */ = create_closure(entry__24_49, 0);
  // 424: if is_an_exit:
  // 425:   !line_no last_line_no
  // 426:   !column_no last_column_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* is_an_exit */;
  arguments->slots[1] = frame->slots[17] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_50;
}
static void entry__24_49(void) {
  allocate_initialized_frame_gc(4, 4);
  // slot allocations:
  // line_no: 0
  // last_line_no: 1
  // column_no: 2
  // last_column_no: 3
  frame->slots[0] = myself->closure.frame->slots[10]; /* line_no */
  frame->slots[1] = myself->closure.frame->slots[13]; /* last_line_no */
  frame->slots[2] = myself->closure.frame->slots[11]; /* column_no */
  frame->slots[3] = myself->closure.frame->slots[14]; /* last_column_no */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 425: !line_no last_line_no
  ((CELL *)frame->slots[0])->contents /* line_no */ = ((CELL *)frame->slots[1])->contents /* last_line_no */;
  // 426: !column_no last_column_no
  ((CELL *)frame->slots[2])->contents /* column_no */ = frame->slots[3] /* last_column_no */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_50(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 430: ... submodule_no != 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* submodule_no */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__24_51;
}
static void cont__24_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[19] /* temp__3 */ = arguments->slots[0];
  // 430: ... submodule_no != 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__24_52;
}
static void cont__24_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 430: ... -> ", @(submodule_no_of(fragment))"
  frame->slots[20] /* temp__4 */ = create_closure(entry__24_53, 0);
  // 430: ... if(submodule_no != 0 (-> ", @(submodule_no_of(fragment))") -> "")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  arguments->slots[1] = frame->slots[20] /* temp__4 */;
  arguments->slots[2] = func__24_57;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_58;
}
static void entry__24_53(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // fragment: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* fragment */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 430: ... submodule_no_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* fragment */;
  result_count = 1;
  myself = get__submodule_no_of();
  func = myself->type;
  frame->cont = cont__24_54;
}
static void cont__24_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 430: ... ", @(submodule_no_of(fragment))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__24_55;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__24_56;
}
static void cont__24_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 430: ... -> ", @(submodule_no_of(fragment))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_57(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 430: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 428: $continuation_info "
  // 429:   @(line_no), @(last_line_no), @(column_no), @(last_column_no)@
  // 430:   @(if(submodule_no != 0 (-> ", @(submodule_no_of(fragment))") -> ""))@
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = string__24_59;
  arguments->slots[2] = ((CELL *)frame->slots[13])->contents /* last_line_no */;
  arguments->slots[3] = string__24_60;
  arguments->slots[4] = ((CELL *)frame->slots[11])->contents /* column_no */;
  arguments->slots[5] = string__24_61;
  arguments->slots[6] = frame->slots[14] /* last_column_no */;
  arguments->slots[7] = frame->slots[17] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__24_62;
}
static void cont__24_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[16] /* continuation_info */, arguments->slots[0]);
  // 432: ... :
  // 433:   $$indent 0
  // 434:   $$do_print_dots false
  // 435:   if last_line_no > line_no+9:
  // 436:     !last_line_no line_no+9
  // 437:     !do_print_dots true
  // 438:   $width length_of(to_string(last_line_no))
  // 439:   if
  // 440:     &&
  // 441:       length_of(prefix) > 0
  // ...
  frame->slots[17] /* temp__1 */ = create_closure(entry__24_63, 0);
  // 432: if print_remark:
  // 433:   $$indent 0
  // 434:   $$do_print_dots false
  // 435:   if last_line_no > line_no+9:
  // 436:     !last_line_no line_no+9
  // 437:     !do_print_dots true
  // 438:   $width length_of(to_string(last_line_no))
  // 439:   if
  // 440:     &&
  // 441:       length_of(prefix) > 0
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* print_remark */;
  arguments->slots[1] = frame->slots[17] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_126;
}
static void entry__24_106(void) {
  allocate_initialized_frame_gc(7, 8);
  // slot allocations:
  // break: 0
  // source: 1
  // indent: 2
  // last_line_no: 3
  // line_no: 4
  // write_line_start: 5
  // do_print_dots: 6
  frame->slots[0] /* break */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[3]; /* source */
  frame->slots[2] = myself->closure.frame->slots[4]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[1]; /* last_line_no */
  frame->slots[4] = myself->closure.frame->slots[0]; /* line_no */
  frame->slots[5] = myself->closure.frame->slots[7]; /* write_line_start */
  frame->slots[6] = myself->closure.frame->slots[5]; /* do_print_dots */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 454: ... : (_idx chr)
  // 455:   case
  // 456:     chr
  // 457:     newline, indent_marker:
  // 458:       if chr == indent_marker: inc &indent
  // 459:       writeln
  // 460:       if
  // 461:         line_no <= last_line_no:
  // 462:           write_line_start
  // 463:         :
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__24_107, 2);
  // 454: for_each source: (_idx chr)
  // 455:   case
  // 456:     chr
  // 457:     newline, indent_marker:
  // 458:       if chr == indent_marker: inc &indent
  // 459:       writeln
  // 460:       if
  // 461:         line_no <= last_line_no:
  // 462:           write_line_start
  // 463:         :
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* source */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__24_125;
}
static void entry__24_117(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // write_line_start: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* write_line_start */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 462: write_line_start
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* write_line_start */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__24_118(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // do_print_dots: 0
  // break: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* do_print_dots */
  frame->slots[1] = myself->closure.frame->slots[6]; /* break */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 464: if do_print_dots: writeln "  // ..."
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* do_print_dots */;
  arguments->slots[1] = func__24_119;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_121;
}
static void entry__24_119(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 464: ... writeln "  // ..."
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__24_120;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__24_121(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 465: break
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* break */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__24_109(void) {
  allocate_initialized_frame_gc(7, 11);
  // slot allocations:
  // chr: 0
  // indent: 1
  // last_line_no: 2
  // line_no: 3
  // write_line_start: 4
  // do_print_dots: 5
  // break: 6
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* last_line_no */
  frame->slots[3] = myself->closure.frame->slots[4]; /* line_no */
  frame->slots[4] = myself->closure.frame->slots[5]; /* write_line_start */
  frame->slots[5] = myself->closure.frame->slots[6]; /* do_print_dots */
  frame->slots[6] = myself->closure.frame->slots[7]; /* break */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 458: ... chr == indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__24_110;
}
static void cont__24_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 458: ... : inc &indent
  frame->slots[8] /* temp__2 */ = create_closure(entry__24_111, 0);
  // 458: if chr == indent_marker: inc &indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_113;
}
static void entry__24_111(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 458: ... inc &indent
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__24_112;
}
static void cont__24_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_113(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 459: writeln
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = get__writeln();
  func = myself->type;
  frame->cont = cont__24_114;
}
static void cont__24_114(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 461: line_no <= last_line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* last_line_no */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__24_115;
}
static void cont__24_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 461: line_no <= last_line_no
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__24_116;
}
static void cont__24_116(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 461: ... :
  // 462:   write_line_start
  frame->slots[9] /* temp__3 */ = create_closure(entry__24_117, 0);
  // 463: :
  // 464:   if do_print_dots: writeln "  // ..."
  // 465:   break
  frame->slots[10] /* temp__4 */ = create_closure(entry__24_118, 0);
  // 460: if
  // 461:   line_no <= last_line_no:
  // 462:     write_line_start
  // 463:   :
  // 464:     if do_print_dots: writeln "  // ..."
  // 465:     break
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__24_122(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 467: dec &indent
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__dec();
  func = myself->type;
  frame->cont = cont__24_123;
}
static void cont__24_123(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_124(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 469: write chr
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__24_107(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // idx: 0
  // chr: 1
  // indent: 2
  // last_line_no: 3
  // line_no: 4
  // write_line_start: 5
  // do_print_dots: 6
  // break: 7
  frame->slots[2] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[3]; /* last_line_no */
  frame->slots[4] = myself->closure.frame->slots[4]; /* line_no */
  frame->slots[5] = myself->closure.frame->slots[5]; /* write_line_start */
  frame->slots[6] = myself->closure.frame->slots[6]; /* do_print_dots */
  frame->slots[7] = myself->closure.frame->slots[0]; /* break */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 457: newline, indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__newline();
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__24_108;
}
static void cont__24_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 457: ... :
  // 458:   if chr == indent_marker: inc &indent
  // 459:   writeln
  // 460:   if
  // 461:     line_no <= last_line_no:
  // 462:       write_line_start
  // 463:     :
  // 464:       if do_print_dots: writeln "  // ..."
  // 465:       break
  frame->slots[9] /* temp__2 */ = create_closure(entry__24_109, 0);
  // 466: ... :
  // 467:   dec &indent
  frame->slots[10] /* temp__3 */ = create_closure(entry__24_122, 0);
  // 468: :
  // 469:   write chr
  frame->slots[11] /* temp__4 */ = create_closure(entry__24_124, 0);
  // 455: case
  // 456:   chr
  // 457:   newline, indent_marker:
  // 458:     if chr == indent_marker: inc &indent
  // 459:     writeln
  // 460:     if
  // 461:       line_no <= last_line_no:
  // 462:         write_line_start
  // 463:       :
  // 464:         if do_print_dots: writeln "  // ..."
  // ...
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = frame->slots[8] /* temp__1 */;
  arguments->slots[2] = frame->slots[9] /* temp__2 */;
  arguments->slots[3] = get__outdent_marker();
  arguments->slots[4] = frame->slots[10] /* temp__3 */;
  arguments->slots[5] = frame->slots[11] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__24_125(void) {
  myself = frame->slots[0] /* break */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__24_63(void) {
  allocate_initialized_frame_gc(4, 13);
  // slot allocations:
  // line_no: 0
  // last_line_no: 1
  // prefix: 2
  // source: 3
  // indent: 4
  // do_print_dots: 5
  // width: 6
  // write_line_start: 7
  frame->slots[0] = myself->closure.frame->slots[10]; /* line_no */
  frame->slots[1] = myself->closure.frame->slots[13]; /* last_line_no */
  frame->slots[2] = myself->closure.frame->slots[7]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[12]; /* source */
  frame->slots[7] /* write_line_start */ = create_future();
  frame->slots[4] /* indent */ = create_cell();
  frame->slots[5] /* do_print_dots */ = create_cell();
  frame->slots[6] /* width */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 448: ... :
  // 449:   write "  // @(pad_left(line_no width)): " dup("  " max(indent 0))
  // 450:   inc &line_no
  frame->slots[8] /* temp__1 */ = create_closure(entry__24_64, 0);
  // 448: $write_line_start:
  // 449:   write "  // @(pad_left(line_no width)): " dup("  " max(indent 0))
  // 450:   inc &line_no
  initialize_future(frame->slots[7] /* write_line_start */, frame->slots[8] /* temp__1 */);
  // 433: $$indent 0
  ((CELL *)frame->slots[4])->contents /* indent */ = number__0;
  // 434: $$do_print_dots false
  ((CELL *)frame->slots[5])->contents /* do_print_dots */ = get__false();
  // 435: ... line_no+9
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line_no */;
  arguments->slots[1] = number__9;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_74;
}
static void entry__24_64(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // line_no: 0
  // width: 1
  // indent: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* line_no */
  frame->slots[1] = myself->closure.frame->slots[6]; /* width */
  frame->slots[2] = myself->closure.frame->slots[4]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 449: ... pad_left(line_no width)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line_no */;
  arguments->slots[1] = frame->slots[1] /* width */;
  result_count = 1;
  myself = get__pad_left();
  func = myself->type;
  frame->cont = cont__24_65;
}
static void cont__24_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 449: ... "  // @(pad_left(line_no width)): "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__24_66;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__24_67;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__24_68;
}
static void cont__24_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 449: ... max(indent 0)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* indent */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__max();
  func = myself->type;
  frame->cont = cont__24_69;
}
static void cont__24_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 449: ... dup("  " max(indent 0))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__24_70;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__dup();
  func = myself->type;
  frame->cont = cont__24_71;
}
static void cont__24_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 449: write "  // @(pad_left(line_no width)): " dup("  " max(indent 0))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__24_72;
}
static void cont__24_72(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 450: inc &line_no
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line_no */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__24_73;
}
static void cont__24_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line_no */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 435: ... last_line_no > line_no+9
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* last_line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__24_75;
}
static void cont__24_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 435: ... :
  // 436:   !last_line_no line_no+9
  // 437:   !do_print_dots true
  frame->slots[10] /* temp__3 */ = create_closure(entry__24_76, 0);
  // 435: if last_line_no > line_no+9:
  // 436:   !last_line_no line_no+9
  // 437:   !do_print_dots true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_78;
}
static void entry__24_76(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // last_line_no: 0
  // line_no: 1
  // do_print_dots: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* last_line_no */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line_no */
  frame->slots[2] = myself->closure.frame->slots[5]; /* do_print_dots */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 436: !last_line_no line_no+9
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* line_no */;
  arguments->slots[1] = number__9;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__24_77;
}
static void cont__24_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* last_line_no */ = arguments->slots[0];
  // 437: !do_print_dots true
  ((CELL *)frame->slots[2])->contents /* do_print_dots */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_78(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 438: ... to_string(last_line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* last_line_no */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__24_79;
}
static void cont__24_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 438: $width length_of(to_string(last_line_no))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__24_80;
}
static void cont__24_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* width */, arguments->slots[0]);
  // 441: length_of(prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__24_81;
}
static void cont__24_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 441: length_of(prefix) > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__24_82;
}
static void cont__24_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  frame->slots[11] /* temp__4 */ = create_closure(entry__24_83, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__24_94;
}
static void entry__24_83(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // prefix: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 442: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__24_84;
}
static void cont__24_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 442: prefix(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = frame->slots[0] /* prefix */;
  func = myself->type;
  frame->cont = cont__24_85;
}
static void cont__24_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 442: prefix(-1) != newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__24_86;
}
static void cont__24_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 442: prefix(-1) != newline
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__24_87;
}
static void cont__24_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 443: prefix(-1) != indent_marker
  frame->slots[6] /* temp__6 */ = create_closure(entry__24_88, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__24_93;
}
static void entry__24_88(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // prefix: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 443: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__24_89;
}
static void cont__24_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 443: prefix(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = frame->slots[0] /* prefix */;
  func = myself->type;
  frame->cont = cont__24_90;
}
static void cont__24_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 443: prefix(-1) != indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__24_91;
}
static void cont__24_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 443: prefix(-1) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__24_92;
}
static void cont__24_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 443: prefix(-1) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 444: :
  // 445:   append "... " &source
  frame->slots[12] /* temp__5 */ = create_closure(entry__24_95, 0);
  // 439: if
  // 440:   &&
  // 441:     length_of(prefix) > 0
  // 442:     prefix(-1) != newline
  // 443:     prefix(-1) != indent_marker
  // 444:   :
  // 445:     append "... " &source
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__24_98;
}
static void entry__24_95(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 445: append "... " &source
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__24_96;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* source */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__24_97;
}
static void cont__24_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* source */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_98(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 446: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__24_99;
}
static void cont__24_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 446: ... source(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* source */;
  func = myself->type;
  frame->cont = cont__24_100;
}
static void cont__24_100(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 446: ... source(-1) == newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__24_101;
}
static void cont__24_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 446: ... : push &source newline
  frame->slots[11] /* temp__4 */ = create_closure(entry__24_102, 0);
  // 446: unless source(-1) == newline: push &source newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__24_104;
}
static void entry__24_102(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 446: ... push &source newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* source */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__24_103;
}
static void cont__24_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* source */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_104(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 452: write_line_start
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[7] /* write_line_start */;
  func = myself->type;
  frame->cont = cont__24_105;
}
static void cont__24_105(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 453: ... : (-> break)
  // 454:   for_each source: (_idx chr)
  // 455:     case
  // 456:       chr
  // 457:       newline, indent_marker:
  // 458:         if chr == indent_marker: inc &indent
  // 459:         writeln
  // 460:         if
  // 461:           line_no <= last_line_no:
  // 462:             write_line_start
  // ...
  frame->slots[8] /* temp__1 */ = create_closure(entry__24_106, 0);
  // 453: do: (-> break)
  // 454:   for_each source: (_idx chr)
  // 455:     case
  // 456:       chr
  // 457:       newline, indent_marker:
  // 458:         if chr == indent_marker: inc &indent
  // 459:         writeln
  // 460:         if
  // 461:           line_no <= last_line_no:
  // 462:             write_line_start
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__24_126(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 470: -> continuation_info
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* continuation_info */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__25_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // node: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* node */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 474: compute_source_text_info !current_continuation_info node true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  arguments->slots[1] = get__true();
  result_count = 1;
  myself = var._compute_source_text_info;
  func = myself->type;
  frame->cont = cont__25_5;
}
static void cont__25_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__current_continuation_info(arguments->slots[0]);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__25_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // node: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 473: ... end_position_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__end_position_of();
  func = myself->type;
  frame->cont = cont__25_2;
}
static void cont__25_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 473: ... end_position_of(node).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__25_3;
}
static void cont__25_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 473: ... :
  // 474:   compute_source_text_info !current_continuation_info node true
  frame->slots[3] /* temp__3 */ = create_closure(entry__25_4, 0);
  // 473: if end_position_of(node).is_defined:
  // 474:   compute_source_text_info !current_continuation_info node true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_1(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // source: 0
  // return: 1
  frame->slots[1] /* return */ = create_continuation();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 486: -> source.is_a_constant: return EARLY
  frame->slots[2] /* temp__1 */ = create_closure(entry__29_2, 0);
  // 487: -> source.is_a_temporary: return STANDARD
  frame->slots[3] /* temp__2 */ = create_closure(entry__29_5, 0);
  // 488: :
  // 489:   $name mangled_name_of(source)
  // 490:   cond
  // 491:     -> current_locals(name).is_defined:
  // 492:       return if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  // 493:     -> needed_names(name).is_defined:
  // 494:       case
  // 495:         variable_kind_of(needed_names(name))
  // 496:         STATIC_SINGLE:
  // 497:           return UNKNOWN
  // ...
  frame->slots[4] /* temp__3 */ = create_closure(entry__29_8, 0);
  // 485: cond
  // 486:   -> source.is_a_constant: return EARLY
  // 487:   -> source.is_a_temporary: return STANDARD
  // 488:   :
  // 489:     $name mangled_name_of(source)
  // 490:     cond
  // 491:       -> current_locals(name).is_defined:
  // 492:         return if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  // 493:       -> needed_names(name).is_defined:
  // 494:         case
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__29_44;
}
static void entry__29_42(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 514: return STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._STANDARD;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_43(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 516: return EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._EARLY;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_26(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 499: return EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._EARLY;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_27(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 501: return STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._STANDARD;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_21(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // name: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 495: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__29_22;
}
static void cont__29_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 495: variable_kind_of(needed_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__29_23;
}
static void cont__29_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 496: ... :
  // 497:   return UNKNOWN
  frame->slots[4] /* temp__3 */ = create_closure(entry__29_24, 0);
  // 498: POLYMORPHIC, DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__POLYMORPHIC();
  arguments->slots[1] = get__DYNAMIC_SINGLE();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__29_25;
}
static void entry__29_24(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 497: return UNKNOWN
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._UNKNOWN;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__29_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 498: ... :
  // 499:   return EARLY
  frame->slots[6] /* temp__5 */ = create_closure(entry__29_26, 0);
  // 500: :
  // 501:   return STANDARD
  frame->slots[7] /* temp__6 */ = create_closure(entry__29_27, 0);
  // 494: case
  // 495:   variable_kind_of(needed_names(name))
  // 496:   STATIC_SINGLE:
  // 497:     return UNKNOWN
  // 498:   POLYMORPHIC, DYNAMIC_SINGLE:
  // 499:     return EARLY
  // 500:   :
  // 501:     return STANDARD
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  arguments->slots[3] = frame->slots[5] /* temp__4 */;
  arguments->slots[4] = frame->slots[6] /* temp__5 */;
  arguments->slots[5] = frame->slots[7] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_13(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // return: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 492: ... name.is_a_shared_local
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  result_count = 1;
  myself = get__is_a_shared_local();
  func = myself->type;
  frame->cont = cont__29_14;
}
static void cont__29_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 492: ... if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = func__29_15;
  arguments->slots[2] = func__29_16;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__29_17;
}
static void entry__29_15(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 492: ... -> STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._STANDARD;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__29_16(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 492: ... -> EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._EARLY;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__29_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 492: return if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_10(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // name: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 491: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__29_11;
}
static void cont__29_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 491: ... current_locals(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__29_12;
}
static void cont__29_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 491: ... :
  // 492:   return if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  frame->slots[4] /* temp__3 */ = create_closure(entry__29_13, 0);
  // 491: -> current_locals(name).is_defined:
  // 492:   return if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__29_18(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // name: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 493: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__29_19;
}
static void cont__29_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 493: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__29_20;
}
static void cont__29_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 493: ... :
  // 494:   case
  // 495:     variable_kind_of(needed_names(name))
  // 496:     STATIC_SINGLE:
  // 497:       return UNKNOWN
  // 498:     POLYMORPHIC, DYNAMIC_SINGLE:
  // 499:       return EARLY
  // 500:     :
  // 501:       return STANDARD
  frame->slots[4] /* temp__3 */ = create_closure(entry__29_21, 0);
  // 493: -> needed_names(name).is_defined:
  // 494:   case
  // 495:     variable_kind_of(needed_names(name))
  // 496:     STATIC_SINGLE:
  // 497:       return UNKNOWN
  // 498:     POLYMORPHIC, DYNAMIC_SINGLE:
  // 499:       return EARLY
  // 500:     :
  // 501:       return STANDARD
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__29_28(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // source: 0
  // name: 1
  // return: 2
  // variable_kind: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[2]; /* name */
  frame->slots[2] = myself->closure.frame->slots[1]; /* return */
  frame->slots[3] /* variable_kind */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 505: namespace_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__29_29;
}
static void cont__29_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 505: namespace_of(source).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__29_30;
}
static void cont__29_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 506: ->
  // 507:   variable_kind_of
  // 508:     exported_names(name_of(source))(namespace_of(source))
  frame->slots[6] /* temp__3 */ = create_closure(entry__29_31, 0);
  // 509: -> variable_kind_of(global_names(name))
  frame->slots[7] /* temp__4 */ = create_closure(entry__29_37, 0);
  // 503: $variable_kind
  // 504:   if
  // 505:     namespace_of(source).is_defined
  // 506:     ->
  // 507:       variable_kind_of
  // 508:         exported_names(name_of(source))(namespace_of(source))
  // 509:     -> variable_kind_of(global_names(name))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__29_40;
}
static void entry__29_31(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 508: ... namespace_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__29_32;
}
static void cont__29_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 508: ... name_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__29_33;
}
static void cont__29_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 508: exported_names(name_of(source))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__29_34;
}
static void cont__29_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 508: exported_names(name_of(source))(namespace_of(source))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = frame->slots[4] /* temp__4 */;
  func = myself->type;
  frame->cont = cont__29_35;
}
static void cont__29_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 507: variable_kind_of
  // 508:   exported_names(name_of(source))(namespace_of(source))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__29_36;
}
static void cont__29_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 506: ->
  // 507:   variable_kind_of
  // 508:     exported_names(name_of(source))(namespace_of(source))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__29_37(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 509: ... global_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__29_38;
}
static void cont__29_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 509: ... variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__29_39;
}
static void cont__29_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 509: -> variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__29_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* variable_kind */, arguments->slots[0]);
  // 513: STATIC_MULTI, DYNAMIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__STATIC_MULTI();
  arguments->slots[1] = get__DYNAMIC_MULTI();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__29_41;
}
static void cont__29_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 513: ... :
  // 514:   return STANDARD
  frame->slots[5] /* temp__2 */ = create_closure(entry__29_42, 0);
  // 515: :
  // 516:   return EARLY
  frame->slots[6] /* temp__3 */ = create_closure(entry__29_43, 0);
  // 511: case
  // 512:   variable_kind
  // 513:   STATIC_MULTI, DYNAMIC_MULTI:
  // 514:     return STANDARD
  // 515:   :
  // 516:     return EARLY
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* variable_kind */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 487: ... return STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._STANDARD;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 486: ... return EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._EARLY;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__29_2(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // source: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 486: ... source.is_a_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_constant();
  func = myself->type;
  frame->cont = cont__29_3;
}
static void cont__29_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 486: ... : return EARLY
  frame->slots[3] /* temp__2 */ = create_closure(entry__29_4, 0);
  // 486: -> source.is_a_constant: return EARLY
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__29_5(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // source: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 487: ... source.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__29_6;
}
static void cont__29_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 487: ... : return STANDARD
  frame->slots[3] /* temp__2 */ = create_closure(entry__29_7, 0);
  // 487: -> source.is_a_temporary: return STANDARD
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__29_8(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // source: 0
  // return: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 489: $name mangled_name_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__29_9;
}
static void cont__29_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 491: -> current_locals(name).is_defined:
  // 492:   return if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  frame->slots[3] /* temp__1 */ = create_closure(entry__29_10, 0);
  // 493: -> needed_names(name).is_defined:
  // 494:   case
  // 495:     variable_kind_of(needed_names(name))
  // 496:     STATIC_SINGLE:
  // 497:       return UNKNOWN
  // 498:     POLYMORPHIC, DYNAMIC_SINGLE:
  // 499:       return EARLY
  // 500:     :
  // 501:       return STANDARD
  frame->slots[4] /* temp__2 */ = create_closure(entry__29_18, 0);
  // 502: :
  // 503:   $variable_kind
  // 504:     if
  // 505:       namespace_of(source).is_defined
  // 506:       ->
  // 507:         variable_kind_of
  // 508:           exported_names(name_of(source))(namespace_of(source))
  // 509:       -> variable_kind_of(global_names(name))
  // 510:   
  // 511:   case
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__29_28, 0);
  // 490: cond
  // 491:   -> current_locals(name).is_defined:
  // 492:     return if(name.is_a_shared_local (-> STANDARD) -> EARLY)
  // 493:   -> needed_names(name).is_defined:
  // 494:     case
  // 495:       variable_kind_of(needed_names(name))
  // 496:       STATIC_SINGLE:
  // 497:         return UNKNOWN
  // 498:       POLYMORPHIC, DYNAMIC_SINGLE:
  // 499:         return EARLY
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__29_44(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 517: -> UNKNOWN
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._UNKNOWN;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__30_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 523: show_compiler_debug_info "generate expression"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__30_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__30_3;
}
static void cont__30_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 524: -> "???"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__30_4;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_1(void) {
  allocate_initialized_frame_gc(2, 11);
  // slot allocations:
  // self: 0
  // return: 1
  // outer_level: 2
  // parent_locals: 3
  // is_an_inherited_shared_local: 4
  // body_suffix: 5
  // par_count: 6
  frame->slots[1] /* return */ = create_continuation();
  // _define $outer_level level
  frame->slots[2] /* outer_level */ = get__level();
  // _define $parent_locals current_locals
  frame->slots[3] /* parent_locals */ = get__current_locals();
  // _define $is_an_inherited_shared_local is_a_shared_local
  frame->slots[4] /* is_an_inherited_shared_local */ = get__is_a_shared_local();
  frame->slots[5] /* body_suffix */ = create_future();
  frame->slots[6] /* par_count */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 534: show_compiler_debug_info "generate body"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__31_3;
}
static void cont__31_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 538: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_4;
}
static void cont__31_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 539: $body_suffix string(suffix '_' index)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__suffix();
  arguments->slots[1] = character__95;
  arguments->slots[2] = get__index();
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__31_5;
}
static void cont__31_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* body_suffix */, arguments->slots[0]);
  // 540: $$par_count undefined
  ((CELL *)frame->slots[6])->contents /* par_count */ = get__undefined();
  // 541: ... :
  // 542:   %level outer_level+1
  // 543:   $$slot_idx 0
  // 544:   $$locals empty_insert_order_table
  // 545:   $$is_shared empty_set
  // 546:   $$min_par_cnt 0
  // 547:   $$max_par_cnt 0
  // 548:   $$right_par_cnt 0
  // 549:   $$has_rest_parameter false
  // 550:   $$has_complex_default_values false
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__31_6, 0);
  // 541: delayed:
  // 542:   %level outer_level+1
  // 543:   $$slot_idx 0
  // 544:   $$locals empty_insert_order_table
  // 545:   $$is_shared empty_set
  // 546:   $$min_par_cnt 0
  // 547:   $$max_par_cnt 0
  // 548:   $$right_par_cnt 0
  // 549:   $$has_rest_parameter false
  // 550:   $$has_complex_default_values false
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = var._delayed;
  func = myself->type;
  frame->cont = cont__31_456;
}
static void entry__31_6(void) {
  allocate_initialized_frame_gc(7, 30);
  // slot allocations:
  // return__2: 0
  // outer_level: 1
  // self: 2
  // par_count: 3
  // is_an_inherited_shared_local: 4
  // body_suffix: 5
  // parent_locals: 6
  // slot_idx: 7
  // locals: 8
  // is_shared: 9
  // min_par_cnt: 10
  // max_par_cnt: 11
  // right_par_cnt: 12
  // has_rest_parameter: 13
  // has_complex_default_values: 14
  // myself_parameter: 15
  // continuation_parameter: 16
  // input_parameters: 17
  // output_parameters: 18
  // implicit_parameters: 19
  // locals_idx: 20
  // total_slots: 21
  // extract_destination_and_source: 22
  // extract_source_or_create_future: 23
  // statements: 24
  // generate_exit: 25
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* outer_level */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[6]; /* par_count */
  frame->slots[4] = myself->closure.frame->slots[4]; /* is_an_inherited_shared_local */
  frame->slots[5] = myself->closure.frame->slots[5]; /* body_suffix */
  frame->slots[6] = myself->closure.frame->slots[3]; /* parent_locals */
  // _define $extract_destination_and_source 
  // : (definition)
  // is_a_key_value_pair temp__1 definition
  // 
  // temp__2:
  // key_of temp__1 definition
  // -> temp__1
  // 
  // temp__3 -> definition
  // 
  // if temp__1 temp__2 temp__3 $destination
  // is_a_key_value_pair temp__1 definition
  // 
  // temp__2:
  // std::value_of temp__1 definition
  // -> temp__1
  // 
  // if temp__1 temp__2 $source -> undefined
  // -> destination source
  frame->slots[22] /* extract_destination_and_source */ = func__31_7;
  // _define $extract_source_or_create_future 
  // : (source)
  // is_undefined temp__1 source
  // 
  // temp__2:
  // get_kind temp__1 source
  // 
  // temp__2:
  // mangled_name_of temp__2 source
  // std::string temp__1 "get_value_or_future__" temp__2 "()"
  // -> temp__1
  // 
  // temp__3:
  // to_c temp__1 source
  // -> temp__1
  // 
  // case temp__1 UNKNOWN temp__2 STANDARD (-> "create_future()") temp__3
  // 
  // if temp__1 (-> "create_future()") temp__2
  frame->slots[23] /* extract_source_or_create_future */ = func__31_18;
  frame->slots[25] /* generate_exit */ = create_future();
  define__level(create_future());
  frame->slots[7] /* slot_idx */ = create_cell();
  frame->slots[8] /* locals */ = create_cell();
  frame->slots[9] /* is_shared */ = create_cell();
  frame->slots[10] /* min_par_cnt */ = create_cell();
  frame->slots[11] /* max_par_cnt */ = create_cell();
  frame->slots[12] /* right_par_cnt */ = create_cell();
  frame->slots[13] /* has_rest_parameter */ = create_cell();
  frame->slots[14] /* has_complex_default_values */ = create_cell();
  frame->slots[15] /* myself_parameter */ = create_cell();
  frame->slots[16] /* continuation_parameter */ = create_cell();
  frame->slots[17] /* input_parameters */ = create_cell();
  frame->slots[18] /* output_parameters */ = create_cell();
  frame->slots[19] /* implicit_parameters */ = create_cell();
  // _define $locals_idx slot_idx
  frame->slots[20] /* locals_idx */ = create_future();
  frame->slots[21] /* total_slots */ = create_future();
  // _define %current_locals locals
  define__current_locals(create_future());
  // _define %is_a_shared_local is_shared
  define__is_a_shared_local(create_future());
  // _define %temporary_offset slot_idx
  define__temporary_offset(create_future());
  define__current_frame(create_future());
  frame->slots[24] /* statements */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 756: ... :
  // 757:   if
  // 758:     ||
  // 759:       self.defines_a_dynamic
  // 760:       &&
  // 761:         continuation_parameter.is_defined
  // 762:         variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 763:     :
  // 764:       write "
  // 765:         @
  // ...
  frame->slots[26] /* temp__1 */ = create_closure(entry__31_33, 0);
  // 756: $generate_exit:
  // 757:   if
  // 758:     ||
  // 759:       self.defines_a_dynamic
  // 760:       &&
  // 761:         continuation_parameter.is_defined
  // 762:         variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 763:     :
  // 764:       write "
  // 765:         @
  // ...
  initialize_future(frame->slots[25] /* generate_exit */, frame->slots[26] /* temp__1 */);
  // 542: %level outer_level+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* outer_level */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__31_51;
}
static void entry__31_42(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 768: ... continuation_parameter.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_43;
}
static void cont__31_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 764: ... "
  // 765:   @
  // 766:     argument_count = 0;
  // 767:     arguments = node_p;
  // 768:     myself = @(continuation_parameter.to_c);
  // 769:     func = myself->type;
  // 770:     frame->cont = invalid_continuation;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_44;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__31_45;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_46;
}
static void cont__31_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 764: write "
  // 765:   @
  // 766:     argument_count = 0;
  // 767:     arguments = node_p;
  // 768:     myself = @(continuation_parameter.to_c);
  // 769:     func = myself->type;
  // 770:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_47(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // self: 0
  // output_parameters: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 772: compute_source_text_info self false true !current_continuation_info
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = get__false();
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._compute_source_text_info;
  func = myself->type;
  frame->cont = cont__31_48;
}
static void cont__31_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__current_continuation_info(arguments->slots[0]);
  // 773: generate_c_arguments output_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 0;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__31_49;
}
static void cont__31_49(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 774: write "
  // 775:   @
  // 776:     frame = frame->caller_frame;
  // 777:     func = frame->cont;
  // 778:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_50;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_22(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 681: ... mangled_name_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__31_23;
}
static void cont__31_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 681: ... "get_value_or_future__@(mangled_name_of(source))()"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_24;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__31_25;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_26;
}
static void cont__31_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 681: -> "get_value_or_future__@(mangled_name_of(source))()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_27(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 684: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_28;
}
static void cont__31_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 684: -> source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_29(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 683: -> "create_future()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_30;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_20(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 679: get_kind(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = var._get_kind;
  func = myself->type;
  frame->cont = cont__31_21;
}
static void cont__31_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 681: -> "get_value_or_future__@(mangled_name_of(source))()"
  frame->slots[2] /* temp__2 */ = create_closure(entry__31_22, 0);
  // 684: -> source.to_c
  frame->slots[3] /* temp__3 */ = create_closure(entry__31_27, 0);
  // 678: case
  // 679:   get_kind(source)
  // 680:   UNKNOWN
  // 681:   -> "get_value_or_future__@(mangled_name_of(source))()"
  // 682:   STANDARD
  // 683:   -> "create_future()"
  // 684:   -> source.to_c
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = var._UNKNOWN;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  arguments->slots[3] = var._STANDARD;
  arguments->slots[4] = func__31_29;
  arguments->slots[5] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_31(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 677: ... -> "create_future()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_32;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_7(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // definition: 0
  // destination: 1
  // source: 2
  frame->slots[1] /* destination */ = create_future();
  frame->slots[2] /* source */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 666: ... definition.is_a_key_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_a_key_value_pair();
  func = myself->type;
  frame->cont = cont__31_8;
}
static void cont__31_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 666: ... -> key_of(definition)
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_9, 0);
  // 666: ... -> definition
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_11, 0);
  // 665: $destination
  // 666:   if(definition.is_a_key_value_pair (-> key_of(definition)) -> definition)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_12;
}
static void entry__31_9(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 666: ... key_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__key_of();
  func = myself->type;
  frame->cont = cont__31_10;
}
static void cont__31_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 666: ... -> key_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_11(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 666: ... -> definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* destination */, arguments->slots[0]);
  // 670: definition.is_a_key_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_a_key_value_pair();
  func = myself->type;
  frame->cont = cont__31_13;
}
static void cont__31_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 671: -> std::value_of(definition)
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_14, 0);
  // 668: $source
  // 669:   if
  // 670:     definition.is_a_key_value_pair
  // 671:     -> std::value_of(definition)
  // 672:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = func__31_16;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_17;
}
static void entry__31_14(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 671: ... std::value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__std__value_of();
  func = myself->type;
  frame->cont = cont__31_15;
}
static void cont__31_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 671: -> std::value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_16(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 672: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* source */, arguments->slots[0]);
  // 674: -> destination source
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  arguments->slots[1] = frame->slots[2] /* source */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_18(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // source: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 677: ... source.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__31_19;
}
static void cont__31_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 677: ... :
  // 678:   case
  // 679:     get_kind(source)
  // 680:     UNKNOWN
  // 681:     -> "get_value_or_future__@(mangled_name_of(source))()"
  // 682:     STANDARD
  // 683:     -> "create_future()"
  // 684:     -> source.to_c
  frame->slots[2] /* temp__2 */ = create_closure(entry__31_20, 0);
  // 677: if source.is_undefined (-> "create_future()"):
  // 678:   case
  // 679:     get_kind(source)
  // 680:     UNKNOWN
  // 681:     -> "get_value_or_future__@(mangled_name_of(source))()"
  // 682:     STANDARD
  // 683:     -> "create_future()"
  // 684:     -> source.to_c
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__31_31;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_33(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // self: 0
  // continuation_parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* self */
  frame->slots[1] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[18]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 759: self.defines_a_dynamic
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__defines_a_dynamic();
  func = myself->type;
  frame->cont = cont__31_34;
}
static void cont__31_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 760: &&
  // 761:   continuation_parameter.is_defined
  // 762:   variable_kind_of(continuation_parameter) == STATIC_MULTI
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_35, 0);
  // 758: ||
  // 759:   self.defines_a_dynamic
  // 760:   &&
  // 761:     continuation_parameter.is_defined
  // 762:     variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__31_41;
}
static void entry__31_35(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 761: continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_36;
}
static void cont__31_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 762: variable_kind_of(continuation_parameter) == STATIC_MULTI
  frame->slots[3] /* temp__3 */ = create_closure(entry__31_37, 0);
  // 760: &&
  // 761:   continuation_parameter.is_defined
  // 762:   variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__31_40;
}
static void entry__31_37(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 762: variable_kind_of(continuation_parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__31_38;
}
static void cont__31_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 762: variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = get__STATIC_MULTI();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_39;
}
static void cont__31_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 762: variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 760: &&
  // 761:   continuation_parameter.is_defined
  // 762:   variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 763: :
  // 764:   write "
  // 765:     @
  // 766:       argument_count = 0;
  // 767:       arguments = node_p;
  // 768:       myself = @(continuation_parameter.to_c);
  // 769:       func = myself->type;
  // 770:       frame->cont = invalid_continuation;
  frame->slots[6] /* temp__4 */ = create_closure(entry__31_42, 0);
  // 771: :
  // 772:   compute_source_text_info self false true !current_continuation_info
  // 773:   generate_c_arguments output_parameters
  // 774:   write "
  // 775:     @
  // 776:       frame = frame->caller_frame;
  // 777:       func = frame->cont;
  // 778:       frame->cont = invalid_continuation;
  frame->slots[7] /* temp__5 */ = create_closure(entry__31_47, 0);
  // 757: if
  // 758:   ||
  // 759:     self.defines_a_dynamic
  // 760:     &&
  // 761:       continuation_parameter.is_defined
  // 762:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 763:   :
  // 764:     write "
  // 765:       @
  // 766:         argument_count = 0;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__level(), arguments->slots[0]);
  // 543: $$slot_idx 0
  ((CELL *)frame->slots[7])->contents /* slot_idx */ = number__0;
  // 544: $$locals empty_insert_order_table
  ((CELL *)frame->slots[8])->contents /* locals */ = get__empty_insert_order_table();
  // 545: $$is_shared empty_set
  ((CELL *)frame->slots[9])->contents /* is_shared */ = get__empty_set();
  // 546: $$min_par_cnt 0
  ((CELL *)frame->slots[10])->contents /* min_par_cnt */ = number__0;
  // 547: $$max_par_cnt 0
  ((CELL *)frame->slots[11])->contents /* max_par_cnt */ = number__0;
  // 548: $$right_par_cnt 0
  ((CELL *)frame->slots[12])->contents /* right_par_cnt */ = number__0;
  // 549: $$has_rest_parameter false
  ((CELL *)frame->slots[13])->contents /* has_rest_parameter */ = get__false();
  // 550: $$has_complex_default_values false
  ((CELL *)frame->slots[14])->contents /* has_complex_default_values */ = get__false();
  // 551: $$myself_parameter undefined
  ((CELL *)frame->slots[15])->contents /* myself_parameter */ = get__undefined();
  // 552: $$continuation_parameter undefined
  ((CELL *)frame->slots[16])->contents /* continuation_parameter */ = get__undefined();
  // 553: $$input_parameters empty_list
  ((CELL *)frame->slots[17])->contents /* input_parameters */ = get__empty_list();
  // 554: $$output_parameters empty_list
  ((CELL *)frame->slots[18])->contents /* output_parameters */ = get__empty_list();
  // 555: $$implicit_parameters empty_list
  ((CELL *)frame->slots[19])->contents /* implicit_parameters */ = get__empty_list();
  // 556: ... parameters_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__parameters_of();
  func = myself->type;
  frame->cont = cont__31_52;
}
static void cont__31_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 556: ... : (parameter)
  // 557:   $kind parameter_kind_of(parameter)
  // 558:   $default_value default_value_of(parameter)
  // 559:   if default_value.is_defined && default_value.is_a_function_call:
  // 560:     !has_complex_default_values true
  // 561:   case
  // 562:     kind
  // 563:     OUT_PARAMETER:
  // 564:       push &output_parameters parameter
  // 565:     IN_OUT_PARAMETER:
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_53, 1);
  // 556: for_each parameters_of(self): (parameter)
  // 557:   $kind parameter_kind_of(parameter)
  // 558:   $default_value default_value_of(parameter)
  // 559:   if default_value.is_defined && default_value.is_a_function_call:
  // 560:     !has_complex_default_values true
  // 561:   case
  // 562:     kind
  // 563:     OUT_PARAMETER:
  // 564:       push &output_parameters parameter
  // 565:     IN_OUT_PARAMETER:
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_72;
}
static void entry__31_68(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // implicit_parameters: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* implicit_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 569: push &implicit_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* implicit_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__31_69;
}
static void cont__31_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* implicit_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_70(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // input_parameters: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* input_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 571: push &input_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* input_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__31_71;
}
static void cont__31_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* input_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_53(void) {
  allocate_initialized_frame_gc(5, 12);
  // slot allocations:
  // parameter: 0
  // has_complex_default_values: 1
  // output_parameters: 2
  // input_parameters: 3
  // implicit_parameters: 4
  // kind: 5
  // default_value: 6
  frame->slots[1] = myself->closure.frame->slots[14]; /* has_complex_default_values */
  frame->slots[2] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[3] = myself->closure.frame->slots[17]; /* input_parameters */
  frame->slots[4] = myself->closure.frame->slots[19]; /* implicit_parameters */
  frame->slots[5] /* kind */ = create_future();
  frame->slots[6] /* default_value */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 557: $kind parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__31_54;
}
static void cont__31_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* kind */, arguments->slots[0]);
  // 558: $default_value default_value_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__31_55;
}
static void cont__31_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* default_value */, arguments->slots[0]);
  // 559: ... default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_56;
}
static void cont__31_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 559: ... default_value.is_a_function_call
  frame->slots[9] /* temp__3 */ = create_closure(entry__31_57, 0);
  // 559: ... default_value.is_defined && default_value.is_a_function_call
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__31_59;
}
static void entry__31_57(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // default_value: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 559: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__31_58;
}
static void cont__31_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 559: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 559: ... :
  // 560:   !has_complex_default_values true
  frame->slots[10] /* temp__4 */ = create_closure(entry__31_60, 0);
  // 559: if default_value.is_defined && default_value.is_a_function_call:
  // 560:   !has_complex_default_values true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_61;
}
static void entry__31_60(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 560: !has_complex_default_values true
  ((CELL *)frame->slots[0])->contents /* has_complex_default_values */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_61(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 563: ... :
  // 564:   push &output_parameters parameter
  frame->slots[7] /* temp__1 */ = create_closure(entry__31_62, 0);
  // 565: ... :
  // 566:   push &input_parameters parameter
  // 567:   push &output_parameters parameter
  frame->slots[8] /* temp__2 */ = create_closure(entry__31_64, 0);
  // 568: MYSELF_PARAMETER, CONTINUATION_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__MYSELF_PARAMETER();
  arguments->slots[1] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__31_67;
}
static void entry__31_62(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // output_parameters: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* output_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 564: push &output_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__31_63;
}
static void cont__31_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* output_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_64(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // input_parameters: 0
  // parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* input_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[2] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 566: push &input_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* input_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__31_65;
}
static void cont__31_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* input_parameters */ = arguments->slots[0];
  // 567: push &output_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__31_66;
}
static void cont__31_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* output_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 568: ... :
  // 569:   push &implicit_parameters parameter
  frame->slots[10] /* temp__4 */ = create_closure(entry__31_68, 0);
  // 570: :
  // 571:   push &input_parameters parameter
  frame->slots[11] /* temp__5 */ = create_closure(entry__31_70, 0);
  // 561: case
  // 562:   kind
  // 563:   OUT_PARAMETER:
  // 564:     push &output_parameters parameter
  // 565:   IN_OUT_PARAMETER:
  // 566:     push &input_parameters parameter
  // 567:     push &output_parameters parameter
  // 568:   MYSELF_PARAMETER, CONTINUATION_PARAMETER:
  // 569:     push &implicit_parameters parameter
  // 570:   :
  // ...
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* kind */;
  arguments->slots[1] = get__OUT_PARAMETER();
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  arguments->slots[3] = get__IN_OUT_PARAMETER();
  arguments->slots[4] = frame->slots[8] /* temp__2 */;
  arguments->slots[5] = frame->slots[9] /* temp__3 */;
  arguments->slots[6] = frame->slots[10] /* temp__4 */;
  arguments->slots[7] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_72(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 575: ... : (parameter)
  // 576:   $name name_of(identifier_of(parameter))
  // 577:   cond
  // 578:     -> parameter.is_an_optional_item: inc &max_par_cnt
  // 579:     -> parameter.is_an_expanded_item: !has_rest_parameter true
  // 580:     :
  // 581:       inc &min_par_cnt
  // 582:       inc &max_par_cnt
  // 583:       if max_par_cnt > min_par_cnt: inc &right_par_cnt
  // 584:   !locals(name) slot_idx
  // ...
  frame->slots[26] /* temp__1 */ = create_closure(entry__31_73, 1);
  // 575: for_each input_parameters: (parameter)
  // 576:   $name name_of(identifier_of(parameter))
  // 577:   cond
  // 578:     -> parameter.is_an_optional_item: inc &max_par_cnt
  // 579:     -> parameter.is_an_expanded_item: !has_rest_parameter true
  // 580:     :
  // 581:       inc &min_par_cnt
  // 582:       inc &max_par_cnt
  // 583:       if max_par_cnt > min_par_cnt: inc &right_par_cnt
  // 584:   !locals(name) slot_idx
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[17])->contents /* input_parameters */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_94;
}
static void entry__31_73(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // parameter: 0
  // max_par_cnt: 1
  // has_rest_parameter: 2
  // min_par_cnt: 3
  // right_par_cnt: 4
  // locals: 5
  // slot_idx: 6
  // is_shared: 7
  // name: 8
  frame->slots[1] = myself->closure.frame->slots[11]; /* max_par_cnt */
  frame->slots[2] = myself->closure.frame->slots[13]; /* has_rest_parameter */
  frame->slots[3] = myself->closure.frame->slots[10]; /* min_par_cnt */
  frame->slots[4] = myself->closure.frame->slots[12]; /* right_par_cnt */
  frame->slots[5] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[6] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[7] = myself->closure.frame->slots[9]; /* is_shared */
  frame->slots[8] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 576: ... identifier_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__31_74;
}
static void cont__31_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 576: $name name_of(identifier_of(parameter))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__31_75;
}
static void cont__31_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* name */, arguments->slots[0]);
  // 578: -> parameter.is_an_optional_item: inc &max_par_cnt
  frame->slots[9] /* temp__1 */ = create_closure(entry__31_76, 0);
  // 579: -> parameter.is_an_expanded_item: !has_rest_parameter true
  frame->slots[10] /* temp__2 */ = create_closure(entry__31_80, 0);
  // 580: :
  // 581:   inc &min_par_cnt
  // 582:   inc &max_par_cnt
  // 583:   if max_par_cnt > min_par_cnt: inc &right_par_cnt
  frame->slots[11] /* temp__3 */ = create_closure(entry__31_83, 0);
  // 577: cond
  // 578:   -> parameter.is_an_optional_item: inc &max_par_cnt
  // 579:   -> parameter.is_an_expanded_item: !has_rest_parameter true
  // 580:   :
  // 581:     inc &min_par_cnt
  // 582:     inc &max_par_cnt
  // 583:     if max_par_cnt > min_par_cnt: inc &right_par_cnt
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__2 */;
  arguments->slots[2] = frame->slots[11] /* temp__3 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__31_89;
}
static void entry__31_87(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // right_par_cnt: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* right_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 583: ... inc &right_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_88;
}
static void cont__31_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right_par_cnt */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_82(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_rest_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_rest_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 579: ... !has_rest_parameter true
  ((CELL *)frame->slots[0])->contents /* has_rest_parameter */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_78(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // max_par_cnt: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* max_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 578: ... inc &max_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* max_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_79;
}
static void cont__31_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* max_par_cnt */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_76(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // parameter: 0
  // max_par_cnt: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[1] = myself->closure.frame->slots[1]; /* max_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 578: ... parameter.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__31_77;
}
static void cont__31_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 578: ... : inc &max_par_cnt
  frame->slots[3] /* temp__2 */ = create_closure(entry__31_78, 0);
  // 578: -> parameter.is_an_optional_item: inc &max_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_80(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // parameter: 0
  // has_rest_parameter: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[1] = myself->closure.frame->slots[2]; /* has_rest_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 579: ... parameter.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__31_81;
}
static void cont__31_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 579: ... : !has_rest_parameter true
  frame->slots[3] /* temp__2 */ = create_closure(entry__31_82, 0);
  // 579: -> parameter.is_an_expanded_item: !has_rest_parameter true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_83(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // min_par_cnt: 0
  // max_par_cnt: 1
  // right_par_cnt: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* min_par_cnt */
  frame->slots[1] = myself->closure.frame->slots[1]; /* max_par_cnt */
  frame->slots[2] = myself->closure.frame->slots[4]; /* right_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 581: inc &min_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* min_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_84;
}
static void cont__31_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* min_par_cnt */ = arguments->slots[0];
  // 582: inc &max_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* max_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_85;
}
static void cont__31_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* max_par_cnt */ = arguments->slots[0];
  // 583: ... max_par_cnt > min_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* min_par_cnt */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* max_par_cnt */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__31_86;
}
static void cont__31_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 583: ... : inc &right_par_cnt
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_87, 0);
  // 583: if max_par_cnt > min_par_cnt: inc &right_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_89(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 584: !locals(name) slot_idx
  frame->slots[9] /* temp__1 */ = ((CELL *)frame->slots[6])->contents /* slot_idx */;
  // 584: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* name */;
  arguments->slots[1] = frame->slots[9] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[5])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__31_90;
}
static void cont__31_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* locals */ = arguments->slots[0];
  // 585: !is_shared(name) parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__31_91;
}
static void cont__31_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 585: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* name */;
  arguments->slots[1] = frame->slots[9] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[7])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__31_92;
}
static void cont__31_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[7])->contents /* is_shared */ = arguments->slots[0];
  // 586: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_93;
}
static void cont__31_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_94(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 587: ... : (parameter)
  // 588:   $name name_of(identifier_of(parameter))
  // 589:   case
  // 590:     parameter_kind_of(parameter)
  // 591:     MYSELF_PARAMETER:
  // 592:       !myself_parameter parameter
  // 593:     CONTINUATION_PARAMETER:
  // 594:       !continuation_parameter parameter
  // 595:   !locals(name) slot_idx
  // 596:   !is_shared(name) parameter.is_a_multi_assign_definition
  // ...
  frame->slots[26] /* temp__1 */ = create_closure(entry__31_95, 1);
  // 587: for_each implicit_parameters: (parameter)
  // 588:   $name name_of(identifier_of(parameter))
  // 589:   case
  // 590:     parameter_kind_of(parameter)
  // 591:     MYSELF_PARAMETER:
  // 592:       !myself_parameter parameter
  // 593:     CONTINUATION_PARAMETER:
  // 594:       !continuation_parameter parameter
  // 595:   !locals(name) slot_idx
  // 596:   !is_shared(name) parameter.is_a_multi_assign_definition
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[19])->contents /* implicit_parameters */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_106;
}
static void entry__31_95(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // parameter: 0
  // myself_parameter: 1
  // continuation_parameter: 2
  // locals: 3
  // slot_idx: 4
  // is_shared: 5
  // name: 6
  frame->slots[1] = myself->closure.frame->slots[15]; /* myself_parameter */
  frame->slots[2] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[3] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[4] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[5] = myself->closure.frame->slots[9]; /* is_shared */
  frame->slots[6] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 588: ... identifier_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__31_96;
}
static void cont__31_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 588: $name name_of(identifier_of(parameter))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__31_97;
}
static void cont__31_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* name */, arguments->slots[0]);
  // 590: parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__31_98;
}
static void cont__31_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 591: ... :
  // 592:   !myself_parameter parameter
  frame->slots[8] /* temp__2 */ = create_closure(entry__31_99, 0);
  // 593: ... :
  // 594:   !continuation_parameter parameter
  frame->slots[9] /* temp__3 */ = create_closure(entry__31_100, 0);
  // 589: case
  // 590:   parameter_kind_of(parameter)
  // 591:   MYSELF_PARAMETER:
  // 592:     !myself_parameter parameter
  // 593:   CONTINUATION_PARAMETER:
  // 594:     !continuation_parameter parameter
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = get__MYSELF_PARAMETER();
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  arguments->slots[3] = get__CONTINUATION_PARAMETER();
  arguments->slots[4] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__31_101;
}
static void entry__31_99(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // myself_parameter: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* myself_parameter */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 592: !myself_parameter parameter
  ((CELL *)frame->slots[0])->contents /* myself_parameter */ = frame->slots[1] /* parameter */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_100(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // continuation_parameter: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* continuation_parameter */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 594: !continuation_parameter parameter
  ((CELL *)frame->slots[0])->contents /* continuation_parameter */ = frame->slots[1] /* parameter */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_101(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 595: !locals(name) slot_idx
  frame->slots[7] /* temp__1 */ = ((CELL *)frame->slots[4])->contents /* slot_idx */;
  // 595: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* name */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__31_102;
}
static void cont__31_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* locals */ = arguments->slots[0];
  // 596: !is_shared(name) parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__31_103;
}
static void cont__31_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 596: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* name */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[5])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__31_104;
}
static void cont__31_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* is_shared */ = arguments->slots[0];
  // 597: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_105;
}
static void cont__31_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_106(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 599: ... max_par_cnt != min_par_cnt
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_107, 0);
  // 599: ... has_rest_parameter || max_par_cnt != min_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[13])->contents /* has_rest_parameter */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__31_110;
}
static void entry__31_107(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // max_par_cnt: 0
  // min_par_cnt: 1
  frame->slots[0] = myself->closure.frame->slots[11]; /* max_par_cnt */
  frame->slots[1] = myself->closure.frame->slots[10]; /* min_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 599: ... max_par_cnt != min_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* max_par_cnt */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* min_par_cnt */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_108;
}
static void cont__31_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 599: ... max_par_cnt != min_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__31_109;
}
static void cont__31_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 599: ... max_par_cnt != min_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 599: ... -> max_par_cnt
  frame->slots[28] /* temp__3 */ = create_closure(entry__31_111, 0);
  // 598: !par_count
  // 599:   if(has_rest_parameter || max_par_cnt != min_par_cnt (-> -1) -> max_par_cnt)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = func__31_112;
  arguments->slots[2] = frame->slots[28] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_114;
}
static void entry__31_111(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // max_par_cnt: 0
  frame->slots[0] = myself->closure.frame->slots[11]; /* max_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 599: ... -> max_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* max_par_cnt */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_112(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 599: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__31_113;
}
static void cont__31_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 599: ... -> -1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* par_count */ = arguments->slots[0];
  // 603: ... inherited_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__inherited_names_of();
  func = myself->type;
  frame->cont = cont__31_115;
}
static void cont__31_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 603: ... : (name _info)
  // 604:   !locals(name) slot_idx
  // 605:   !is_shared(name) is_an_inherited_shared_local(name)
  // 606:   inc &slot_idx
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_116, 2);
  // 603: for_each inherited_names_of(self): (name _info)
  // 604:   !locals(name) slot_idx
  // 605:   !is_shared(name) is_an_inherited_shared_local(name)
  // 606:   inc &slot_idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_121;
}
static void entry__31_116(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // name: 0
  // info: 1
  // locals: 2
  // slot_idx: 3
  // is_shared: 4
  // is_an_inherited_shared_local: 5
  frame->slots[2] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[3] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[4] = myself->closure.frame->slots[9]; /* is_shared */
  frame->slots[5] = myself->closure.frame->slots[4]; /* is_an_inherited_shared_local */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 604: !locals(name) slot_idx
  frame->slots[6] /* temp__1 */ = ((CELL *)frame->slots[3])->contents /* slot_idx */;
  // 604: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[2])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__31_117;
}
static void cont__31_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* locals */ = arguments->slots[0];
  // 605: !is_shared(name) is_an_inherited_shared_local(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = frame->slots[5] /* is_an_inherited_shared_local */;
  func = myself->type;
  frame->cont = cont__31_118;
}
static void cont__31_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 605: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[4])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__31_119;
}
static void cont__31_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* is_shared */ = arguments->slots[0];
  // 606: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_120;
}
static void cont__31_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_121(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 607: $locals_idx slot_idx
  initialize_maybe_future(frame->slots[20] /* locals_idx */, ((CELL *)frame->slots[7])->contents /* slot_idx */);
  // 611: ... defined_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__defined_names_of();
  func = myself->type;
  frame->cont = cont__31_122;
}
static void cont__31_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 611: ... : (name info)
  // 612:   unless info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER:
  // 613:     !locals(name) slot_idx
  // 614:     !is_shared(name) info.is_a_multi_assign_definition
  // 615:     inc &slot_idx
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_123, 2);
  // 611: for_each defined_names_of(self): (name info)
  // 612:   unless info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER:
  // 613:     !locals(name) slot_idx
  // 614:     !is_shared(name) info.is_a_multi_assign_definition
  // 615:     inc &slot_idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_135;
}
static void entry__31_130(void) {
  allocate_initialized_frame_gc(5, 6);
  // slot allocations:
  // locals: 0
  // name: 1
  // slot_idx: 2
  // is_shared: 3
  // info: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* locals */
  frame->slots[1] = myself->closure.frame->slots[0]; /* name */
  frame->slots[2] = myself->closure.frame->slots[3]; /* slot_idx */
  frame->slots[3] = myself->closure.frame->slots[4]; /* is_shared */
  frame->slots[4] = myself->closure.frame->slots[1]; /* info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 613: !locals(name) slot_idx
  frame->slots[5] /* temp__1 */ = ((CELL *)frame->slots[2])->contents /* slot_idx */;
  // 613: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__31_131;
}
static void cont__31_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* locals */ = arguments->slots[0];
  // 614: !is_shared(name) info.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* info */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__31_132;
}
static void cont__31_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 614: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__31_133;
}
static void cont__31_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* is_shared */ = arguments->slots[0];
  // 615: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_134;
}
static void cont__31_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_123(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // name: 0
  // info: 1
  // locals: 2
  // slot_idx: 3
  // is_shared: 4
  frame->slots[2] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[3] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[4] = myself->closure.frame->slots[9]; /* is_shared */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 612: ... info.is_a_parameter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* info */;
  result_count = 1;
  myself = get__is_a_parameter();
  func = myself->type;
  frame->cont = cont__31_124;
}
static void cont__31_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 612: ... parameter_kind_of(info) != OUT_PARAMETER
  frame->slots[7] /* temp__3 */ = create_closure(entry__31_125, 0);
  // 612: ... info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__31_129;
}
static void entry__31_125(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // info: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 612: ... parameter_kind_of(info)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* info */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__31_126;
}
static void cont__31_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 612: ... parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__OUT_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_127;
}
static void cont__31_127(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 612: ... parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__31_128;
}
static void cont__31_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 612: ... parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 612: ... :
  // 613:   !locals(name) slot_idx
  // 614:   !is_shared(name) info.is_a_multi_assign_definition
  // 615:   inc &slot_idx
  frame->slots[8] /* temp__4 */ = create_closure(entry__31_130, 0);
  // 612: unless info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER:
  // 613:   !locals(name) slot_idx
  // 614:   !is_shared(name) info.is_a_multi_assign_definition
  // 615:   inc &slot_idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_135(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 616: ... temporary_count_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__temporary_count_of();
  func = myself->type;
  frame->cont = cont__31_136;
}
static void cont__31_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 616: $total_slots slot_idx+temporary_count_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[7])->contents /* slot_idx */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__31_137;
}
static void cont__31_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[21] /* total_slots */, arguments->slots[0]);
  // 617: %current_locals locals
  initialize_maybe_future(get__current_locals(), ((CELL *)frame->slots[8])->contents /* locals */);
  // 618: %is_a_shared_local is_shared
  initialize_maybe_future(get__is_a_shared_local(), ((CELL *)frame->slots[9])->contents /* is_shared */);
  // 619: %temporary_offset slot_idx
  initialize_maybe_future(get__temporary_offset(), ((CELL *)frame->slots[7])->contents /* slot_idx */);
  // 620: ... "static NODE *func@(body_suffix);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_138;
  arguments->slots[1] = frame->slots[5] /* body_suffix */;
  arguments->slots[2] = string__31_139;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_140;
}
static void cont__31_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 620: write_to_declarations "static NODE *func@(body_suffix);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__31_141;
}
static void cont__31_141(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 621: ... :
  // 622:   %current_frame undefined
  // 623:   begin_continuation "entry@(body_suffix)"
  frame->slots[26] /* temp__1 */ = create_closure(entry__31_142, 0);
  // 621: do:
  // 622:   %current_frame undefined
  // 623:   begin_continuation "entry@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__31_146;
}
static void entry__31_142(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // return__1: 0
  // body_suffix: 1
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[5]; /* body_suffix */
  // _define %current_frame undefined
  define__current_frame(get_value_or_future__undefined());
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 622: %current_frame undefined
  initialize_maybe_future(get__current_frame(), get__undefined());
  // 623: ... "entry@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__31_143;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_144;
}
static void cont__31_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 623: begin_continuation "entry@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__begin_continuation();
  func = myself->type;
  frame->cont = cont__31_145;
}
static void cont__31_145(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__31_146(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 624: ... has_complex_default_values
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_147, 0);
  // 624: ... has_rest_parameter || has_complex_default_values
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[13])->contents /* has_rest_parameter */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__31_148;
}
static void entry__31_147(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[14]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 624: ... has_complex_default_values
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* has_complex_default_values */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_148(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 624: if has_rest_parameter || has_complex_default_values:
  // 625:   write "
  // 626:     @
  // 627:       allocate_arguments();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = func__31_149;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_151;
}
static void entry__31_149(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 625: write "
  // 626:   @
  // 627:     allocate_arguments();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_150;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_151(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 630: continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[16])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_152;
}
static void cont__31_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[27] /* temp__2 */ = arguments->slots[0];
  // 631: continuation_parameter.is_a_multi_assign_definition
  frame->slots[28] /* temp__3 */ = create_closure(entry__31_153, 0);
  // 629: &&
  // 630:   continuation_parameter.is_defined
  // 631:   continuation_parameter.is_a_multi_assign_definition
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[27] /* temp__2 */;
  arguments->slots[1] = frame->slots[28] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__31_155;
}
static void entry__31_153(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[16]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 631: continuation_parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__31_154;
}
static void cont__31_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 631: continuation_parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_155(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 628: if
  // 629:   &&
  // 630:     continuation_parameter.is_defined
  // 631:     continuation_parameter.is_a_multi_assign_definition
  // 632:   :
  // 633:     write "
  // 634:       @
  // 635:         caller_frame = frame;
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = func__31_156;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_158;
}
static void entry__31_156(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 633: write "
  // 634:   @
  // 635:     caller_frame = frame;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_157;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_158(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 636: ... "  allocate_initialized_frame_gc(@(locals_idx), @(total_slots));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_159;
  arguments->slots[1] = frame->slots[20] /* locals_idx */;
  arguments->slots[2] = string__31_160;
  arguments->slots[3] = frame->slots[21] /* total_slots */;
  arguments->slots[4] = string__31_161;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_162;
}
static void cont__31_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 636: write "  allocate_initialized_frame_gc(@(locals_idx), @(total_slots));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_163;
}
static void cont__31_163(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 637: writeln "  // slot allocations:"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_164;
  result_count = 0;
  myself = get__writeln();
  func = myself->type;
  frame->cont = cont__31_165;
}
static void cont__31_165(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 639: ... length_of(current_locals)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__current_locals();
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__31_166;
}
static void cont__31_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[27] /* temp__2 */ = arguments->slots[0];
  // 639: "static FRAME_INFO frame@(body_suffix) = {@(length_of(current_locals)), {"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_167;
  arguments->slots[1] = frame->slots[5] /* body_suffix */;
  arguments->slots[2] = string__31_168;
  arguments->slots[3] = frame->slots[27] /* temp__2 */;
  arguments->slots[4] = string__31_169;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_170;
}
static void cont__31_170(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 638: write_to_declarations
  // 639:   "static FRAME_INFO frame@(body_suffix) = {@(length_of(current_locals)), {"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__31_171;
}
static void cont__31_171(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 640: for_each current_locals: (name slot)
  // 641:   writeln "  // @(name): @(slot)"
  // 642:   if slot != 0: write_to_declarations ", "
  // 643:   write_to_declarations "@quot;@(name)@quot;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__current_locals();
  arguments->slots[1] = func__31_172;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_185;
}
static void entry__31_172(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // name: 0
  // slot: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 641: ... "  // @(name): @(slot)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__31_173;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__31_174;
  arguments->slots[3] = frame->slots[1] /* slot */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_175;
}
static void cont__31_175(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 641: writeln "  // @(name): @(slot)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__writeln();
  func = myself->type;
  frame->cont = cont__31_176;
}
static void cont__31_176(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 642: ... slot != 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* slot */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_177;
}
static void cont__31_177(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 642: ... slot != 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__31_178;
}
static void cont__31_178(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 642: if slot != 0: write_to_declarations ", "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = func__31_179;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_181;
}
static void entry__31_179(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 642: ... write_to_declarations ", "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_180;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_181(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 643: ... "@quot;@(name)@quot;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_182;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__31_183;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_184;
}
static void cont__31_184(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 643: write_to_declarations "@quot;@(name)@quot;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_185(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 644: write_to_declarations "
  // 645:   }};
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_186;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__31_187;
}
static void cont__31_187(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 646: %current_frame "frame@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__31_188;
  arguments->slots[1] = frame->slots[5] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_189;
}
static void cont__31_189(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__current_frame(), arguments->slots[0]);
  // 647: ... continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[16])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_190;
}
static void cont__31_190(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 647: ... :
  // 648:   assign_argument_or_result
  // 649:     "arguments"
  // 650:     continuation_parameter
  // 651:     if
  // 652:       output_parameters.is_empty
  // 653:       -> "create_continuation()"
  // 654:       :
  // 655:         write_to_declarations "
  // 656:           static void exit@(body_suffix)(void);
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_191, 0);
  // 647: if continuation_parameter.is_defined:
  // 648:   assign_argument_or_result
  // 649:     "arguments"
  // 650:     continuation_parameter
  // 651:     if
  // 652:       output_parameters.is_empty
  // 653:       -> "create_continuation()"
  // 654:       :
  // 655:         write_to_declarations "
  // 656:           static void exit@(body_suffix)(void);
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_205;
}
static void entry__31_191(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // continuation_parameter: 0
  // output_parameters: 1
  // body_suffix: 2
  frame->slots[0] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[1] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[2] = myself->closure.frame->slots[5]; /* body_suffix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 652: output_parameters.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__31_192;
}
static void cont__31_192(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 654: :
  // 655:   write_to_declarations "
  // 656:     static void exit@(body_suffix)(void);
  // 657:   -> "create_continuation_with_exit(exit@(body_suffix))"
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_193, 0);
  // 651: if
  // 652:   output_parameters.is_empty
  // 653:   -> "create_continuation()"
  // 654:   :
  // 655:     write_to_declarations "
  // 656:       static void exit@(body_suffix)(void);
  // 657:     -> "create_continuation_with_exit(exit@(body_suffix))"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = func__31_201;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_203;
}
static void entry__31_193(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // body_suffix: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* body_suffix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 655: ... "
  // 656:   static void exit@(body_suffix)(void);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_194;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__31_195;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_196;
}
static void cont__31_196(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 655: write_to_declarations "
  // 656:   static void exit@(body_suffix)(void);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__31_197;
}
static void cont__31_197(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 657: ... "create_continuation_with_exit(exit@(body_suffix))"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_198;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__31_199;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_200;
}
static void cont__31_200(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 657: -> "create_continuation_with_exit(exit@(body_suffix))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_201(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 653: -> "create_continuation()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_202;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_203(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 648: assign_argument_or_result
  // 649:   "arguments"
  // 650:   continuation_parameter
  // 651:   if
  // 652:     output_parameters.is_empty
  // 653:     -> "create_continuation()"
  // 654:     :
  // 655:       write_to_declarations "
  // 656:         static void exit@(body_suffix)(void);
  // 657:       -> "create_continuation_with_exit(exit@(body_suffix))"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_204;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_205(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 658: ... inherited_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__inherited_names_of();
  func = myself->type;
  frame->cont = cont__31_206;
}
static void cont__31_206(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 658: ... : (name _info)
  // 659:   write "
  // 660:     @
  // 661:       frame->slots[@(current_locals(name))] = @
  // 662:     myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_207, 2);
  // 658: for_each inherited_names_of(self): (name _info)
  // 659:   write "
  // 660:     @
  // 661:       frame->slots[@(current_locals(name))] = @
  // 662:     myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_215;
}
static void entry__31_207(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // name: 0
  // info: 1
  // parent_locals: 2
  frame->slots[2] = myself->closure.frame->slots[6]; /* parent_locals */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 661: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__31_208;
}
static void cont__31_208(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 662: ... parent_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = frame->slots[2] /* parent_locals */;
  func = myself->type;
  frame->cont = cont__31_209;
}
static void cont__31_209(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 659: ... "
  // 660:   @
  // 661:     frame->slots[@(current_locals(name))] = @
  // 662:   myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__31_210;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__31_211;
  arguments->slots[3] = frame->slots[5] /* temp__3 */;
  arguments->slots[4] = string__31_212;
  arguments->slots[5] = frame->slots[0] /* name */;
  arguments->slots[6] = string__31_213;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_214;
}
static void cont__31_214(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 659: write "
  // 660:   @
  // 661:     frame->slots[@(current_locals(name))] = @
  // 662:   myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_215(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 686: ... definitions_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__definitions_of();
  func = myself->type;
  frame->cont = cont__31_216;
}
static void cont__31_216(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 686: ... : (definition)
  // 687:   extract_destination_and_source $destination $source definition
  // 688:   if source.is_defined:
  // 689:     write_as_remark
  // 690:       "_define @(key_of(definition)) @(std::value_of(definition))"
  // 691:   case
  // 692:     variable_kind_of(destination)
  // 693:     STATIC_SINGLE, DYNAMIC_SINGLE:
  // 694:       if attribute_kind_of(destination) == NONE:
  // 695:         extract_source_or_create_future $src source
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_217, 1);
  // 686: for_each definitions_of(self): (definition)
  // 687:   extract_destination_and_source $destination $source definition
  // 688:   if source.is_defined:
  // 689:     write_as_remark
  // 690:       "_define @(key_of(definition)) @(std::value_of(definition))"
  // 691:   case
  // 692:     variable_kind_of(destination)
  // 693:     STATIC_SINGLE, DYNAMIC_SINGLE:
  // 694:       if attribute_kind_of(destination) == NONE:
  // 695:         extract_source_or_create_future $src source
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_246;
}
static void entry__31_232(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // extract_source_or_create_future: 0
  // source: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] /* src */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 695: extract_source_or_create_future $src source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = frame->slots[0] /* extract_source_or_create_future */;
  func = myself->type;
  frame->cont = cont__31_233;
}
static void cont__31_233(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 696: ... assignment_to_c(destination src)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  arguments->slots[1] = frame->slots[3] /* src */;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__31_234;
}
static void cont__31_234(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 696: write assignment_to_c(destination src)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_229(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // extract_source_or_create_future: 1
  // source: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[2]; /* extract_source_or_create_future */
  frame->slots[2] = myself->closure.frame->slots[5]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 694: ... attribute_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__31_230;
}
static void cont__31_230(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 694: ... attribute_kind_of(destination) == NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__NONE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_231;
}
static void cont__31_231(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 694: ... :
  // 695:   extract_source_or_create_future $src source
  // 696:   write assignment_to_c(destination src)
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_232, 0);
  // 694: if attribute_kind_of(destination) == NONE:
  // 695:   extract_source_or_create_future $src source
  // 696:   write assignment_to_c(destination src)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_235(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // destination: 0
  // locals: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* locals */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 698: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__31_236;
}
static void cont__31_236(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 698: $name name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__31_237;
}
static void cont__31_237(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 701: ... locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* name */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__31_238;
}
static void cont__31_238(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 699: ... "
  // 700:   @
  // 701:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_239;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__31_240;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__31_241;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_242;
}
static void cont__31_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 699: write "
  // 700:   @
  // 701:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_243(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // destination: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* destination */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 703: ... assignment_to_c(destination "undefined")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  arguments->slots[1] = string__31_244;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__31_245;
}
static void cont__31_245(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 703: write assignment_to_c(destination "undefined")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_217(void) {
  allocate_initialized_frame_gc(4, 11);
  // slot allocations:
  // definition: 0
  // extract_destination_and_source: 1
  // extract_source_or_create_future: 2
  // locals: 3
  // destination: 4
  // source: 5
  frame->slots[1] = myself->closure.frame->slots[22]; /* extract_destination_and_source */
  frame->slots[2] = myself->closure.frame->slots[23]; /* extract_source_or_create_future */
  frame->slots[3] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[4] /* destination */ = create_future();
  frame->slots[5] /* source */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 687: extract_destination_and_source $destination $source definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 2;
  myself = frame->slots[1] /* extract_destination_and_source */;
  func = myself->type;
  frame->cont = cont__31_218;
}
static void cont__31_218(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  frame->slots[7] /* temp__2 */ = arguments->slots[1];
  // 687: ... destination
  initialize_future(frame->slots[4] /* destination */, frame->slots[6] /* temp__1 */);
  // 687: ... source
  initialize_future(frame->slots[5] /* source */, frame->slots[7] /* temp__2 */);
  // 688: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_219;
}
static void cont__31_219(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 688: ... :
  // 689:   write_as_remark
  // 690:     "_define @(key_of(definition)) @(std::value_of(definition))"
  frame->slots[7] /* temp__2 */ = create_closure(entry__31_220, 0);
  // 688: if source.is_defined:
  // 689:   write_as_remark
  // 690:     "_define @(key_of(definition)) @(std::value_of(definition))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_226;
}
static void entry__31_220(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 690: ... key_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__key_of();
  func = myself->type;
  frame->cont = cont__31_221;
}
static void cont__31_221(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 690: ... std::value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__std__value_of();
  func = myself->type;
  frame->cont = cont__31_222;
}
static void cont__31_222(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 690: "_define @(key_of(definition)) @(std::value_of(definition))"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__31_223;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__31_224;
  arguments->slots[3] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_225;
}
static void cont__31_225(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 689: write_as_remark
  // 690:   "_define @(key_of(definition)) @(std::value_of(definition))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._write_as_remark;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_226(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 692: variable_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* destination */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__31_227;
}
static void cont__31_227(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 693: STATIC_SINGLE, DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__STATIC_SINGLE();
  arguments->slots[1] = get__DYNAMIC_SINGLE();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__31_228;
}
static void cont__31_228(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 693: ... :
  // 694:   if attribute_kind_of(destination) == NONE:
  // 695:     extract_source_or_create_future $src source
  // 696:     write assignment_to_c(destination src)
  frame->slots[8] /* temp__3 */ = create_closure(entry__31_229, 0);
  // 697: ... :
  // 698:   $name name_of(identifier_of(destination))
  // 699:   write "
  // 700:     @
  // 701:       frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  frame->slots[9] /* temp__4 */ = create_closure(entry__31_235, 0);
  // 702: ... :
  // 703:   write assignment_to_c(destination "undefined")
  frame->slots[10] /* temp__5 */ = create_closure(entry__31_243, 0);
  // 691: case
  // 692:   variable_kind_of(destination)
  // 693:   STATIC_SINGLE, DYNAMIC_SINGLE:
  // 694:     if attribute_kind_of(destination) == NONE:
  // 695:       extract_source_or_create_future $src source
  // 696:       write assignment_to_c(destination src)
  // 697:   STATIC_MULTI:
  // 698:     $name name_of(identifier_of(destination))
  // 699:     write "
  // 700:       @
  // ...
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  arguments->slots[3] = get__STATIC_MULTI();
  arguments->slots[4] = frame->slots[9] /* temp__4 */;
  arguments->slots[5] = get__DYNAMIC_MULTI();
  arguments->slots[6] = frame->slots[10] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_246(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 704: ... definitions_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__definitions_of();
  func = myself->type;
  frame->cont = cont__31_247;
}
static void cont__31_247(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 704: ... : (definition)
  // 705:   extract_destination_and_source $destination $source definition
  // 706:   if
  // 707:     &&
  // 708:       variable_kind_of(destination) == STATIC_SINGLE
  // 709:       attribute_kind_of(destination) != NONE
  // 710:     :
  // 711:       case
  // 712:         attribute_kind_of(destination)
  // 713:         ATTRIBUTE_KIND:
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_248, 1);
  // 704: for_each definitions_of(self): (definition)
  // 705:   extract_destination_and_source $destination $source definition
  // 706:   if
  // 707:     &&
  // 708:       variable_kind_of(destination) == STATIC_SINGLE
  // 709:       attribute_kind_of(destination) != NONE
  // 710:     :
  // 711:       case
  // 712:         attribute_kind_of(destination)
  // 713:         ATTRIBUTE_KIND:
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_292;
}
static void entry__31_273(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // extract_source_or_create_future: 0
  // source: 1
  // destination: 2
  // src: 3
  // attribute_name: 4
  // dest: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] /* src */ = create_future();
  frame->slots[4] /* attribute_name */ = create_future();
  frame->slots[5] /* dest */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 725: extract_source_or_create_future $src source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = frame->slots[0] /* extract_source_or_create_future */;
  func = myself->type;
  frame->cont = cont__31_274;
}
static void cont__31_274(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 726: ... attribute_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__31_275;
}
static void cont__31_275(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 726: $attribute_name mangled_name_of(attribute_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__31_276;
}
static void cont__31_276(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* attribute_name */, arguments->slots[0]);
  // 727: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__31_277;
}
static void cont__31_277(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 727: $dest identifier_of(destination).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_278;
}
static void cont__31_278(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* dest */, arguments->slots[0]);
  // 728: ... "
  // 729:   @
  // 730:     update_start_p = node_p;
  // 731:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 732:   @(src));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__31_279;
  arguments->slots[1] = frame->slots[5] /* dest */;
  arguments->slots[2] = string__31_280;
  arguments->slots[3] = frame->slots[4] /* attribute_name */;
  arguments->slots[4] = string__31_281;
  arguments->slots[5] = frame->slots[3] /* src */;
  arguments->slots[6] = string__31_282;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_283;
}
static void cont__31_283(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 728: write "
  // 729:   @
  // 730:     update_start_p = node_p;
  // 731:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 732:   @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_284(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // source: 0
  // destination: 1
  // entry: 2
  // fun_par_count: 3
  // dest: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[2] /* entry */ = create_future();
  frame->slots[3] /* fun_par_count */ = create_future();
  frame->slots[4] /* dest */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 734: to_c $entry $_fun_par_count source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 2;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_285;
}
static void cont__31_285(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  frame->slots[6] /* temp__2 */ = arguments->slots[1];
  // 734: ... entry
  initialize_future(frame->slots[2] /* entry */, frame->slots[5] /* temp__1 */);
  // 734: ... _fun_par_count
  initialize_future(frame->slots[3] /* fun_par_count */, frame->slots[6] /* temp__2 */);
  // 738: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__31_286;
}
static void cont__31_286(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 738: $dest identifier_of(destination).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_287;
}
static void cont__31_287(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* dest */, arguments->slots[0]);
  // 739: ... "
  // 740:   @
  // 741:     update_start_p = node_p;
  // 742:     def_attribute(&@(dest), -1, @(entry));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_288;
  arguments->slots[1] = frame->slots[4] /* dest */;
  arguments->slots[2] = string__31_289;
  arguments->slots[3] = frame->slots[2] /* entry */;
  arguments->slots[4] = string__31_290;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_291;
}
static void cont__31_291(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 739: write "
  // 740:   @
  // 741:     update_start_p = node_p;
  // 742:     def_attribute(&@(dest), -1, @(entry));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_259(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // extract_source_or_create_future: 0
  // source: 1
  // destination: 2
  // src: 3
  // attribute_name: 4
  // dest: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] /* src */ = create_future();
  frame->slots[4] /* attribute_name */ = create_future();
  frame->slots[5] /* dest */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 714: extract_source_or_create_future $src source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = frame->slots[0] /* extract_source_or_create_future */;
  func = myself->type;
  frame->cont = cont__31_260;
}
static void cont__31_260(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 715: ... attribute_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__31_261;
}
static void cont__31_261(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 715: $attribute_name mangled_name_of(attribute_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__31_262;
}
static void cont__31_262(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* attribute_name */, arguments->slots[0]);
  // 716: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__31_263;
}
static void cont__31_263(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 716: $dest identifier_of(destination).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_264;
}
static void cont__31_264(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* dest */, arguments->slots[0]);
  // 717: ... "
  // 718:   @
  // 719:     update_start_p = node_p;
  // 720:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 721:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__31_265;
  arguments->slots[1] = frame->slots[5] /* dest */;
  arguments->slots[2] = string__31_266;
  arguments->slots[3] = frame->slots[4] /* attribute_name */;
  arguments->slots[4] = string__31_267;
  arguments->slots[5] = frame->slots[3] /* src */;
  arguments->slots[6] = string__31_268;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_269;
}
static void cont__31_269(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 717: write "
  // 718:   @
  // 719:     update_start_p = node_p;
  // 720:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 721:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_270(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // destination: 0
  // extract_source_or_create_future: 1
  // source: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[2] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 724: attribute_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__31_271;
}
static void cont__31_271(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 724: attribute_of(destination).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_272;
}
static void cont__31_272(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 724: ... :
  // 725:   extract_source_or_create_future $src source
  // 726:   $attribute_name mangled_name_of(attribute_of(destination))
  // 727:   $dest identifier_of(destination).to_c
  // 728:   write "
  // 729:     @
  // 730:       update_start_p = node_p;
  // 731:       def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 732:     @(src));
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_273, 0);
  // 733: :
  // 734:   to_c $entry $_fun_par_count source
  // 735:   
  // 736:   #ewriteln name "/:"
  // 737:   
  // 738:   $dest identifier_of(destination).to_c
  // 739:   write "
  // 740:     @
  // 741:       update_start_p = node_p;
  // 742:       def_attribute(&@(dest), -1, @(entry));
  frame->slots[6] /* temp__4 */ = create_closure(entry__31_284, 0);
  // 723: if
  // 724:   attribute_of(destination).is_defined:
  // 725:     extract_source_or_create_future $src source
  // 726:     $attribute_name mangled_name_of(attribute_of(destination))
  // 727:     $dest identifier_of(destination).to_c
  // 728:     write "
  // 729:       @
  // 730:         update_start_p = node_p;
  // 731:         def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 732:       @(src));
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_257(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // extract_source_or_create_future: 1
  // source: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[2]; /* extract_source_or_create_future */
  frame->slots[2] = myself->closure.frame->slots[4]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 712: attribute_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__31_258;
}
static void cont__31_258(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 713: ... :
  // 714:   extract_source_or_create_future $src source
  // 715:   $attribute_name mangled_name_of(attribute_of(destination))
  // 716:   $dest identifier_of(destination).to_c
  // 717:   write "
  // 718:     @
  // 719:       update_start_p = node_p;
  // 720:       def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 721:     MAKE_ATTRIBUTE_VALUE(@(src)));
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_259, 0);
  // 722: ... :
  // 723:   if
  // 724:     attribute_of(destination).is_defined:
  // 725:       extract_source_or_create_future $src source
  // 726:       $attribute_name mangled_name_of(attribute_of(destination))
  // 727:       $dest identifier_of(destination).to_c
  // 728:       write "
  // 729:         @
  // 730:           update_start_p = node_p;
  // 731:           def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_270, 0);
  // 711: case
  // 712:   attribute_kind_of(destination)
  // 713:   ATTRIBUTE_KIND:
  // 714:     extract_source_or_create_future $src source
  // 715:     $attribute_name mangled_name_of(attribute_of(destination))
  // 716:     $dest identifier_of(destination).to_c
  // 717:     write "
  // 718:       @
  // 719:         update_start_p = node_p;
  // 720:         def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // ...
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = get__ATTRIBUTE_KIND();
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  arguments->slots[3] = get__METHOD_KIND();
  arguments->slots[4] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_248(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // definition: 0
  // extract_destination_and_source: 1
  // extract_source_or_create_future: 2
  // destination: 3
  // source: 4
  frame->slots[1] = myself->closure.frame->slots[22]; /* extract_destination_and_source */
  frame->slots[2] = myself->closure.frame->slots[23]; /* extract_source_or_create_future */
  frame->slots[3] /* destination */ = create_future();
  frame->slots[4] /* source */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 705: extract_destination_and_source $destination $source definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 2;
  myself = frame->slots[1] /* extract_destination_and_source */;
  func = myself->type;
  frame->cont = cont__31_249;
}
static void cont__31_249(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  frame->slots[6] /* temp__2 */ = arguments->slots[1];
  // 705: ... destination
  initialize_future(frame->slots[3] /* destination */, frame->slots[5] /* temp__1 */);
  // 705: ... source
  initialize_future(frame->slots[4] /* source */, frame->slots[6] /* temp__2 */);
  // 708: variable_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* destination */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__31_250;
}
static void cont__31_250(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 708: variable_kind_of(destination) == STATIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  arguments->slots[1] = get__STATIC_SINGLE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_251;
}
static void cont__31_251(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 709: attribute_kind_of(destination) != NONE
  frame->slots[8] /* temp__4 */ = create_closure(entry__31_252, 0);
  // 707: &&
  // 708:   variable_kind_of(destination) == STATIC_SINGLE
  // 709:   attribute_kind_of(destination) != NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__31_256;
}
static void entry__31_252(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // destination: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* destination */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 709: attribute_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__31_253;
}
static void cont__31_253(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 709: attribute_kind_of(destination) != NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__NONE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_254;
}
static void cont__31_254(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 709: attribute_kind_of(destination) != NONE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__31_255;
}
static void cont__31_255(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 709: attribute_kind_of(destination) != NONE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_256(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 710: :
  // 711:   case
  // 712:     attribute_kind_of(destination)
  // 713:     ATTRIBUTE_KIND:
  // 714:       extract_source_or_create_future $src source
  // 715:       $attribute_name mangled_name_of(attribute_of(destination))
  // 716:       $dest identifier_of(destination).to_c
  // 717:       write "
  // 718:         @
  // 719:           update_start_p = node_p;
  // ...
  frame->slots[9] /* temp__5 */ = create_closure(entry__31_257, 0);
  // 706: if
  // 707:   &&
  // 708:     variable_kind_of(destination) == STATIC_SINGLE
  // 709:     attribute_kind_of(destination) != NONE
  // 710:   :
  // 711:     case
  // 712:       attribute_kind_of(destination)
  // 713:       ATTRIBUTE_KIND:
  // 714:         extract_source_or_create_future $src source
  // 715:         $attribute_name mangled_name_of(attribute_of(destination))
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_292(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 743: ... :
  // 744:   collect_output $code: extract "arguments" input_parameters
  // 745:   write code
  frame->slots[26] /* temp__1 */ = create_closure(entry__31_293, 0);
  // 743: do:
  // 744:   collect_output $code: extract "arguments" input_parameters
  // 745:   write code
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__31_297;
}
static void entry__31_293(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // input_parameters: 0
  // code: 1
  frame->slots[0] = myself->closure.frame->slots[17]; /* input_parameters */
  frame->slots[1] /* code */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 744: ... : extract "arguments" input_parameters
  frame->slots[2] /* temp__1 */ = create_closure(entry__31_294, 0);
  // 744: collect_output $code: extract "arguments" input_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__collect_output();
  func = myself->type;
  frame->cont = cont__31_296;
}
static void entry__31_294(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // input_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* input_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 744: ... extract "arguments" input_parameters
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__31_295;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* input_parameters */;
  result_count = frame->caller_result_count;
  myself = var._extract;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_296(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* code */, arguments->slots[0]);
  // 745: write code
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* code */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_297(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 746: ... myself_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[15])->contents /* myself_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_298;
}
static void cont__31_298(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 746: ... :
  // 747:   assign_argument_or_result "arguments" myself_parameter "myself"
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_299, 0);
  // 746: if myself_parameter.is_defined:
  // 747:   assign_argument_or_result "arguments" myself_parameter "myself"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_302;
}
static void entry__31_299(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // myself_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[15]; /* myself_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 747: assign_argument_or_result "arguments" myself_parameter "myself"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_300;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* myself_parameter */;
  arguments->slots[2] = string__31_301;
  result_count = frame->caller_result_count;
  myself = var._assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_302(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 748: ... : (parameter)
  // 749:   unless parameter_kind_of(parameter) == IN_OUT_PARAMETER:
  // 750:     $name name_of(identifier_of(parameter))
  // 751:     write "
  // 752:       @
  // 753:         frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  frame->slots[26] /* temp__1 */ = create_closure(entry__31_303, 1);
  // 748: for_each output_parameters: (parameter)
  // 749:   unless parameter_kind_of(parameter) == IN_OUT_PARAMETER:
  // 750:     $name name_of(identifier_of(parameter))
  // 751:     write "
  // 752:       @
  // 753:         frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[18])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__31_314;
}
static void entry__31_306(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // parameter: 0
  // locals: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[1] = myself->closure.frame->slots[1]; /* locals */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 750: ... identifier_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__31_307;
}
static void cont__31_307(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 750: $name name_of(identifier_of(parameter))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__31_308;
}
static void cont__31_308(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 753: ... locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* name */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__31_309;
}
static void cont__31_309(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 751: ... "
  // 752:   @
  // 753:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_310;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__31_311;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__31_312;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_313;
}
static void cont__31_313(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 751: write "
  // 752:   @
  // 753:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_303(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // parameter: 0
  // locals: 1
  frame->slots[1] = myself->closure.frame->slots[8]; /* locals */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 749: ... parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__31_304;
}
static void cont__31_304(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 749: ... parameter_kind_of(parameter) == IN_OUT_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__IN_OUT_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_305;
}
static void cont__31_305(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 749: ... :
  // 750:   $name name_of(identifier_of(parameter))
  // 751:   write "
  // 752:     @
  // 753:       frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  frame->slots[4] /* temp__3 */ = create_closure(entry__31_306, 0);
  // 749: unless parameter_kind_of(parameter) == IN_OUT_PARAMETER:
  // 750:   $name name_of(identifier_of(parameter))
  // 751:   write "
  // 752:     @
  // 753:       frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_314(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 754: $statements statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__31_315;
}
static void cont__31_315(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[24] /* statements */, arguments->slots[0]);
  // 780: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__31_316;
}
static void cont__31_316(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 780: for_each_from_to statements 1 -2: (statement) generate_statement statement
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[24] /* statements */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[26] /* temp__1 */;
  arguments->slots[3] = func__31_317;
  result_count = 0;
  myself = get__for_each_from_to();
  func = myself->type;
  frame->cont = cont__31_318;
}
static void entry__31_317(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // statement: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 780: ... generate_statement statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = frame->caller_result_count;
  myself = get__generate_statement();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_318(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 782: is_empty(statements)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[24] /* statements */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__31_319;
}
static void cont__31_319(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 782: ... : # there might be only definitions
  // 783:   generate_exit
  frame->slots[27] /* temp__2 */ = create_closure(entry__31_320, 0);
  // 784: :
  // 785:   $statement statements(-1)
  // 786:   cond
  // 787:     -> statement.is_a_return:
  // 788:       write_source_as_remark statement
  // 789:       
  // 790:       #if
  // 791:         continuation_parameter.is_defined &&
  // 792:         (
  // 793:           not(output_parameters.is_empty) ||
  // ...
  frame->slots[28] /* temp__3 */ = create_closure(entry__31_321, 0);
  // 781: if
  // 782:   is_empty(statements): # there might be only definitions
  // 783:     generate_exit
  // 784:   :
  // 785:     $statement statements(-1)
  // 786:     cond
  // 787:       -> statement.is_a_return:
  // 788:         write_source_as_remark statement
  // 789:         
  // 790:         #if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  arguments->slots[2] = frame->slots[28] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_427;
}
static void entry__31_396(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // output_parameters: 1
  // n: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[0]; /* output_parameters */
  frame->slots[2] /* n */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 868: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_397;
}
static void cont__31_397(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 869: ... "cont@(suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__31_398;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__31_399;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_400;
}
static void cont__31_400(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 869: get_func_and_myself functor "cont@(suffix)_@(index)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = var._get_func_and_myself;
  func = myself->type;
  frame->cont = cont__31_401;
}
static void cont__31_401(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 870: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_402;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_403;
}
static void cont__31_403(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 871: ... "cont@(suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__31_404;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__31_405;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_406;
}
static void cont__31_406(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 871: next_continuation "cont@(suffix)_@(index)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__next_continuation();
  func = myself->type;
  frame->cont = cont__31_407;
}
static void cont__31_407(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 872: $n count_arguments(output_parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = var._count_arguments;
  func = myself->type;
  frame->cont = cont__31_408;
}
static void cont__31_408(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* n */, arguments->slots[0]);
  // 874: n.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* n */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_409;
}
static void cont__31_409(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 874: ... :
  // 875:   write "
  // 876:     @
  // 877:       int i = argument_count;
  // 878:       while (--i >= 0) {
  // 879:         arguments->slots[i+@(n)] = arguments->slots[i];
  // 880:       }
  // 881:   generate_c_arguments output_parameters true
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_410, 0);
  // 882: :
  // 883:   write "
  // 884:     @
  // 885:       int i;
  // 886:       int n = argument_count;
  // 887:       FRAME *return_arguments = arguments;
  // 888:       allocate_arguments();
  // 889:   generate_c_arguments output_parameters
  // 890:   write "
  // 891:     @
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_415, 0);
  // 873: if
  // 874:   n.is_defined:
  // 875:     write "
  // 876:       @
  // 877:         int i = argument_count;
  // 878:         while (--i >= 0) {
  // 879:           arguments->slots[i+@(n)] = arguments->slots[i];
  // 880:         }
  // 881:     generate_c_arguments output_parameters true
  // 882:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_420;
}
static void entry__31_410(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // n: 0
  // output_parameters: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* n */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 875: ... "
  // 876:   @
  // 877:     int i = argument_count;
  // 878:     while (--i >= 0) {
  // 879:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 880:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_411;
  arguments->slots[1] = frame->slots[0] /* n */;
  arguments->slots[2] = string__31_412;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_413;
}
static void cont__31_413(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 875: write "
  // 876:   @
  // 877:     int i = argument_count;
  // 878:     while (--i >= 0) {
  // 879:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 880:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_414;
}
static void cont__31_414(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 881: generate_c_arguments output_parameters true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  arguments->slots[1] = get__true();
  result_count = frame->caller_result_count;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_415(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // output_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 883: write "
  // 884:   @
  // 885:     int i;
  // 886:     int n = argument_count;
  // 887:     FRAME *return_arguments = arguments;
  // 888:     allocate_arguments();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_416;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_417;
}
static void cont__31_417(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 889: generate_c_arguments output_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 0;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__31_418;
}
static void cont__31_418(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 890: write "
  // 891:   @
  // 892:     for (i = 0; i < n; ++i) {
  // 893:       arguments->slots[argument_count++] = @
  // 894:   return_arguments->slots[i];
  // 895:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_419;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_420(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 896: write "
  // 897:   @
  // 898:     frame = frame->caller_frame;
  // 899:     func = frame->cont;
  // 900:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_421;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_376(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // functor: 0
  // statement: 1
  // continuation_parameter: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[2]; /* statement */
  frame->slots[2] = myself->closure.frame->slots[0]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 853: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__31_377;
}
static void cont__31_377(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 854: ... "cont@(suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__31_378;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__31_379;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_380;
}
static void cont__31_380(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 854: get_func_and_myself functor "cont@(suffix)_@(index)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = var._get_func_and_myself;
  func = myself->type;
  frame->cont = cont__31_381;
}
static void cont__31_381(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 855: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_382;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_383;
}
static void cont__31_383(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 856: ... "cont@(suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__31_384;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__31_385;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_386;
}
static void cont__31_386(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 856: next_continuation "cont@(suffix)_@(index)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__next_continuation();
  func = myself->type;
  frame->cont = cont__31_387;
}
static void cont__31_387(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 857: compute_source_text_info
  // 858:   statement
  // 859:   false
  // 860:   true
  // 861:   !current_continuation_info
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  arguments->slots[1] = get__false();
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._compute_source_text_info;
  func = myself->type;
  frame->cont = cont__31_388;
}
static void cont__31_388(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__current_continuation_info(arguments->slots[0]);
  // 864: ... continuation_parameter.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_389;
}
static void cont__31_389(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 862: ... "
  // 863:   @
  // 864:     myself = @(continuation_parameter.to_c);
  // 865:     func = myself->type;
  // 866:     frame->cont = invalid_continuation;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_390;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__31_391;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_392;
}
static void cont__31_392(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 862: write "
  // 863:   @
  // 864:     myself = @(continuation_parameter.to_c);
  // 865:     func = myself->type;
  // 866:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_374(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // continuation_parameter: 0
  // functor: 1
  // statement: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* continuation_parameter */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[2] = myself->closure.frame->slots[3]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 852: ... continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_375;
}
static void cont__31_375(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 852: ... :
  // 853:   inc &index
  // 854:   get_func_and_myself functor "cont@(suffix)_@(index)"
  // 855:   write "}@nl;"
  // 856:   next_continuation "cont@(suffix)_@(index)"
  // 857:   compute_source_text_info
  // 858:     statement
  // 859:     false
  // 860:     true
  // 861:     !current_continuation_info
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_376, 0);
  // 852: -> continuation_parameter.is_defined:
  // 853:   inc &index
  // 854:   get_func_and_myself functor "cont@(suffix)_@(index)"
  // 855:   write "}@nl;"
  // 856:   next_continuation "cont@(suffix)_@(index)"
  // 857:   compute_source_text_info
  // 858:     statement
  // 859:     false
  // 860:     true
  // 861:     !current_continuation_info
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_393(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // output_parameters: 0
  // functor: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* output_parameters */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 867: ... output_parameters.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__31_394;
}
static void cont__31_394(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 867: ... not(output_parameters.is_empty)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__31_395;
}
static void cont__31_395(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 867: ... :
  // 868:   inc &index
  // 869:   get_func_and_myself functor "cont@(suffix)_@(index)"
  // 870:   write "}@nl;"
  // 871:   next_continuation "cont@(suffix)_@(index)"
  // 872:   $n count_arguments(output_parameters)
  // 873:   if
  // 874:     n.is_defined:
  // 875:       write "
  // 876:         @
  // ...
  frame->slots[4] /* temp__3 */ = create_closure(entry__31_396, 0);
  // 867: -> not(output_parameters.is_empty):
  // 868:   inc &index
  // 869:   get_func_and_myself functor "cont@(suffix)_@(index)"
  // 870:   write "}@nl;"
  // 871:   next_continuation "cont@(suffix)_@(index)"
  // 872:   $n count_arguments(output_parameters)
  // 873:   if
  // 874:     n.is_defined:
  // 875:       write "
  // 876:         @
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_422(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 902: get_func_and_myself
  // 903:   functor
  // 904:   "frame->cont"
  // 905:   "frame = frame->caller_frame;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = string__31_423;
  arguments->slots[2] = string__31_424;
  result_count = frame->caller_result_count;
  myself = var._get_func_and_myself;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_355(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // functor: 0
  // statement: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 825: get_func_and_myself functor "continuation_trampoline"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = string__31_356;
  result_count = 0;
  myself = var._get_func_and_myself;
  func = myself->type;
  frame->cont = cont__31_357;
}
static void cont__31_357(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 828: ... continuation_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  result_count = 1;
  myself = get__continuation_of();
  func = myself->type;
  frame->cont = cont__31_358;
}
static void cont__31_358(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 828: ... continuation_of(statement).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_359;
}
static void cont__31_359(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 826: ... "
  // 827:   @
  // 828:     frame->slots[0] = @(continuation_of(statement).to_c);
  // 829:     if (frame->slots[0]->type != continuation_type_function)
  // 830:       invalid_continuation_error();
  // 831:     frame->slot_count = 1;
  // 832:     frame->caller_frame = NULL;
  // 833:     result_count = frame->slots[0]->continuation.result_count;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_360;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__31_361;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_362;
}
static void cont__31_362(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 826: write "
  // 827:   @
  // 828:     frame->slots[0] = @(continuation_of(statement).to_c);
  // 829:     if (frame->slots[0]->type != continuation_type_function)
  // 830:       invalid_continuation_error();
  // 831:     frame->slot_count = 1;
  // 832:     frame->caller_frame = NULL;
  // 833:     result_count = frame->slots[0]->continuation.result_count;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_363(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // result_count: 0
  // continuation_parameter: 1
  // functor: 2
  // statement: 3
  // output_parameters: 4
  frame->slots[0] = myself->closure.frame->slots[5]; /* result_count */
  frame->slots[1] = myself->closure.frame->slots[2]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor */
  frame->slots[3] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[4] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 845: :
  // 846:   write "
  // 847:     @
  // 848:       result_count =
  // 849:         frame->caller_result_count >= @(result_count) ?
  // 850:         frame->caller_result_count-@(result_count) : -1;
  frame->slots[5] /* temp__1 */ = create_closure(entry__31_364, 0);
  // 835: case
  // 836:   result_count
  // 837:   undefined:
  // 838:     write "
  // 839:       @
  // 840:         result_count = -1;
  // 841:   0:
  // 842:     write "
  // 843:       @
  // 844:         result_count = frame->caller_result_count;
  // ...
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* result_count */;
  arguments->slots[1] = get__undefined();
  arguments->slots[2] = func__31_369;
  arguments->slots[3] = number__0;
  arguments->slots[4] = func__31_371;
  arguments->slots[5] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__31_373;
}
static void entry__31_364(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // result_count: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* result_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 846: ... "
  // 847:   @
  // 848:     result_count =
  // 849:       frame->caller_result_count >= @(result_count) ?
  // 850:       frame->caller_result_count-@(result_count) : -1;
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_365;
  arguments->slots[1] = frame->slots[0] /* result_count */;
  arguments->slots[2] = string__31_366;
  arguments->slots[3] = frame->slots[0] /* result_count */;
  arguments->slots[4] = string__31_367;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_368;
}
static void cont__31_368(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 846: write "
  // 847:   @
  // 848:     result_count =
  // 849:       frame->caller_result_count >= @(result_count) ?
  // 850:       frame->caller_result_count-@(result_count) : -1;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_369(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 838: write "
  // 839:   @
  // 840:     result_count = -1;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_370;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_371(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 842: write "
  // 843:   @
  // 844:     result_count = frame->caller_result_count;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_372;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_373(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 852: -> continuation_parameter.is_defined:
  // 853:   inc &index
  // 854:   get_func_and_myself functor "cont@(suffix)_@(index)"
  // 855:   write "}@nl;"
  // 856:   next_continuation "cont@(suffix)_@(index)"
  // 857:   compute_source_text_info
  // 858:     statement
  // 859:     false
  // 860:     true
  // 861:     !current_continuation_info
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__31_374, 0);
  // 867: -> not(output_parameters.is_empty):
  // 868:   inc &index
  // 869:   get_func_and_myself functor "cont@(suffix)_@(index)"
  // 870:   write "}@nl;"
  // 871:   next_continuation "cont@(suffix)_@(index)"
  // 872:   $n count_arguments(output_parameters)
  // 873:   if
  // 874:     n.is_defined:
  // 875:       write "
  // 876:         @
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__31_393, 0);
  // 901: :
  // 902:   get_func_and_myself
  // 903:     functor
  // 904:     "frame->cont"
  // 905:     "frame = frame->caller_frame;"
  frame->slots[7] /* temp__3 */ = create_closure(entry__31_422, 0);
  // 851: cond
  // 852:   -> continuation_parameter.is_defined:
  // 853:     inc &index
  // 854:     get_func_and_myself functor "cont@(suffix)_@(index)"
  // 855:     write "}@nl;"
  // 856:     next_continuation "cont@(suffix)_@(index)"
  // 857:     compute_source_text_info
  // 858:       statement
  // 859:       false
  // 860:       true
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_347(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // statement: 0
  // output_parameters: 1
  // continuation_parameter: 2
  // functor: 3
  // input_arguments: 4
  // result_count: 5
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output_parameters */
  frame->slots[2] = myself->closure.frame->slots[2]; /* continuation_parameter */
  frame->slots[3] /* functor */ = create_future();
  frame->slots[4] /* input_arguments */ = create_future();
  frame->slots[5] /* result_count */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 818: write_source_as_remark statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__write_source_as_remark();
  func = myself->type;
  frame->cont = cont__31_348;
}
static void cont__31_348(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 819: $functor functor_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__31_349;
}
static void cont__31_349(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* functor */, arguments->slots[0]);
  // 820: $input_arguments arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__31_350;
}
static void cont__31_350(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* input_arguments */, arguments->slots[0]);
  // 821: $result_count count_arguments(output_parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = var._count_arguments;
  func = myself->type;
  frame->cont = cont__31_351;
}
static void cont__31_351(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* result_count */, arguments->slots[0]);
  // 822: generate_c_arguments input_arguments
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* input_arguments */;
  result_count = 0;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__31_352;
}
static void cont__31_352(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 824: continuation_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__continuation_of();
  func = myself->type;
  frame->cont = cont__31_353;
}
static void cont__31_353(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 824: continuation_of(statement).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_354;
}
static void cont__31_354(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 824: ... :
  // 825:   get_func_and_myself functor "continuation_trampoline"
  // 826:   write "
  // 827:     @
  // 828:       frame->slots[0] = @(continuation_of(statement).to_c);
  // 829:       if (frame->slots[0]->type != continuation_type_function)
  // 830:         invalid_continuation_error();
  // 831:       frame->slot_count = 1;
  // 832:       frame->caller_frame = NULL;
  // 833:       result_count = frame->slots[0]->continuation.result_count;
  frame->slots[8] /* temp__3 */ = create_closure(entry__31_355, 0);
  // 834: :
  // 835:   case
  // 836:     result_count
  // 837:     undefined:
  // 838:       write "
  // 839:         @
  // 840:           result_count = -1;
  // 841:     0:
  // 842:       write "
  // 843:         @
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__31_363, 0);
  // 823: if
  // 824:   continuation_of(statement).is_defined:
  // 825:     get_func_and_myself functor "continuation_trampoline"
  // 826:     write "
  // 827:       @
  // 828:         frame->slots[0] = @(continuation_of(statement).to_c);
  // 829:         if (frame->slots[0]->type != continuation_type_function)
  // 830:           invalid_continuation_error();
  // 831:         frame->slot_count = 1;
  // 832:         frame->caller_frame = NULL;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_329(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // statement: 0
  // continuation_parameter: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 799: ... arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__31_330;
}
static void cont__31_330(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 799: generate_c_arguments arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__31_331;
}
static void cont__31_331(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 802: ... continuation_parameter.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__31_332;
}
static void cont__31_332(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 800: ... "
  // 801:   @
  // 802:     myself = @(continuation_parameter.to_c);
  // 803:     func = myself->type;
  // 804:     frame->cont = invalid_continuation;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_333;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__31_334;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_335;
}
static void cont__31_335(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 800: write "
  // 801:   @
  // 802:     myself = @(continuation_parameter.to_c);
  // 803:     func = myself->type;
  // 804:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_336(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // output_parameters: 0
  // statement: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* output_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 807: ... arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__31_337;
}
static void cont__31_337(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 807: append(output_parameters arguments_of(statement))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__31_338;
}
static void cont__31_338(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 806: generate_c_arguments
  // 807:   append(output_parameters arguments_of(statement))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__31_339;
}
static void cont__31_339(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 808: write "
  // 809:   @
  // 810:     frame = frame->caller_frame;
  // 811:     func = frame->cont;
  // 812:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_340;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_326(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // statement: 0
  // continuation_parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 788: write_source_as_remark statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__write_source_as_remark();
  func = myself->type;
  frame->cont = cont__31_327;
}
static void cont__31_327(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 798: continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_328;
}
static void cont__31_328(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 798: ... :
  // 799:   generate_c_arguments arguments_of(statement)
  // 800:   write "
  // 801:     @
  // 802:       myself = @(continuation_parameter.to_c);
  // 803:       func = myself->type;
  // 804:       frame->cont = invalid_continuation;
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_329, 0);
  // 805: :
  // 806:   generate_c_arguments
  // 807:     append(output_parameters arguments_of(statement))
  // 808:   write "
  // 809:     @
  // 810:       frame = frame->caller_frame;
  // 811:       func = frame->cont;
  // 812:       frame->cont = invalid_continuation;
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_336, 0);
  // 797: if
  // 798:   continuation_parameter.is_defined:
  // 799:     generate_c_arguments arguments_of(statement)
  // 800:     write "
  // 801:       @
  // 802:         myself = @(continuation_parameter.to_c);
  // 803:         func = myself->type;
  // 804:         frame->cont = invalid_continuation;
  // 805:   :
  // 806:     generate_c_arguments
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_324(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // statement: 0
  // continuation_parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 787: ... statement.is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_a_return();
  func = myself->type;
  frame->cont = cont__31_325;
}
static void cont__31_325(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 787: ... :
  // 788:   write_source_as_remark statement
  // 789:   
  // 790:   #if
  // 791:     continuation_parameter.is_defined &&
  // 792:     (
  // 793:       not(output_parameters.is_empty) ||
  // 794:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 795:     ):
  // 796:   
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_326, 0);
  // 787: -> statement.is_a_return:
  // 788:   write_source_as_remark statement
  // 789:   
  // 790:   #if
  // 791:     continuation_parameter.is_defined &&
  // 792:     (
  // 793:       not(output_parameters.is_empty) ||
  // 794:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 795:     ):
  // 796:   
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_341(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // statement: 0
  // output_parameters: 1
  // continuation_parameter: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[2]; /* output_parameters */
  frame->slots[2] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 815: statement.is_a_procedure_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_a_procedure_call();
  func = myself->type;
  frame->cont = cont__31_342;
}
static void cont__31_342(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 816: output_arguments_of(statement).is_empty
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_343, 0);
  // 814: &&
  // 815:   statement.is_a_procedure_call
  // 816:   output_arguments_of(statement).is_empty
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__31_346;
}
static void entry__31_343(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 816: output_arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__output_arguments_of();
  func = myself->type;
  frame->cont = cont__31_344;
}
static void cont__31_344(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 816: output_arguments_of(statement).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__31_345;
}
static void cont__31_345(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 816: output_arguments_of(statement).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_346(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 817: :
  // 818:   write_source_as_remark statement
  // 819:   $functor functor_of(statement)
  // 820:   $input_arguments arguments_of(statement)
  // 821:   $result_count count_arguments(output_parameters)
  // 822:   generate_c_arguments input_arguments
  // 823:   if
  // 824:     continuation_of(statement).is_defined:
  // 825:       get_func_and_myself functor "continuation_trampoline"
  // 826:       write "
  // ...
  frame->slots[6] /* temp__4 */ = create_closure(entry__31_347, 0);
  // 813: ->
  // 814:   &&
  // 815:     statement.is_a_procedure_call
  // 816:     output_arguments_of(statement).is_empty
  // 817:   :
  // 818:     write_source_as_remark statement
  // 819:     $functor functor_of(statement)
  // 820:     $input_arguments arguments_of(statement)
  // 821:     $result_count count_arguments(output_parameters)
  // 822:     generate_c_arguments input_arguments
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_425(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // statement: 0
  // generate_exit: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[3]; /* generate_exit */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 907: generate_statement statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__generate_statement();
  func = myself->type;
  frame->cont = cont__31_426;
}
static void cont__31_426(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 908: generate_exit
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* generate_exit */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_320(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // generate_exit: 0
  frame->slots[0] = myself->closure.frame->slots[25]; /* generate_exit */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 783: generate_exit
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* generate_exit */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_321(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // statements: 0
  // continuation_parameter: 1
  // output_parameters: 2
  // generate_exit: 3
  // statement: 4
  frame->slots[0] = myself->closure.frame->slots[24]; /* statements */
  frame->slots[1] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[3] = myself->closure.frame->slots[25]; /* generate_exit */
  frame->slots[4] /* statement */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 785: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__31_322;
}
static void cont__31_322(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 785: $statement statements(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = frame->slots[0] /* statements */;
  func = myself->type;
  frame->cont = cont__31_323;
}
static void cont__31_323(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* statement */, arguments->slots[0]);
  // 787: -> statement.is_a_return:
  // 788:   write_source_as_remark statement
  // 789:   
  // 790:   #if
  // 791:     continuation_parameter.is_defined &&
  // 792:     (
  // 793:       not(output_parameters.is_empty) ||
  // 794:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 795:     ):
  // 796:   
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__31_324, 0);
  // 813: ->
  // 814:   &&
  // 815:     statement.is_a_procedure_call
  // 816:     output_arguments_of(statement).is_empty
  // 817:   :
  // 818:     write_source_as_remark statement
  // 819:     $functor functor_of(statement)
  // 820:     $input_arguments arguments_of(statement)
  // 821:     $result_count count_arguments(output_parameters)
  // 822:     generate_c_arguments input_arguments
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__31_341, 0);
  // 906: :
  // 907:   generate_statement statement
  // 908:   generate_exit
  frame->slots[7] /* temp__3 */ = create_closure(entry__31_425, 0);
  // 786: cond
  // 787:   -> statement.is_a_return:
  // 788:     write_source_as_remark statement
  // 789:     
  // 790:     #if
  // 791:       continuation_parameter.is_defined &&
  // 792:       (
  // 793:         not(output_parameters.is_empty) ||
  // 794:         variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 795:       ):
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_427(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 909: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_428;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_429;
}
static void cont__31_429(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 910: end_continuation
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = get__end_continuation();
  func = myself->type;
  frame->cont = cont__31_430;
}
static void cont__31_430(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 911: ... continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[16])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_431;
}
static void cont__31_431(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[27] /* temp__2 */ = arguments->slots[0];
  // 911: ... not(output_parameters.is_empty)
  frame->slots[28] /* temp__3 */ = create_closure(entry__31_432, 0);
  // 911: ... continuation_parameter.is_defined && not(output_parameters.is_empty)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[27] /* temp__2 */;
  arguments->slots[1] = frame->slots[28] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__31_435;
}
static void entry__31_432(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // output_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[18]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 911: ... output_parameters.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__31_433;
}
static void cont__31_433(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 911: ... not(output_parameters.is_empty)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__31_434;
}
static void cont__31_434(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 911: ... not(output_parameters.is_empty)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__31_435(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 911: ... :
  // 912:   # create an exit-function as a helper for the continuation parameter
  // 913:   
  // 914:   write "
  // 915:     static void exit@(body_suffix)(void) {
  // 916:       frame = ((CONTINUATION *)myself)->exit_frame;
  // 917:   $n count_arguments(output_parameters)
  // 918:   if
  // 919:     n.is_defined:
  // 920:       write "
  // ...
  frame->slots[29] /* temp__4 */ = create_closure(entry__31_436, 0);
  // 911: if continuation_parameter.is_defined && not(output_parameters.is_empty):
  // 912:   # create an exit-function as a helper for the continuation parameter
  // 913:   
  // 914:   write "
  // 915:     static void exit@(body_suffix)(void) {
  // 916:       frame = ((CONTINUATION *)myself)->exit_frame;
  // 917:   $n count_arguments(output_parameters)
  // 918:   if
  // 919:     n.is_defined:
  // 920:       write "
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[29] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_455;
}
static void entry__31_436(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // body_suffix: 0
  // output_parameters: 1
  // n: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* body_suffix */
  frame->slots[1] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[2] /* n */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 914: ... "
  // 915:   static void exit@(body_suffix)(void) {
  // 916:     frame = ((CONTINUATION *)myself)->exit_frame;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_437;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__31_438;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_439;
}
static void cont__31_439(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 914: write "
  // 915:   static void exit@(body_suffix)(void) {
  // 916:     frame = ((CONTINUATION *)myself)->exit_frame;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_440;
}
static void cont__31_440(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 917: $n count_arguments(output_parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = var._count_arguments;
  func = myself->type;
  frame->cont = cont__31_441;
}
static void cont__31_441(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* n */, arguments->slots[0]);
  // 919: n.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* n */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__31_442;
}
static void cont__31_442(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 919: ... :
  // 920:   write "
  // 921:     @
  // 922:       int i = argument_count;
  // 923:       while (--i >= 0) {
  // 924:         arguments->slots[i+@(n)] = arguments->slots[i];
  // 925:       }
  // 926:   generate_c_arguments output_parameters true
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_443, 0);
  // 927: :
  // 928:   write "
  // 929:     @
  // 930:       int i;
  // 931:       int n = argument_count;
  // 932:       FRAME *return_arguments = arguments;
  // 933:       allocate_arguments();
  // 934:   generate_c_arguments output_parameters
  // 935:   write "
  // 936:     @
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_448, 0);
  // 918: if
  // 919:   n.is_defined:
  // 920:     write "
  // 921:       @
  // 922:         int i = argument_count;
  // 923:         while (--i >= 0) {
  // 924:           arguments->slots[i+@(n)] = arguments->slots[i];
  // 925:         }
  // 926:     generate_c_arguments output_parameters true
  // 927:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_453;
}
static void entry__31_443(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // n: 0
  // output_parameters: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* n */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 920: ... "
  // 921:   @
  // 922:     int i = argument_count;
  // 923:     while (--i >= 0) {
  // 924:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 925:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_444;
  arguments->slots[1] = frame->slots[0] /* n */;
  arguments->slots[2] = string__31_445;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_446;
}
static void cont__31_446(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 920: write "
  // 921:   @
  // 922:     int i = argument_count;
  // 923:     while (--i >= 0) {
  // 924:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 925:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_447;
}
static void cont__31_447(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 926: generate_c_arguments output_parameters true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  arguments->slots[1] = get__true();
  result_count = frame->caller_result_count;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_448(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // output_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 928: write "
  // 929:   @
  // 930:     int i;
  // 931:     int n = argument_count;
  // 932:     FRAME *return_arguments = arguments;
  // 933:     allocate_arguments();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_449;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__31_450;
}
static void cont__31_450(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 934: generate_c_arguments output_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 0;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__31_451;
}
static void cont__31_451(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 935: write "
  // 936:   @
  // 937:     for (i = 0; i < n; ++i) {
  // 938:       arguments->slots[argument_count++] = return_arguments->slots[i];
  // 939:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_452;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_453(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 940: write "
  // 941:     func = continuation_type_function;
  // 942:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__31_454;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_455(void) {
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__31_456(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 943: ... parameter_count_of(return)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* return */;
  result_count = 1;
  myself = get__parameter_count_of();
  func = myself->type;
  frame->cont = cont__31_457;
}
static void cont__31_457(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 943: ... parameter_count_of(return) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__31_458;
}
static void cont__31_458(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 943: ... : # type function
  // 944:   return "entry@(body_suffix)" par_count
  frame->slots[9] /* temp__3 */ = create_closure(entry__31_459, 0);
  // 943: if parameter_count_of(return) == 2: # type function
  // 944:   return "entry@(body_suffix)" par_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_462;
}
static void entry__31_459(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // return: 0
  // body_suffix: 1
  // par_count: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[5]; /* body_suffix */
  frame->slots[2] = myself->closure.frame->slots[6]; /* par_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 944: ... "entry@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__31_460;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_461;
}
static void cont__31_461(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 944: return "entry@(body_suffix)" par_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* par_count */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_462(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 946: inherited_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__inherited_names_of();
  func = myself->type;
  frame->cont = cont__31_463;
}
static void cont__31_463(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 946: inherited_names_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__31_464;
}
static void cont__31_464(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 946: ... :
  // 947:   write_to_phase_2 "
  // 948:     @
  // 949:       func@(body_suffix) = create_future();
  // 950:   write_to_phase_5 "
  // 951:     @
  // 952:       assign_value(&func@(body_suffix), create_function(entry@(body_suffix)@
  // 953:     , @(par_count)));
  // 954:   write_to_generated_collections
  // 955:     "  func@(body_suffix) = collect_node(func@(body_suffix));@nl;"
  // ...
  frame->slots[9] /* temp__3 */ = create_closure(entry__31_465, 0);
  // 957: : # it's a closure
  // 958:   return "create_closure(entry@(body_suffix), @(par_count))"
  frame->slots[10] /* temp__4 */ = create_closure(entry__31_483, 0);
  // 945: if
  // 946:   inherited_names_of(self).is_empty:
  // 947:     write_to_phase_2 "
  // 948:       @
  // 949:         func@(body_suffix) = create_future();
  // 950:     write_to_phase_5 "
  // 951:       @
  // 952:         assign_value(&func@(body_suffix), create_function(entry@(body_suffix)@
  // 953:       , @(par_count)));
  // 954:     write_to_generated_collections
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__31_488;
}
static void entry__31_465(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // body_suffix: 0
  // par_count: 1
  // return: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* body_suffix */
  frame->slots[1] = myself->closure.frame->slots[6]; /* par_count */
  frame->slots[2] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 947: ... "
  // 948:   @
  // 949:     func@(body_suffix) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__31_466;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__31_467;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_468;
}
static void cont__31_468(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 947: write_to_phase_2 "
  // 948:   @
  // 949:     func@(body_suffix) = create_future();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__31_469;
}
static void cont__31_469(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 950: ... "
  // 951:   @
  // 952:     assign_value(&func@(body_suffix), create_function(entry@(body_suffix)@
  // 953:   , @(par_count)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__31_470;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__31_471;
  arguments->slots[3] = frame->slots[0] /* body_suffix */;
  arguments->slots[4] = string__31_472;
  arguments->slots[5] = ((CELL *)frame->slots[1])->contents /* par_count */;
  arguments->slots[6] = string__31_473;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_474;
}
static void cont__31_474(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 950: write_to_phase_5 "
  // 951:   @
  // 952:     assign_value(&func@(body_suffix), create_function(entry@(body_suffix)@
  // 953:   , @(par_count)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame->cont = cont__31_475;
}
static void cont__31_475(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 955: "  func@(body_suffix) = collect_node(func@(body_suffix));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_476;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__31_477;
  arguments->slots[3] = frame->slots[0] /* body_suffix */;
  arguments->slots[4] = string__31_478;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_479;
}
static void cont__31_479(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 954: write_to_generated_collections
  // 955:   "  func@(body_suffix) = collect_node(func@(body_suffix));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__31_480;
}
static void cont__31_480(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 956: ... "func@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__31_481;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_482;
}
static void cont__31_482(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 956: return "func@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[2] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__31_483(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // return: 0
  // body_suffix: 1
  // par_count: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[5]; /* body_suffix */
  frame->slots[2] = myself->closure.frame->slots[6]; /* par_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 958: ... "create_closure(entry@(body_suffix), @(par_count))"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__31_484;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__31_485;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* par_count */;
  arguments->slots[4] = string__31_486;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__31_487;
}
static void cont__31_487(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 958: return "create_closure(entry@(body_suffix), @(par_count))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__31_488(void) {
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__32_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // self: 0
  // return: 1
  frame->slots[1] /* return */ = create_continuation();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 968: show_compiler_debug_info "generate definition"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__32_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__32_3;
}
static void cont__32_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 969: ... attribute_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__32_4;
}
static void cont__32_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 969: ... attribute_kind_of(self) != NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = get__NONE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__32_5;
}
static void cont__32_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 969: ... attribute_kind_of(self) != NONE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__32_6;
}
static void cont__32_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 969: ... :
  // 970:   return
  // 971:     string
  // 972:       "var."
  // 973:       mangled_name_of(identifier_of(self))
  // 974:       "__"
  // 975:       mangled_name_of(attribute_of(self))
  frame->slots[5] /* temp__4 */ = create_closure(entry__32_7, 0);
  // 969: if attribute_kind_of(self) != NONE:
  // 970:   return
  // 971:     string
  // 972:       "var."
  // 973:       mangled_name_of(identifier_of(self))
  // 974:       "__"
  // 975:       mangled_name_of(attribute_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__32_15;
}
static void entry__32_7(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // return: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 973: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__32_8;
}
static void cont__32_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 973: mangled_name_of(identifier_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__32_9;
}
static void cont__32_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 975: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__32_10;
}
static void cont__32_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 975: mangled_name_of(attribute_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__32_11;
}
static void cont__32_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 971: string
  // 972:   "var."
  // 973:   mangled_name_of(identifier_of(self))
  // 974:   "__"
  // 975:   mangled_name_of(attribute_of(self))
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__32_12;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__32_13;
  arguments->slots[3] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__32_14;
}
static void cont__32_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 970: return
  // 971:   string
  // 972:     "var."
  // 973:     mangled_name_of(identifier_of(self))
  // 974:     "__"
  // 975:     mangled_name_of(attribute_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__32_15(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 976: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__32_16;
}
static void cont__32_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 976: ... identifier_of(self).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__32_17;
}
static void cont__32_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 976: -> identifier_of(self).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__33_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 982: show_compiler_debug_info "generate attribute-value pair"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__33_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__33_3;
}
static void cont__33_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 983: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__33_4;
}
static void cont__33_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 983: ... generate_c_arguments(arguments_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__33_5;
}
static void cont__33_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 983: -> generate_c_arguments(arguments_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__34_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 989: show_compiler_debug_info "generate attribute-function pair"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__34_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__34_3;
}
static void cont__34_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 990: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__34_4;
}
static void cont__34_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 990: ... generate_c_arguments(arguments_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__34_5;
}
static void cont__34_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 990: -> generate_c_arguments(arguments_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__35_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[1] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 996: show_compiler_debug_info "generate numeric literal"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__35_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__35_3;
}
static void cont__35_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 997: ... mangled_name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__35_4;
}
static void cont__35_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 997: $name "number__@(mangled_name_of(self))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__35_5;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__35_6;
}
static void cont__35_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 998: use_literal name self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 0;
  myself = get__use_literal();
  func = myself->type;
  frame->cont = cont__35_7;
}
static void cont__35_7(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 999: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__36_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[1] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1005: show_compiler_debug_info "generate character literal"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__36_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__36_3;
}
static void cont__36_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1006: ... node::value_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__value_of();
  func = myself->type;
  frame->cont = cont__36_4;
}
static void cont__36_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1006: ... node::value_of(self).to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__36_5;
}
static void cont__36_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1006: $name "character__@(node::value_of(self).to_integer)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__36_6;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__36_7;
}
static void cont__36_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1007: use_literal name self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 0;
  myself = get__use_literal();
  func = myself->type;
  frame->cont = cont__36_8;
}
static void cont__36_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1008: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__37_1(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // str: 0
  // buf: 1
  // s: 2
  frame->slots[1] /* buf */ = create_cell();
  frame->slots[2] /* s */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1014: $$buf ""
  ((CELL *)frame->slots[1])->contents /* buf */ = empty_string;
  // 1015: $$s 1
  ((CELL *)frame->slots[2])->contents /* s */ = number__1;
  // 1016: ... : (idx chr)
  // 1017:   if chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\':
  // 1018:     append &buf range(str s idx-1)
  // 1019:     write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1020:     !s idx+1
  frame->slots[3] /* temp__1 */ = create_closure(entry__37_2, 2);
  // 1016: for_each str: (idx chr)
  // 1017:   if chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\':
  // 1018:     append &buf range(str s idx-1)
  // 1019:     write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1020:     !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__37_24;
}
static void entry__37_13(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // buf: 0
  // str: 1
  // s: 2
  // idx: 3
  // chr: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  frame->slots[2] = myself->closure.frame->slots[4]; /* s */
  frame->slots[3] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[4] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1018: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__37_14;
}
static void cont__37_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1018: ... range(str s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__37_15;
}
static void cont__37_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1018: append &buf range(str s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__37_16;
}
static void cont__37_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1019: ... chr.to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* chr */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__37_17;
}
static void cont__37_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 1019: ... oct(chr.to_integer)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__oct();
  func = myself->type;
  frame->cont = cont__37_18;
}
static void cont__37_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1019: ... pad_left(oct(chr.to_integer) 3 "0")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = number__3;
  arguments->slots[2] = string__37_19;
  result_count = 1;
  myself = get__pad_left();
  func = myself->type;
  frame->cont = cont__37_20;
}
static void cont__37_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1019: write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = string__37_21;
  arguments->slots[2] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__37_22;
}
static void cont__37_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1020: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__37_23;
}
static void cont__37_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__37_2(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // idx: 0
  // chr: 1
  // buf: 2
  // str: 3
  // s: 4
  frame->slots[2] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[0]; /* str */
  frame->slots[4] = myself->closure.frame->slots[2]; /* s */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1017: ... chr < ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__37_3;
}
static void cont__37_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1017: ... chr > '~' || chr == '@quot;' || chr == '\'
  frame->slots[7] /* temp__3 */ = create_closure(entry__37_4, 0);
  // 1017: ... chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__37_12;
}
static void entry__37_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1017: ... chr > '~'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__126;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__37_5;
}
static void cont__37_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1017: ... chr == '@quot;' || chr == '\'
  frame->slots[3] /* temp__3 */ = create_closure(entry__37_6, 0);
  // 1017: ... chr > '~' || chr == '@quot;' || chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__37_11;
}
static void entry__37_6(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1017: ... chr == '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__37_7;
}
static void cont__37_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1017: ... chr == '\'
  frame->slots[3] /* temp__3 */ = create_closure(entry__37_8, 0);
  // 1017: ... chr == '@quot;' || chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__37_10;
}
static void entry__37_8(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1017: ... chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__92;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__37_9;
}
static void cont__37_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1017: ... chr == '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__37_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1017: ... chr == '@quot;' || chr == '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__37_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1017: ... chr > '~' || chr == '@quot;' || chr == '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__37_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1017: ... :
  // 1018:   append &buf range(str s idx-1)
  // 1019:   write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1020:   !s idx+1
  frame->slots[8] /* temp__4 */ = create_closure(entry__37_13, 0);
  // 1017: if chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\':
  // 1018:   append &buf range(str s idx-1)
  // 1019:   write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1020:   !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__37_24(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1021: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__37_25;
}
static void cont__37_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1021: ... s <= length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__37_26;
}
static void cont__37_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1021: ... s <= length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__37_27;
}
static void cont__37_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1021: ... : append &buf range(str s -1)
  frame->slots[6] /* temp__4 */ = create_closure(entry__37_28, 0);
  // 1021: if s <= length_of(str): append &buf range(str s -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__37_32;
}
static void entry__37_28(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // str: 1
  // s: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  frame->slots[2] = myself->closure.frame->slots[2]; /* s */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1021: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__37_29;
}
static void cont__37_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1021: ... range(str s -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__37_30;
}
static void cont__37_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1021: ... append &buf range(str s -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__37_31;
}
static void cont__37_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__37_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1022: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__38_4(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // str: 0
  // len: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* len */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1027: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__38_5;
}
static void cont__38_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 1028: $name "string@(suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__38_6;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__38_7;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__38_8;
}
static void cont__38_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 1029: ... "static NODE *@(name);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__38_9;
  arguments->slots[1] = frame->slots[2] /* name */;
  arguments->slots[2] = string__38_10;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__38_11;
}
static void cont__38_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1029: write_to_declarations "static NODE *@(name);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__38_12;
}
static void cont__38_12(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1031: str.is_a_latin_1_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__is_a_latin_1_string();
  func = myself->type;
  frame->cont = cont__38_13;
}
static void cont__38_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1031: ... :
  // 1032:   write_to_phase_2 "
  // 1033:     @
  // 1034:       @(name) = from_latin_1_string("@(to_c_string(str))@quot;, @(len));
  frame->slots[4] /* temp__2 */ = create_closure(entry__38_14, 0);
  // 1035: :
  // 1036:   write_to_phase_2 "  uint32_t @(name)_literal[@(len)] = {"
  // 1037:   for_each
  // 1038:     str: (chr)
  // 1039:       if
  // 1040:         ||
  // 1041:           &&
  // 1042:             chr >= ' '
  // 1043:             chr <= '~'
  // 1044:             chr != '@apos;'
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__38_21, 0);
  // 1030: if
  // 1031:   str.is_a_latin_1_string:
  // 1032:     write_to_phase_2 "
  // 1033:       @
  // 1034:         @(name) = from_latin_1_string("@(to_c_string(str))@quot;, @(len));
  // 1035:   :
  // 1036:     write_to_phase_2 "  uint32_t @(name)_literal[@(len)] = {"
  // 1037:     for_each
  // 1038:       str: (chr)
  // 1039:         if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__38_69;
}
static void entry__38_14(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // name: 0
  // str: 1
  // len: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  frame->slots[2] = myself->closure.frame->slots[1]; /* len */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1034: ... to_c_string(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  result_count = 1;
  myself = var._to_c_string;
  func = myself->type;
  frame->cont = cont__38_15;
}
static void cont__38_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1032: ... "
  // 1033:   @
  // 1034:     @(name) = from_latin_1_string("@(to_c_string(str))@quot;, @(len));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__38_16;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__38_17;
  arguments->slots[3] = frame->slots[4] /* temp__2 */;
  arguments->slots[4] = string__38_18;
  arguments->slots[5] = frame->slots[2] /* len */;
  arguments->slots[6] = string__38_19;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__38_20;
}
static void cont__38_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1032: write_to_phase_2 "
  // 1033:   @
  // 1034:     @(name) = from_latin_1_string("@(to_c_string(str))@quot;, @(len));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__38_21(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // name: 0
  // len: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* len */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1036: ... "  uint32_t @(name)_literal[@(len)] = {"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__38_22;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__38_23;
  arguments->slots[3] = frame->slots[1] /* len */;
  arguments->slots[4] = string__38_24;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__38_25;
}
static void cont__38_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1036: write_to_phase_2 "  uint32_t @(name)_literal[@(len)] = {"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__38_26;
}
static void cont__38_26(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1037: for_each
  // 1038:   str: (chr)
  // 1039:     if
  // 1040:       ||
  // 1041:         &&
  // 1042:           chr >= ' '
  // 1043:           chr <= '~'
  // 1044:           chr != '@apos;'
  // 1045:           chr != '@quot;'
  // 1046:           chr != '\'
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  arguments->slots[1] = func__38_27;
  arguments->slots[2] = func__38_59;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__38_61;
}
static void entry__38_54(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1049: write_to_phase_2 '@apos;' chr '@apos;'
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__39;
  arguments->slots[1] = frame->slots[0] /* chr */;
  arguments->slots[2] = character__39;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__38_55(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1051: ... chr.to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__38_56;
}
static void cont__38_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1051: ... hex(chr.to_integer)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__hex();
  func = myself->type;
  frame->cont = cont__38_57;
}
static void cont__38_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1051: write_to_phase_2 "0x" hex(chr.to_integer)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__38_58;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__38_27(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // chr: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1042: chr >= ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__38_28;
}
static void cont__38_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 1042: chr >= ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__38_29;
}
static void cont__38_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  frame->slots[5] /* temp__5 */ = create_closure(entry__38_30, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__38_45;
}
static void entry__38_30(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1043: chr <= '~'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__126;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__38_31;
}
static void cont__38_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1043: chr <= '~'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__38_32;
}
static void cont__38_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__38_33, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__38_44;
}
static void entry__38_33(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1044: chr != '@apos;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__39;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__38_34;
}
static void cont__38_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1044: chr != '@apos;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__38_35;
}
static void cont__38_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__38_36, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__38_43;
}
static void entry__38_36(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1045: chr != '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__38_37;
}
static void cont__38_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1045: chr != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__38_38;
}
static void cont__38_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1046: chr != '\'
  frame->slots[4] /* temp__4 */ = create_closure(entry__38_39, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__38_42;
}
static void entry__38_39(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1046: chr != '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__92;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__38_40;
}
static void cont__38_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1046: chr != '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__38_41;
}
static void cont__38_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1046: chr != '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__38_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__38_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__38_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__38_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1047: chr >= ' ' && chr <= 'ÿ'
  frame->slots[6] /* temp__6 */ = create_closure(entry__38_46, 0);
  // 1040: ||
  // 1041:   &&
  // 1042:     chr >= ' '
  // 1043:     chr <= '~'
  // 1044:     chr != '@apos;'
  // 1045:     chr != '@quot;'
  // 1046:     chr != '\'
  // 1047:   chr >= ' ' && chr <= 'ÿ'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__38_53;
}
static void entry__38_46(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1047: chr >= ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__160;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__38_47;
}
static void cont__38_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1047: chr >= ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__38_48;
}
static void cont__38_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1047: ... chr <= 'ÿ'
  frame->slots[4] /* temp__4 */ = create_closure(entry__38_49, 0);
  // 1047: chr >= ' ' && chr <= 'ÿ'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__38_52;
}
static void entry__38_49(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1047: ... chr <= 'ÿ'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__255;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__38_50;
}
static void cont__38_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1047: ... chr <= 'ÿ'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__38_51;
}
static void cont__38_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1047: ... chr <= 'ÿ'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__38_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1047: chr >= ' ' && chr <= 'ÿ'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__38_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1048: :
  // 1049:   write_to_phase_2 '@apos;' chr '@apos;'
  frame->slots[7] /* temp__7 */ = create_closure(entry__38_54, 0);
  // 1050: :
  // 1051:   write_to_phase_2 "0x" hex(chr.to_integer)
  frame->slots[8] /* temp__8 */ = create_closure(entry__38_55, 0);
  // 1039: if
  // 1040:   ||
  // 1041:     &&
  // 1042:       chr >= ' '
  // 1043:       chr <= '~'
  // 1044:       chr != '@apos;'
  // 1045:       chr != '@quot;'
  // 1046:       chr != '\'
  // 1047:     chr >= ' ' && chr <= 'ÿ'
  // 1048:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__7 */;
  arguments->slots[2] = frame->slots[8] /* temp__8 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__38_59(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1053: write_to_phase_2 ", "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__38_60;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__38_61(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1054: write_to_phase_2 "};@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__38_62;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__38_63;
}
static void cont__38_63(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1056: "  @(name) = from_uint32_string(@(name)_literal, @(len));@nl;"
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__38_64;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__38_65;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__38_66;
  arguments->slots[5] = frame->slots[1] /* len */;
  arguments->slots[6] = string__38_67;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__38_68;
}
static void cont__38_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1055: write_to_phase_2
  // 1056:   "  @(name) = from_uint32_string(@(name)_literal, @(len));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__38_69(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1057: ... "  @(name) = collect_node(@(name));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__38_70;
  arguments->slots[1] = frame->slots[2] /* name */;
  arguments->slots[2] = string__38_71;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__38_72;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__38_73;
}
static void cont__38_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1057: write_to_generated_collections "  @(name) = collect_node(@(name));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__38_74;
}
static void cont__38_74(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1058: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__38_75(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1026: ... -> "empty_string"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__38_76;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__38_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // str: 0
  // len: 1
  frame->slots[1] /* len */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1025: $len length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__38_2;
}
static void cont__38_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* len */, arguments->slots[0]);
  // 1026: ... len == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* len */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__38_3;
}
static void cont__38_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1026: ... :
  // 1027:   inc &index
  // 1028:   $name "string@(suffix)_@(index)"
  // 1029:   write_to_declarations "static NODE *@(name);@nl;"
  // 1030:   if
  // 1031:     str.is_a_latin_1_string:
  // 1032:       write_to_phase_2 "
  // 1033:         @
  // 1034:           @(name) = from_latin_1_string("@(to_c_string(str))@quot;, @(len));
  // 1035:     :
  // ...
  frame->slots[3] /* temp__2 */ = create_closure(entry__38_4, 0);
  // 1026: if len == 0 (-> "empty_string"):
  // 1027:   inc &index
  // 1028:   $name "string@(suffix)_@(index)"
  // 1029:   write_to_declarations "static NODE *@(name);@nl;"
  // 1030:   if
  // 1031:     str.is_a_latin_1_string:
  // 1032:       write_to_phase_2 "
  // 1033:         @
  // 1034:           @(name) = from_latin_1_string("@(to_c_string(str))@quot;, @(len));
  // 1035:     :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = func__38_75;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__39_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1061: show_compiler_debug_info "generate string literal"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__39_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__39_3;
}
static void cont__39_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1062: ... node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__39_4;
}
static void cont__39_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1062: ... register_string(node::text_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._register_string;
  func = myself->type;
  frame->cont = cont__39_5;
}
static void cont__39_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1062: -> register_string(node::text_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__40_1(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // self: 0
  // name: 1
  // reg_name: 2
  frame->slots[1] /* name */ = create_future();
  frame->slots[2] /* reg_name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1068: show_compiler_debug_info "generate unique item"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__40_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__40_3;
}
static void cont__40_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1069: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__40_4;
}
static void cont__40_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 1070: $name string("unique" suffix "_" index)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40_5;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__40_6;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__40_7;
}
static void cont__40_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1071: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__40_8;
}
static void cont__40_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1071: ... name_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__40_9;
}
static void cont__40_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1071: ... -> name_of(self)
  frame->slots[5] /* temp__3 */ = create_closure(entry__40_10, 0);
  // 1071: ... -> name
  frame->slots[6] /* temp__4 */ = create_closure(entry__40_12, 0);
  // 1071: $reg_name if(name_of(self).is_defined (-> name_of(self)) -> name)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__40_13;
}
static void entry__40_10(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1071: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__40_11;
}
static void cont__40_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1071: ... -> name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__40_12(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1071: ... -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__40_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* reg_name */, arguments->slots[0]);
  // 1072: ... "static NODE *@(name);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__40_14;
  arguments->slots[1] = frame->slots[1] /* name */;
  arguments->slots[2] = string__40_15;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__40_16;
}
static void cont__40_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1072: write_to_declarations "static NODE *@(name);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__40_17;
}
static void cont__40_17(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1073: ... "
  // 1074:   @
  // 1075:     @(name) = register_unique_item("@(reg_name)");
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__40_18;
  arguments->slots[1] = frame->slots[1] /* name */;
  arguments->slots[2] = string__40_19;
  arguments->slots[3] = frame->slots[2] /* reg_name */;
  arguments->slots[4] = string__40_20;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__40_21;
}
static void cont__40_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1073: write_to_phase_2 "
  // 1074:   @
  // 1075:     @(name) = register_unique_item("@(reg_name)");
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__40_22;
}
static void cont__40_22(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1076: ... "  @(name) = collect_node(@(name));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__40_23;
  arguments->slots[1] = frame->slots[1] /* name */;
  arguments->slots[2] = string__40_24;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__40_25;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__40_26;
}
static void cont__40_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1076: write_to_generated_collections "  @(name) = collect_node(@(name));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__40_27;
}
static void cont__40_27(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1077: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_47(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // self: 0
  // name: 1
  // variable_kind: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  frame->slots[2] /* variable_kind */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1103: namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__41_48;
}
static void cont__41_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1103: namespace_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__41_49;
}
static void cont__41_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1104: -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  frame->slots[5] /* temp__3 */ = create_closure(entry__41_50, 0);
  // 1105: -> variable_kind_of(global_names(name))
  frame->slots[6] /* temp__4 */ = create_closure(entry__41_56, 0);
  // 1101: $variable_kind
  // 1102:   if
  // 1103:     namespace_of(self).is_defined
  // 1104:     -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1105:     -> variable_kind_of(global_names(name))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__41_59;
}
static void entry__41_50(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1104: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__41_51;
}
static void cont__41_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1104: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__41_52;
}
static void cont__41_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 1104: ... exported_names(name_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__41_53;
}
static void cont__41_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 1104: ... exported_names(name_of(self))(namespace_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = frame->slots[4] /* temp__4 */;
  func = myself->type;
  frame->cont = cont__41_54;
}
static void cont__41_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1104: ... variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__41_55;
}
static void cont__41_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1104: -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_56(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1105: ... global_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__41_57;
}
static void cont__41_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1105: ... variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__41_58;
}
static void cont__41_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1105: -> variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__41_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* variable_kind */, arguments->slots[0]);
  // 1110: DYNAMIC_SINGLE, DYNAMIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__DYNAMIC_SINGLE();
  arguments->slots[1] = get__DYNAMIC_MULTI();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__41_60;
}
static void cont__41_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1111: -> "get__@(name)()"
  frame->slots[5] /* temp__3 */ = create_closure(entry__41_61, 0);
  // 1112: -> var_entry(name)
  frame->slots[6] /* temp__4 */ = create_closure(entry__41_65, 0);
  // 1108: case
  // 1109:   variable_kind
  // 1110:   DYNAMIC_SINGLE, DYNAMIC_MULTI
  // 1111:   -> "get__@(name)()"
  // 1112:   -> var_entry(name)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* variable_kind */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  arguments->slots[3] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__41_67;
}
static void entry__41_61(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1111: ... "get__@(name)()"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__41_62;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__41_63;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__41_64;
}
static void cont__41_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1111: -> "get__@(name)()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_65(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1112: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__41_66;
}
static void cont__41_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1112: -> var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__41_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1107: ->
  // 1108:   case
  // 1109:     variable_kind
  // 1110:     DYNAMIC_SINGLE, DYNAMIC_MULTI
  // 1111:     -> "get__@(name)()"
  // 1112:     -> var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_42(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1099: ... "get__@(name)()"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__41_43;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__41_44;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__41_45;
}
static void cont__41_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1099: ... -> "get__@(name)()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_24(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1094: name.is_a_shared_local
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__is_a_shared_local();
  func = myself->type;
  frame->cont = cont__41_25;
}
static void cont__41_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1095: -> "
  // 1096:   ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:   */@
  frame->slots[3] /* temp__3 */ = create_closure(entry__41_26, 0);
  // 1098: -> "frame->slots[@(current_locals(name))] /* @(name) */"
  frame->slots[4] /* temp__4 */ = create_closure(entry__41_32, 0);
  // 1093: if
  // 1094:   name.is_a_shared_local
  // 1095:   -> "
  // 1096:     ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:     */@
  // 1098:   -> "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__41_38;
}
static void entry__41_26(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1096: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__41_27;
}
static void cont__41_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1095: ... "
  // 1096:   ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:   */@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__41_28;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__41_29;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__41_30;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__41_31;
}
static void cont__41_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1095: -> "
  // 1096:   ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:   */@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_32(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1098: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__41_33;
}
static void cont__41_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1098: ... "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__41_34;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__41_35;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__41_36;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__41_37;
}
static void cont__41_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1098: -> "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__41_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1092: ... ->
  // 1093:   if
  // 1094:     name.is_a_shared_local
  // 1095:     -> "
  // 1096:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:       */@
  // 1098:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_7(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1088: temporary_offset.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__temporary_offset();
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__41_8;
}
static void cont__41_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1088: ... :
  // 1089:   $idx temporary_offset+behind(name "__").to_integer-1
  // 1090:   -> "frame->slots[@(idx)] /* @(name) */"
  frame->slots[3] /* temp__3 */ = create_closure(entry__41_9, 0);
  // 1091: -> name
  frame->slots[4] /* temp__4 */ = create_closure(entry__41_19, 0);
  // 1087: if
  // 1088:   temporary_offset.is_defined:
  // 1089:     $idx temporary_offset+behind(name "__").to_integer-1
  // 1090:     -> "frame->slots[@(idx)] /* @(name) */"
  // 1091:   -> name
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__41_20;
}
static void entry__41_9(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // name: 0
  // idx: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  frame->slots[1] /* idx */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1089: ... behind(name "__")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__41_10;
  result_count = 1;
  myself = get__behind();
  func = myself->type;
  frame->cont = cont__41_11;
}
static void cont__41_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1089: ... behind(name "__").to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__41_12;
}
static void cont__41_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1089: ... temporary_offset+behind(name "__").to_integer
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__temporary_offset();
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__41_13;
}
static void cont__41_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1089: $idx temporary_offset+behind(name "__").to_integer-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__41_14;
}
static void cont__41_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* idx */, arguments->slots[0]);
  // 1090: ... "frame->slots[@(idx)] /* @(name) */"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__41_15;
  arguments->slots[1] = frame->slots[1] /* idx */;
  arguments->slots[2] = string__41_16;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__41_17;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__41_18;
}
static void cont__41_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1090: -> "frame->slots[@(idx)] /* @(name) */"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_19(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1091: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__41_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1086: ... ->
  // 1087:   if
  // 1088:     temporary_offset.is_defined:
  // 1089:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1090:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1091:     -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_5(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1086: ... self.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__41_6;
}
static void cont__41_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1086: ... ->
  // 1087:   if
  // 1088:     temporary_offset.is_defined:
  // 1089:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1090:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1091:     -> name
  frame->slots[3] /* temp__2 */ = create_closure(entry__41_7, 0);
  // 1086: -> self.is_a_temporary ->
  // 1087:   if
  // 1088:     temporary_offset.is_defined:
  // 1089:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1090:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1091:     -> name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_21(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1092: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__41_22;
}
static void cont__41_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1092: ... current_locals(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__41_23;
}
static void cont__41_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1092: ... ->
  // 1093:   if
  // 1094:     name.is_a_shared_local
  // 1095:     -> "
  // 1096:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:       */@
  // 1098:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  frame->slots[3] /* temp__3 */ = create_closure(entry__41_24, 0);
  // 1092: -> current_locals(name).is_defined ->
  // 1093:   if
  // 1094:     name.is_a_shared_local
  // 1095:     -> "
  // 1096:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:       */@
  // 1098:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_39(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1099: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__41_40;
}
static void cont__41_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1099: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__41_41;
}
static void cont__41_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1099: ... -> "get__@(name)()"
  frame->slots[3] /* temp__3 */ = create_closure(entry__41_42, 0);
  // 1099: -> needed_names(name).is_defined -> "get__@(name)()"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_46(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1100: ... :
  // 1101:   $variable_kind
  // 1102:     if
  // 1103:       namespace_of(self).is_defined
  // 1104:       -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1105:       -> variable_kind_of(global_names(name))
  // 1106:   
  // 1107:   ->
  // 1108:     case
  // 1109:       variable_kind
  // ...
  frame->slots[2] /* temp__1 */ = create_closure(entry__41_47, 0);
  // 1100: -> true:
  // 1101:   $variable_kind
  // 1102:     if
  // 1103:       namespace_of(self).is_defined
  // 1104:       -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1105:       -> variable_kind_of(global_names(name))
  // 1106:   
  // 1107:   ->
  // 1108:     case
  // 1109:       variable_kind
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[1] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1083: show_compiler_debug_info "generate identifier " self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__41_2;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__41_3;
}
static void cont__41_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1084: $name mangled_name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__41_4;
}
static void cont__41_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1086: -> self.is_a_temporary ->
  // 1087:   if
  // 1088:     temporary_offset.is_defined:
  // 1089:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1090:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1091:     -> name
  frame->slots[2] /* temp__1 */ = create_closure(entry__41_5, 0);
  // 1092: -> current_locals(name).is_defined ->
  // 1093:   if
  // 1094:     name.is_a_shared_local
  // 1095:     -> "
  // 1096:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1097:       */@
  // 1098:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  frame->slots[3] /* temp__2 */ = create_closure(entry__41_21, 0);
  // 1099: -> needed_names(name).is_defined -> "get__@(name)()"
  frame->slots[4] /* temp__3 */ = create_closure(entry__41_39, 0);
  // 1100: -> true:
  // 1101:   $variable_kind
  // 1102:     if
  // 1103:       namespace_of(self).is_defined
  // 1104:       -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1105:       -> variable_kind_of(global_names(name))
  // 1106:   
  // 1107:   ->
  // 1108:     case
  // 1109:       variable_kind
  // ...
  frame->slots[5] /* temp__4 */ = create_closure(entry__41_46, 0);
  // 1085: cond
  // 1086:   -> self.is_a_temporary ->
  // 1087:     if
  // 1088:       temporary_offset.is_defined:
  // 1089:         $idx temporary_offset+behind(name "__").to_integer-1
  // 1090:         -> "frame->slots[@(idx)] /* @(name) */"
  // 1091:       -> name
  // 1092:   -> current_locals(name).is_defined ->
  // 1093:     if
  // 1094:       name.is_a_shared_local
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  arguments->slots[3] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__42_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // body_suffix: 1
  // continuation_info: 2
  frame->slots[1] /* body_suffix */ = create_future();
  frame->slots[2] /* continuation_info */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1118: show_compiler_debug_info "generate C-body"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__42_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__42_3;
}
static void cont__42_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1119: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__42_4;
}
static void cont__42_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 1120: $body_suffix string(suffix '_' index)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__suffix();
  arguments->slots[1] = character__95;
  arguments->slots[2] = get__index();
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__42_5;
}
static void cont__42_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* body_suffix */, arguments->slots[0]);
  // 1121: $$continuation_info undefined
  ((CELL *)frame->slots[2])->contents /* continuation_info */ = get__undefined();
  // 1122: ... end_position_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__end_position_of();
  func = myself->type;
  frame->cont = cont__42_6;
}
static void cont__42_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1122: ... end_position_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__42_7;
}
static void cont__42_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1122: ... :
  // 1123:   compute_source_text_info !continuation_info self
  frame->slots[5] /* temp__3 */ = create_closure(entry__42_8, 0);
  // 1122: if end_position_of(self).is_defined:
  // 1123:   compute_source_text_info !continuation_info self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__42_10;
}
static void entry__42_8(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // continuation_info: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* continuation_info */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1123: compute_source_text_info !continuation_info self
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = var._compute_source_text_info;
  func = myself->type;
  frame->cont = cont__42_9;
}
static void cont__42_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* continuation_info */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_10(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1124: ... :
  // 1125:   $par_count
  // 1126:     if
  // 1127:       source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  // 1128:       -> between(source_of(self) '(' ')')
  // 1129:       -> -1
  // 1130:   
  // 1131:   write_to_declarations "
  // 1132:     static void entry@(body_suffix)(void);
  // 1133:     static NODE *func@(body_suffix);
  // ...
  frame->slots[3] /* temp__1 */ = create_closure(entry__42_11, 0);
  // 1124: delayed:
  // 1125:   $par_count
  // 1126:     if
  // 1127:       source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  // 1128:       -> between(source_of(self) '(' ')')
  // 1129:       -> -1
  // 1130:   
  // 1131:   write_to_declarations "
  // 1132:     static void entry@(body_suffix)(void);
  // 1133:     static NODE *func@(body_suffix);
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = var._delayed;
  func = myself->type;
  frame->cont = cont__42_50;
}
static void entry__42_11(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // self: 0
  // body_suffix: 1
  // continuation_info: 2
  // par_count: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* body_suffix */
  frame->slots[2] = myself->closure.frame->slots[2]; /* continuation_info */
  frame->slots[3] /* par_count */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1127: source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__42_12;
}
static void cont__42_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1127: source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = string__42_13;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__42_14;
}
static void cont__42_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1128: -> between(source_of(self) '(' ')')
  frame->slots[6] /* temp__3 */ = create_closure(entry__42_15, 0);
  // 1125: $par_count
  // 1126:   if
  // 1127:     source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  // 1128:     -> between(source_of(self) '(' ')')
  // 1129:     -> -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = func__42_18;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__42_20;
}
static void entry__42_15(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1128: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__42_16;
}
static void cont__42_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1128: ... between(source_of(self) '(' ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__40;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__between();
  func = myself->type;
  frame->cont = cont__42_17;
}
static void cont__42_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1128: -> between(source_of(self) '(' ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_18(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1129: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__42_19;
}
static void cont__42_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 1129: -> -1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* par_count */, arguments->slots[0]);
  // 1131: ... "
  // 1132:   static void entry@(body_suffix)(void);
  // 1133:   static NODE *func@(body_suffix);
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__42_21;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__42_22;
  arguments->slots[3] = frame->slots[1] /* body_suffix */;
  arguments->slots[4] = string__42_23;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__42_24;
}
static void cont__42_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1131: write_to_declarations "
  // 1132:   static void entry@(body_suffix)(void);
  // 1133:   static NODE *func@(body_suffix);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__42_25;
}
static void cont__42_25(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1134: ... continuation_info.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* continuation_info */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__42_26;
}
static void cont__42_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1134: ... :
  // 1135:   write_to_continuation_table
  // 1136:     "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__42_27, 0);
  // 1134: if continuation_info.is_defined:
  // 1135:   write_to_continuation_table
  // 1136:     "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__42_32;
}
static void entry__42_27(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // body_suffix: 0
  // continuation_info: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* body_suffix */
  frame->slots[1] = myself->closure.frame->slots[2]; /* continuation_info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1136: "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__42_28;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__42_29;
  arguments->slots[3] = ((CELL *)frame->slots[1])->contents /* continuation_info */;
  arguments->slots[4] = string__42_30;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__42_31;
}
static void cont__42_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1135: write_to_continuation_table
  // 1136:   "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__42_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1139: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__42_33;
}
static void cont__42_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1139: ... source_of(self).converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__42_34;
}
static void cont__42_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1139: ... indented(2 source_of(self).converted)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__42_35;
}
static void cont__42_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1137: ... "
  // 1138:   static void entry@(body_suffix)(void) {
  // 1139:   @(indented(2 source_of(self).converted))@nl;}
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__42_36;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__42_37;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  arguments->slots[4] = string__42_38;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__42_39;
}
static void cont__42_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1137: write "
  // 1138:   static void entry@(body_suffix)(void) {
  // 1139:   @(indented(2 source_of(self).converted))@nl;}
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__42_40;
}
static void cont__42_40(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1140: ... "
  // 1141:   @
  // 1142:     func@(body_suffix) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__42_41;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__42_42;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__42_43;
}
static void cont__42_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1140: write_to_phase_2 "
  // 1141:   @
  // 1142:     func@(body_suffix) = create_future();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__42_44;
}
static void cont__42_44(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1143: ... "
  // 1144:   @
  // 1145:     assign_value(&func@(body_suffix), create_function(entry@(body_suffix), @
  // 1146:   @(par_count)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__42_45;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__42_46;
  arguments->slots[3] = frame->slots[1] /* body_suffix */;
  arguments->slots[4] = string__42_47;
  arguments->slots[5] = frame->slots[3] /* par_count */;
  arguments->slots[6] = string__42_48;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__42_49;
}
static void cont__42_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1143: write_to_phase_5 "
  // 1144:   @
  // 1145:     assign_value(&func@(body_suffix), create_function(entry@(body_suffix), @
  // 1146:   @(par_count)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__42_50(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1147: ... "func@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__42_51;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__42_52;
}
static void cont__42_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1147: -> "func@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__43_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // destination: 0
  // identifier: 1
  frame->slots[1] /* identifier */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1152: $identifier identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__43_2;
}
static void cont__43_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* identifier */, arguments->slots[0]);
  // 1153: ... namespace_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__43_3;
}
static void cont__43_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1153: ... name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__43_4;
}
static void cont__43_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1153: ... mangled_name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__43_5;
}
static void cont__43_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1153: -> namespace_of(identifier) name_of(identifier) mangled_name_of(identifier)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_1(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // expr: 0
  // return: 1
  // info: 2
  frame->slots[1] /* return */ = create_continuation();
  frame->slots[2] /* info */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1160: ... expr.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__44_2;
}
static void cont__44_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1160: ... not(expr.is_a_temporary)
  frame->slots[5] /* temp__3 */ = create_closure(entry__44_3, 0);
  // 1160: ... expr.is_an_identifier && not(expr.is_a_temporary)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__44_6;
}
static void entry__44_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1160: ... expr.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__44_4;
}
static void cont__44_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1160: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__44_5;
}
static void cont__44_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1160: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1160: ... : return false
  frame->slots[6] /* temp__4 */ = create_closure(entry__44_7, 0);
  // 1160: unless expr.is_an_identifier && not(expr.is_a_temporary): return false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__44_8;
}
static void entry__44_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1160: ... return false
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__false();
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__44_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1164: namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__44_9;
}
static void cont__44_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1164: namespace_of(expr).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__44_10;
}
static void cont__44_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1164: ... :
  // 1165:   $namespaces exported_names(name_of(expr))
  // 1166:   ->
  // 1167:     if
  // 1168:       namespaces.is_defined
  // 1169:       -> namespaces(namespace_of(expr))
  // 1170:       -> undefined
  frame->slots[5] /* temp__3 */ = create_closure(entry__44_11, 0);
  // 1171: -> global_names(name_of(expr))
  frame->slots[6] /* temp__4 */ = create_closure(entry__44_20, 0);
  // 1162: $info
  // 1163:   if
  // 1164:     namespace_of(expr).is_defined:
  // 1165:       $namespaces exported_names(name_of(expr))
  // 1166:       ->
  // 1167:         if
  // 1168:           namespaces.is_defined
  // 1169:           -> namespaces(namespace_of(expr))
  // 1170:           -> undefined
  // 1171:     -> global_names(name_of(expr))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__44_23;
}
static void entry__44_11(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  // namespaces: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  frame->slots[1] /* namespaces */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1165: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__44_12;
}
static void cont__44_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1165: $namespaces exported_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__44_13;
}
static void cont__44_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* namespaces */, arguments->slots[0]);
  // 1168: namespaces.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* namespaces */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__44_14;
}
static void cont__44_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1169: -> namespaces(namespace_of(expr))
  frame->slots[4] /* temp__3 */ = create_closure(entry__44_15, 0);
  // 1167: if
  // 1168:   namespaces.is_defined
  // 1169:   -> namespaces(namespace_of(expr))
  // 1170:   -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = func__44_18;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__44_19;
}
static void entry__44_15(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // namespaces: 0
  // expr: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* namespaces */
  frame->slots[1] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1169: ... namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__44_16;
}
static void cont__44_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1169: ... namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[0] /* namespaces */;
  func = myself->type;
  frame->cont = cont__44_17;
}
static void cont__44_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1169: -> namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1170: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1166: ->
  // 1167:   if
  // 1168:     namespaces.is_defined
  // 1169:     -> namespaces(namespace_of(expr))
  // 1170:     -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_20(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1171: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__44_21;
}
static void cont__44_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1171: ... global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__44_22;
}
static void cont__44_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1171: -> global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* info */, arguments->slots[0]);
  // 1173: ... info.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* info */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__44_24;
}
static void cont__44_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1173: ... info.is_a_single_assign_definition
  frame->slots[5] /* temp__3 */ = create_closure(entry__44_25, 0);
  // 1173: ... info.is_defined && info.is_a_single_assign_definition
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__44_27;
}
static void entry__44_25(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // info: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1173: ... info.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* info */;
  result_count = 1;
  myself = get__is_a_single_assign_definition();
  func = myself->type;
  frame->cont = cont__44_26;
}
static void cont__44_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1173: ... info.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1173: -> info.is_defined && info.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__45_1(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // expr: 0
  // return: 1
  // info: 2
  frame->slots[1] /* return */ = create_continuation();
  frame->slots[2] /* info */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1180: ... expr.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__45_2;
}
static void cont__45_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1180: ... not(expr.is_a_temporary)
  frame->slots[5] /* temp__3 */ = create_closure(entry__45_3, 0);
  // 1180: ... expr.is_an_identifier && not(expr.is_a_temporary)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_6;
}
static void entry__45_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1180: ... expr.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__45_4;
}
static void cont__45_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1180: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__45_5;
}
static void cont__45_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1180: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1180: ... : return false
  frame->slots[6] /* temp__4 */ = create_closure(entry__45_7, 0);
  // 1180: unless expr.is_an_identifier && not(expr.is_a_temporary): return false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__45_8;
}
static void entry__45_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1180: ... return false
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__false();
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__45_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1184: namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__45_9;
}
static void cont__45_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1184: namespace_of(expr).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__45_10;
}
static void cont__45_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1184: ... :
  // 1185:   $namespaces exported_names(name_of(expr))
  // 1186:   ->
  // 1187:     if
  // 1188:       namespaces.is_defined
  // 1189:       -> namespaces(namespace_of(expr))
  // 1190:       -> undefined
  frame->slots[5] /* temp__3 */ = create_closure(entry__45_11, 0);
  // 1191: -> global_names(name_of(expr))
  frame->slots[6] /* temp__4 */ = create_closure(entry__45_20, 0);
  // 1182: $info
  // 1183:   if
  // 1184:     namespace_of(expr).is_defined:
  // 1185:       $namespaces exported_names(name_of(expr))
  // 1186:       ->
  // 1187:         if
  // 1188:           namespaces.is_defined
  // 1189:           -> namespaces(namespace_of(expr))
  // 1190:           -> undefined
  // 1191:     -> global_names(name_of(expr))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_23;
}
static void entry__45_11(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  // namespaces: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  frame->slots[1] /* namespaces */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1185: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__45_12;
}
static void cont__45_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1185: $namespaces exported_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__45_13;
}
static void cont__45_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* namespaces */, arguments->slots[0]);
  // 1188: namespaces.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* namespaces */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__45_14;
}
static void cont__45_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1189: -> namespaces(namespace_of(expr))
  frame->slots[4] /* temp__3 */ = create_closure(entry__45_15, 0);
  // 1187: if
  // 1188:   namespaces.is_defined
  // 1189:   -> namespaces(namespace_of(expr))
  // 1190:   -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = func__45_18;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_19;
}
static void entry__45_15(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // namespaces: 0
  // expr: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* namespaces */
  frame->slots[1] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1189: ... namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__45_16;
}
static void cont__45_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1189: ... namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[0] /* namespaces */;
  func = myself->type;
  frame->cont = cont__45_17;
}
static void cont__45_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1189: -> namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1190: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1186: ->
  // 1187:   if
  // 1188:     namespaces.is_defined
  // 1189:     -> namespaces(namespace_of(expr))
  // 1190:     -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_20(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1191: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__45_21;
}
static void cont__45_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1191: ... global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__45_22;
}
static void cont__45_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1191: -> global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* info */, arguments->slots[0]);
  // 1193: ... info.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* info */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__45_24;
}
static void cont__45_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1193: -> info.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__46_15(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // dest: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* dest */
  frame->slots[1] = myself->closure.frame->slots[0]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1202: ... "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__46_16;
  arguments->slots[1] = frame->slots[0] /* dest */;
  arguments->slots[2] = string__46_17;
  arguments->slots[3] = frame->slots[1] /* src */;
  arguments->slots[4] = string__46_18;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__46_19;
}
static void cont__46_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1202: write_to_phase_2 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__46_7(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // dest: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* dest */
  frame->slots[1] = myself->closure.frame->slots[0]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1198: ... "  assign_variable(&@(dest), &@(src));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__46_8;
  arguments->slots[1] = frame->slots[0] /* dest */;
  arguments->slots[2] = string__46_9;
  arguments->slots[3] = frame->slots[1] /* src */;
  arguments->slots[4] = string__46_10;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__46_11;
}
static void cont__46_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1198: write_to_phase_4 "  assign_variable(&@(dest), &@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__46_2(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // src: 0
  // dest: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  frame->slots[1] = myself->closure.frame->slots[0]; /* dest */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1197: ... alt("var." "func__")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__46_3;
  arguments->slots[1] = string__46_4;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__46_5;
}
static void cont__46_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1197: ... src .has_prefix. alt("var." "func__")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* src */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__46_6;
}
static void cont__46_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1197: ... :
  // 1198:   write_to_phase_4 "  assign_variable(&@(dest), &@(src));@nl;"
  frame->slots[4] /* temp__3 */ = create_closure(entry__46_7, 0);
  // 1197: -> src .has_prefix. alt("var." "func__"):
  // 1198:   write_to_phase_4 "  assign_variable(&@(dest), &@(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__46_12(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // src: 0
  // dest: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  frame->slots[1] = myself->closure.frame->slots[0]; /* dest */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1199: ... src .has_prefix. "unique__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* src */;
  arguments->slots[1] = string__46_13;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__46_14;
}
static void cont__46_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1199: ... :
  // 1200:   # was originally assigned in phase 5, but in some cases this is to late
  // 1201:   
  // 1202:   write_to_phase_2 "  assign_value(&@(dest), @(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__46_15, 0);
  // 1199: -> src .has_prefix. "unique__":
  // 1200:   # was originally assigned in phase 5, but in some cases this is to late
  // 1201:   
  // 1202:   write_to_phase_2 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__46_20(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // dest: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* dest */
  frame->slots[1] = myself->closure.frame->slots[1]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1204: ... "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__46_21;
  arguments->slots[1] = frame->slots[0] /* dest */;
  arguments->slots[2] = string__46_22;
  arguments->slots[3] = frame->slots[1] /* src */;
  arguments->slots[4] = string__46_23;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__46_24;
}
static void cont__46_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1204: write_to_phase_4 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__46_1(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // dest: 0
  // src: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1197: -> src .has_prefix. alt("var." "func__"):
  // 1198:   write_to_phase_4 "  assign_variable(&@(dest), &@(src));@nl;"
  frame->slots[2] /* temp__1 */ = create_closure(entry__46_2, 0);
  // 1199: -> src .has_prefix. "unique__":
  // 1200:   # was originally assigned in phase 5, but in some cases this is to late
  // 1201:   
  // 1202:   write_to_phase_2 "  assign_value(&@(dest), @(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__46_12, 0);
  // 1203: :
  // 1204:   write_to_phase_4 "  assign_value(&@(dest), @(src));@nl;"
  frame->slots[4] /* temp__3 */ = create_closure(entry__46_20, 0);
  // 1196: cond
  // 1197:   -> src .has_prefix. alt("var." "func__"):
  // 1198:     write_to_phase_4 "  assign_variable(&@(dest), &@(src));@nl;"
  // 1199:   -> src .has_prefix. "unique__":
  // 1200:     # was originally assigned in phase 5, but in some cases this is to late
  // 1201:     
  // 1202:     write_to_phase_2 "  assign_value(&@(dest), @(src));@nl;"
  // 1203:   :
  // 1204:     write_to_phase_4 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_180(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1354: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__47_181;
}
static void cont__47_181(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1351: ... "
  // 1352:   @
  // 1353:     maybe_initialize_future(get__@(mangled_name)(), @
  // 1354:   @(source.to_c));@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__47_182;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_183;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__47_184;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_185;
}
static void cont__47_185(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1351: write_to_phase_4 "
  // 1352:   @
  // 1353:     maybe_initialize_future(get__@(mangled_name)(), @
  // 1354:   @(source.to_c));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_186(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1358: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__47_187;
}
static void cont__47_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1356: ... "
  // 1357:   @
  // 1358:     initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // 1359:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__47_188;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_189;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__47_190;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_191;
}
static void cont__47_191(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1356: write_to_phase_4 "
  // 1357:   @
  // 1358:     initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // 1359:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_174(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1346: ... "
  // 1347:   @
  // 1348:     define__@(mangled_name)(create_future());
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_175;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_176;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_177;
}
static void cont__47_177(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1346: write_to_phase_2 "
  // 1347:   @
  // 1348:     define__@(mangled_name)(create_future());
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__47_178;
}
static void cont__47_178(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1350: source.might_be_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__might_be_constant();
  func = myself->type;
  frame->cont = cont__47_179;
}
static void cont__47_179(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1350: ... :
  // 1351:   write_to_phase_4 "
  // 1352:     @
  // 1353:       maybe_initialize_future(get__@(mangled_name)(), @
  // 1354:     @(source.to_c));@nl;@
  frame->slots[3] /* temp__2 */ = create_closure(entry__47_180, 0);
  // 1355: :
  // 1356:   write_to_phase_4 "
  // 1357:     @
  // 1358:       initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // 1359:     );@nl;@
  frame->slots[4] /* temp__3 */ = create_closure(entry__47_186, 0);
  // 1349: if
  // 1350:   source.might_be_constant:
  // 1351:     write_to_phase_4 "
  // 1352:       @
  // 1353:         maybe_initialize_future(get__@(mangled_name)(), @
  // 1354:       @(source.to_c));@nl;@
  // 1355:   :
  // 1356:     write_to_phase_4 "
  // 1357:       @
  // 1358:         initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_166(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1343: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__47_167;
}
static void cont__47_167(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1343: ... "  define__@(mangled_name)(@(source.to_c));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__47_168;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_169;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__47_170;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_171;
}
static void cont__47_171(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1343: write_to_phase_4 "  define__@(mangled_name)(@(source.to_c));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_172(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // source: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1345: ... source.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__47_173;
}
static void cont__47_173(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1345: ... :
  // 1346:   write_to_phase_2 "
  // 1347:     @
  // 1348:       define__@(mangled_name)(create_future());
  // 1349:   if
  // 1350:     source.might_be_constant:
  // 1351:       write_to_phase_4 "
  // 1352:         @
  // 1353:           maybe_initialize_future(get__@(mangled_name)(), @
  // 1354:         @(source.to_c));@nl;@
  // ...
  frame->slots[3] /* temp__2 */ = create_closure(entry__47_174, 0);
  // 1345: if source.is_an_identifier:
  // 1346:   write_to_phase_2 "
  // 1347:     @
  // 1348:       define__@(mangled_name)(create_future());
  // 1349:   if
  // 1350:     source.might_be_constant:
  // 1351:       write_to_phase_4 "
  // 1352:         @
  // 1353:           maybe_initialize_future(get__@(mangled_name)(), @
  // 1354:         @(source.to_c));@nl;@
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_164(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // source: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* source */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1342: source.is_a_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_constant();
  func = myself->type;
  frame->cont = cont__47_165;
}
static void cont__47_165(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1342: ... :
  // 1343:   write_to_phase_4 "  define__@(mangled_name)(@(source.to_c));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__47_166, 0);
  // 1344: :
  // 1345:   if source.is_an_identifier:
  // 1346:     write_to_phase_2 "
  // 1347:       @
  // 1348:         define__@(mangled_name)(create_future());
  // 1349:     if
  // 1350:       source.might_be_constant:
  // 1351:         write_to_phase_4 "
  // 1352:           @
  // 1353:             maybe_initialize_future(get__@(mangled_name)(), @
  // ...
  frame->slots[4] /* temp__3 */ = create_closure(entry__47_172, 0);
  // 1341: if
  // 1342:   source.is_a_constant:
  // 1343:     write_to_phase_4 "  define__@(mangled_name)(@(source.to_c));@nl;"
  // 1344:   :
  // 1345:     if source.is_an_identifier:
  // 1346:       write_to_phase_2 "
  // 1347:         @
  // 1348:           define__@(mangled_name)(create_future());
  // 1349:       if
  // 1350:         source.might_be_constant:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_1(void) {
  allocate_initialized_frame_gc(2, 10);
  // slot allocations:
  // definition: 0
  // source: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  // kind: 5
  frame->slots[2] /* namespace */ = create_future();
  frame->slots[3] /* name */ = create_future();
  frame->slots[4] /* mangled_name */ = create_future();
  frame->slots[5] /* kind */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1207: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = var._extract_destination;
  func = myself->type;
  frame->cont = cont__47_2;
}
static void cont__47_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  frame->slots[7] /* temp__2 */ = arguments->slots[1];
  frame->slots[8] /* temp__3 */ = arguments->slots[2];
  // 1207: ... namespace
  initialize_future(frame->slots[2] /* namespace */, frame->slots[6] /* temp__1 */);
  // 1207: ... name
  initialize_future(frame->slots[3] /* name */, frame->slots[7] /* temp__2 */);
  // 1207: ... mangled_name
  initialize_future(frame->slots[4] /* mangled_name */, frame->slots[8] /* temp__3 */);
  // 1208: ... definition.is_a_static_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_a_static_definition();
  func = myself->type;
  frame->cont = cont__47_3;
}
static void cont__47_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1208: ... :
  // 1209:   write_to_generated_collections "
  // 1210:     @
  // 1211:       @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1212:     );@nl;@
  frame->slots[7] /* temp__2 */ = create_closure(entry__47_4, 0);
  // 1208: if definition.is_a_static_definition:
  // 1209:   write_to_generated_collections "
  // 1210:     @
  // 1211:       @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1212:     );@nl;@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_11;
}
static void entry__47_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1211: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__47_5;
}
static void cont__47_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1211: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__47_6;
}
static void cont__47_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1209: ... "
  // 1210:   @
  // 1211:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1212:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__47_7;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__47_8;
  arguments->slots[3] = frame->slots[3] /* temp__3 */;
  arguments->slots[4] = string__47_9;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_10;
}
static void cont__47_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1209: write_to_generated_collections "
  // 1210:   @
  // 1211:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1212:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__47_11(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1213: $kind variable_kind_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__47_12;
}
static void cont__47_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* kind */, arguments->slots[0]);
  // 1214: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__47_13;
}
static void cont__47_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1214: ... kind == STATIC_SINGLE
  frame->slots[8] /* temp__3 */ = create_closure(entry__47_14, 0);
  // 1214: ... source.is_defined && kind == STATIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__47_16;
}
static void entry__47_14(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1214: ... kind == STATIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__STATIC_SINGLE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_15;
}
static void cont__47_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1214: ... kind == STATIC_SINGLE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1214: ... :
  // 1215:   assign var_entry(mangled_name) source.to_c
  // 1216:   
  // 1217:   #if
  // 1218:     source.is_a_constant:
  // 1219:       assign var_entry(mangled_name) source.to_c
  // 1220:     :
  // 1221:       if source.is_an_identifier:
  // 1222:         #write_to_phase_2 "
  // 1223:           @
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__47_17, 0);
  // 1214: if source.is_defined && kind == STATIC_SINGLE:
  // 1215:   assign var_entry(mangled_name) source.to_c
  // 1216:   
  // 1217:   #if
  // 1218:     source.is_a_constant:
  // 1219:       assign var_entry(mangled_name) source.to_c
  // 1220:     :
  // 1221:       if source.is_an_identifier:
  // 1222:         #write_to_phase_2 "
  // 1223:           @
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_20;
}
static void entry__47_17(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1215: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__47_18;
}
static void cont__47_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1215: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__47_19;
}
static void cont__47_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1215: assign var_entry(mangled_name) source.to_c
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = var._assign;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__47_20(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1235: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__47_21;
}
static void cont__47_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1235: ... :
  // 1236:   case
  // 1237:     kind
  // 1238:     STATIC_SINGLE:
  // 1239:       write_to_global_variable_declarations
  // 1240:         string("  NODE *" mangled_name ";@nl;")
  // 1241:       write_to_declarations "
  // 1242:         static NODE *get__@(namespace)__@(name)(void) {
  // 1243:           return var.@(namespace)__@(name);
  // 1244:         }
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__47_22, 0);
  // 1295: :
  // 1296:   case
  // 1297:     kind
  // 1298:     STATIC_SINGLE:
  // 1299:       write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1300:       write_to_top_level_variable_declarations
  // 1301:         string("  NODE *" var_name(mangled_name) ";@nl;")
  // 1302:       unless source.is_defined:
  // 1303:         write_to_phase_2 "
  // 1304:           @
  // ...
  frame->slots[8] /* temp__3 */ = create_closure(entry__47_100, 0);
  // 1234: if
  // 1235:   namespace.is_defined:
  // 1236:     case
  // 1237:       kind
  // 1238:       STATIC_SINGLE:
  // 1239:         write_to_global_variable_declarations
  // 1240:           string("  NODE *" mangled_name ";@nl;")
  // 1241:         write_to_declarations "
  // 1242:           static NODE *get__@(namespace)__@(name)(void) {
  // 1243:             return var.@(namespace)__@(name);
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_159;
}
static void entry__47_140(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1321: ... "
  // 1322:   @
  // 1323:     define__@(name)(create_future());
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_141;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__47_142;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_143;
}
static void cont__47_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1321: write_to_phase_2 "
  // 1322:   @
  // 1323:     define__@(name)(create_future());
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_112(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1305: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__47_113;
}
static void cont__47_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1303: ... "
  // 1304:   @
  // 1305:     @(var_entry(name)) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_114;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__47_115;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_116;
}
static void cont__47_116(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1303: write_to_phase_2 "
  // 1304:   @
  // 1305:     @(var_entry(name)) = create_future();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_101(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1299: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_102;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_103;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_104;
}
static void cont__47_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1299: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__47_105;
}
static void cont__47_105(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1301: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_name;
  func = myself->type;
  frame->cont = cont__47_106;
}
static void cont__47_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1301: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_107;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__47_108;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_109;
}
static void cont__47_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1300: write_to_top_level_variable_declarations
  // 1301:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame->cont = cont__47_110;
}
static void cont__47_110(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1302: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__47_111;
}
static void cont__47_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1302: ... :
  // 1303:   write_to_phase_2 "
  // 1304:     @
  // 1305:       @(var_entry(name)) = create_future();
  frame->slots[4] /* temp__2 */ = create_closure(entry__47_112, 0);
  // 1302: unless source.is_defined:
  // 1303:   write_to_phase_2 "
  // 1304:     @
  // 1305:       @(var_entry(name)) = create_future();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_117(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1307: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_118;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_119;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_120;
}
static void cont__47_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1307: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__47_121;
}
static void cont__47_121(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1309: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_name;
  func = myself->type;
  frame->cont = cont__47_122;
}
static void cont__47_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1309: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_123;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__47_124;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_125;
}
static void cont__47_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1308: write_to_top_level_variable_declarations
  // 1309:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_126(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1311: ... "
  // 1312:   static int dyna_idx__@(name);
  // 1313:   static NODE *get__@(name)(void) {
  // 1314:     return get_dynamic_slot(dyna_idx__@(name));
  // 1315:   }
  // 1316:   static void define__@(name)(NODE *node) {
  // 1317:     define_dynamic_slot(dyna_idx__@(name), node);
  // 1318:   }
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__47_127;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__47_128;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__47_129;
  arguments->slots[5] = frame->slots[0] /* name */;
  arguments->slots[6] = string__47_130;
  arguments->slots[7] = frame->slots[0] /* name */;
  arguments->slots[8] = string__47_131;
  arguments->slots[9] = frame->slots[0] /* name */;
  arguments->slots[10] = string__47_132;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_133;
}
static void cont__47_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1311: write_to_declarations "
  // 1312:   static int dyna_idx__@(name);
  // 1313:   static NODE *get__@(name)(void) {
  // 1314:     return get_dynamic_slot(dyna_idx__@(name));
  // 1315:   }
  // 1316:   static void define__@(name)(NODE *node) {
  // 1317:     define_dynamic_slot(dyna_idx__@(name), node);
  // 1318:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__47_134;
}
static void cont__47_134(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1319: ... "  register_dynamic(&dyna_idx__@(name));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_135;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__47_136;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_137;
}
static void cont__47_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1319: write_to_phase_2 "  register_dynamic(&dyna_idx__@(name));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__47_138;
}
static void cont__47_138(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1320: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__47_139;
}
static void cont__47_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1320: ... :
  // 1321:   write_to_phase_2 "
  // 1322:     @
  // 1323:       define__@(name)(create_future());
  frame->slots[3] /* temp__2 */ = create_closure(entry__47_140, 0);
  // 1320: unless source.is_defined:
  // 1321:   write_to_phase_2 "
  // 1322:     @
  // 1323:       define__@(name)(create_future());
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_144(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1325: ... "
  // 1326:   static int dyna_idx__@(name);
  // 1327:   static NODE *get__@(name)(void) {
  // 1328:     return get_dynamic_cell(dyna_idx__@(name));
  // 1329:   }
  // 1330:   static void set__@(name)(NODE *node) {
  // 1331:     set_dynamic_cell(dyna_idx__@(name), node);
  // 1332:   }
  // 1333:   static void define__@(name)(NODE *node) {
  // 1334:     define_dynamic_cell(dyna_idx__@(name), node);
  // ...
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__47_145;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__47_146;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__47_147;
  arguments->slots[5] = frame->slots[0] /* name */;
  arguments->slots[6] = string__47_148;
  arguments->slots[7] = frame->slots[0] /* name */;
  arguments->slots[8] = string__47_149;
  arguments->slots[9] = frame->slots[0] /* name */;
  arguments->slots[10] = string__47_150;
  arguments->slots[11] = frame->slots[0] /* name */;
  arguments->slots[12] = string__47_151;
  arguments->slots[13] = frame->slots[0] /* name */;
  arguments->slots[14] = string__47_152;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_153;
}
static void cont__47_153(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1325: write_to_declarations "
  // 1326:   static int dyna_idx__@(name);
  // 1327:   static NODE *get__@(name)(void) {
  // 1328:     return get_dynamic_cell(dyna_idx__@(name));
  // 1329:   }
  // 1330:   static void set__@(name)(NODE *node) {
  // 1331:     set_dynamic_cell(dyna_idx__@(name), node);
  // 1332:   }
  // 1333:   static void define__@(name)(NODE *node) {
  // 1334:     define_dynamic_cell(dyna_idx__@(name), node);
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__47_154;
}
static void cont__47_154(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1336: ... "
  // 1337:   @
  // 1338:     register_dynamic(&dyna_idx__@(name));
  // 1339:     define__@(name)(undefined);
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__47_155;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__47_156;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__47_157;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_158;
}
static void cont__47_158(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1336: write_to_phase_2 "
  // 1337:   @
  // 1338:     register_dynamic(&dyna_idx__@(name));
  // 1339:     define__@(name)(undefined);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_23(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1240: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_24;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_25;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_26;
}
static void cont__47_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1239: write_to_global_variable_declarations
  // 1240:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame->cont = cont__47_27;
}
static void cont__47_27(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1241: ... "
  // 1242:   static NODE *get__@(namespace)__@(name)(void) {
  // 1243:     return var.@(namespace)__@(name);
  // 1244:   }
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__47_28;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__47_29;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__47_30;
  arguments->slots[5] = frame->slots[1] /* namespace */;
  arguments->slots[6] = string__47_31;
  arguments->slots[7] = frame->slots[2] /* name */;
  arguments->slots[8] = string__47_32;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_33;
}
static void cont__47_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1241: write_to_declarations "
  // 1242:   static NODE *get__@(namespace)__@(name)(void) {
  // 1243:     return var.@(namespace)__@(name);
  // 1244:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__47_34;
}
static void cont__47_34(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1248: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__47_35;
}
static void cont__47_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1245: ... "
  // 1246:   @
  // 1247:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1248:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__47_36;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__47_37;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__47_38;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__47_39;
  arguments->slots[7] = frame->slots[4] /* temp__2 */;
  arguments->slots[8] = string__47_40;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_41;
}
static void cont__47_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1245: write_to_phase_2 "
  // 1246:   @
  // 1247:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1248:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_42(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1251: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_43;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_44;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_45;
}
static void cont__47_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1250: write_to_global_variable_declarations
  // 1251:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame->cont = cont__47_46;
}
static void cont__47_46(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1252: ... "
  // 1253:   static NODE *get__@(namespace)__@(name)(void) {
  // 1254:     return var.@(namespace)__@(name);
  // 1255:   }
  // 1256:   static void set__@(namespace)__@(name)(NODE *val) {
  // 1257:     var.@(namespace)__@(name) = val;
  // 1258:   }
  argument_count = 17;
  arguments = node_p;
  arguments->slots[0] = string__47_47;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__47_48;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__47_49;
  arguments->slots[5] = frame->slots[1] /* namespace */;
  arguments->slots[6] = string__47_50;
  arguments->slots[7] = frame->slots[2] /* name */;
  arguments->slots[8] = string__47_51;
  arguments->slots[9] = frame->slots[1] /* namespace */;
  arguments->slots[10] = string__47_52;
  arguments->slots[11] = frame->slots[2] /* name */;
  arguments->slots[12] = string__47_53;
  arguments->slots[13] = frame->slots[1] /* namespace */;
  arguments->slots[14] = string__47_54;
  arguments->slots[15] = frame->slots[2] /* name */;
  arguments->slots[16] = string__47_55;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_56;
}
static void cont__47_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1252: write_to_declarations "
  // 1253:   static NODE *get__@(namespace)__@(name)(void) {
  // 1254:     return var.@(namespace)__@(name);
  // 1255:   }
  // 1256:   static void set__@(namespace)__@(name)(NODE *val) {
  // 1257:     var.@(namespace)__@(name) = val;
  // 1258:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__47_57;
}
static void cont__47_57(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1259: ... "
  // 1260:   @
  // 1261:     define_multi_assign_static("@(namespace)", "@(name)", @
  // 1262:   get__@(mangled_name), set__@(mangled_name));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__47_58;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__47_59;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__47_60;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__47_61;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__47_62;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_63;
}
static void cont__47_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1259: write_to_phase_2 "
  // 1260:   @
  // 1261:     define_multi_assign_static("@(namespace)", "@(name)", @
  // 1262:   get__@(mangled_name), set__@(mangled_name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_64(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1264: ... "
  // 1265:   static int dyna_idx__@(mangled_name);
  // 1266:   static NODE *get__@(mangled_name)(void) {
  // 1267:     return get_dynamic_slot(dyna_idx__@(mangled_name));
  // 1268:   }
  // 1269:   static void define__@(mangled_name)(NODE *node) {
  // 1270:     define_dynamic_slot(dyna_idx__@(mangled_name), node);
  // 1271:   }
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__47_65;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_66;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__47_67;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__47_68;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__47_69;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__47_70;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_71;
}
static void cont__47_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1264: write_to_declarations "
  // 1265:   static int dyna_idx__@(mangled_name);
  // 1266:   static NODE *get__@(mangled_name)(void) {
  // 1267:     return get_dynamic_slot(dyna_idx__@(mangled_name));
  // 1268:   }
  // 1269:   static void define__@(mangled_name)(NODE *node) {
  // 1270:     define_dynamic_slot(dyna_idx__@(mangled_name), node);
  // 1271:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__47_72;
}
static void cont__47_72(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1272: ... "
  // 1273:   @
  // 1274:     define_single_assign_dynamic("@(namespace)", "@(name)", @
  // 1275:   get__@(mangled_name), define__@(mangled_name), @
  // 1276:   &dyna_idx__@(mangled_name));
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__47_73;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__47_74;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__47_75;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__47_76;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__47_77;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__47_78;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_79;
}
static void cont__47_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1272: write_to_phase_2 "
  // 1273:   @
  // 1274:     define_single_assign_dynamic("@(namespace)", "@(name)", @
  // 1275:   get__@(mangled_name), define__@(mangled_name), @
  // 1276:   &dyna_idx__@(mangled_name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_80(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1278: ... "
  // 1279:   static int dyna_idx__@(mangled_name);
  // 1280:   static NODE *get__@(mangled_name)(void) {
  // 1281:     return get_dynamic_cell(dyna_idx__@(mangled_name));
  // 1282:   }
  // 1283:   static void set__@(mangled_name)(NODE *node) {
  // 1284:     set_dynamic_cell(dyna_idx__@(mangled_name), node);
  // 1285:   }
  // 1286:   static void define__@(mangled_name)(NODE *node) {
  // 1287:     define_dynamic_cell(dyna_idx__@(mangled_name), node);
  // ...
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__47_81;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__47_82;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__47_83;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__47_84;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__47_85;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__47_86;
  arguments->slots[11] = frame->slots[0] /* mangled_name */;
  arguments->slots[12] = string__47_87;
  arguments->slots[13] = frame->slots[0] /* mangled_name */;
  arguments->slots[14] = string__47_88;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_89;
}
static void cont__47_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1278: write_to_declarations "
  // 1279:   static int dyna_idx__@(mangled_name);
  // 1280:   static NODE *get__@(mangled_name)(void) {
  // 1281:     return get_dynamic_cell(dyna_idx__@(mangled_name));
  // 1282:   }
  // 1283:   static void set__@(mangled_name)(NODE *node) {
  // 1284:     set_dynamic_cell(dyna_idx__@(mangled_name), node);
  // 1285:   }
  // 1286:   static void define__@(mangled_name)(NODE *node) {
  // 1287:     define_dynamic_cell(dyna_idx__@(mangled_name), node);
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__47_90;
}
static void cont__47_90(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1289: ... "
  // 1290:   @
  // 1291:     define_multi_assign_dynamic("@(namespace)", "@(name)", @
  // 1292:   get__@(mangled_name), set__@(mangled_name), define__@(mangled_name)@
  // 1293:   , &dyna_idx__@(mangled_name));
  // 1294:     define__@(mangled_name)(undefined);
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__47_91;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__47_92;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__47_93;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__47_94;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__47_95;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__47_96;
  arguments->slots[11] = frame->slots[0] /* mangled_name */;
  arguments->slots[12] = string__47_97;
  arguments->slots[13] = frame->slots[0] /* mangled_name */;
  arguments->slots[14] = string__47_98;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__47_99;
}
static void cont__47_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1289: write_to_phase_2 "
  // 1290:   @
  // 1291:     define_multi_assign_dynamic("@(namespace)", "@(name)", @
  // 1292:   get__@(mangled_name), set__@(mangled_name), define__@(mangled_name)@
  // 1293:   , &dyna_idx__@(mangled_name));
  // 1294:     define__@(mangled_name)(undefined);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_22(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // kind: 0
  // mangled_name: 1
  // namespace: 2
  // name: 3
  frame->slots[0] = myself->closure.frame->slots[5]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[3] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1238: ... :
  // 1239:   write_to_global_variable_declarations
  // 1240:     string("  NODE *" mangled_name ";@nl;")
  // 1241:   write_to_declarations "
  // 1242:     static NODE *get__@(namespace)__@(name)(void) {
  // 1243:       return var.@(namespace)__@(name);
  // 1244:     }
  // 1245:   write_to_phase_2 "
  // 1246:     @
  // 1247:       define_single_assign_static("@(namespace)", "@(name)", @
  // ...
  frame->slots[4] /* temp__1 */ = create_closure(entry__47_23, 0);
  // 1249: ... :
  // 1250:   write_to_global_variable_declarations
  // 1251:     string("  NODE *" mangled_name ";@nl;")
  // 1252:   write_to_declarations "
  // 1253:     static NODE *get__@(namespace)__@(name)(void) {
  // 1254:       return var.@(namespace)__@(name);
  // 1255:     }
  // 1256:     static void set__@(namespace)__@(name)(NODE *val) {
  // 1257:       var.@(namespace)__@(name) = val;
  // 1258:     }
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__47_42, 0);
  // 1263: ... :
  // 1264:   write_to_declarations "
  // 1265:     static int dyna_idx__@(mangled_name);
  // 1266:     static NODE *get__@(mangled_name)(void) {
  // 1267:       return get_dynamic_slot(dyna_idx__@(mangled_name));
  // 1268:     }
  // 1269:     static void define__@(mangled_name)(NODE *node) {
  // 1270:       define_dynamic_slot(dyna_idx__@(mangled_name), node);
  // 1271:     }
  // 1272:   write_to_phase_2 "
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__47_64, 0);
  // 1277: ... :
  // 1278:   write_to_declarations "
  // 1279:     static int dyna_idx__@(mangled_name);
  // 1280:     static NODE *get__@(mangled_name)(void) {
  // 1281:       return get_dynamic_cell(dyna_idx__@(mangled_name));
  // 1282:     }
  // 1283:     static void set__@(mangled_name)(NODE *node) {
  // 1284:       set_dynamic_cell(dyna_idx__@(mangled_name), node);
  // 1285:     }
  // 1286:     static void define__@(mangled_name)(NODE *node) {
  // ...
  frame->slots[7] /* temp__4 */ = create_closure(entry__47_80, 0);
  // 1236: case
  // 1237:   kind
  // 1238:   STATIC_SINGLE:
  // 1239:     write_to_global_variable_declarations
  // 1240:       string("  NODE *" mangled_name ";@nl;")
  // 1241:     write_to_declarations "
  // 1242:       static NODE *get__@(namespace)__@(name)(void) {
  // 1243:         return var.@(namespace)__@(name);
  // 1244:       }
  // 1245:     write_to_phase_2 "
  // ...
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  arguments->slots[3] = get__STATIC_MULTI();
  arguments->slots[4] = frame->slots[5] /* temp__2 */;
  arguments->slots[5] = get__DYNAMIC_SINGLE();
  arguments->slots[6] = frame->slots[6] /* temp__3 */;
  arguments->slots[7] = get__DYNAMIC_MULTI();
  arguments->slots[8] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__47_100(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // kind: 0
  // mangled_name: 1
  // source: 2
  // name: 3
  frame->slots[0] = myself->closure.frame->slots[5]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[1]; /* source */
  frame->slots[3] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1298: ... :
  // 1299:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1300:   write_to_top_level_variable_declarations
  // 1301:     string("  NODE *" var_name(mangled_name) ";@nl;")
  // 1302:   unless source.is_defined:
  // 1303:     write_to_phase_2 "
  // 1304:       @
  // 1305:         @(var_entry(name)) = create_future();
  frame->slots[4] /* temp__1 */ = create_closure(entry__47_101, 0);
  // 1306: ... :
  // 1307:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1308:   write_to_top_level_variable_declarations
  // 1309:     string("  NODE *" var_name(mangled_name) ";@nl;")
  frame->slots[5] /* temp__2 */ = create_closure(entry__47_117, 0);
  // 1310: ... :
  // 1311:   write_to_declarations "
  // 1312:     static int dyna_idx__@(name);
  // 1313:     static NODE *get__@(name)(void) {
  // 1314:       return get_dynamic_slot(dyna_idx__@(name));
  // 1315:     }
  // 1316:     static void define__@(name)(NODE *node) {
  // 1317:       define_dynamic_slot(dyna_idx__@(name), node);
  // 1318:     }
  // 1319:   write_to_phase_2 "  register_dynamic(&dyna_idx__@(name));@nl;"
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__47_126, 0);
  // 1324: ... :
  // 1325:   write_to_declarations "
  // 1326:     static int dyna_idx__@(name);
  // 1327:     static NODE *get__@(name)(void) {
  // 1328:       return get_dynamic_cell(dyna_idx__@(name));
  // 1329:     }
  // 1330:     static void set__@(name)(NODE *node) {
  // 1331:       set_dynamic_cell(dyna_idx__@(name), node);
  // 1332:     }
  // 1333:     static void define__@(name)(NODE *node) {
  // ...
  frame->slots[7] /* temp__4 */ = create_closure(entry__47_144, 0);
  // 1296: case
  // 1297:   kind
  // 1298:   STATIC_SINGLE:
  // 1299:     write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1300:     write_to_top_level_variable_declarations
  // 1301:       string("  NODE *" var_name(mangled_name) ";@nl;")
  // 1302:     unless source.is_defined:
  // 1303:       write_to_phase_2 "
  // 1304:         @
  // 1305:           @(var_entry(name)) = create_future();
  // ...
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  arguments->slots[3] = get__STATIC_MULTI();
  arguments->slots[4] = frame->slots[5] /* temp__2 */;
  arguments->slots[5] = get__DYNAMIC_SINGLE();
  arguments->slots[6] = frame->slots[6] /* temp__3 */;
  arguments->slots[7] = get__DYNAMIC_MULTI();
  arguments->slots[8] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__47_159(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1340: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__47_160;
}
static void cont__47_160(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1340: ... kind == DYNAMIC_SINGLE
  frame->slots[8] /* temp__3 */ = create_closure(entry__47_161, 0);
  // 1340: ... source.is_defined && kind == DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__47_163;
}
static void entry__47_161(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1340: ... kind == DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__DYNAMIC_SINGLE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_162;
}
static void cont__47_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1340: ... kind == DYNAMIC_SINGLE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_163(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1340: ... :
  // 1341:   if
  // 1342:     source.is_a_constant:
  // 1343:       write_to_phase_4 "  define__@(mangled_name)(@(source.to_c));@nl;"
  // 1344:     :
  // 1345:       if source.is_an_identifier:
  // 1346:         write_to_phase_2 "
  // 1347:           @
  // 1348:             define__@(mangled_name)(create_future());
  // 1349:         if
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__47_164, 0);
  // 1340: if source.is_defined && kind == DYNAMIC_SINGLE:
  // 1341:   if
  // 1342:     source.is_a_constant:
  // 1343:       write_to_phase_4 "  define__@(mangled_name)(@(source.to_c));@nl;"
  // 1344:     :
  // 1345:       if source.is_an_identifier:
  // 1346:         write_to_phase_2 "
  // 1347:           @
  // 1348:             define__@(mangled_name)(create_future());
  // 1349:         if
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__48_3(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // namespace: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* namespace */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1362: ... "@quot;@(namespace)@quot;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__48_4;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__48_5;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__48_6;
}
static void cont__48_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1362: ... -> "@quot;@(namespace)@quot;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__48_7(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1362: ... -> "NULL"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__48_8;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__48_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // namespace: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1362: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__48_2;
}
static void cont__48_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1362: ... -> "@quot;@(namespace)@quot;"
  frame->slots[2] /* temp__2 */ = create_closure(entry__48_3, 0);
  // 1362: if namespace.is_defined (-> "@quot;@(namespace)@quot;") -> "NULL"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = func__48_7;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__49_21(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // attribute_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[3] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1382: ... namespace_argument(namespace)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = var._namespace_argument;
  func = myself->type;
  frame->cont = cont__49_22;
}
static void cont__49_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1380: ... "
  // 1381:   @
  // 1382:     define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1383:   poly_idx__@(attribute_name), @(src));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__49_23;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__49_24;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__49_25;
  arguments->slots[5] = frame->slots[2] /* attribute_name */;
  arguments->slots[6] = string__49_26;
  arguments->slots[7] = ((CELL *)frame->slots[3])->contents /* src */;
  arguments->slots[8] = string__49_27;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__49_28;
}
static void cont__49_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1380: write_to_phase_3 "
  // 1381:   @
  // 1382:     define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1383:   poly_idx__@(attribute_name), @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__49_29(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // name: 0
  // attribute_name: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[2] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1388: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__49_30;
}
static void cont__49_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1385: ... "
  // 1386:   @
  // 1387:     update_start_p = node_p;
  // 1388:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1389:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__49_31;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__49_32;
  arguments->slots[3] = frame->slots[1] /* attribute_name */;
  arguments->slots[4] = string__49_33;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* src */;
  arguments->slots[6] = string__49_34;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__49_35;
}
static void cont__49_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1385: write_to_phase_3 "
  // 1386:   @
  // 1387:     update_start_p = node_p;
  // 1388:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1389:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__49_1(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // source: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  // attribute_name: 5
  // src: 6
  frame->slots[2] /* namespace */ = create_future();
  frame->slots[3] /* name */ = create_future();
  frame->slots[4] /* mangled_name */ = create_future();
  frame->slots[5] /* attribute_name */ = create_future();
  frame->slots[6] /* src */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1365: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = var._extract_destination;
  func = myself->type;
  frame->cont = cont__49_2;
}
static void cont__49_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  frame->slots[8] /* temp__2 */ = arguments->slots[1];
  frame->slots[9] /* temp__3 */ = arguments->slots[2];
  // 1365: ... namespace
  initialize_future(frame->slots[2] /* namespace */, frame->slots[7] /* temp__1 */);
  // 1365: ... name
  initialize_future(frame->slots[3] /* name */, frame->slots[8] /* temp__2 */);
  // 1365: ... mangled_name
  initialize_future(frame->slots[4] /* mangled_name */, frame->slots[9] /* temp__3 */);
  // 1366: ... attribute_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__49_3;
}
static void cont__49_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1366: $attribute_name mangled_name_of(attribute_of(definition))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__49_4;
}
static void cont__49_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* attribute_name */, arguments->slots[0]);
  // 1367: $$src undefined
  ((CELL *)frame->slots[6])->contents /* src */ = get__undefined();
  // 1369: source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__49_5;
}
static void cont__49_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1369: ... :
  // 1370:   !src source.to_c
  frame->slots[8] /* temp__2 */ = create_closure(entry__49_6, 0);
  // 1371: :
  // 1372:   !src string("var__" mangled_name "__" attribute_name)
  // 1373:   write_to_declarations "static NODE *@(src);@nl;"
  // 1374:   
  // 1375:   #write_to_phase_2 "
  // 1376:     @
  // 1377:       @(src) = create_future();
  frame->slots[9] /* temp__3 */ = create_closure(entry__49_8, 0);
  // 1368: if
  // 1369:   source.is_defined:
  // 1370:     !src source.to_c
  // 1371:   :
  // 1372:     !src string("var__" mangled_name "__" attribute_name)
  // 1373:     write_to_declarations "static NODE *@(src);@nl;"
  // 1374:     
  // 1375:     #write_to_phase_2 "
  // 1376:       @
  // 1377:         @(src) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__49_15;
}
static void entry__49_6(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // src: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1370: !src source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__49_7;
}
static void cont__49_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__49_8(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // src: 0
  // mangled_name: 1
  // attribute_name: 2
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1372: !src string("var__" mangled_name "__" attribute_name)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__49_9;
  arguments->slots[1] = frame->slots[1] /* mangled_name */;
  arguments->slots[2] = string__49_10;
  arguments->slots[3] = frame->slots[2] /* attribute_name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__49_11;
}
static void cont__49_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  // 1373: ... "static NODE *@(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__49_12;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* src */;
  arguments->slots[2] = string__49_13;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__49_14;
}
static void cont__49_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1373: write_to_declarations "static NODE *@(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__49_15(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1379: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__49_16;
}
static void cont__49_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1379: ... needed_names(name).is_defined
  frame->slots[9] /* temp__3 */ = create_closure(entry__49_17, 0);
  // 1379: namespace.is_defined || needed_names(name).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__49_20;
}
static void entry__49_17(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1379: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__49_18;
}
static void cont__49_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1379: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__49_19;
}
static void cont__49_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1379: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__49_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1379: ... :
  // 1380:   write_to_phase_3 "
  // 1381:     @
  // 1382:       define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1383:     poly_idx__@(attribute_name), @(src));
  frame->slots[10] /* temp__4 */ = create_closure(entry__49_21, 0);
  // 1384: :
  // 1385:   write_to_phase_3 "
  // 1386:     @
  // 1387:       update_start_p = node_p;
  // 1388:       def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1389:     MAKE_ATTRIBUTE_VALUE(@(src)));
  frame->slots[11] /* temp__5 */ = create_closure(entry__49_29, 0);
  // 1378: if
  // 1379:   namespace.is_defined || needed_names(name).is_defined:
  // 1380:     write_to_phase_3 "
  // 1381:       @
  // 1382:         define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1383:       poly_idx__@(attribute_name), @(src));
  // 1384:   :
  // 1385:     write_to_phase_3 "
  // 1386:       @
  // 1387:         update_start_p = node_p;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__50_21(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // attribute_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[3] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1409: ... namespace_argument(namespace)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = var._namespace_argument;
  func = myself->type;
  frame->cont = cont__50_22;
}
static void cont__50_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1407: ... "
  // 1408:   @
  // 1409:     define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1410:   poly_idx__@(attribute_name), @(src));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__50_23;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__50_24;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__50_25;
  arguments->slots[5] = frame->slots[2] /* attribute_name */;
  arguments->slots[6] = string__50_26;
  arguments->slots[7] = ((CELL *)frame->slots[3])->contents /* src */;
  arguments->slots[8] = string__50_27;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__50_28;
}
static void cont__50_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1407: write_to_phase_3 "
  // 1408:   @
  // 1409:     define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1410:   poly_idx__@(attribute_name), @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__50_29(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // name: 0
  // attribute_name: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[2] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1415: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__50_30;
}
static void cont__50_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1412: ... "
  // 1413:   @
  // 1414:     update_start_p = node_p;
  // 1415:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1416:   @(src));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__50_31;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__50_32;
  arguments->slots[3] = frame->slots[1] /* attribute_name */;
  arguments->slots[4] = string__50_33;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* src */;
  arguments->slots[6] = string__50_34;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__50_35;
}
static void cont__50_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1412: write_to_phase_3 "
  // 1413:   @
  // 1414:     update_start_p = node_p;
  // 1415:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1416:   @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__50_1(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // source: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  // attribute_name: 5
  // src: 6
  frame->slots[2] /* namespace */ = create_future();
  frame->slots[3] /* name */ = create_future();
  frame->slots[4] /* mangled_name */ = create_future();
  frame->slots[5] /* attribute_name */ = create_future();
  frame->slots[6] /* src */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1392: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = var._extract_destination;
  func = myself->type;
  frame->cont = cont__50_2;
}
static void cont__50_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  frame->slots[8] /* temp__2 */ = arguments->slots[1];
  frame->slots[9] /* temp__3 */ = arguments->slots[2];
  // 1392: ... namespace
  initialize_future(frame->slots[2] /* namespace */, frame->slots[7] /* temp__1 */);
  // 1392: ... name
  initialize_future(frame->slots[3] /* name */, frame->slots[8] /* temp__2 */);
  // 1392: ... mangled_name
  initialize_future(frame->slots[4] /* mangled_name */, frame->slots[9] /* temp__3 */);
  // 1393: ... attribute_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__50_3;
}
static void cont__50_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1393: $attribute_name mangled_name_of(attribute_of(definition))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__50_4;
}
static void cont__50_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* attribute_name */, arguments->slots[0]);
  // 1394: $$src undefined
  ((CELL *)frame->slots[6])->contents /* src */ = get__undefined();
  // 1396: source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__50_5;
}
static void cont__50_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1396: ... :
  // 1397:   !src source.to_c
  frame->slots[8] /* temp__2 */ = create_closure(entry__50_6, 0);
  // 1398: :
  // 1399:   !src string("var__" mangled_name "__" attribute_name)
  // 1400:   write_to_declarations "static NODE *@(src);@nl;"
  // 1401:   
  // 1402:   #write_to_phase_2 "
  // 1403:     @
  // 1404:       @(src) = create_future();
  frame->slots[9] /* temp__3 */ = create_closure(entry__50_8, 0);
  // 1395: if
  // 1396:   source.is_defined:
  // 1397:     !src source.to_c
  // 1398:   :
  // 1399:     !src string("var__" mangled_name "__" attribute_name)
  // 1400:     write_to_declarations "static NODE *@(src);@nl;"
  // 1401:     
  // 1402:     #write_to_phase_2 "
  // 1403:       @
  // 1404:         @(src) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__50_15;
}
static void entry__50_6(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // src: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1397: !src source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__50_7;
}
static void cont__50_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__50_8(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // src: 0
  // mangled_name: 1
  // attribute_name: 2
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1399: !src string("var__" mangled_name "__" attribute_name)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__50_9;
  arguments->slots[1] = frame->slots[1] /* mangled_name */;
  arguments->slots[2] = string__50_10;
  arguments->slots[3] = frame->slots[2] /* attribute_name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__50_11;
}
static void cont__50_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  // 1400: ... "static NODE *@(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__50_12;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* src */;
  arguments->slots[2] = string__50_13;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__50_14;
}
static void cont__50_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1400: write_to_declarations "static NODE *@(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__50_15(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1406: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__50_16;
}
static void cont__50_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1406: ... needed_names(name).is_defined
  frame->slots[9] /* temp__3 */ = create_closure(entry__50_17, 0);
  // 1406: namespace.is_defined || needed_names(name).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__50_20;
}
static void entry__50_17(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1406: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__50_18;
}
static void cont__50_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1406: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__50_19;
}
static void cont__50_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1406: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__50_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1406: ... :
  // 1407:   write_to_phase_3 "
  // 1408:     @
  // 1409:       define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1410:     poly_idx__@(attribute_name), @(src));
  frame->slots[10] /* temp__4 */ = create_closure(entry__50_21, 0);
  // 1411: :
  // 1412:   write_to_phase_3 "
  // 1413:     @
  // 1414:       update_start_p = node_p;
  // 1415:       def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1416:     @(src));
  frame->slots[11] /* temp__5 */ = create_closure(entry__50_29, 0);
  // 1405: if
  // 1406:   namespace.is_defined || needed_names(name).is_defined:
  // 1407:     write_to_phase_3 "
  // 1408:       @
  // 1409:         define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1410:       poly_idx__@(attribute_name), @(src));
  // 1411:   :
  // 1412:     write_to_phase_3 "
  // 1413:       @
  // 1414:         update_start_p = node_p;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__51_9(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // entry: 2
  // par_count: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* entry */
  frame->slots[3] = myself->closure.frame->slots[6]; /* par_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1425: ... namespace_argument(namespace)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = var._namespace_argument;
  func = myself->type;
  frame->cont = cont__51_10;
}
static void cont__51_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1423: ... "
  // 1424:   @
  // 1425:     define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1426:   @quot;, @(entry), @(par_count));@nl;@
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__51_11;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__51_12;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__51_13;
  arguments->slots[5] = frame->slots[2] /* entry */;
  arguments->slots[6] = string__51_14;
  arguments->slots[7] = frame->slots[3] /* par_count */;
  arguments->slots[8] = string__51_15;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__51_16;
}
static void cont__51_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1423: write_to_phase_3 "
  // 1424:   @
  // 1425:     define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1426:   @quot;, @(entry), @(par_count));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__51_17(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // name: 0
  // entry: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[5]; /* entry */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1431: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__51_18;
}
static void cont__51_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1428: ... "
  // 1429:   @
  // 1430:     update_start_p = node_p;
  // 1431:     def_attribute(&@(var_entry(name)), -1, @(entry));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__51_19;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__51_20;
  arguments->slots[3] = frame->slots[1] /* entry */;
  arguments->slots[4] = string__51_21;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__51_22;
}
static void cont__51_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1428: write_to_phase_3 "
  // 1429:   @
  // 1430:     update_start_p = node_p;
  // 1431:     def_attribute(&@(var_entry(name)), -1, @(entry));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__51_1(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // source: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  // entry: 5
  // par_count: 6
  frame->slots[2] /* namespace */ = create_future();
  frame->slots[3] /* name */ = create_future();
  frame->slots[4] /* mangled_name */ = create_future();
  frame->slots[5] /* entry */ = create_future();
  frame->slots[6] /* par_count */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1419: extract_destination definition $namespace $name $_mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = var._extract_destination;
  func = myself->type;
  frame->cont = cont__51_2;
}
static void cont__51_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  frame->slots[8] /* temp__2 */ = arguments->slots[1];
  frame->slots[9] /* temp__3 */ = arguments->slots[2];
  // 1419: ... namespace
  initialize_future(frame->slots[2] /* namespace */, frame->slots[7] /* temp__1 */);
  // 1419: ... name
  initialize_future(frame->slots[3] /* name */, frame->slots[8] /* temp__2 */);
  // 1419: ... _mangled_name
  initialize_future(frame->slots[4] /* mangled_name */, frame->slots[9] /* temp__3 */);
  // 1420: to_c source $entry $par_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 2;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__51_3;
}
static void cont__51_3(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  frame->slots[8] /* temp__2 */ = arguments->slots[1];
  // 1420: ... entry
  initialize_future(frame->slots[5] /* entry */, frame->slots[7] /* temp__1 */);
  // 1420: ... par_count
  initialize_future(frame->slots[6] /* par_count */, frame->slots[8] /* temp__2 */);
  // 1422: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__51_4;
}
static void cont__51_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1422: ... needed_names(name).is_defined
  frame->slots[9] /* temp__3 */ = create_closure(entry__51_5, 0);
  // 1422: namespace.is_defined || needed_names(name).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__51_8;
}
static void entry__51_5(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1422: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__51_6;
}
static void cont__51_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1422: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__51_7;
}
static void cont__51_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1422: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__51_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1422: ... :
  // 1423:   write_to_phase_3 "
  // 1424:     @
  // 1425:       define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1426:     @quot;, @(entry), @(par_count));@nl;@
  frame->slots[10] /* temp__4 */ = create_closure(entry__51_9, 0);
  // 1427: :
  // 1428:   write_to_phase_3 "
  // 1429:     @
  // 1430:       update_start_p = node_p;
  // 1431:       def_attribute(&@(var_entry(name)), -1, @(entry));
  frame->slots[11] /* temp__5 */ = create_closure(entry__51_17, 0);
  // 1421: if
  // 1422:   namespace.is_defined || needed_names(name).is_defined:
  // 1423:     write_to_phase_3 "
  // 1424:       @
  // 1425:         define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1426:       @quot;, @(entry), @(par_count));@nl;@
  // 1427:   :
  // 1428:     write_to_phase_3 "
  // 1429:       @
  // 1430:         update_start_p = node_p;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__52_64(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // mangled_name: 2
  // id: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  frame->slots[2] = myself->closure.frame->slots[3]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[2]; /* id */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1476: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__52_65;
}
static void cont__52_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1473: ... "
  // 1474:   @
  // 1475:     define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1476:   ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__52_66;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__52_67;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__52_68;
  arguments->slots[5] = frame->slots[2] /* mangled_name */;
  arguments->slots[6] = string__52_69;
  arguments->slots[7] = frame->slots[3] /* id */;
  arguments->slots[8] = string__52_70;
  arguments->slots[9] = frame->slots[5] /* temp__2 */;
  arguments->slots[10] = string__52_71;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_72;
}
static void cont__52_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1473: write_to_phase_1 "
  // 1474:   @
  // 1475:     define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1476:   ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_1();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__52_73(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // with_setter: 0
  // namespace: 1
  // name: 2
  // mangled_name: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* with_setter */
  frame->slots[1] = myself->closure.frame->slots[0]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[1]; /* name */
  frame->slots[3] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1480: ... with_setter()
  argument_count = 0;
  arguments = node_p;
  result_count = 1;
  myself = frame->slots[0] /* with_setter */;
  func = myself->type;
  frame->cont = cont__52_74;
}
static void cont__52_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1482: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__52_75;
}
static void cont__52_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1478: ... "
  // 1479:   @
  // 1480:     define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // 1481:   "@(name)", get__@(mangled_name), &poly_idx__@(mangled_name), @
  // 1482:   &@(var_entry(mangled_name)));
  argument_count = 13;
  arguments = node_p;
  arguments->slots[0] = string__52_76;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__52_77;
  arguments->slots[3] = frame->slots[1] /* namespace */;
  arguments->slots[4] = string__52_78;
  arguments->slots[5] = frame->slots[2] /* name */;
  arguments->slots[6] = string__52_79;
  arguments->slots[7] = frame->slots[3] /* mangled_name */;
  arguments->slots[8] = string__52_80;
  arguments->slots[9] = frame->slots[3] /* mangled_name */;
  arguments->slots[10] = string__52_81;
  arguments->slots[11] = frame->slots[6] /* temp__3 */;
  arguments->slots[12] = string__52_82;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_83;
}
static void cont__52_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1478: write_to_phase_1 "
  // 1479:   @
  // 1480:     define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // 1481:   "@(name)", get__@(mangled_name), &poly_idx__@(mangled_name), @
  // 1482:   &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_1();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__52_55(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // namespace: 0
  // name: 1
  // id: 2
  // mangled_name: 3
  // with_setter: 4
  frame->slots[0] = myself->closure.frame->slots[3]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[4]; /* name */
  frame->slots[2] = myself->closure.frame->slots[6]; /* id */
  frame->slots[3] = myself->closure.frame->slots[5]; /* mangled_name */
  frame->slots[4] = myself->closure.frame->slots[2]; /* with_setter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1467: ... "
  // 1468:   static NODE *get__@(namespace)__@(name)(void) {
  // 1469:     return var.@(namespace)__@(name);
  // 1470:   }
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__52_56;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__52_57;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__52_58;
  arguments->slots[5] = frame->slots[0] /* namespace */;
  arguments->slots[6] = string__52_59;
  arguments->slots[7] = frame->slots[1] /* name */;
  arguments->slots[8] = string__52_60;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_61;
}
static void cont__52_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1467: write_to_declarations "
  // 1468:   static NODE *get__@(namespace)__@(name)(void) {
  // 1469:     return var.@(namespace)__@(name);
  // 1470:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__52_62;
}
static void cont__52_62(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1472: id.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* id */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__52_63;
}
static void cont__52_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1472: ... :
  // 1473:   write_to_phase_1 "
  // 1474:     @
  // 1475:       define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1476:     ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  frame->slots[6] /* temp__2 */ = create_closure(entry__52_64, 0);
  // 1477: :
  // 1478:   write_to_phase_1 "
  // 1479:     @
  // 1480:       define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // 1481:     "@(name)", get__@(mangled_name), &poly_idx__@(mangled_name), @
  // 1482:     &@(var_entry(mangled_name)));
  frame->slots[7] /* temp__3 */ = create_closure(entry__52_73, 0);
  // 1471: if
  // 1472:   id.is_defined:
  // 1473:     write_to_phase_1 "
  // 1474:       @
  // 1475:         define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1476:       ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  // 1477:   :
  // 1478:     write_to_phase_1 "
  // 1479:       @
  // 1480:         define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__52_84(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // with_setter: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* with_setter */
  frame->slots[1] = myself->closure.frame->slots[4]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1486: ... with_setter()
  argument_count = 0;
  arguments = node_p;
  result_count = 1;
  myself = frame->slots[0] /* with_setter */;
  func = myself->type;
  frame->cont = cont__52_85;
}
static void cont__52_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1484: ... "
  // 1485:   @
  // 1486:     register_polymorphic_function@(with_setter())(@quot;_@(module_name)@
  // 1487:   ::@(name)", &poly_idx__@(name));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__52_86;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__52_87;
  arguments->slots[3] = get__module_name();
  arguments->slots[4] = string__52_88;
  arguments->slots[5] = frame->slots[1] /* name */;
  arguments->slots[6] = string__52_89;
  arguments->slots[7] = frame->slots[1] /* name */;
  arguments->slots[8] = string__52_90;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_91;
}
static void cont__52_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1484: write_to_phase_1 "
  // 1485:   @
  // 1486:     register_polymorphic_function@(with_setter())(@quot;_@(module_name)@
  // 1487:   ::@(name)", &poly_idx__@(name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_1();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__52_1(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // is_a_setter: 1
  // with_setter: 2
  // namespace: 3
  // name: 4
  // mangled_name: 5
  // id: 6
  // info: 7
  frame->slots[2] /* with_setter */ = create_future();
  frame->slots[3] /* namespace */ = create_future();
  frame->slots[4] /* name */ = create_future();
  frame->slots[5] /* mangled_name */ = create_future();
  frame->slots[6] /* id */ = create_future();
  frame->slots[7] /* info */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1434: ... : if is_a_setter (-> "_with_setter") -> ""
  frame->slots[8] /* temp__1 */ = create_closure(entry__52_2, 0);
  // 1434: $with_setter: if is_a_setter (-> "_with_setter") -> ""
  initialize_future(frame->slots[2] /* with_setter */, frame->slots[8] /* temp__1 */);
  // 1436: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = var._extract_destination;
  func = myself->type;
  frame->cont = cont__52_6;
}
static void entry__52_3(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1434: ... -> "_with_setter"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__52_4;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__52_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1434: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__52_2(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_a_setter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* is_a_setter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1434: ... if is_a_setter (-> "_with_setter") -> ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* is_a_setter */;
  arguments->slots[1] = func__52_3;
  arguments->slots[2] = func__52_5;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__52_6(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  frame->slots[9] /* temp__2 */ = arguments->slots[1];
  frame->slots[10] /* temp__3 */ = arguments->slots[2];
  // 1436: ... namespace
  initialize_future(frame->slots[3] /* namespace */, frame->slots[8] /* temp__1 */);
  // 1436: ... name
  initialize_future(frame->slots[4] /* name */, frame->slots[9] /* temp__2 */);
  // 1436: ... mangled_name
  initialize_future(frame->slots[5] /* mangled_name */, frame->slots[10] /* temp__3 */);
  // 1438: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__52_7;
}
static void cont__52_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1438: ... :
  // 1439:   write_to_global_variable_declarations
  // 1440:     string("  NODE *" mangled_name ";@nl;")
  frame->slots[9] /* temp__2 */ = create_closure(entry__52_8, 0);
  // 1441: :
  // 1442:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1443:   write_to_top_level_variable_declarations
  // 1444:     string("  NODE *" var_name(mangled_name) ";@nl;")
  frame->slots[10] /* temp__3 */ = create_closure(entry__52_12, 0);
  // 1437: if
  // 1438:   namespace.is_defined:
  // 1439:     write_to_global_variable_declarations
  // 1440:       string("  NODE *" mangled_name ";@nl;")
  // 1441:   :
  // 1442:     write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1443:     write_to_top_level_variable_declarations
  // 1444:       string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__52_21;
}
static void entry__52_8(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1440: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__52_9;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__52_10;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__52_11;
}
static void cont__52_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1439: write_to_global_variable_declarations
  // 1440:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__52_12(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1442: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__52_13;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__52_14;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_15;
}
static void cont__52_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1442: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__52_16;
}
static void cont__52_16(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1444: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_name;
  func = myself->type;
  frame->cont = cont__52_17;
}
static void cont__52_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1444: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__52_18;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__52_19;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__52_20;
}
static void cont__52_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1443: write_to_top_level_variable_declarations
  // 1444:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__52_21(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1445: $id privileged_polymorphic_functions(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = get__privileged_polymorphic_functions();
  func = myself->type;
  frame->cont = cont__52_22;
}
static void cont__52_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* id */, arguments->slots[0]);
  // 1448: ... id.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* id */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__52_23;
}
static void cont__52_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 1448: ... -> " = @(id)"
  frame->slots[11] /* temp__4 */ = create_closure(entry__52_24, 0);
  // 1448: ... if(id.is_defined (-> " = @(id)") -> "")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__3 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  arguments->slots[2] = func__52_27;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__52_28;
}
static void entry__52_24(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // id: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* id */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1448: ... " = @(id)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__52_25;
  arguments->slots[1] = frame->slots[0] /* id */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_26;
}
static void cont__52_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1448: ... -> " = @(id)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__52_27(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1448: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__52_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 1446: ... "
  // 1447:   static int poly_idx__@(mangled_name)@
  // 1448:   @(if(id.is_defined (-> " = @(id)") -> ""));@nl;@
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__52_29;
  arguments->slots[1] = frame->slots[5] /* mangled_name */;
  arguments->slots[2] = frame->slots[9] /* temp__2 */;
  arguments->slots[3] = string__52_30;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_31;
}
static void cont__52_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1446: write_to_declarations "
  // 1447:   static int poly_idx__@(mangled_name)@
  // 1448:   @(if(id.is_defined (-> " = @(id)") -> ""));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__52_32;
}
static void cont__52_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1451: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__52_33;
}
static void cont__52_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 1451: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__52_34;
}
static void cont__52_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 1449: ... "
  // 1450:   @
  // 1451:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1452:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__52_35;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = string__52_36;
  arguments->slots[3] = frame->slots[10] /* temp__3 */;
  arguments->slots[4] = string__52_37;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_38;
}
static void cont__52_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1449: write_to_generated_collections "
  // 1450:   @
  // 1451:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1452:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__52_39;
}
static void cont__52_39(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1453: ... identifier_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__52_40;
}
static void cont__52_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1453: compute_source_text_info $info identifier_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 1;
  myself = var._compute_source_text_info;
  func = myself->type;
  frame->cont = cont__52_41;
}
static void cont__52_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* info */, arguments->slots[0]);
  // 1454: ... "  {type__@(mangled_name), NULL, @(info)},@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__52_42;
  arguments->slots[1] = frame->slots[5] /* mangled_name */;
  arguments->slots[2] = string__52_43;
  arguments->slots[3] = frame->slots[7] /* info */;
  arguments->slots[4] = string__52_44;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_45;
}
static void cont__52_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1454: write_to_continuation_table "  {type__@(mangled_name), NULL, @(info)},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame->cont = cont__52_46;
}
static void cont__52_46(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1455: generate_dispatcher_function mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 0;
  myself = get__generate_dispatcher_function();
  func = myself->type;
  frame->cont = cont__52_47;
}
static void cont__52_47(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1463: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__52_48;
}
static void cont__52_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 1461: ... "
  // 1462:   @
  // 1463:     assign_value(&@(var_entry(mangled_name)), @
  // 1464:   create_function(type__@(mangled_name), -1));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__52_49;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = string__52_50;
  arguments->slots[3] = frame->slots[5] /* mangled_name */;
  arguments->slots[4] = string__52_51;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__52_52;
}
static void cont__52_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1461: write_to_phase_4 "
  // 1462:   @
  // 1463:     assign_value(&@(var_entry(mangled_name)), @
  // 1464:   create_function(type__@(mangled_name), -1));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame->cont = cont__52_53;
}
static void cont__52_53(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1466: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__52_54;
}
static void cont__52_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1466: ... :
  // 1467:   write_to_declarations "
  // 1468:     static NODE *get__@(namespace)__@(name)(void) {
  // 1469:       return var.@(namespace)__@(name);
  // 1470:     }
  // 1471:   if
  // 1472:     id.is_defined:
  // 1473:       write_to_phase_1 "
  // 1474:         @
  // 1475:           define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // ...
  frame->slots[9] /* temp__2 */ = create_closure(entry__52_55, 0);
  // 1483: :
  // 1484:   write_to_phase_1 "
  // 1485:     @
  // 1486:       register_polymorphic_function@(with_setter())(@quot;_@(module_name)@
  // 1487:     ::@(name)", &poly_idx__@(name));
  frame->slots[10] /* temp__3 */ = create_closure(entry__52_84, 0);
  // 1465: if
  // 1466:   namespace.is_defined:
  // 1467:     write_to_declarations "
  // 1468:       static NODE *get__@(namespace)__@(name)(void) {
  // 1469:         return var.@(namespace)__@(name);
  // 1470:       }
  // 1471:     if
  // 1472:       id.is_defined:
  // 1473:         write_to_phase_1 "
  // 1474:           @
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_374(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // scope: 1
  frame->slots[1] = myself->closure.frame->slots[1]; /* scope */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1782: ... line .has_suffix. ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__53_375;
}
static void cont__53_375(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1782: ... line(1) > ' '
  frame->slots[4] /* temp__3 */ = create_closure(entry__53_376, 0);
  // 1782: ... line .has_suffix. ';' && line(1) > ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__53_379;
}
static void entry__53_376(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // line: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1782: ... line(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* line */;
  func = myself->type;
  frame->cont = cont__53_377;
}
static void cont__53_377(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1782: ... line(1) > ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__53_378;
}
static void cont__53_378(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1782: ... line(1) > ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_379(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1782: ... :
  // 1783:   unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1784:     write_to_declarations scope
  frame->slots[5] /* temp__4 */ = create_closure(entry__53_380, 0);
  // 1782: if line .has_suffix. ';' && line(1) > ' ':
  // 1783:   unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1784:     write_to_declarations scope
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_387;
}
static void entry__53_386(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // scope: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* scope */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1784: write_to_declarations scope
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_380(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // line: 0
  // scope: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* scope */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1783: ... alt("typedef" "static " "extern " '}')
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__53_381;
  arguments->slots[1] = string__53_382;
  arguments->slots[2] = string__53_383;
  arguments->slots[3] = character__125;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__53_384;
}
static void cont__53_384(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1783: ... line .has_prefix. alt("typedef" "static " "extern " '}')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__53_385;
}
static void cont__53_385(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1783: ... :
  // 1784:   write_to_declarations scope
  frame->slots[4] /* temp__3 */ = create_closure(entry__53_386, 0);
  // 1783: unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1784:   write_to_declarations scope
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_387(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1785: ... line.converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__53_388;
}
static void cont__53_388(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1785: write_to_declarations line.converted '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = character__10;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_314(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // namespace: 0
  // name: 1
  // mangled_name: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[4]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1748: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_315;
}
static void cont__53_315(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1745: ... "
  // 1746:   @
  // 1747:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1748:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__53_316;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__53_317;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__53_318;
  arguments->slots[5] = frame->slots[2] /* mangled_name */;
  arguments->slots[6] = string__53_319;
  arguments->slots[7] = frame->slots[4] /* temp__2 */;
  arguments->slots[8] = string__53_320;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_321;
}
static void cont__53_321(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1745: write_to_phase_2 "
  // 1746:   @
  // 1747:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1748:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_292(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // mangled_name: 0
  // scope: 1
  // constructor_name: 2
  // arguments: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* scope */
  frame->slots[2] = myself->closure.frame->slots[1]; /* constructor_name */
  frame->slots[3] = myself->closure.frame->slots[2]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1724: ... "
  // 1725:   SIMPLE_NODE @(mangled_name)__node =
  // 1726:     {
  // 1727:       type__@(mangled_name),
  // 1728:       &attributes__@(mangled_name)
  // 1729:     };
  // 1730:   
  // 1731:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1732:     return (NODE *)&@(mangled_name)__node;
  // 1733:   }
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__53_293;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__53_294;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__53_295;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__53_296;
  arguments->slots[7] = frame->slots[1] /* scope */;
  arguments->slots[8] = string__53_297;
  arguments->slots[9] = frame->slots[2] /* constructor_name */;
  arguments->slots[10] = string__53_298;
  arguments->slots[11] = ((CELL *)frame->slots[3])->contents /* arguments */;
  arguments->slots[12] = string__53_299;
  arguments->slots[13] = frame->slots[0] /* mangled_name */;
  arguments->slots[14] = string__53_300;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_301;
}
static void cont__53_301(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1724: write "
  // 1725:   SIMPLE_NODE @(mangled_name)__node =
  // 1726:     {
  // 1727:       type__@(mangled_name),
  // 1728:       &attributes__@(mangled_name)
  // 1729:     };
  // 1730:   
  // 1731:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1732:     return (NODE *)&@(mangled_name)__node;
  // 1733:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_302(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // scope: 0
  // constructor_name: 1
  // arguments: 2
  // node_name: 3
  // mangled_name: 4
  // initializers: 5
  frame->slots[0] = myself->closure.frame->slots[0]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[1]; /* constructor_name */
  frame->slots[2] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[3]; /* node_name */
  frame->slots[4] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[5] = myself->closure.frame->slots[5]; /* initializers */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1735: ... "
  // 1736:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1737:     NODE *node = allocate(sizeof(@(node_name)));
  // 1738:     node->type = type__@(mangled_name);
  // 1739:     node->attributes = &attributes__@(mangled_name)@
  // 1740:   ;@nl;@(initializers)  return node;
  // 1741:   }
  argument_count = 14;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  arguments->slots[1] = string__53_303;
  arguments->slots[2] = frame->slots[1] /* constructor_name */;
  arguments->slots[3] = string__53_304;
  arguments->slots[4] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[5] = string__53_305;
  arguments->slots[6] = frame->slots[3] /* node_name */;
  arguments->slots[7] = string__53_306;
  arguments->slots[8] = frame->slots[4] /* mangled_name */;
  arguments->slots[9] = string__53_307;
  arguments->slots[10] = frame->slots[4] /* mangled_name */;
  arguments->slots[11] = string__53_308;
  arguments->slots[12] = ((CELL *)frame->slots[5])->contents /* initializers */;
  arguments->slots[13] = string__53_309;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_310;
}
static void cont__53_310(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1735: write "
  // 1736:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1737:     NODE *node = allocate(sizeof(@(node_name)));
  // 1738:     node->type = type__@(mangled_name);
  // 1739:     node->attributes = &attributes__@(mangled_name)@
  // 1740:   ;@nl;@(initializers)  return node;
  // 1741:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_284(void) {
  allocate_initialized_frame_gc(6, 9);
  // slot allocations:
  // scope: 0
  // constructor_name: 1
  // arguments: 2
  // node_name: 3
  // mangled_name: 4
  // initializers: 5
  frame->slots[0] = myself->closure.frame->slots[5]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[12]; /* constructor_name */
  frame->slots[2] = myself->closure.frame->slots[9]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[7]; /* node_name */
  frame->slots[4] = myself->closure.frame->slots[2]; /* mangled_name */
  frame->slots[5] = myself->closure.frame->slots[10]; /* initializers */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1721: "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  arguments->slots[1] = string__53_285;
  arguments->slots[2] = frame->slots[1] /* constructor_name */;
  arguments->slots[3] = string__53_286;
  arguments->slots[4] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[5] = string__53_287;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_288;
}
static void cont__53_288(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1720: write_to_declarations
  // 1721:   "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__53_289;
}
static void cont__53_289(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1723: node_name == "SIMPLE_NODE"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* node_name */;
  arguments->slots[1] = string__53_290;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__53_291;
}
static void cont__53_291(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1723: ... :
  // 1724:   write "
  // 1725:     SIMPLE_NODE @(mangled_name)__node =
  // 1726:       {
  // 1727:         type__@(mangled_name),
  // 1728:         &attributes__@(mangled_name)
  // 1729:       };
  // 1730:     
  // 1731:     @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1732:       return (NODE *)&@(mangled_name)__node;
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__53_292, 0);
  // 1734: :
  // 1735:   write "
  // 1736:     @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1737:       NODE *node = allocate(sizeof(@(node_name)));
  // 1738:       node->type = type__@(mangled_name);
  // 1739:       node->attributes = &attributes__@(mangled_name)@
  // 1740:     ;@nl;@(initializers)  return node;
  // 1741:     }
  frame->slots[8] /* temp__3 */ = create_closure(entry__53_302, 0);
  // 1722: if
  // 1723:   node_name == "SIMPLE_NODE":
  // 1724:     write "
  // 1725:       SIMPLE_NODE @(mangled_name)__node =
  // 1726:         {
  // 1727:           type__@(mangled_name),
  // 1728:           &attributes__@(mangled_name)
  // 1729:         };
  // 1730:       
  // 1731:       @(scope)NODE *@(constructor_name)(@(arguments)) {
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_114(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // scope: 0
  // collector_name: 1
  // mangled_name: 2
  // source: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[3]; /* collector_name */
  frame->slots[2] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1588: ... "
  // 1589:   @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1590:     @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1591:     new_node->type = node->type;
  // 1592:     *(void **)node = ENCODE_ADDRESS(new_node);
  // 1593:     new_node->attributes = collect_attributes(node->attributes);
  argument_count = 10;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  arguments->slots[1] = string__53_115;
  arguments->slots[2] = frame->slots[1] /* collector_name */;
  arguments->slots[3] = string__53_116;
  arguments->slots[4] = frame->slots[2] /* mangled_name */;
  arguments->slots[5] = string__53_117;
  arguments->slots[6] = frame->slots[2] /* mangled_name */;
  arguments->slots[7] = string__53_118;
  arguments->slots[8] = frame->slots[2] /* mangled_name */;
  arguments->slots[9] = string__53_119;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_120;
}
static void cont__53_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1588: write "
  // 1589:   @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1590:     @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1591:     new_node->type = node->type;
  // 1592:     *(void **)node = ENCODE_ADDRESS(new_node);
  // 1593:     new_node->attributes = collect_attributes(node->attributes);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__53_121;
}
static void cont__53_121(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1594: for_each_line source: ($line)
  // 1595:   truncate_from &line "//"
  // 1596:   normalize &line
  // 1597:   $field_type trim(truncate_behind(line alt(' ' '*') -1))
  // 1598:   
  // 1599:   $field_name
  // 1600:     trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  // 1601:   
  // 1602:   $base_type
  // 1603:     cond
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* source */;
  arguments->slots[1] = func__53_122;
  result_count = 0;
  myself = get__for_each_line();
  func = myself->type;
  frame->cont = cont__53_165;
}
static void entry__53_153(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // field_name: 0
  // base_type: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* field_name */
  frame->slots[1] = myself->closure.frame->slots[3]; /* base_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1613: ... base_type.to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* base_type */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__53_154;
}
static void cont__53_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1610: ... "
  // 1611:   @
  // 1612:     new_node->@(field_name) = @
  // 1613:   collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__53_155;
  arguments->slots[1] = frame->slots[0] /* field_name */;
  arguments->slots[2] = string__53_156;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__53_157;
  arguments->slots[5] = frame->slots[0] /* field_name */;
  arguments->slots[6] = string__53_158;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_159;
}
static void cont__53_159(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1610: write "
  // 1611:   @
  // 1612:     new_node->@(field_name) = @
  // 1613:   collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_160(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // field_name: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* field_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1615: ... "  new_node->@(field_name) = node->@(field_name);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__53_161;
  arguments->slots[1] = frame->slots[0] /* field_name */;
  arguments->slots[2] = string__53_162;
  arguments->slots[3] = frame->slots[0] /* field_name */;
  arguments->slots[4] = string__53_163;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_164;
}
static void cont__53_164(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1615: write "  new_node->@(field_name) = node->@(field_name);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_122(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // line: 0
  // field_type: 1
  // field_name: 2
  // base_type: 3
  frame->slots[1] /* field_type */ = create_future();
  frame->slots[2] /* field_name */ = create_future();
  frame->slots[3] /* base_type */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* line */ = create_cell_with_contents(arguments->slots[0]);
  // 1595: truncate_from &line "//"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = string__53_123;
  result_count = 1;
  myself = get__truncate_from();
  func = myself->type;
  frame->cont = cont__53_124;
}
static void cont__53_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1596: normalize &line
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  result_count = 1;
  myself = get__normalize();
  func = myself->type;
  frame->cont = cont__53_125;
}
static void cont__53_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1597: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__53_126;
}
static void cont__53_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1597: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_127;
}
static void cont__53_127(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1597: ... truncate_behind(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__truncate_behind();
  func = myself->type;
  frame->cont = cont__53_128;
}
static void cont__53_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1597: $field_type trim(truncate_behind(line alt(' ' '*') -1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__53_129;
}
static void cont__53_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* field_type */, arguments->slots[0]);
  // 1600: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__53_130;
}
static void cont__53_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1600: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_131;
}
static void cont__53_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1600: ... truncate_until(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__truncate_until();
  func = myself->type;
  frame->cont = cont__53_132;
}
static void cont__53_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1600: ... truncate_until(line alt(' ' '*') -1) .without_suffix. ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__without_suffix();
  func = myself->type;
  frame->cont = cont__53_133;
}
static void cont__53_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1599: $field_name
  // 1600:   trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__53_134;
}
static void cont__53_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* field_name */, arguments->slots[0]);
  // 1604: -> field_type .has_suffix. " *" -> range(field_type 1 -3)
  frame->slots[4] /* temp__1 */ = create_closure(entry__53_135, 0);
  // 1605: -> field_type .has_suffix. '*' -> range(field_type 1 -2)
  frame->slots[5] /* temp__2 */ = create_closure(entry__53_141, 0);
  // 1602: $base_type
  // 1603:   cond
  // 1604:     -> field_type .has_suffix. " *" -> range(field_type 1 -3)
  // 1605:     -> field_type .has_suffix. '*' -> range(field_type 1 -2)
  // 1606:     -> true -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = func__53_146;
  result_count = 1;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__53_148;
}
static void entry__53_147(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1606: ... -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_143(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1605: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_144;
}
static void cont__53_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1605: ... range(field_type 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__53_145;
}
static void cont__53_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1605: ... -> range(field_type 1 -2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_138(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1604: ... 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__3;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_139;
}
static void cont__53_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1604: ... range(field_type 1 -3)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__53_140;
}
static void cont__53_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1604: ... -> range(field_type 1 -3)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_135(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1604: ... field_type .has_suffix. " *"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = string__53_136;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__53_137;
}
static void cont__53_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1604: ... -> range(field_type 1 -3)
  frame->slots[2] /* temp__2 */ = create_closure(entry__53_138, 0);
  // 1604: -> field_type .has_suffix. " *" -> range(field_type 1 -3)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_141(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1605: ... field_type .has_suffix. '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__53_142;
}
static void cont__53_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1605: ... -> range(field_type 1 -2)
  frame->slots[2] /* temp__2 */ = create_closure(entry__53_143, 0);
  // 1605: -> field_type .has_suffix. '*' -> range(field_type 1 -2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_146(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1606: -> true -> undefined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = func__53_147;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_148(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* base_type */, arguments->slots[0]);
  // 1609: base_type.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* base_type */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_149;
}
static void cont__53_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1609: ... defined_structs(base_type)
  frame->slots[6] /* temp__3 */ = create_closure(entry__53_150, 0);
  // 1609: base_type.is_defined && defined_structs(base_type)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__53_152;
}
static void entry__53_150(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // base_type: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* base_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1609: ... defined_structs(base_type)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* base_type */;
  result_count = 1;
  myself = get__defined_structs();
  func = myself->type;
  frame->cont = cont__53_151;
}
static void cont__53_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1609: ... defined_structs(base_type)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1609: ... :
  // 1610:   write "
  // 1611:     @
  // 1612:       new_node->@(field_name) = @
  // 1613:     collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  frame->slots[7] /* temp__4 */ = create_closure(entry__53_153, 0);
  // 1614: :
  // 1615:   write "  new_node->@(field_name) = node->@(field_name);@nl;"
  frame->slots[8] /* temp__5 */ = create_closure(entry__53_160, 0);
  // 1608: if
  // 1609:   base_type.is_defined && defined_structs(base_type):
  // 1610:     write "
  // 1611:       @
  // 1612:         new_node->@(field_name) = @
  // 1613:       collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  // 1614:   :
  // 1615:     write "  new_node->@(field_name) = node->@(field_name);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_165(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1616: write "
  // 1617:     return new_node;
  // 1618:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__53_166;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_95(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1577: ... indented(2 source)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__53_96;
}
static void cont__53_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1574: ... "
  // 1575:   
  // 1576:   typedef struct @(mangled_name) @(mangled_name);
  // 1577:   struct @(mangled_name) {@nl;@(indented(2 source))
  // 1578:   };
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__53_97;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__53_98;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__53_99;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__53_100;
  arguments->slots[7] = frame->slots[3] /* temp__2 */;
  arguments->slots[8] = string__53_101;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_102;
}
static void cont__53_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1574: write_to_declarations "
  // 1575:   
  // 1576:   typedef struct @(mangled_name) @(mangled_name);
  // 1577:   struct @(mangled_name) {@nl;@(indented(2 source))
  // 1578:   };
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_103(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // source: 0
  // mangled_name: 1
  // scope: 2
  // collector_name: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[3]; /* scope */
  frame->slots[3] /* collector_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1585: ... indented(2 source)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__53_104;
}
static void cont__53_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1580: ... "
  // 1581:   
  // 1582:   typedef struct {
  // 1583:     void *type;
  // 1584:     ATTRIBUTES *attributes;
  // 1585:   @(indented(2 source))@nl;} @(mangled_name);
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__53_105;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__53_106;
  arguments->slots[3] = frame->slots[1] /* mangled_name */;
  arguments->slots[4] = string__53_107;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_108;
}
static void cont__53_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1580: write_to_declarations "
  // 1581:   
  // 1582:   typedef struct {
  // 1583:     void *type;
  // 1584:     ATTRIBUTES *attributes;
  // 1585:   @(indented(2 source))@nl;} @(mangled_name);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__53_109;
}
static void cont__53_109(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1586: ... mangled_name.to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__53_110;
}
static void cont__53_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1586: $collector_name "collect_@(mangled_name.to_lower_case)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__53_111;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_112;
}
static void cont__53_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* collector_name */, arguments->slots[0]);
  // 1587: ... defined_functions(collector_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* collector_name */;
  result_count = 1;
  myself = get__defined_functions();
  func = myself->type;
  frame->cont = cont__53_113;
}
static void cont__53_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1587: ... :
  // 1588:   write "
  // 1589:     @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1590:       @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1591:       new_node->type = node->type;
  // 1592:       *(void **)node = ENCODE_ADDRESS(new_node);
  // 1593:       new_node->attributes = collect_attributes(node->attributes);
  // 1594:   for_each_line source: ($line)
  // 1595:     truncate_from &line "//"
  // 1596:     normalize &line
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__53_114, 0);
  // 1587: unless defined_functions(collector_name):
  // 1588:   write "
  // 1589:     @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1590:       @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1591:       new_node->type = node->type;
  // 1592:       *(void **)node = ENCODE_ADDRESS(new_node);
  // 1593:       new_node->attributes = collect_attributes(node->attributes);
  // 1594:   for_each_line source: ($line)
  // 1595:     truncate_from &line "//"
  // 1596:     normalize &line
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_167(void) {
  allocate_initialized_frame_gc(7, 17);
  // slot allocations:
  // self: 0
  // initialize_object: 1
  // mangled_name: 2
  // namespace: 3
  // name: 4
  // scope: 5
  // source: 6
  // node_name: 7
  // node: 8
  // arguments: 9
  // initializers: 10
  // attributes_declaration: 11
  // constructor_name: 12
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[9]; /* initialize_object */
  frame->slots[2] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[5]; /* namespace */
  frame->slots[4] = myself->closure.frame->slots[6]; /* name */
  frame->slots[5] = myself->closure.frame->slots[3]; /* scope */
  frame->slots[6] = myself->closure.frame->slots[2]; /* source */
  frame->slots[7] /* node_name */ = create_future();
  frame->slots[8] /* node */ = create_future();
  frame->slots[9] /* arguments */ = create_cell();
  frame->slots[10] /* initializers */ = create_cell();
  frame->slots[11] /* attributes_declaration */ = create_cell();
  frame->slots[12] /* constructor_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1620: $node_name node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__53_168;
}
static void cont__53_168(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* node_name */, arguments->slots[0]);
  // 1621: $node defined_nodes(node_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* node_name */;
  result_count = 1;
  myself = get__defined_nodes();
  func = myself->type;
  frame->cont = cont__53_169;
}
static void cont__53_169(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* node */, arguments->slots[0]);
  // 1622: ... node.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* node */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_170;
}
static void cont__53_170(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1622: ... :
  // 1623:   Error "
  // 1624:     Missing definition for a node named "@(node_name)@quot;!@
  frame->slots[14] /* temp__2 */ = create_closure(entry__53_171, 0);
  // 1622: unless node.is_defined:
  // 1623:   Error "
  // 1624:     Missing definition for a node named "@(node_name)@quot;!@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__53_175;
}
static void entry__53_171(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // node_name: 0
  frame->slots[0] = myself->closure.frame->slots[7]; /* node_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1623: ... "
  // 1624:   Missing definition for a node named "@(node_name)@quot;!@
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__53_172;
  arguments->slots[1] = frame->slots[0] /* node_name */;
  arguments->slots[2] = string__53_173;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_174;
}
static void cont__53_174(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1623: Error "
  // 1624:   Missing definition for a node named "@(node_name)@quot;!@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__Error();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_175(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1626: base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__53_176;
}
static void cont__53_176(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__2 */ = arguments->slots[0];
  // 1626: base_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[14] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_177;
}
static void cont__53_177(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1626: ... :
  // 1627:   initialize_object mangled_name true
  // 1628:   assign var_entry(mangled_name) base_of(self).to_c
  frame->slots[15] /* temp__3 */ = create_closure(entry__53_178, 0);
  // 1629: :
  // 1630:   initialize_object mangled_name
  frame->slots[16] /* temp__4 */ = create_closure(entry__53_183, 0);
  // 1625: if
  // 1626:   base_of(self).is_defined:
  // 1627:     initialize_object mangled_name true
  // 1628:     assign var_entry(mangled_name) base_of(self).to_c
  // 1629:   :
  // 1630:     initialize_object mangled_name
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[15] /* temp__3 */;
  arguments->slots[2] = frame->slots[16] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_184;
}
static void entry__53_178(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // initialize_object: 0
  // mangled_name: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* initialize_object */
  frame->slots[1] = myself->closure.frame->slots[2]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1627: initialize_object mangled_name true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  arguments->slots[1] = get__true();
  result_count = 0;
  myself = frame->slots[0] /* initialize_object */;
  func = myself->type;
  frame->cont = cont__53_179;
}
static void cont__53_179(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1628: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_180;
}
static void cont__53_180(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1628: ... base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__53_181;
}
static void cont__53_181(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1628: ... base_of(self).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__53_182;
}
static void cont__53_182(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1628: assign var_entry(mangled_name) base_of(self).to_c
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = var._assign;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_183(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // initialize_object: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* initialize_object */
  frame->slots[1] = myself->closure.frame->slots[2]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1630: initialize_object mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* initialize_object */;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_184(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1631: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_185;
}
static void cont__53_185(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1631: ... :
  // 1632:   write_to_phase_2 "
  // 1633:     @
  // 1634:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1635:     get__@(mangled_name), &@(var_entry(mangled_name)));
  frame->slots[14] /* temp__2 */ = create_closure(entry__53_186, 0);
  // 1631: if namespace.is_defined:
  // 1632:   write_to_phase_2 "
  // 1633:     @
  // 1634:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1635:     get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_194;
}
static void entry__53_186(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // namespace: 0
  // name: 1
  // mangled_name: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[4]; /* name */
  frame->slots[2] = myself->closure.frame->slots[2]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1635: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_187;
}
static void cont__53_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1632: ... "
  // 1633:   @
  // 1634:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1635:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__53_188;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__53_189;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__53_190;
  arguments->slots[5] = frame->slots[2] /* mangled_name */;
  arguments->slots[6] = string__53_191;
  arguments->slots[7] = frame->slots[4] /* temp__2 */;
  arguments->slots[8] = string__53_192;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_193;
}
static void cont__53_193(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1632: write_to_phase_2 "
  // 1633:   @
  // 1634:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1635:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_194(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1636: $$arguments ""
  ((CELL *)frame->slots[9])->contents /* arguments */ = empty_string;
  // 1637: $$initializers ""
  ((CELL *)frame->slots[10])->contents /* initializers */ = empty_string;
  // 1639: source_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* node */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__53_195;
}
static void cont__53_195(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1639: ... : ($line)
  // 1640:   truncate_from &line "//"
  // 1641:   normalize &line
  // 1642:   $field_type trim(truncate_behind(line alt(' ' '*') -1))
  // 1643:   
  // 1644:   $field_name
  // 1645:     trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  // 1646:   
  // 1647:   append &arguments field_type
  // 1648:   unless field_type .has_suffix. '*': push &arguments ' '
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__53_196, 1);
  // 1654: :
  // 1655:   append &arguments ", "
  frame->slots[15] /* temp__3 */ = create_closure(entry__53_222, 0);
  // 1638: for_each_line
  // 1639:   source_of(node): ($line)
  // 1640:     truncate_from &line "//"
  // 1641:     normalize &line
  // 1642:     $field_type trim(truncate_behind(line alt(' ' '*') -1))
  // 1643:     
  // 1644:     $field_name
  // 1645:       trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  // 1646:     
  // 1647:     append &arguments field_type
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__for_each_line();
  func = myself->type;
  frame->cont = cont__53_225;
}
static void entry__53_196(void) {
  allocate_initialized_frame_gc(4, 10);
  // slot allocations:
  // line: 0
  // arguments: 1
  // initializers: 2
  // node_name: 3
  // field_type: 4
  // field_name: 5
  frame->slots[1] = myself->closure.frame->slots[9]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[10]; /* initializers */
  frame->slots[3] = myself->closure.frame->slots[7]; /* node_name */
  frame->slots[4] /* field_type */ = create_future();
  frame->slots[5] /* field_name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* line */ = create_cell_with_contents(arguments->slots[0]);
  // 1640: truncate_from &line "//"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = string__53_197;
  result_count = 1;
  myself = get__truncate_from();
  func = myself->type;
  frame->cont = cont__53_198;
}
static void cont__53_198(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1641: normalize &line
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  result_count = 1;
  myself = get__normalize();
  func = myself->type;
  frame->cont = cont__53_199;
}
static void cont__53_199(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1642: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__53_200;
}
static void cont__53_200(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1642: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_201;
}
static void cont__53_201(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 1642: ... truncate_behind(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__truncate_behind();
  func = myself->type;
  frame->cont = cont__53_202;
}
static void cont__53_202(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1642: $field_type trim(truncate_behind(line alt(' ' '*') -1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__53_203;
}
static void cont__53_203(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* field_type */, arguments->slots[0]);
  // 1645: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__53_204;
}
static void cont__53_204(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 1645: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_205;
}
static void cont__53_205(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__4 */ = arguments->slots[0];
  // 1645: ... truncate_until(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = 1;
  myself = get__truncate_until();
  func = myself->type;
  frame->cont = cont__53_206;
}
static void cont__53_206(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1645: ... truncate_until(line alt(' ' '*') -1) .without_suffix. ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__without_suffix();
  func = myself->type;
  frame->cont = cont__53_207;
}
static void cont__53_207(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1644: $field_name
  // 1645:   trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__53_208;
}
static void cont__53_208(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* field_name */, arguments->slots[0]);
  // 1647: append &arguments field_type
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = frame->slots[4] /* field_type */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_209;
}
static void cont__53_209(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* arguments */ = arguments->slots[0];
  // 1648: ... field_type .has_suffix. '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* field_type */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__53_210;
}
static void cont__53_210(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1648: ... : push &arguments ' '
  frame->slots[7] /* temp__2 */ = create_closure(entry__53_211, 0);
  // 1648: unless field_type .has_suffix. '*': push &arguments ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__53_213;
}
static void entry__53_211(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1648: ... push &arguments ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__53_212;
}
static void cont__53_212(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_213(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1649: append &arguments field_name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = frame->slots[5] /* field_name */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_214;
}
static void cont__53_214(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* arguments */ = arguments->slots[0];
  // 1652: ... node_name.to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* node_name */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__53_215;
}
static void cont__53_215(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1650: ... "
  // 1651:   @
  // 1652:     node->@(node_name.to_lower_case).@(field_name) = @(field_name)@
  // 1653:   ;@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__53_216;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = string__53_217;
  arguments->slots[3] = frame->slots[5] /* field_name */;
  arguments->slots[4] = string__53_218;
  arguments->slots[5] = frame->slots[5] /* field_name */;
  arguments->slots[6] = string__53_219;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_220;
}
static void cont__53_220(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1650: write_to &initializers "
  // 1651:   @
  // 1652:     node->@(node_name.to_lower_case).@(field_name) = @(field_name)@
  // 1653:   ;@nl;@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* initializers */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__53_221;
}
static void cont__53_221(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* initializers */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_222(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[9]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1655: append &arguments ", "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[1] = string__53_223;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_224;
}
static void cont__53_224(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_225(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1660: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__53_226;
}
static void cont__53_226(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1661: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__53_227;
}
static void cont__53_227(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__3 */ = arguments->slots[0];
  // 1661: ... node_of(self).to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__3 */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__53_228;
}
static void cont__53_228(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__2 */ = arguments->slots[0];
  // 1657: $$attributes_declaration "
  // 1658:   
  // 1659:   static VTABLE vtable__@(mangled_name) = {
  // 1660:     sizeof(@(node_of(self))),
  // 1661:     (COLLECTOR *)&collect_@(node_of(self).to_lower_case),
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__53_229;
  arguments->slots[1] = frame->slots[2] /* mangled_name */;
  arguments->slots[2] = string__53_230;
  arguments->slots[3] = frame->slots[13] /* temp__1 */;
  arguments->slots[4] = string__53_231;
  arguments->slots[5] = frame->slots[14] /* temp__2 */;
  arguments->slots[6] = string__53_232;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_233;
}
static void cont__53_233(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[11])->contents /* attributes_declaration */ = arguments->slots[0];
  // 1664: ... : (entry)
  // 1665:   $func_name
  // 1666:     string
  // 1667:       if(namespace.is_defined (-> "@(namespace)::") -> "")
  // 1668:       name
  // 1669:       '/'
  // 1670:       entry
  // 1671:   
  // 1672:   if
  // 1673:     defined_functions(func_name):
  // ...
  frame->slots[13] /* temp__1 */ = create_closure(entry__53_234, 1);
  // 1682: :
  // 1683:   append &attributes_declaration ",@nl;"
  frame->slots[14] /* temp__2 */ = create_closure(entry__53_250, 0);
  // 1663: for_each
  // 1664:   vtable_entries: (entry)
  // 1665:     $func_name
  // 1666:       string
  // 1667:         if(namespace.is_defined (-> "@(namespace)::") -> "")
  // 1668:         name
  // 1669:         '/'
  // 1670:         entry
  // 1671:     
  // 1672:     if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__vtable_entries();
  arguments->slots[1] = frame->slots[13] /* temp__1 */;
  arguments->slots[2] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__53_253;
}
static void entry__53_243(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // attributes_declaration: 0
  // mangled_name: 1
  // entry: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* attributes_declaration */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[0]; /* entry */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1674: write_to
  // 1675:   &attributes_declaration
  // 1676:   "  &func__"
  // 1677:   mangled_name
  // 1678:   "___"
  // 1679:   entry
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__53_244;
  arguments->slots[2] = frame->slots[1] /* mangled_name */;
  arguments->slots[3] = string__53_245;
  arguments->slots[4] = frame->slots[2] /* entry */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__53_246;
}
static void cont__53_246(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_247(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // attributes_declaration: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* attributes_declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1681: append &attributes_declaration "  (void *)no_such_function"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__53_248;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_249;
}
static void cont__53_249(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_234(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // entry: 0
  // namespace: 1
  // name: 2
  // attributes_declaration: 3
  // mangled_name: 4
  // func_name: 5
  frame->slots[1] = myself->closure.frame->slots[3]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[4]; /* name */
  frame->slots[3] = myself->closure.frame->slots[11]; /* attributes_declaration */
  frame->slots[4] = myself->closure.frame->slots[2]; /* mangled_name */
  frame->slots[5] /* func_name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1667: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_235;
}
static void cont__53_235(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1667: ... -> "@(namespace)::"
  frame->slots[8] /* temp__3 */ = create_closure(entry__53_236, 0);
  // 1667: if(namespace.is_defined (-> "@(namespace)::") -> "")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = func__53_239;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_240;
}
static void entry__53_236(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // namespace: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* namespace */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1667: ... "@(namespace)::"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  arguments->slots[1] = string__53_237;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_238;
}
static void cont__53_238(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1667: ... -> "@(namespace)::"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_239(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1667: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_240(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1665: $func_name
  // 1666:   string
  // 1667:     if(namespace.is_defined (-> "@(namespace)::") -> "")
  // 1668:     name
  // 1669:     '/'
  // 1670:     entry
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* name */;
  arguments->slots[2] = character__47;
  arguments->slots[3] = frame->slots[0] /* entry */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__53_241;
}
static void cont__53_241(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* func_name */, arguments->slots[0]);
  // 1673: defined_functions(func_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* func_name */;
  result_count = 1;
  myself = get__defined_functions();
  func = myself->type;
  frame->cont = cont__53_242;
}
static void cont__53_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1673: ... :
  // 1674:   write_to
  // 1675:     &attributes_declaration
  // 1676:     "  &func__"
  // 1677:     mangled_name
  // 1678:     "___"
  // 1679:     entry
  frame->slots[7] /* temp__2 */ = create_closure(entry__53_243, 0);
  // 1680: :
  // 1681:   append &attributes_declaration "  (void *)no_such_function"
  frame->slots[8] /* temp__3 */ = create_closure(entry__53_247, 0);
  // 1672: if
  // 1673:   defined_functions(func_name):
  // 1674:     write_to
  // 1675:       &attributes_declaration
  // 1676:       "  &func__"
  // 1677:       mangled_name
  // 1678:       "___"
  // 1679:       entry
  // 1680:   :
  // 1681:     append &attributes_declaration "  (void *)no_such_function"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_250(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // attributes_declaration: 0
  frame->slots[0] = myself->closure.frame->slots[11]; /* attributes_declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1683: append &attributes_declaration ",@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__53_251;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_252;
}
static void cont__53_252(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_253(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1684: append &attributes_declaration "
  // 1685:   
  // 1686:   };
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* attributes_declaration */;
  arguments->slots[1] = string__53_254;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_255;
}
static void cont__53_255(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[11])->contents /* attributes_declaration */ = arguments->slots[0];
  // 1688: mangled_name == "types__undefined"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  arguments->slots[1] = string__53_256;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__53_257;
}
static void cont__53_257(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1688: ... :
  // 1689:   append &attributes_declaration "
  // 1690:     
  // 1691:     static ATTRIBUTES attributes__types__undefined = {
  // 1692:       &vtable__types__undefined,
  // 1693:       {
  // 1694:         &no_attributes_level_1, &no_attributes_level_2,
  // 1695:         &no_attributes_level_3, &no_attributes_level_4,
  // 1696:         &no_attributes_level_5, &no_attributes_level_6,
  // 1697:         &no_attributes_level_7
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__53_258, 0);
  // 1700: :
  // 1701:   append &attributes_declaration "
  // 1702:     
  // 1703:     static ATTRIBUTES attributes__@(mangled_name) = {
  // 1704:       &vtable__@(mangled_name),
  // 1705:       {
  // 1706:         &undefined_attributes_level_1, &undefined_attributes_level_2,
  // 1707:         &undefined_attributes_level_3, &undefined_attributes_level_4,
  // 1708:         &undefined_attributes_level_5, &undefined_attributes_level_6,
  // 1709:         &undefined_attributes_level_7
  // ...
  frame->slots[15] /* temp__3 */ = create_closure(entry__53_261, 0);
  // 1687: if
  // 1688:   mangled_name == "types__undefined":
  // 1689:     append &attributes_declaration "
  // 1690:       
  // 1691:       static ATTRIBUTES attributes__types__undefined = {
  // 1692:         &vtable__types__undefined,
  // 1693:         {
  // 1694:           &no_attributes_level_1, &no_attributes_level_2,
  // 1695:           &no_attributes_level_3, &no_attributes_level_4,
  // 1696:           &no_attributes_level_5, &no_attributes_level_6,
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_267;
}
static void entry__53_258(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // attributes_declaration: 0
  frame->slots[0] = myself->closure.frame->slots[11]; /* attributes_declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1689: append &attributes_declaration "
  // 1690:   
  // 1691:   static ATTRIBUTES attributes__types__undefined = {
  // 1692:     &vtable__types__undefined,
  // 1693:     {
  // 1694:       &no_attributes_level_1, &no_attributes_level_2,
  // 1695:       &no_attributes_level_3, &no_attributes_level_4,
  // 1696:       &no_attributes_level_5, &no_attributes_level_6,
  // 1697:       &no_attributes_level_7
  // 1698:     }
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__53_259;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_260;
}
static void cont__53_260(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_261(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // attributes_declaration: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[11]; /* attributes_declaration */
  frame->slots[1] = myself->closure.frame->slots[2]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1701: ... "
  // 1702:   
  // 1703:   static ATTRIBUTES attributes__@(mangled_name) = {
  // 1704:     &vtable__@(mangled_name),
  // 1705:     {
  // 1706:       &undefined_attributes_level_1, &undefined_attributes_level_2,
  // 1707:       &undefined_attributes_level_3, &undefined_attributes_level_4,
  // 1708:       &undefined_attributes_level_5, &undefined_attributes_level_6,
  // 1709:       &undefined_attributes_level_7
  // 1710:     }
  // ...
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__53_262;
  arguments->slots[1] = frame->slots[1] /* mangled_name */;
  arguments->slots[2] = string__53_263;
  arguments->slots[3] = frame->slots[1] /* mangled_name */;
  arguments->slots[4] = string__53_264;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_265;
}
static void cont__53_265(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1701: append &attributes_declaration "
  // 1702:   
  // 1703:   static ATTRIBUTES attributes__@(mangled_name) = {
  // 1704:     &vtable__@(mangled_name),
  // 1705:     {
  // 1706:       &undefined_attributes_level_1, &undefined_attributes_level_2,
  // 1707:       &undefined_attributes_level_3, &undefined_attributes_level_4,
  // 1708:       &undefined_attributes_level_5, &undefined_attributes_level_6,
  // 1709:       &undefined_attributes_level_7
  // 1710:     }
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_266;
}
static void cont__53_266(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_267(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1712: write attributes_declaration
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* attributes_declaration */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__53_268;
}
static void cont__53_268(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1714: "  collect_static_attributes(&attributes__@(mangled_name));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__53_269;
  arguments->slots[1] = frame->slots[2] /* mangled_name */;
  arguments->slots[2] = string__53_270;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_271;
}
static void cont__53_271(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1713: write_to_generated_collections
  // 1714:   "  collect_static_attributes(&attributes__@(mangled_name));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__53_272;
}
static void cont__53_272(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1717: ... source.converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* source */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__53_273;
}
static void cont__53_273(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__3 */ = arguments->slots[0];
  // 1717: ... indented(2 source.converted)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[15] /* temp__3 */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__53_274;
}
static void cont__53_274(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__2 */ = arguments->slots[0];
  // 1715: ... "
  // 1716:   @nl;@(scope)void type__@(mangled_name)(void) {
  // 1717:   @(indented(2 source.converted))@nl;}
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__53_275;
  arguments->slots[1] = frame->slots[5] /* scope */;
  arguments->slots[2] = string__53_276;
  arguments->slots[3] = frame->slots[2] /* mangled_name */;
  arguments->slots[4] = string__53_277;
  arguments->slots[5] = frame->slots[14] /* temp__2 */;
  arguments->slots[6] = string__53_278;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_279;
}
static void cont__53_279(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1715: write "
  // 1716:   @nl;@(scope)void type__@(mangled_name)(void) {
  // 1717:   @(indented(2 source.converted))@nl;}
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__53_280;
}
static void cont__53_280(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1718: $constructor_name "create__@(mangled_name)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__53_281;
  arguments->slots[1] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_282;
}
static void cont__53_282(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[12] /* constructor_name */, arguments->slots[0]);
  // 1719: ... defined_functions(constructor_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* constructor_name */;
  result_count = 1;
  myself = get__defined_functions();
  func = myself->type;
  frame->cont = cont__53_283;
}
static void cont__53_283(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1719: ... :
  // 1720:   write_to_declarations
  // 1721:     "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  // 1722:   if
  // 1723:     node_name == "SIMPLE_NODE":
  // 1724:       write "
  // 1725:         SIMPLE_NODE @(mangled_name)__node =
  // 1726:           {
  // 1727:             type__@(mangled_name),
  // 1728:             &attributes__@(mangled_name)
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__53_284, 0);
  // 1719: unless defined_functions(constructor_name):
  // 1720:   write_to_declarations
  // 1721:     "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  // 1722:   if
  // 1723:     node_name == "SIMPLE_NODE":
  // 1724:       write "
  // 1725:         SIMPLE_NODE @(mangled_name)__node =
  // 1726:           {
  // 1727:             type__@(mangled_name),
  // 1728:             &attributes__@(mangled_name)
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_311(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // initialize_object: 0
  // type: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  frame->slots[0] = myself->closure.frame->slots[9]; /* initialize_object */
  frame->slots[1] = myself->closure.frame->slots[8]; /* type */
  frame->slots[2] = myself->closure.frame->slots[5]; /* namespace */
  frame->slots[3] = myself->closure.frame->slots[6]; /* name */
  frame->slots[4] = myself->closure.frame->slots[7]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1743: initialize_object type
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* type */;
  result_count = 0;
  myself = frame->slots[0] /* initialize_object */;
  func = myself->type;
  frame->cont = cont__53_312;
}
static void cont__53_312(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1744: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_313;
}
static void cont__53_313(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1744: ... :
  // 1745:   write_to_phase_2 "
  // 1746:     @
  // 1747:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1748:     get__@(mangled_name), &@(var_entry(mangled_name)));
  frame->slots[6] /* temp__2 */ = create_closure(entry__53_314, 0);
  // 1744: if namespace.is_defined:
  // 1745:   write_to_phase_2 "
  // 1746:     @
  // 1747:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1748:     get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_322(void) {
  allocate_initialized_frame_gc(3, 15);
  // slot allocations:
  // source: 0
  // self: 1
  // scope: 2
  // raw_declaration: 3
  // type_and_name: 4
  // function_name: 5
  // mangled_function_name: 6
  // function_type: 7
  // arguments: 8
  // declaration: 9
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* scope */
  frame->slots[3] /* raw_declaration */ = create_future();
  frame->slots[4] /* type_and_name */ = create_future();
  frame->slots[5] /* function_name */ = create_future();
  frame->slots[6] /* mangled_function_name */ = create_future();
  frame->slots[7] /* function_type */ = create_future();
  frame->slots[8] /* arguments */ = create_future();
  frame->slots[9] /* declaration */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1750: $raw_declaration source .until. ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__until();
  func = myself->type;
  frame->cont = cont__53_323;
}
static void cont__53_323(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* raw_declaration */, arguments->slots[0]);
  // 1751: $type_and_name raw_declaration .before. '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* raw_declaration */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__before();
  func = myself->type;
  frame->cont = cont__53_324;
}
static void cont__53_324(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* type_and_name */, arguments->slots[0]);
  // 1752: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__53_325;
}
static void cont__53_325(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1752: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_326;
}
static void cont__53_326(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1752: $function_name behind(type_and_name alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* type_and_name */;
  arguments->slots[1] = frame->slots[10] /* temp__1 */;
  arguments->slots[2] = frame->slots[11] /* temp__2 */;
  result_count = 1;
  myself = get__behind();
  func = myself->type;
  frame->cont = cont__53_327;
}
static void cont__53_327(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* function_name */, arguments->slots[0]);
  // 1756: scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__53_328;
}
static void cont__53_328(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1756: scope_of(self) == "runtime"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = string__53_329;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__53_330;
}
static void cont__53_330(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1757: -> string("runtime__" function_name)
  frame->slots[12] /* temp__3 */ = create_closure(entry__53_331, 0);
  // 1758: -> function_name
  frame->slots[13] /* temp__4 */ = create_closure(entry__53_334, 0);
  // 1754: $mangled_function_name
  // 1755:   if
  // 1756:     scope_of(self) == "runtime"
  // 1757:     -> string("runtime__" function_name)
  // 1758:     -> function_name
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__3 */;
  arguments->slots[2] = frame->slots[13] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_335;
}
static void entry__53_331(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // function_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* function_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1757: ... string("runtime__" function_name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__53_332;
  arguments->slots[1] = frame->slots[0] /* function_name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__53_333;
}
static void cont__53_333(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1757: -> string("runtime__" function_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_334(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // function_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* function_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1758: -> function_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* function_name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_335(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* mangled_function_name */, arguments->slots[0]);
  // 1760: ... length_of(function_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* function_name */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__53_336;
}
static void cont__53_336(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__3 */ = arguments->slots[0];
  // 1760: ... length_of(function_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__3 */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__53_337;
}
static void cont__53_337(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1760: ... length_of(function_name)-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__53_338;
}
static void cont__53_338(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1760: $function_type range(type_and_name 1 -length_of(function_name)-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* type_and_name */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[10] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__53_339;
}
static void cont__53_339(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* function_type */, arguments->slots[0]);
  // 1761: $arguments raw_declaration .from. '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* raw_declaration */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__from();
  func = myself->type;
  frame->cont = cont__53_340;
}
static void cont__53_340(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* arguments */, arguments->slots[0]);
  // 1766: ... function_name .contains. "::"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* function_name */;
  arguments->slots[1] = string__53_341;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__53_342;
}
static void cont__53_342(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1766: if(function_name .contains. "::" (-> "func__") -> "")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = func__53_343;
  arguments->slots[2] = func__53_345;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_346;
}
static void entry__53_343(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1766: ... -> "func__"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__53_344;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_345(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1766: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_346(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1767: ... "::" = "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__53_347;
  arguments->slots[1] = string__53_348;
  result_count = 1;
  myself = get__std__key_value_pair();
  func = myself->type;
  frame->cont = cont__53_349;
}
static void cont__53_349(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__4 */ = arguments->slots[0];
  // 1767: ... '/' = "___"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__47;
  arguments->slots[1] = string__53_350;
  result_count = 1;
  myself = get__std__key_value_pair();
  func = myself->type;
  frame->cont = cont__53_351;
}
static void cont__53_351(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__5 */ = arguments->slots[0];
  // 1767: replace_all(mangled_function_name "::" = "__" '/' = "___")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* mangled_function_name */;
  arguments->slots[1] = frame->slots[13] /* temp__4 */;
  arguments->slots[2] = frame->slots[14] /* temp__5 */;
  result_count = 1;
  myself = get__replace_all();
  func = myself->type;
  frame->cont = cont__53_352;
}
static void cont__53_352(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__3 */ = arguments->slots[0];
  // 1763: $declaration
  // 1764:   string
  // 1765:     function_type
  // 1766:     if(function_name .contains. "::" (-> "func__") -> "")
  // 1767:     replace_all(mangled_function_name "::" = "__" '/' = "___")
  // 1768:     arguments
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* function_type */;
  arguments->slots[1] = frame->slots[10] /* temp__1 */;
  arguments->slots[2] = frame->slots[12] /* temp__3 */;
  arguments->slots[3] = frame->slots[8] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__53_353;
}
static void cont__53_353(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[9] /* declaration */, arguments->slots[0]);
  // 1771: scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__53_354;
}
static void cont__53_354(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1771: scope_of(self) == "runtime"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = string__53_355;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__53_356;
}
static void cont__53_356(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1771: ... :
  // 1772:   write_to_phase_1 "
  // 1773:     @
  // 1774:       define_c_function("@(function_name)@quot;, @
  // 1775:     @(mangled_function_name));
  frame->slots[12] /* temp__3 */ = create_closure(entry__53_357, 0);
  // 1776: :
  // 1777:   write_to_declarations "@nl;@(scope)@(declaration);@nl;"
  frame->slots[13] /* temp__4 */ = create_closure(entry__53_362, 0);
  // 1770: if
  // 1771:   scope_of(self) == "runtime":
  // 1772:     write_to_phase_1 "
  // 1773:       @
  // 1774:         define_c_function("@(function_name)@quot;, @
  // 1775:       @(mangled_function_name));
  // 1776:   :
  // 1777:     write_to_declarations "@nl;@(scope)@(declaration);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__3 */;
  arguments->slots[2] = frame->slots[13] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_366;
}
static void entry__53_357(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // function_name: 0
  // mangled_function_name: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* function_name */
  frame->slots[1] = myself->closure.frame->slots[6]; /* mangled_function_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1772: ... "
  // 1773:   @
  // 1774:     define_c_function("@(function_name)@quot;, @
  // 1775:   @(mangled_function_name));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__53_358;
  arguments->slots[1] = frame->slots[0] /* function_name */;
  arguments->slots[2] = string__53_359;
  arguments->slots[3] = frame->slots[1] /* mangled_function_name */;
  arguments->slots[4] = string__53_360;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_361;
}
static void cont__53_361(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1772: write_to_phase_1 "
  // 1773:   @
  // 1774:     define_c_function("@(function_name)@quot;, @
  // 1775:   @(mangled_function_name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_1();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_362(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // scope: 0
  // declaration: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[9]; /* declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1777: ... "@nl;@(scope)@(declaration);@nl;"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__53_363;
  arguments->slots[1] = frame->slots[0] /* scope */;
  arguments->slots[2] = frame->slots[1] /* declaration */;
  arguments->slots[3] = string__53_364;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_365;
}
static void cont__53_365(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1777: write_to_declarations "@nl;@(scope)@(declaration);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_366(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1778: ... source .behind. ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__behind();
  func = myself->type;
  frame->cont = cont__53_367;
}
static void cont__53_367(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__3 */ = arguments->slots[0];
  // 1778: ... source .behind. ')').converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__3 */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__53_368;
}
static void cont__53_368(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1778: ... "@nl;@(scope)@(declaration)@((source .behind. ')').converted)@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__53_369;
  arguments->slots[1] = frame->slots[2] /* scope */;
  arguments->slots[2] = frame->slots[9] /* declaration */;
  arguments->slots[3] = frame->slots[11] /* temp__2 */;
  arguments->slots[4] = string__53_370;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_371;
}
static void cont__53_371(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1778: write "@nl;@(scope)@(declaration)@((source .behind. ')').converted)@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_372(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // source: 0
  // scope: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[3]; /* scope */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1780: write_to_declarations '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__10;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__53_373;
}
static void cont__53_373(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1781: ... : (line)
  // 1782:   if line .has_suffix. ';' && line(1) > ' ':
  // 1783:     unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1784:       write_to_declarations scope
  // 1785:   write_to_declarations line.converted '@nl;'
  frame->slots[2] /* temp__1 */ = create_closure(entry__53_374, 1);
  // 1781: for_each_line source: (line)
  // 1782:   if line .has_suffix. ';' && line(1) > ' ':
  // 1783:     unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1784:       write_to_declarations scope
  // 1785:   write_to_declarations line.converted '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_line();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_389(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1787: ... "
  // 1788:   Unknown kind ("@(kind)") in C-code declaration!@
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__53_390;
  arguments->slots[1] = frame->slots[0] /* kind */;
  arguments->slots[2] = string__53_391;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_392;
}
static void cont__53_392(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1787: Error "
  // 1788:   Unknown kind ("@(kind)") in C-code declaration!@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__Error();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_4(void) {
  allocate_initialized_frame_gc(1, 17);
  // slot allocations:
  // self: 0
  // kind: 1
  // source: 2
  // scope: 3
  // identifier: 4
  // namespace: 5
  // name: 6
  // mangled_name: 7
  // type: 8
  // initialize_object: 9
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[9] /* initialize_object */ = create_future();
  frame->slots[1] /* kind */ = create_future();
  frame->slots[2] /* source */ = create_future();
  frame->slots[3] /* scope */ = create_future();
  frame->slots[4] /* identifier */ = create_future();
  frame->slots[5] /* namespace */ = create_future();
  frame->slots[6] /* name */ = create_future();
  frame->slots[7] /* mangled_name */ = create_future();
  frame->slots[8] /* type */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1531: ... :
  // 1532:   (
  // 1533:     obj_type
  // 1534:     as_a_future = false
  // 1535:   )
  // 1536:   $$arguments ""
  // 1537:   for_each
  // 1538:     arguments_of(self): (argument)
  // 1539:       write_to &arguments argument
  // 1540:     :
  // ...
  frame->slots[10] /* temp__1 */ = create_closure(entry__53_5, -1);
  // 1531: $initialize_object:
  // 1532:   (
  // 1533:     obj_type
  // 1534:     as_a_future = false
  // 1535:   )
  // 1536:   $$arguments ""
  // 1537:   for_each
  // 1538:     arguments_of(self): (argument)
  // 1539:       write_to &arguments argument
  // 1540:     :
  // ...
  initialize_future(frame->slots[9] /* initialize_object */, frame->slots[10] /* temp__1 */);
  // 1492: $kind kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__kind_of();
  func = myself->type;
  frame->cont = cont__53_58;
}
static void entry__53_52(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1568: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_53;
}
static void cont__53_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1566: ... "
  // 1567:   static NODE *get__@(mangled_name)(void) {
  // 1568:     return @(var_entry(mangled_name));
  // 1569:   }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__53_54;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__53_55;
  arguments->slots[3] = frame->slots[2] /* temp__2 */;
  arguments->slots[4] = string__53_56;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_57;
}
static void cont__53_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1566: write_to_declarations "
  // 1567:   static NODE *get__@(mangled_name)(void) {
  // 1568:     return @(var_entry(mangled_name));
  // 1569:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_5(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // obj_type: 0
  // as_a_future: 1
  // self: 2
  // mangled_name: 3
  // namespace: 4
  // arguments: 5
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[4] = myself->closure.frame->slots[5]; /* namespace */
  frame->slots[5] /* arguments */ = create_cell();
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 2) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[1] /* as_a_future */ = arguments->slots[1];
    case 1:;
  }
  switch(argument_count) {
    case 1: frame->slots[1] /* as_a_future */ = get__false();
  }
  // 1536: $$arguments ""
  ((CELL *)frame->slots[5])->contents /* arguments */ = empty_string;
  // 1538: arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__53_6;
}
static void cont__53_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1538: ... : (argument)
  // 1539:   write_to &arguments argument
  frame->slots[7] /* temp__2 */ = create_closure(entry__53_7, 1);
  // 1540: :
  // 1541:   append &arguments ", "
  frame->slots[8] /* temp__3 */ = create_closure(entry__53_9, 0);
  // 1537: for_each
  // 1538:   arguments_of(self): (argument)
  // 1539:     write_to &arguments argument
  // 1540:   :
  // 1541:     append &arguments ", "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__53_12;
}
static void entry__53_7(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // argument: 0
  // arguments: 1
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1539: write_to &arguments argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__53_8;
}
static void cont__53_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_9(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1541: append &arguments ", "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[1] = string__53_10;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__53_11;
}
static void cont__53_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_12(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1543: mangled_name .contains. "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  arguments->slots[1] = string__53_13;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__53_14;
}
static void cont__53_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1543: ... :
  // 1544:   write_to_global_variable_declarations
  // 1545:     string("  NODE *" mangled_name ";@nl;")
  frame->slots[7] /* temp__2 */ = create_closure(entry__53_15, 0);
  // 1546: :
  // 1547:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1548:   write_to_top_level_variable_declarations
  // 1549:     string("  NODE *" var_name(mangled_name) ";@nl;")
  frame->slots[8] /* temp__3 */ = create_closure(entry__53_19, 0);
  // 1542: if
  // 1543:   mangled_name .contains. "__":
  // 1544:     write_to_global_variable_declarations
  // 1545:       string("  NODE *" mangled_name ";@nl;")
  // 1546:   :
  // 1547:     write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1548:     write_to_top_level_variable_declarations
  // 1549:       string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_28;
}
static void entry__53_15(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1545: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__53_16;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__53_17;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__53_18;
}
static void cont__53_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1544: write_to_global_variable_declarations
  // 1545:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_19(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1547: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__53_20;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__53_21;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_22;
}
static void cont__53_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1547: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__53_23;
}
static void cont__53_23(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1549: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_name;
  func = myself->type;
  frame->cont = cont__53_24;
}
static void cont__53_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1549: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__53_25;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__53_26;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__53_27;
}
static void cont__53_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1548: write_to_top_level_variable_declarations
  // 1549:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_28(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1552: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_29;
}
static void cont__53_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1552: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_30;
}
static void cont__53_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 1550: ... "
  // 1551:   @
  // 1552:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1553:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__53_31;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = string__53_32;
  arguments->slots[3] = frame->slots[8] /* temp__3 */;
  arguments->slots[4] = string__53_33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_34;
}
static void cont__53_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1550: write_to_generated_collections "
  // 1551:   @
  // 1552:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1553:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__53_35;
}
static void cont__53_35(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1555: ... :
  // 1556:   write_to_phase_2 "
  // 1557:     @
  // 1558:       @(var_entry(mangled_name)) = @
  // 1559:     create_future_with_prototype(create__@(obj_type)(@(arguments)));
  frame->slots[6] /* temp__1 */ = create_closure(entry__53_36, 0);
  // 1560: :
  // 1561:   write_to_phase_2 "
  // 1562:     @
  // 1563:       @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // 1564:     );@nl;@
  frame->slots[7] /* temp__2 */ = create_closure(entry__53_43, 0);
  // 1554: if
  // 1555:   as_a_future:
  // 1556:     write_to_phase_2 "
  // 1557:       @
  // 1558:         @(var_entry(mangled_name)) = @
  // 1559:       create_future_with_prototype(create__@(obj_type)(@(arguments)));
  // 1560:   :
  // 1561:     write_to_phase_2 "
  // 1562:       @
  // 1563:         @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* as_a_future */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_50;
}
static void entry__53_36(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // obj_type: 1
  // arguments: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* obj_type */
  frame->slots[2] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1558: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_37;
}
static void cont__53_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1556: ... "
  // 1557:   @
  // 1558:     @(var_entry(mangled_name)) = @
  // 1559:   create_future_with_prototype(create__@(obj_type)(@(arguments)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__53_38;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__53_39;
  arguments->slots[3] = frame->slots[1] /* obj_type */;
  arguments->slots[4] = string__53_40;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[6] = string__53_41;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_42;
}
static void cont__53_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1556: write_to_phase_2 "
  // 1557:   @
  // 1558:     @(var_entry(mangled_name)) = @
  // 1559:   create_future_with_prototype(create__@(obj_type)(@(arguments)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_43(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // obj_type: 1
  // arguments: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* obj_type */
  frame->slots[2] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1563: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = var._var_entry;
  func = myself->type;
  frame->cont = cont__53_44;
}
static void cont__53_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1561: ... "
  // 1562:   @
  // 1563:     @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // 1564:   );@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__53_45;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__53_46;
  arguments->slots[3] = frame->slots[1] /* obj_type */;
  arguments->slots[4] = string__53_47;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[6] = string__53_48;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__53_49;
}
static void cont__53_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1561: write_to_phase_2 "
  // 1562:   @
  // 1563:     @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // 1564:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_50(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1565: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_51;
}
static void cont__53_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1565: ... :
  // 1566:   write_to_declarations "
  // 1567:     static NODE *get__@(mangled_name)(void) {
  // 1568:       return @(var_entry(mangled_name));
  // 1569:     }
  frame->slots[7] /* temp__2 */ = create_closure(entry__53_52, 0);
  // 1565: if namespace.is_defined:
  // 1566:   write_to_declarations "
  // 1567:     static NODE *get__@(mangled_name)(void) {
  // 1568:       return @(var_entry(mangled_name));
  // 1569:     }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__53_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* kind */, arguments->slots[0]);
  // 1493: $source source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__53_59;
}
static void cont__53_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* source */, arguments->slots[0]);
  // 1497: scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__53_60;
}
static void cont__53_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1495: $scope
  // 1496:   case
  // 1497:     scope_of(self)
  // 1498:     "runtime"
  // 1499:     -> ""
  // 1500:     "global"
  // 1501:     -> ""
  // 1502:     "extern"
  // 1503:     -> "extern "
  // 1504:     -> "static "
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = string__53_61;
  arguments->slots[2] = func__53_62;
  arguments->slots[3] = string__53_63;
  arguments->slots[4] = func__53_64;
  arguments->slots[5] = string__53_65;
  arguments->slots[6] = func__53_66;
  arguments->slots[7] = func__53_68;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__53_70;
}
static void entry__53_62(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1499: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_64(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1501: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_66(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1503: -> "extern "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__53_67;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_68(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1504: -> "static "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__53_69;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* scope */, arguments->slots[0]);
  // 1512: $identifier identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__53_71;
}
static void cont__53_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* identifier */, arguments->slots[0]);
  // 1515: ... identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_72;
}
static void cont__53_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1515: ... -> namespace_of(identifier)
  frame->slots[11] /* temp__2 */ = create_closure(entry__53_73, 0);
  // 1514: $namespace
  // 1515:   if(identifier.is_defined (-> namespace_of(identifier)) -> undefined)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__2 */;
  arguments->slots[2] = func__53_75;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_76;
}
static void entry__53_73(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // identifier: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* identifier */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1515: ... namespace_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* identifier */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__53_74;
}
static void cont__53_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1515: ... -> namespace_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_75(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1515: ... -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* namespace */, arguments->slots[0]);
  // 1517: ... identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_77;
}
static void cont__53_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1517: ... -> name_of(identifier)
  frame->slots[11] /* temp__2 */ = create_closure(entry__53_78, 0);
  // 1517: $name if(identifier.is_defined (-> name_of(identifier)) -> undefined)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__2 */;
  arguments->slots[2] = func__53_80;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_81;
}
static void entry__53_78(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // identifier: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* identifier */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1517: ... name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* identifier */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__53_79;
}
static void cont__53_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1517: ... -> name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_80(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1517: ... -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* name */, arguments->slots[0]);
  // 1521: identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_82;
}
static void cont__53_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1522: -> mangled_name_of(identifier_of(self))
  frame->slots[11] /* temp__2 */ = create_closure(entry__53_83, 0);
  // 1519: $mangled_name
  // 1520:   if
  // 1521:     identifier.is_defined
  // 1522:     -> mangled_name_of(identifier_of(self))
  // 1523:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__2 */;
  arguments->slots[2] = func__53_86;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_87;
}
static void entry__53_83(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1522: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__53_84;
}
static void cont__53_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1522: ... mangled_name_of(identifier_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__53_85;
}
static void cont__53_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1522: -> mangled_name_of(identifier_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_86(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1523: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* mangled_name */, arguments->slots[0]);
  // 1527: node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__53_88;
}
static void cont__53_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1527: node::type_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__53_89;
}
static void cont__53_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1528: -> mangled_name_of(node::type_of(self))
  frame->slots[12] /* temp__3 */ = create_closure(entry__53_90, 0);
  // 1525: $type
  // 1526:   if
  // 1527:     node::type_of(self).is_defined
  // 1528:     -> mangled_name_of(node::type_of(self))
  // 1529:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__3 */;
  arguments->slots[2] = func__53_93;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__53_94;
}
static void entry__53_90(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1528: ... node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__53_91;
}
static void cont__53_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1528: ... mangled_name_of(node::type_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__53_92;
}
static void cont__53_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1528: -> mangled_name_of(node::type_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_93(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1529: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* type */, arguments->slots[0]);
  // 1573: ... :
  // 1574:   write_to_declarations "
  // 1575:     
  // 1576:     typedef struct @(mangled_name) @(mangled_name);
  // 1577:     struct @(mangled_name) {@nl;@(indented(2 source))
  // 1578:     };
  frame->slots[10] /* temp__1 */ = create_closure(entry__53_95, 0);
  // 1579: ... :
  // 1580:   write_to_declarations "
  // 1581:     
  // 1582:     typedef struct {
  // 1583:       void *type;
  // 1584:       ATTRIBUTES *attributes;
  // 1585:     @(indented(2 source))@nl;} @(mangled_name);
  // 1586:   $collector_name "collect_@(mangled_name.to_lower_case)"
  // 1587:   unless defined_functions(collector_name):
  // 1588:     write "
  // ...
  frame->slots[11] /* temp__2 */ = create_closure(entry__53_103, 0);
  // 1619: ... :
  // 1620:   $node_name node_of(self)
  // 1621:   $node defined_nodes(node_name)
  // 1622:   unless node.is_defined:
  // 1623:     Error "
  // 1624:       Missing definition for a node named "@(node_name)@quot;!@
  // 1625:   if
  // 1626:     base_of(self).is_defined:
  // 1627:       initialize_object mangled_name true
  // 1628:       assign var_entry(mangled_name) base_of(self).to_c
  // ...
  frame->slots[12] /* temp__3 */ = create_closure(entry__53_167, 0);
  // 1742: ... :
  // 1743:   initialize_object type
  // 1744:   if namespace.is_defined:
  // 1745:     write_to_phase_2 "
  // 1746:       @
  // 1747:         define_single_assign_static("@(namespace)", "@(name)", @
  // 1748:       get__@(mangled_name), &@(var_entry(mangled_name)));
  frame->slots[13] /* temp__4 */ = create_closure(entry__53_311, 0);
  // 1749: ... :
  // 1750:   $raw_declaration source .until. ')'
  // 1751:   $type_and_name raw_declaration .before. '('
  // 1752:   $function_name behind(type_and_name alt(' ' '*') -1)
  // 1753:   
  // 1754:   $mangled_function_name
  // 1755:     if
  // 1756:       scope_of(self) == "runtime"
  // 1757:       -> string("runtime__" function_name)
  // 1758:       -> function_name
  // ...
  frame->slots[14] /* temp__5 */ = create_closure(entry__53_322, 0);
  // 1779: ... :
  // 1780:   write_to_declarations '@nl;'
  // 1781:   for_each_line source: (line)
  // 1782:     if line .has_suffix. ';' && line(1) > ' ':
  // 1783:       unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1784:         write_to_declarations scope
  // 1785:     write_to_declarations line.converted '@nl;'
  frame->slots[15] /* temp__6 */ = create_closure(entry__53_372, 0);
  // 1786: :
  // 1787:   Error "
  // 1788:     Unknown kind ("@(kind)") in C-code declaration!@
  frame->slots[16] /* temp__7 */ = create_closure(entry__53_389, 0);
  // 1571: case
  // 1572:   kind
  // 1573:   "struct":
  // 1574:     write_to_declarations "
  // 1575:       
  // 1576:       typedef struct @(mangled_name) @(mangled_name);
  // 1577:       struct @(mangled_name) {@nl;@(indented(2 source))
  // 1578:       };
  // 1579:   "node":
  // 1580:     write_to_declarations "
  // ...
  argument_count = 14;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* kind */;
  arguments->slots[1] = string__53_393;
  arguments->slots[2] = frame->slots[10] /* temp__1 */;
  arguments->slots[3] = string__53_394;
  arguments->slots[4] = frame->slots[11] /* temp__2 */;
  arguments->slots[5] = string__53_395;
  arguments->slots[6] = frame->slots[12] /* temp__3 */;
  arguments->slots[7] = string__53_396;
  arguments->slots[8] = frame->slots[13] /* temp__4 */;
  arguments->slots[9] = string__53_397;
  arguments->slots[10] = frame->slots[14] /* temp__5 */;
  arguments->slots[11] = get__undefined();
  arguments->slots[12] = frame->slots[15] /* temp__6 */;
  arguments->slots[13] = frame->slots[16] /* temp__7 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__53_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1490: show_compiler_debug_info "define C-code"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__53_2;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__53_3;
}
static void cont__53_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1491: ... :
  // 1492:   $kind kind_of(self)
  // 1493:   $source source_of(self)
  // 1494:   
  // 1495:   $scope
  // 1496:     case
  // 1497:       scope_of(self)
  // 1498:       "runtime"
  // 1499:       -> ""
  // 1500:       "global"
  // ...
  frame->slots[1] /* temp__1 */ = create_closure(entry__53_4, 0);
  // 1491: delayed:
  // 1492:   $kind kind_of(self)
  // 1493:   $source source_of(self)
  // 1494:   
  // 1495:   $scope
  // 1496:     case
  // 1497:       scope_of(self)
  // 1498:       "runtime"
  // 1499:       -> ""
  // 1500:       "global"
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._delayed;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__54_1(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // source: 1
  // attributes: 2
  // code: 3
  frame->slots[3] /* code */ = create_future();
  if (argument_count != 3) {
    invalid_arguments_error();
    return;
  }
  // 1794: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__54_2;
}
static void cont__54_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1791: ... "
  // 1792:   @
  // 1793:     {
  // 1794:       NODE *temp = clone_object_and_attributes(@(source.to_c));
  // 1795:       update_start_p = node_p;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__54_3;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__54_4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__54_5;
}
static void cont__54_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1791: write "
  // 1792:   @
  // 1793:     {
  // 1794:       NODE *temp = clone_object_and_attributes(@(source.to_c));
  // 1795:       update_start_p = node_p;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__54_6;
}
static void cont__54_6(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1796: for_each attributes: (attribute)
  // 1797:   $identifier identifier_of(attribute)
  // 1798:   $value arguments_of(attribute)(1).to_c
  // 1799:   if
  // 1800:     identifier.is_defined:
  // 1801:       $kind if(attribute.is_an_attribute_function_pair (-> "") -> "_value")
  // 1802:       write "
  // 1803:         @
  // 1804:             set_attribute@(kind)(temp->attributes, @
  // 1805:         poly_idx__@(mangled_name_of(identifier)), @(value));@nl;@
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* attributes */;
  arguments->slots[1] = func__54_7;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__54_29;
}
static void entry__54_13(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // attribute: 0
  // identifier: 1
  // value: 2
  // kind: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* attribute */
  frame->slots[1] = myself->closure.frame->slots[1]; /* identifier */
  frame->slots[2] = myself->closure.frame->slots[2]; /* value */
  frame->slots[3] /* kind */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1801: ... attribute.is_an_attribute_function_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* attribute */;
  result_count = 1;
  myself = get__is_an_attribute_function_pair();
  func = myself->type;
  frame->cont = cont__54_14;
}
static void cont__54_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1801: $kind if(attribute.is_an_attribute_function_pair (-> "") -> "_value")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = func__54_15;
  arguments->slots[2] = func__54_16;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__54_18;
}
static void entry__54_15(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1801: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__54_16(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1801: ... -> "_value"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__54_17;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__54_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* kind */, arguments->slots[0]);
  // 1805: ... mangled_name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__54_19;
}
static void cont__54_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1802: ... "
  // 1803:   @
  // 1804:       set_attribute@(kind)(temp->attributes, @
  // 1805:   poly_idx__@(mangled_name_of(identifier)), @(value));@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__54_20;
  arguments->slots[1] = frame->slots[3] /* kind */;
  arguments->slots[2] = string__54_21;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  arguments->slots[4] = string__54_22;
  arguments->slots[5] = frame->slots[2] /* value */;
  arguments->slots[6] = string__54_23;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__54_24;
}
static void cont__54_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1802: write "
  // 1803:   @
  // 1804:       set_attribute@(kind)(temp->attributes, @
  // 1805:   poly_idx__@(mangled_name_of(identifier)), @(value));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__54_25(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // value: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1807: ... "
  // 1808:   @
  // 1809:       temp->type = @(value)->type;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__54_26;
  arguments->slots[1] = frame->slots[0] /* value */;
  arguments->slots[2] = string__54_27;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__54_28;
}
static void cont__54_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1807: write "
  // 1808:   @
  // 1809:       temp->type = @(value)->type;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__54_7(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // attribute: 0
  // identifier: 1
  // value: 2
  frame->slots[1] /* identifier */ = create_future();
  frame->slots[2] /* value */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1797: $identifier identifier_of(attribute)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* attribute */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__54_8;
}
static void cont__54_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* identifier */, arguments->slots[0]);
  // 1798: ... arguments_of(attribute)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* attribute */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__54_9;
}
static void cont__54_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1798: ... arguments_of(attribute)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__2 */;
  func = myself->type;
  frame->cont = cont__54_10;
}
static void cont__54_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1798: $value arguments_of(attribute)(1).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__54_11;
}
static void cont__54_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* value */, arguments->slots[0]);
  // 1800: identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__54_12;
}
static void cont__54_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1800: ... :
  // 1801:   $kind if(attribute.is_an_attribute_function_pair (-> "") -> "_value")
  // 1802:   write "
  // 1803:     @
  // 1804:         set_attribute@(kind)(temp->attributes, @
  // 1805:     poly_idx__@(mangled_name_of(identifier)), @(value));@nl;@
  frame->slots[4] /* temp__2 */ = create_closure(entry__54_13, 0);
  // 1806: :
  // 1807:   write "
  // 1808:     @
  // 1809:         temp->type = @(value)->type;
  frame->slots[5] /* temp__3 */ = create_closure(entry__54_25, 0);
  // 1799: if
  // 1800:   identifier.is_defined:
  // 1801:     $kind if(attribute.is_an_attribute_function_pair (-> "") -> "_value")
  // 1802:     write "
  // 1803:       @
  // 1804:           set_attribute@(kind)(temp->attributes, @
  // 1805:       poly_idx__@(mangled_name_of(identifier)), @(value));@nl;@
  // 1806:   :
  // 1807:     write "
  // 1808:       @
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__54_29(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1810: $code assignment_to_c(destination "temp")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  arguments->slots[1] = string__54_30;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__54_31;
}
static void cont__54_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* code */, arguments->slots[0]);
  // 1811: ... "
  // 1812:   @
  // 1813:     @(code)
  // 1814:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__54_32;
  arguments->slots[1] = frame->slots[3] /* code */;
  arguments->slots[2] = string__54_33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__54_34;
}
static void cont__54_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1811: write "
  // 1812:   @
  // 1813:     @(code)
  // 1814:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_82(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // destination: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1878: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__55_83;
}
static void cont__55_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1878: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__55_84;
}
static void cont__55_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1876: ... "
  // 1877:   @
  // 1878:     initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1879:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__55_85;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__55_86;
  arguments->slots[3] = frame->slots[4] /* temp__3 */;
  arguments->slots[4] = string__55_87;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__55_88;
}
static void cont__55_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1876: write "
  // 1877:   @
  // 1878:     initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1879:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_89(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // destination: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1881: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__55_90;
}
static void cont__55_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1881: ... assignment_to_c(destination source.to_c)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__55_91;
}
static void cont__55_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1881: write assignment_to_c(destination source.to_c)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_35(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // input_arguments: 0
  // statement: 1
  // output_arguments: 2
  // functor: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* input_arguments */
  frame->slots[1] = myself->closure.frame->slots[2]; /* statement */
  frame->slots[2] = myself->closure.frame->slots[3]; /* output_arguments */
  frame->slots[3] = myself->closure.frame->slots[0]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1840: generate_c_arguments input_arguments
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* input_arguments */;
  result_count = 0;
  myself = var._generate_c_arguments;
  func = myself->type;
  frame->cont = cont__55_36;
}
static void cont__55_36(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1842: -> result_count_of(statement).is_defined:
  // 1843:   writeln
  // 1844:     "  result_count = to_int(@(result_count_of(statement).to_c));"
  frame->slots[4] /* temp__1 */ = create_closure(entry__55_37, 0);
  // 1845: -> continuation_of(statement).is_defined:
  // 1846:   # This makes no sense because we're not in a tail-call position!
  // 1847:   
  // 1848:   SyntaxError
  // 1849:     statement
  // 1850:     "Call with continuation followed by another statement"
  frame->slots[5] /* temp__2 */ = create_closure(entry__55_46, 0);
  // 1851: :
  // 1852:   $result_count count_arguments(output_arguments)
  // 1853:   case
  // 1854:     result_count
  // 1855:     undefined:
  // 1856:       writeln "  result_count = -1;"
  // 1857:     :
  // 1858:       writeln "  result_count = @(result_count);"
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_51, 0);
  // 1841: cond
  // 1842:   -> result_count_of(statement).is_defined:
  // 1843:     writeln
  // 1844:       "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1845:   -> continuation_of(statement).is_defined:
  // 1846:     # This makes no sense because we're not in a tail-call position!
  // 1847:     
  // 1848:     SyntaxError
  // 1849:       statement
  // 1850:       "Call with continuation followed by another statement"
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__55_59;
}
static void entry__55_53(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // result_count: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* result_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1858: ... "  result_count = @(result_count);"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__55_54;
  arguments->slots[1] = frame->slots[0] /* result_count */;
  arguments->slots[2] = string__55_55;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__55_56;
}
static void cont__55_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1858: writeln "  result_count = @(result_count);"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_57(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1856: writeln "  result_count = -1;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__55_58;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_49(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1848: SyntaxError
  // 1849:   statement
  // 1850:   "Call with continuation followed by another statement"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  arguments->slots[1] = string__55_50;
  result_count = frame->caller_result_count;
  myself = get__SyntaxError();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_40(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1844: ... result_count_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__result_count_of();
  func = myself->type;
  frame->cont = cont__55_41;
}
static void cont__55_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1844: ... result_count_of(statement).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__55_42;
}
static void cont__55_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1844: "  result_count = to_int(@(result_count_of(statement).to_c));"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__55_43;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__55_44;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__55_45;
}
static void cont__55_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1843: writeln
  // 1844:   "  result_count = to_int(@(result_count_of(statement).to_c));"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_37(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1842: ... result_count_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__result_count_of();
  func = myself->type;
  frame->cont = cont__55_38;
}
static void cont__55_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1842: ... result_count_of(statement).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_39;
}
static void cont__55_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1842: ... :
  // 1843:   writeln
  // 1844:     "  result_count = to_int(@(result_count_of(statement).to_c));"
  frame->slots[3] /* temp__3 */ = create_closure(entry__55_40, 0);
  // 1842: -> result_count_of(statement).is_defined:
  // 1843:   writeln
  // 1844:     "  result_count = to_int(@(result_count_of(statement).to_c));"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_46(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1845: ... continuation_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__continuation_of();
  func = myself->type;
  frame->cont = cont__55_47;
}
static void cont__55_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1845: ... continuation_of(statement).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_48;
}
static void cont__55_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1845: ... :
  // 1846:   # This makes no sense because we're not in a tail-call position!
  // 1847:   
  // 1848:   SyntaxError
  // 1849:     statement
  // 1850:     "Call with continuation followed by another statement"
  frame->slots[3] /* temp__3 */ = create_closure(entry__55_49, 0);
  // 1845: -> continuation_of(statement).is_defined:
  // 1846:   # This makes no sense because we're not in a tail-call position!
  // 1847:   
  // 1848:   SyntaxError
  // 1849:     statement
  // 1850:     "Call with continuation followed by another statement"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_51(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // output_arguments: 0
  // result_count: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* output_arguments */
  frame->slots[1] /* result_count */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1852: $result_count count_arguments(output_arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output_arguments */;
  result_count = 1;
  myself = var._count_arguments;
  func = myself->type;
  frame->cont = cont__55_52;
}
static void cont__55_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* result_count */, arguments->slots[0]);
  // 1857: :
  // 1858:   writeln "  result_count = @(result_count);"
  frame->slots[2] /* temp__1 */ = create_closure(entry__55_53, 0);
  // 1853: case
  // 1854:   result_count
  // 1855:   undefined:
  // 1856:     writeln "  result_count = -1;"
  // 1857:   :
  // 1858:     writeln "  result_count = @(result_count);"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* result_count */;
  arguments->slots[1] = get__undefined();
  arguments->slots[2] = func__55_57;
  arguments->slots[3] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__55_59(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1859: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__55_60;
}
static void cont__55_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 1860: ... "cont@(suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__55_61;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__55_62;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__55_63;
}
static void cont__55_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1860: get_func_and_myself functor "cont@(suffix)_@(index)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* functor */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = var._get_func_and_myself;
  func = myself->type;
  frame->cont = cont__55_64;
}
static void cont__55_64(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1861: if do_use_goto:
  // 1862:   write "
  // 1863:     @
  // 1864:       goto *(func+4);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__do_use_goto();
  arguments->slots[1] = func__55_65;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_67;
}
static void entry__55_65(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1862: write "
  // 1863:   @
  // 1864:     goto *(func+4);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__55_66;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__55_67(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1865: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__55_68;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__55_69;
}
static void cont__55_69(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1866: ... "cont@(suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__55_70;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__55_71;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__55_72;
}
static void cont__55_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1866: next_continuation "cont@(suffix)_@(index)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__next_continuation();
  func = myself->type;
  frame->cont = cont__55_73;
}
static void cont__55_73(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1867: extract "results" output_arguments
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__55_74;
  arguments->slots[1] = frame->slots[2] /* output_arguments */;
  result_count = frame->caller_result_count;
  myself = var._extract;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_75(void) {
  allocate_initialized_frame_gc(2, 9);
  // slot allocations:
  // output_arguments: 0
  // input_arguments: 1
  // destination: 2
  // source: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* output_arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* input_arguments */
  frame->slots[2] /* destination */ = create_future();
  frame->slots[3] /* source */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1869: $destination output_arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* output_arguments */;
  func = myself->type;
  frame->cont = cont__55_76;
}
static void cont__55_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* destination */, arguments->slots[0]);
  // 1870: $source input_arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* input_arguments */;
  func = myself->type;
  frame->cont = cont__55_77;
}
static void cont__55_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* source */, arguments->slots[0]);
  // 1873: destination.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__is_a_single_assign_definition();
  func = myself->type;
  frame->cont = cont__55_78;
}
static void cont__55_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1874: source.might_be_constant
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_79, 0);
  // 1872: &&
  // 1873:   destination.is_a_single_assign_definition
  // 1874:   source.might_be_constant
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_81;
}
static void entry__55_79(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1874: source.might_be_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__might_be_constant();
  func = myself->type;
  frame->cont = cont__55_80;
}
static void cont__55_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1874: source.might_be_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1875: :
  // 1876:   write "
  // 1877:     @
  // 1878:       initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1879:     );@nl;@
  frame->slots[7] /* temp__4 */ = create_closure(entry__55_82, 0);
  // 1880: :
  // 1881:   write assignment_to_c(destination source.to_c)
  frame->slots[8] /* temp__5 */ = create_closure(entry__55_89, 0);
  // 1871: if
  // 1872:   &&
  // 1873:     destination.is_a_single_assign_definition
  // 1874:     source.might_be_constant
  // 1875:   :
  // 1876:     write "
  // 1877:       @
  // 1878:         initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1879:       );@nl;@
  // 1880:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_26(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // statement: 0
  // functor: 1
  // input_arguments: 2
  // destination: 3
  // source: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[2] = myself->closure.frame->slots[2]; /* input_arguments */
  frame->slots[3] /* destination */ = create_future();
  frame->slots[4] /* source */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1834: ... output_arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__output_arguments_of();
  func = myself->type;
  frame->cont = cont__55_27;
}
static void cont__55_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1834: $destination output_arguments_of(statement)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[5] /* temp__1 */;
  func = myself->type;
  frame->cont = cont__55_28;
}
static void cont__55_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* destination */, arguments->slots[0]);
  // 1835: ... functor.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* functor */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_29;
}
static void cont__55_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1835: ... -> functor
  frame->slots[6] /* temp__2 */ = create_closure(entry__55_30, 0);
  // 1835: ... -> destination
  frame->slots[7] /* temp__3 */ = create_closure(entry__55_31, 0);
  // 1835: $source if(functor.is_defined (-> functor) -> destination)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_32;
}
static void entry__55_30(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1835: ... -> functor
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_31(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // destination: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* destination */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1835: ... -> destination
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* source */, arguments->slots[0]);
  // 1836: assign_attributes destination source input_arguments
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* destination */;
  arguments->slots[1] = frame->slots[4] /* source */;
  arguments->slots[2] = frame->slots[2] /* input_arguments */;
  result_count = frame->caller_result_count;
  myself = var._assign_attributes;
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_33(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // functor: 0
  // input_arguments: 1
  // statement: 2
  // output_arguments: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[2]; /* input_arguments */
  frame->slots[2] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[3] = myself->closure.frame->slots[3]; /* output_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1839: functor.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_34;
}
static void cont__55_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1839: ... :
  // 1840:   generate_c_arguments input_arguments
  // 1841:   cond
  // 1842:     -> result_count_of(statement).is_defined:
  // 1843:       writeln
  // 1844:         "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1845:     -> continuation_of(statement).is_defined:
  // 1846:       # This makes no sense because we're not in a tail-call position!
  // 1847:       
  // 1848:       SyntaxError
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__55_35, 0);
  // 1868: : # assignment
  // 1869:   $destination output_arguments(1)
  // 1870:   $source input_arguments(1)
  // 1871:   if
  // 1872:     &&
  // 1873:       destination.is_a_single_assign_definition
  // 1874:       source.might_be_constant
  // 1875:     :
  // 1876:       write "
  // 1877:         @
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_75, 0);
  // 1838: if
  // 1839:   functor.is_defined:
  // 1840:     generate_c_arguments input_arguments
  // 1841:     cond
  // 1842:       -> result_count_of(statement).is_defined:
  // 1843:         writeln
  // 1844:           "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1845:       -> continuation_of(statement).is_defined:
  // 1846:         # This makes no sense because we're not in a tail-call position!
  // 1847:         
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_1(void) {
  allocate_initialized_frame_gc(1, 11);
  // slot allocations:
  // statement: 0
  // functor: 1
  // input_arguments: 2
  // output_arguments: 3
  frame->slots[1] /* functor */ = create_future();
  frame->slots[2] /* input_arguments */ = create_future();
  frame->slots[3] /* output_arguments */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1819: ... :
  // 1820:   cond
  // 1821:     -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  // 1822:     -> statement.is_an_assignment: ewriteln "generate assignment"
  // 1823:     :
  // 1824:       ewriteln "generate unknown statement"
  frame->slots[4] /* temp__1 */ = create_closure(entry__55_2, 0);
  // 1819: if do_show_compiler_debug_infos:
  // 1820:   cond
  // 1821:     -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  // 1822:     -> statement.is_an_assignment: ewriteln "generate assignment"
  // 1823:     :
  // 1824:       ewriteln "generate unknown statement"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__do_show_compiler_debug_infos();
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_13;
}
static void entry__55_9(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1822: ... ewriteln "generate assignment"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__55_10;
  result_count = frame->caller_result_count;
  myself = get__ewriteln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1821: ... ewriteln "generate procedure call"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__55_6;
  result_count = frame->caller_result_count;
  myself = get__ewriteln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_3(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1821: ... statement.is_a_procedure_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_a_procedure_call();
  func = myself->type;
  frame->cont = cont__55_4;
}
static void cont__55_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1821: -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__55_5;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_7(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1822: ... statement.is_an_assignment
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_an_assignment();
  func = myself->type;
  frame->cont = cont__55_8;
}
static void cont__55_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1822: -> statement.is_an_assignment: ewriteln "generate assignment"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__55_9;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_11(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1824: ewriteln "generate unknown statement"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__55_12;
  result_count = frame->caller_result_count;
  myself = get__ewriteln();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void entry__55_2(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1821: -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  frame->slots[1] /* temp__1 */ = create_closure(entry__55_3, 0);
  // 1822: -> statement.is_an_assignment: ewriteln "generate assignment"
  frame->slots[2] /* temp__2 */ = create_closure(entry__55_7, 0);
  // 1820: cond
  // 1821:   -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  // 1822:   -> statement.is_an_assignment: ewriteln "generate assignment"
  // 1823:   :
  // 1824:     ewriteln "generate unknown statement"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = func__55_11;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
static void cont__55_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1825: write_source_as_remark statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__write_source_as_remark();
  func = myself->type;
  frame->cont = cont__55_14;
}
static void cont__55_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1826: $functor functor_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__55_15;
}
static void cont__55_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* functor */, arguments->slots[0]);
  // 1827: $input_arguments arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__55_16;
}
static void cont__55_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* input_arguments */, arguments->slots[0]);
  // 1828: $output_arguments output_arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__output_arguments_of();
  func = myself->type;
  frame->cont = cont__55_17;
}
static void cont__55_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* output_arguments */, arguments->slots[0]);
  // 1831: length_of(input_arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* input_arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_18;
}
static void cont__55_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1831: length_of(input_arguments) >= 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_19;
}
static void cont__55_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1831: length_of(input_arguments) >= 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__55_20;
}
static void cont__55_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1832: input_arguments(-1).is_an_attribute_value_pair
  frame->slots[8] /* temp__5 */ = create_closure(entry__55_21, 0);
  // 1830: &&
  // 1831:   length_of(input_arguments) >= 1
  // 1832:   input_arguments(-1).is_an_attribute_value_pair
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_25;
}
static void entry__55_21(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // input_arguments: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* input_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1832: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__55_22;
}
static void cont__55_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1832: input_arguments(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = frame->slots[0] /* input_arguments */;
  func = myself->type;
  frame->cont = cont__55_23;
}
static void cont__55_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1832: input_arguments(-1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_attribute_value_pair();
  func = myself->type;
  frame->cont = cont__55_24;
}
static void cont__55_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1832: input_arguments(-1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1833: :
  // 1834:   $destination output_arguments_of(statement)(1)
  // 1835:   $source if(functor.is_defined (-> functor) -> destination)
  // 1836:   assign_attributes destination source input_arguments
  frame->slots[9] /* temp__6 */ = create_closure(entry__55_26, 0);
  // 1837: :
  // 1838:   if
  // 1839:     functor.is_defined:
  // 1840:       generate_c_arguments input_arguments
  // 1841:       cond
  // 1842:         -> result_count_of(statement).is_defined:
  // 1843:           writeln
  // 1844:             "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1845:         -> continuation_of(statement).is_defined:
  // 1846:           # This makes no sense because we're not in a tail-call position!
  // ...
  frame->slots[10] /* temp__7 */ = create_closure(entry__55_33, 0);
  // 1829: if
  // 1830:   &&
  // 1831:     length_of(input_arguments) >= 1
  // 1832:     input_arguments(-1).is_an_attribute_value_pair
  // 1833:   :
  // 1834:     $destination output_arguments_of(statement)(1)
  // 1835:     $source if(functor.is_defined (-> functor) -> destination)
  // 1836:     assign_attributes destination source input_arguments
  // 1837:   :
  // 1838:     if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__6 */;
  arguments->slots[2] = frame->slots[10] /* temp__7 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
  frame->cont = frame->cont;
}
EXPORT void collect__c_code_generator(void) {
  var.sim2c__to_c = collect_node(var.sim2c__to_c);
  var._var_name = collect_node(var._var_name);
  string__9_2 = collect_node(string__9_2);
  func__9_1 = collect_node(func__9_1);
  var._var_entry = collect_node(var._var_entry);
  string__10_2 = collect_node(string__10_2);
  string__10_5 = collect_node(string__10_5);
  string__10_8 = collect_node(string__10_8);
  func__10_1 = collect_node(func__10_1);
  var._insert_delayed = collect_node(var._insert_delayed);
  func__11_1 = collect_node(func__11_1);
  var._delayed = collect_node(var._delayed);
  func__12_1 = collect_node(func__12_1);
  var.sim2c__begin_continuation = collect_node(var.sim2c__begin_continuation);
  string__13_2 = collect_node(string__13_2);
  string__13_3 = collect_node(string__13_3);
  string__13_7 = collect_node(string__13_7);
  string__13_8 = collect_node(string__13_8);
  string__13_11 = collect_node(string__13_11);
  string__13_12 = collect_node(string__13_12);
  string__13_17 = collect_node(string__13_17);
  string__13_18 = collect_node(string__13_18);
  func__13_16 = collect_node(func__13_16);
  string__13_21 = collect_node(string__13_21);
  func__13_20 = collect_node(func__13_20);
  func__13_1 = collect_node(func__13_1);
  var.sim2c__end_continuation = collect_node(var.sim2c__end_continuation);
  string__14_4 = collect_node(string__14_4);
  func__14_3 = collect_node(func__14_3);
  string__14_8 = collect_node(string__14_8);
  func__14_7 = collect_node(func__14_7);
  func__14_1 = collect_node(func__14_1);
  var.sim2c__next_continuation = collect_node(var.sim2c__next_continuation);
  func__15_1 = collect_node(func__15_1);
  var._count_arguments = collect_node(var._count_arguments);
  func__16_1 = collect_node(func__16_1);
  var._generate_c_arguments = collect_node(var._generate_c_arguments);
  string__17_6 = collect_node(string__17_6);
  string__17_7 = collect_node(string__17_7);
  string__17_11 = collect_node(string__17_11);
  string__17_12 = collect_node(string__17_12);
  string__17_20 = collect_node(string__17_20);
  string__17_21 = collect_node(string__17_21);
  string__17_26 = collect_node(string__17_26);
  string__17_27 = collect_node(string__17_27);
  string__17_33 = collect_node(string__17_33);
  func__17_32 = collect_node(func__17_32);
  string__17_35 = collect_node(string__17_35);
  string__17_36 = collect_node(string__17_36);
  string__17_37 = collect_node(string__17_37);
  func__17_1 = collect_node(func__17_1);
  var._get_func_and_myself = collect_node(var._get_func_and_myself);
  func__18_7 = collect_node(func__18_7);
  func__18_9 = collect_node(func__18_9);
  string__18_13 = collect_node(string__18_13);
  string__18_14 = collect_node(string__18_14);
  string__18_15 = collect_node(string__18_15);
  string__18_16 = collect_node(string__18_16);
  func__18_1 = collect_node(func__18_1);
  var.sim2c__assignment_to_c = collect_node(var.sim2c__assignment_to_c);
  string__19_2 = collect_node(string__19_2);
  string__19_10 = collect_node(string__19_10);
  string__19_11 = collect_node(string__19_11);
  string__19_12 = collect_node(string__19_12);
  string__19_16 = collect_node(string__19_16);
  string__19_17 = collect_node(string__19_17);
  string__19_23 = collect_node(string__19_23);
  string__19_24 = collect_node(string__19_24);
  string__19_25 = collect_node(string__19_25);
  string__19_30 = collect_node(string__19_30);
  string__19_31 = collect_node(string__19_31);
  string__19_32 = collect_node(string__19_32);
  string__19_39 = collect_node(string__19_39);
  string__19_40 = collect_node(string__19_40);
  string__19_41 = collect_node(string__19_41);
  string__19_44 = collect_node(string__19_44);
  string__19_45 = collect_node(string__19_45);
  string__19_46 = collect_node(string__19_46);
  string__19_50 = collect_node(string__19_50);
  string__19_55 = collect_node(string__19_55);
  string__19_56 = collect_node(string__19_56);
  string__19_57 = collect_node(string__19_57);
  string__19_60 = collect_node(string__19_60);
  string__19_61 = collect_node(string__19_61);
  func__19_1 = collect_node(func__19_1);
  var._assign_argument_or_result = collect_node(var._assign_argument_or_result);
  string__20_2 = collect_node(string__20_2);
  string__20_5 = collect_node(string__20_5);
  string__20_12 = collect_node(string__20_12);
  string__20_13 = collect_node(string__20_13);
  string__20_14 = collect_node(string__20_14);
  string__20_15 = collect_node(string__20_15);
  func__20_1 = collect_node(func__20_1);
  var._extract = collect_node(var._extract);
  string__21_31 = collect_node(string__21_31);
  string__21_32 = collect_node(string__21_32);
  string__21_33 = collect_node(string__21_33);
  string__21_37 = collect_node(string__21_37);
  string__21_38 = collect_node(string__21_38);
  string__21_39 = collect_node(string__21_39);
  string__21_42 = collect_node(string__21_42);
  string__21_43 = collect_node(string__21_43);
  string__21_44 = collect_node(string__21_44);
  string__21_47 = collect_node(string__21_47);
  string__21_52 = collect_node(string__21_52);
  func__21_51 = collect_node(func__21_51);
  string__21_57 = collect_node(string__21_57);
  string__21_68 = collect_node(string__21_68);
  string__21_69 = collect_node(string__21_69);
  string__21_76 = collect_node(string__21_76);
  string__21_77 = collect_node(string__21_77);
  string__21_85 = collect_node(string__21_85);
  string__21_86 = collect_node(string__21_86);
  string__21_87 = collect_node(string__21_87);
  string__21_92 = collect_node(string__21_92);
  string__21_101 = collect_node(string__21_101);
  string__21_104 = collect_node(string__21_104);
  func__21_103 = collect_node(func__21_103);
  string__21_106 = collect_node(string__21_106);
  string__21_107 = collect_node(string__21_107);
  string__21_111 = collect_node(string__21_111);
  string__21_112 = collect_node(string__21_112);
  string__21_115 = collect_node(string__21_115);
  string__21_116 = collect_node(string__21_116);
  string__21_127 = collect_node(string__21_127);
  string__21_130 = collect_node(string__21_130);
  func__21_129 = collect_node(func__21_129);
  string__21_134 = collect_node(string__21_134);
  string__21_135 = collect_node(string__21_135);
  string__21_136 = collect_node(string__21_136);
  string__21_137 = collect_node(string__21_137);
  string__21_140 = collect_node(string__21_140);
  string__21_141 = collect_node(string__21_141);
  func__21_155 = collect_node(func__21_155);
  string__21_159 = collect_node(string__21_159);
  string__21_163 = collect_node(string__21_163);
  string__21_164 = collect_node(string__21_164);
  string__21_165 = collect_node(string__21_165);
  string__21_168 = collect_node(string__21_168);
  string__21_169 = collect_node(string__21_169);
  string__21_182 = collect_node(string__21_182);
  func__21_181 = collect_node(func__21_181);
  string__21_186 = collect_node(string__21_186);
  string__21_187 = collect_node(string__21_187);
  string__21_190 = collect_node(string__21_190);
  func__21_1 = collect_node(func__21_1);
  var._write_as_remark = collect_node(var._write_as_remark);
  string__22_2 = collect_node(string__22_2);
  string__22_5 = collect_node(string__22_5);
  func__22_1 = collect_node(func__22_1);
  var._compute_column_no = collect_node(var._compute_column_no);
  func__23_1 = collect_node(func__23_1);
  var._compute_source_text_info = collect_node(var._compute_source_text_info);
  string__24_55 = collect_node(string__24_55);
  func__24_57 = collect_node(func__24_57);
  string__24_59 = collect_node(string__24_59);
  string__24_60 = collect_node(string__24_60);
  string__24_61 = collect_node(string__24_61);
  string__24_66 = collect_node(string__24_66);
  string__24_67 = collect_node(string__24_67);
  string__24_70 = collect_node(string__24_70);
  string__24_96 = collect_node(string__24_96);
  string__24_120 = collect_node(string__24_120);
  func__24_119 = collect_node(func__24_119);
  func__24_1 = collect_node(func__24_1);
  var.sim2c__write_source_as_remark = collect_node(var.sim2c__write_source_as_remark);
  func__25_1 = collect_node(func__25_1);
  var._EARLY = collect_node(var._EARLY);
  unique__26_1 = collect_node(unique__26_1);
  var._STANDARD = collect_node(var._STANDARD);
  unique__27_1 = collect_node(unique__27_1);
  var._UNKNOWN = collect_node(var._UNKNOWN);
  unique__28_1 = collect_node(unique__28_1);
  var._get_kind = collect_node(var._get_kind);
  func__29_15 = collect_node(func__29_15);
  func__29_16 = collect_node(func__29_16);
  func__29_1 = collect_node(func__29_1);
  string__30_2 = collect_node(string__30_2);
  string__30_4 = collect_node(string__30_4);
  func__30_1 = collect_node(func__30_1);
  string__31_2 = collect_node(string__31_2);
  func__31_16 = collect_node(func__31_16);
  func__31_7 = collect_node(func__31_7);
  string__31_24 = collect_node(string__31_24);
  string__31_25 = collect_node(string__31_25);
  string__31_30 = collect_node(string__31_30);
  func__31_29 = collect_node(func__31_29);
  string__31_32 = collect_node(string__31_32);
  func__31_31 = collect_node(func__31_31);
  func__31_18 = collect_node(func__31_18);
  string__31_44 = collect_node(string__31_44);
  string__31_45 = collect_node(string__31_45);
  string__31_50 = collect_node(string__31_50);
  func__31_112 = collect_node(func__31_112);
  string__31_138 = collect_node(string__31_138);
  string__31_139 = collect_node(string__31_139);
  string__31_143 = collect_node(string__31_143);
  string__31_150 = collect_node(string__31_150);
  func__31_149 = collect_node(func__31_149);
  string__31_157 = collect_node(string__31_157);
  func__31_156 = collect_node(func__31_156);
  string__31_159 = collect_node(string__31_159);
  string__31_160 = collect_node(string__31_160);
  string__31_161 = collect_node(string__31_161);
  string__31_164 = collect_node(string__31_164);
  string__31_167 = collect_node(string__31_167);
  string__31_168 = collect_node(string__31_168);
  string__31_169 = collect_node(string__31_169);
  string__31_173 = collect_node(string__31_173);
  string__31_174 = collect_node(string__31_174);
  string__31_180 = collect_node(string__31_180);
  func__31_179 = collect_node(func__31_179);
  string__31_182 = collect_node(string__31_182);
  string__31_183 = collect_node(string__31_183);
  func__31_172 = collect_node(func__31_172);
  string__31_186 = collect_node(string__31_186);
  string__31_188 = collect_node(string__31_188);
  string__31_194 = collect_node(string__31_194);
  string__31_195 = collect_node(string__31_195);
  string__31_198 = collect_node(string__31_198);
  string__31_199 = collect_node(string__31_199);
  string__31_202 = collect_node(string__31_202);
  func__31_201 = collect_node(func__31_201);
  string__31_204 = collect_node(string__31_204);
  string__31_210 = collect_node(string__31_210);
  string__31_211 = collect_node(string__31_211);
  string__31_212 = collect_node(string__31_212);
  string__31_213 = collect_node(string__31_213);
  string__31_223 = collect_node(string__31_223);
  string__31_224 = collect_node(string__31_224);
  string__31_239 = collect_node(string__31_239);
  string__31_240 = collect_node(string__31_240);
  string__31_241 = collect_node(string__31_241);
  string__31_244 = collect_node(string__31_244);
  string__31_265 = collect_node(string__31_265);
  string__31_266 = collect_node(string__31_266);
  string__31_267 = collect_node(string__31_267);
  string__31_268 = collect_node(string__31_268);
  string__31_279 = collect_node(string__31_279);
  string__31_280 = collect_node(string__31_280);
  string__31_281 = collect_node(string__31_281);
  string__31_282 = collect_node(string__31_282);
  string__31_288 = collect_node(string__31_288);
  string__31_289 = collect_node(string__31_289);
  string__31_290 = collect_node(string__31_290);
  string__31_295 = collect_node(string__31_295);
  string__31_300 = collect_node(string__31_300);
  string__31_301 = collect_node(string__31_301);
  string__31_310 = collect_node(string__31_310);
  string__31_311 = collect_node(string__31_311);
  string__31_312 = collect_node(string__31_312);
  func__31_317 = collect_node(func__31_317);
  string__31_333 = collect_node(string__31_333);
  string__31_334 = collect_node(string__31_334);
  string__31_340 = collect_node(string__31_340);
  string__31_356 = collect_node(string__31_356);
  string__31_360 = collect_node(string__31_360);
  string__31_361 = collect_node(string__31_361);
  string__31_365 = collect_node(string__31_365);
  string__31_366 = collect_node(string__31_366);
  string__31_367 = collect_node(string__31_367);
  string__31_370 = collect_node(string__31_370);
  func__31_369 = collect_node(func__31_369);
  string__31_372 = collect_node(string__31_372);
  func__31_371 = collect_node(func__31_371);
  string__31_378 = collect_node(string__31_378);
  string__31_379 = collect_node(string__31_379);
  string__31_382 = collect_node(string__31_382);
  string__31_384 = collect_node(string__31_384);
  string__31_385 = collect_node(string__31_385);
  string__31_390 = collect_node(string__31_390);
  string__31_391 = collect_node(string__31_391);
  string__31_398 = collect_node(string__31_398);
  string__31_399 = collect_node(string__31_399);
  string__31_402 = collect_node(string__31_402);
  string__31_404 = collect_node(string__31_404);
  string__31_405 = collect_node(string__31_405);
  string__31_411 = collect_node(string__31_411);
  string__31_412 = collect_node(string__31_412);
  string__31_416 = collect_node(string__31_416);
  string__31_419 = collect_node(string__31_419);
  string__31_421 = collect_node(string__31_421);
  string__31_423 = collect_node(string__31_423);
  string__31_424 = collect_node(string__31_424);
  string__31_428 = collect_node(string__31_428);
  string__31_437 = collect_node(string__31_437);
  string__31_438 = collect_node(string__31_438);
  string__31_444 = collect_node(string__31_444);
  string__31_445 = collect_node(string__31_445);
  string__31_449 = collect_node(string__31_449);
  string__31_452 = collect_node(string__31_452);
  string__31_454 = collect_node(string__31_454);
  string__31_460 = collect_node(string__31_460);
  string__31_466 = collect_node(string__31_466);
  string__31_467 = collect_node(string__31_467);
  string__31_470 = collect_node(string__31_470);
  string__31_471 = collect_node(string__31_471);
  string__31_472 = collect_node(string__31_472);
  string__31_473 = collect_node(string__31_473);
  string__31_476 = collect_node(string__31_476);
  string__31_477 = collect_node(string__31_477);
  string__31_478 = collect_node(string__31_478);
  string__31_481 = collect_node(string__31_481);
  string__31_484 = collect_node(string__31_484);
  string__31_485 = collect_node(string__31_485);
  string__31_486 = collect_node(string__31_486);
  func__31_1 = collect_node(func__31_1);
  string__32_2 = collect_node(string__32_2);
  string__32_12 = collect_node(string__32_12);
  string__32_13 = collect_node(string__32_13);
  func__32_1 = collect_node(func__32_1);
  string__33_2 = collect_node(string__33_2);
  func__33_1 = collect_node(func__33_1);
  string__34_2 = collect_node(string__34_2);
  func__34_1 = collect_node(func__34_1);
  string__35_2 = collect_node(string__35_2);
  string__35_5 = collect_node(string__35_5);
  func__35_1 = collect_node(func__35_1);
  string__36_2 = collect_node(string__36_2);
  string__36_6 = collect_node(string__36_6);
  func__36_1 = collect_node(func__36_1);
  var._to_c_string = collect_node(var._to_c_string);
  string__37_19 = collect_node(string__37_19);
  string__37_21 = collect_node(string__37_21);
  func__37_1 = collect_node(func__37_1);
  var._register_string = collect_node(var._register_string);
  string__38_6 = collect_node(string__38_6);
  string__38_7 = collect_node(string__38_7);
  string__38_9 = collect_node(string__38_9);
  string__38_10 = collect_node(string__38_10);
  string__38_16 = collect_node(string__38_16);
  string__38_17 = collect_node(string__38_17);
  string__38_18 = collect_node(string__38_18);
  string__38_19 = collect_node(string__38_19);
  string__38_22 = collect_node(string__38_22);
  string__38_23 = collect_node(string__38_23);
  string__38_24 = collect_node(string__38_24);
  string__38_58 = collect_node(string__38_58);
  func__38_27 = collect_node(func__38_27);
  string__38_60 = collect_node(string__38_60);
  func__38_59 = collect_node(func__38_59);
  string__38_62 = collect_node(string__38_62);
  string__38_64 = collect_node(string__38_64);
  string__38_65 = collect_node(string__38_65);
  string__38_66 = collect_node(string__38_66);
  string__38_67 = collect_node(string__38_67);
  string__38_70 = collect_node(string__38_70);
  string__38_71 = collect_node(string__38_71);
  string__38_72 = collect_node(string__38_72);
  string__38_76 = collect_node(string__38_76);
  func__38_75 = collect_node(func__38_75);
  func__38_1 = collect_node(func__38_1);
  string__39_2 = collect_node(string__39_2);
  func__39_1 = collect_node(func__39_1);
  string__40_2 = collect_node(string__40_2);
  string__40_5 = collect_node(string__40_5);
  string__40_6 = collect_node(string__40_6);
  string__40_14 = collect_node(string__40_14);
  string__40_15 = collect_node(string__40_15);
  string__40_18 = collect_node(string__40_18);
  string__40_19 = collect_node(string__40_19);
  string__40_20 = collect_node(string__40_20);
  string__40_23 = collect_node(string__40_23);
  string__40_24 = collect_node(string__40_24);
  string__40_25 = collect_node(string__40_25);
  func__40_1 = collect_node(func__40_1);
  string__41_2 = collect_node(string__41_2);
  string__41_10 = collect_node(string__41_10);
  string__41_15 = collect_node(string__41_15);
  string__41_16 = collect_node(string__41_16);
  string__41_17 = collect_node(string__41_17);
  string__41_28 = collect_node(string__41_28);
  string__41_29 = collect_node(string__41_29);
  string__41_30 = collect_node(string__41_30);
  string__41_34 = collect_node(string__41_34);
  string__41_35 = collect_node(string__41_35);
  string__41_36 = collect_node(string__41_36);
  string__41_43 = collect_node(string__41_43);
  string__41_44 = collect_node(string__41_44);
  string__41_62 = collect_node(string__41_62);
  string__41_63 = collect_node(string__41_63);
  func__41_1 = collect_node(func__41_1);
  string__42_2 = collect_node(string__42_2);
  string__42_13 = collect_node(string__42_13);
  func__42_18 = collect_node(func__42_18);
  string__42_21 = collect_node(string__42_21);
  string__42_22 = collect_node(string__42_22);
  string__42_23 = collect_node(string__42_23);
  string__42_28 = collect_node(string__42_28);
  string__42_29 = collect_node(string__42_29);
  string__42_30 = collect_node(string__42_30);
  string__42_36 = collect_node(string__42_36);
  string__42_37 = collect_node(string__42_37);
  string__42_38 = collect_node(string__42_38);
  string__42_41 = collect_node(string__42_41);
  string__42_42 = collect_node(string__42_42);
  string__42_45 = collect_node(string__42_45);
  string__42_46 = collect_node(string__42_46);
  string__42_47 = collect_node(string__42_47);
  string__42_48 = collect_node(string__42_48);
  string__42_51 = collect_node(string__42_51);
  func__42_1 = collect_node(func__42_1);
  var._extract_destination = collect_node(var._extract_destination);
  func__43_1 = collect_node(func__43_1);
  var.sim2c__is_single_assign = collect_node(var.sim2c__is_single_assign);
  func__44_18 = collect_node(func__44_18);
  func__44_1 = collect_node(func__44_1);
  var.sim2c__might_be_constant = collect_node(var.sim2c__might_be_constant);
  func__45_18 = collect_node(func__45_18);
  func__45_1 = collect_node(func__45_1);
  var._assign = collect_node(var._assign);
  string__46_3 = collect_node(string__46_3);
  string__46_4 = collect_node(string__46_4);
  string__46_8 = collect_node(string__46_8);
  string__46_9 = collect_node(string__46_9);
  string__46_10 = collect_node(string__46_10);
  string__46_13 = collect_node(string__46_13);
  string__46_16 = collect_node(string__46_16);
  string__46_17 = collect_node(string__46_17);
  string__46_18 = collect_node(string__46_18);
  string__46_21 = collect_node(string__46_21);
  string__46_22 = collect_node(string__46_22);
  string__46_23 = collect_node(string__46_23);
  func__46_1 = collect_node(func__46_1);
  var.sim2c__define_variable = collect_node(var.sim2c__define_variable);
  string__47_7 = collect_node(string__47_7);
  string__47_8 = collect_node(string__47_8);
  string__47_9 = collect_node(string__47_9);
  string__47_24 = collect_node(string__47_24);
  string__47_25 = collect_node(string__47_25);
  string__47_28 = collect_node(string__47_28);
  string__47_29 = collect_node(string__47_29);
  string__47_30 = collect_node(string__47_30);
  string__47_31 = collect_node(string__47_31);
  string__47_32 = collect_node(string__47_32);
  string__47_36 = collect_node(string__47_36);
  string__47_37 = collect_node(string__47_37);
  string__47_38 = collect_node(string__47_38);
  string__47_39 = collect_node(string__47_39);
  string__47_40 = collect_node(string__47_40);
  string__47_43 = collect_node(string__47_43);
  string__47_44 = collect_node(string__47_44);
  string__47_47 = collect_node(string__47_47);
  string__47_48 = collect_node(string__47_48);
  string__47_49 = collect_node(string__47_49);
  string__47_50 = collect_node(string__47_50);
  string__47_51 = collect_node(string__47_51);
  string__47_52 = collect_node(string__47_52);
  string__47_53 = collect_node(string__47_53);
  string__47_54 = collect_node(string__47_54);
  string__47_55 = collect_node(string__47_55);
  string__47_58 = collect_node(string__47_58);
  string__47_59 = collect_node(string__47_59);
  string__47_60 = collect_node(string__47_60);
  string__47_61 = collect_node(string__47_61);
  string__47_62 = collect_node(string__47_62);
  string__47_65 = collect_node(string__47_65);
  string__47_66 = collect_node(string__47_66);
  string__47_67 = collect_node(string__47_67);
  string__47_68 = collect_node(string__47_68);
  string__47_69 = collect_node(string__47_69);
  string__47_70 = collect_node(string__47_70);
  string__47_73 = collect_node(string__47_73);
  string__47_74 = collect_node(string__47_74);
  string__47_75 = collect_node(string__47_75);
  string__47_76 = collect_node(string__47_76);
  string__47_77 = collect_node(string__47_77);
  string__47_78 = collect_node(string__47_78);
  string__47_81 = collect_node(string__47_81);
  string__47_82 = collect_node(string__47_82);
  string__47_83 = collect_node(string__47_83);
  string__47_84 = collect_node(string__47_84);
  string__47_85 = collect_node(string__47_85);
  string__47_86 = collect_node(string__47_86);
  string__47_87 = collect_node(string__47_87);
  string__47_88 = collect_node(string__47_88);
  string__47_91 = collect_node(string__47_91);
  string__47_92 = collect_node(string__47_92);
  string__47_93 = collect_node(string__47_93);
  string__47_94 = collect_node(string__47_94);
  string__47_95 = collect_node(string__47_95);
  string__47_96 = collect_node(string__47_96);
  string__47_97 = collect_node(string__47_97);
  string__47_98 = collect_node(string__47_98);
  string__47_102 = collect_node(string__47_102);
  string__47_103 = collect_node(string__47_103);
  string__47_107 = collect_node(string__47_107);
  string__47_108 = collect_node(string__47_108);
  string__47_114 = collect_node(string__47_114);
  string__47_115 = collect_node(string__47_115);
  string__47_118 = collect_node(string__47_118);
  string__47_119 = collect_node(string__47_119);
  string__47_123 = collect_node(string__47_123);
  string__47_124 = collect_node(string__47_124);
  string__47_127 = collect_node(string__47_127);
  string__47_128 = collect_node(string__47_128);
  string__47_129 = collect_node(string__47_129);
  string__47_130 = collect_node(string__47_130);
  string__47_131 = collect_node(string__47_131);
  string__47_132 = collect_node(string__47_132);
  string__47_135 = collect_node(string__47_135);
  string__47_136 = collect_node(string__47_136);
  string__47_141 = collect_node(string__47_141);
  string__47_142 = collect_node(string__47_142);
  string__47_145 = collect_node(string__47_145);
  string__47_146 = collect_node(string__47_146);
  string__47_147 = collect_node(string__47_147);
  string__47_148 = collect_node(string__47_148);
  string__47_149 = collect_node(string__47_149);
  string__47_150 = collect_node(string__47_150);
  string__47_151 = collect_node(string__47_151);
  string__47_152 = collect_node(string__47_152);
  string__47_155 = collect_node(string__47_155);
  string__47_156 = collect_node(string__47_156);
  string__47_157 = collect_node(string__47_157);
  string__47_168 = collect_node(string__47_168);
  string__47_169 = collect_node(string__47_169);
  string__47_170 = collect_node(string__47_170);
  string__47_175 = collect_node(string__47_175);
  string__47_176 = collect_node(string__47_176);
  string__47_182 = collect_node(string__47_182);
  string__47_183 = collect_node(string__47_183);
  string__47_184 = collect_node(string__47_184);
  string__47_188 = collect_node(string__47_188);
  string__47_189 = collect_node(string__47_189);
  string__47_190 = collect_node(string__47_190);
  func__47_1 = collect_node(func__47_1);
  var._namespace_argument = collect_node(var._namespace_argument);
  string__48_4 = collect_node(string__48_4);
  string__48_5 = collect_node(string__48_5);
  string__48_8 = collect_node(string__48_8);
  func__48_7 = collect_node(func__48_7);
  func__48_1 = collect_node(func__48_1);
  var.sim2c__define_attribute = collect_node(var.sim2c__define_attribute);
  string__49_9 = collect_node(string__49_9);
  string__49_10 = collect_node(string__49_10);
  string__49_12 = collect_node(string__49_12);
  string__49_13 = collect_node(string__49_13);
  string__49_23 = collect_node(string__49_23);
  string__49_24 = collect_node(string__49_24);
  string__49_25 = collect_node(string__49_25);
  string__49_26 = collect_node(string__49_26);
  string__49_27 = collect_node(string__49_27);
  string__49_31 = collect_node(string__49_31);
  string__49_32 = collect_node(string__49_32);
  string__49_33 = collect_node(string__49_33);
  string__49_34 = collect_node(string__49_34);
  func__49_1 = collect_node(func__49_1);
  var.sim2c__define_method = collect_node(var.sim2c__define_method);
  string__50_9 = collect_node(string__50_9);
  string__50_10 = collect_node(string__50_10);
  string__50_12 = collect_node(string__50_12);
  string__50_13 = collect_node(string__50_13);
  string__50_23 = collect_node(string__50_23);
  string__50_24 = collect_node(string__50_24);
  string__50_25 = collect_node(string__50_25);
  string__50_26 = collect_node(string__50_26);
  string__50_27 = collect_node(string__50_27);
  string__50_31 = collect_node(string__50_31);
  string__50_32 = collect_node(string__50_32);
  string__50_33 = collect_node(string__50_33);
  string__50_34 = collect_node(string__50_34);
  func__50_1 = collect_node(func__50_1);
  var.sim2c__define_type_function = collect_node(var.sim2c__define_type_function);
  string__51_11 = collect_node(string__51_11);
  string__51_12 = collect_node(string__51_12);
  string__51_13 = collect_node(string__51_13);
  string__51_14 = collect_node(string__51_14);
  string__51_15 = collect_node(string__51_15);
  string__51_19 = collect_node(string__51_19);
  string__51_20 = collect_node(string__51_20);
  string__51_21 = collect_node(string__51_21);
  func__51_1 = collect_node(func__51_1);
  var.sim2c__define_polymorphic_function = collect_node(var.sim2c__define_polymorphic_function);
  string__52_4 = collect_node(string__52_4);
  func__52_3 = collect_node(func__52_3);
  func__52_5 = collect_node(func__52_5);
  string__52_9 = collect_node(string__52_9);
  string__52_10 = collect_node(string__52_10);
  string__52_13 = collect_node(string__52_13);
  string__52_14 = collect_node(string__52_14);
  string__52_18 = collect_node(string__52_18);
  string__52_19 = collect_node(string__52_19);
  string__52_25 = collect_node(string__52_25);
  func__52_27 = collect_node(func__52_27);
  string__52_29 = collect_node(string__52_29);
  string__52_30 = collect_node(string__52_30);
  string__52_35 = collect_node(string__52_35);
  string__52_36 = collect_node(string__52_36);
  string__52_37 = collect_node(string__52_37);
  string__52_42 = collect_node(string__52_42);
  string__52_43 = collect_node(string__52_43);
  string__52_44 = collect_node(string__52_44);
  string__52_49 = collect_node(string__52_49);
  string__52_50 = collect_node(string__52_50);
  string__52_51 = collect_node(string__52_51);
  string__52_56 = collect_node(string__52_56);
  string__52_57 = collect_node(string__52_57);
  string__52_58 = collect_node(string__52_58);
  string__52_59 = collect_node(string__52_59);
  string__52_60 = collect_node(string__52_60);
  string__52_66 = collect_node(string__52_66);
  string__52_67 = collect_node(string__52_67);
  string__52_68 = collect_node(string__52_68);
  string__52_69 = collect_node(string__52_69);
  string__52_70 = collect_node(string__52_70);
  string__52_71 = collect_node(string__52_71);
  string__52_76 = collect_node(string__52_76);
  string__52_77 = collect_node(string__52_77);
  string__52_78 = collect_node(string__52_78);
  string__52_79 = collect_node(string__52_79);
  string__52_80 = collect_node(string__52_80);
  string__52_81 = collect_node(string__52_81);
  string__52_82 = collect_node(string__52_82);
  string__52_86 = collect_node(string__52_86);
  string__52_87 = collect_node(string__52_87);
  string__52_88 = collect_node(string__52_88);
  string__52_89 = collect_node(string__52_89);
  string__52_90 = collect_node(string__52_90);
  func__52_1 = collect_node(func__52_1);
  var.sim2c__define_c_code = collect_node(var.sim2c__define_c_code);
  string__53_2 = collect_node(string__53_2);
  string__53_10 = collect_node(string__53_10);
  string__53_13 = collect_node(string__53_13);
  string__53_16 = collect_node(string__53_16);
  string__53_17 = collect_node(string__53_17);
  string__53_20 = collect_node(string__53_20);
  string__53_21 = collect_node(string__53_21);
  string__53_25 = collect_node(string__53_25);
  string__53_26 = collect_node(string__53_26);
  string__53_31 = collect_node(string__53_31);
  string__53_32 = collect_node(string__53_32);
  string__53_33 = collect_node(string__53_33);
  string__53_38 = collect_node(string__53_38);
  string__53_39 = collect_node(string__53_39);
  string__53_40 = collect_node(string__53_40);
  string__53_41 = collect_node(string__53_41);
  string__53_45 = collect_node(string__53_45);
  string__53_46 = collect_node(string__53_46);
  string__53_47 = collect_node(string__53_47);
  string__53_48 = collect_node(string__53_48);
  string__53_54 = collect_node(string__53_54);
  string__53_55 = collect_node(string__53_55);
  string__53_56 = collect_node(string__53_56);
  string__53_61 = collect_node(string__53_61);
  func__53_62 = collect_node(func__53_62);
  string__53_63 = collect_node(string__53_63);
  func__53_64 = collect_node(func__53_64);
  string__53_65 = collect_node(string__53_65);
  string__53_67 = collect_node(string__53_67);
  func__53_66 = collect_node(func__53_66);
  string__53_69 = collect_node(string__53_69);
  func__53_68 = collect_node(func__53_68);
  func__53_75 = collect_node(func__53_75);
  func__53_80 = collect_node(func__53_80);
  func__53_86 = collect_node(func__53_86);
  func__53_93 = collect_node(func__53_93);
  string__53_97 = collect_node(string__53_97);
  string__53_98 = collect_node(string__53_98);
  string__53_99 = collect_node(string__53_99);
  string__53_100 = collect_node(string__53_100);
  string__53_101 = collect_node(string__53_101);
  string__53_105 = collect_node(string__53_105);
  string__53_106 = collect_node(string__53_106);
  string__53_107 = collect_node(string__53_107);
  string__53_111 = collect_node(string__53_111);
  string__53_115 = collect_node(string__53_115);
  string__53_116 = collect_node(string__53_116);
  string__53_117 = collect_node(string__53_117);
  string__53_118 = collect_node(string__53_118);
  string__53_119 = collect_node(string__53_119);
  string__53_123 = collect_node(string__53_123);
  string__53_136 = collect_node(string__53_136);
  func__53_147 = collect_node(func__53_147);
  func__53_146 = collect_node(func__53_146);
  string__53_155 = collect_node(string__53_155);
  string__53_156 = collect_node(string__53_156);
  string__53_157 = collect_node(string__53_157);
  string__53_158 = collect_node(string__53_158);
  string__53_161 = collect_node(string__53_161);
  string__53_162 = collect_node(string__53_162);
  string__53_163 = collect_node(string__53_163);
  func__53_122 = collect_node(func__53_122);
  string__53_166 = collect_node(string__53_166);
  string__53_172 = collect_node(string__53_172);
  string__53_173 = collect_node(string__53_173);
  string__53_188 = collect_node(string__53_188);
  string__53_189 = collect_node(string__53_189);
  string__53_190 = collect_node(string__53_190);
  string__53_191 = collect_node(string__53_191);
  string__53_192 = collect_node(string__53_192);
  string__53_197 = collect_node(string__53_197);
  string__53_216 = collect_node(string__53_216);
  string__53_217 = collect_node(string__53_217);
  string__53_218 = collect_node(string__53_218);
  string__53_219 = collect_node(string__53_219);
  string__53_223 = collect_node(string__53_223);
  string__53_229 = collect_node(string__53_229);
  string__53_230 = collect_node(string__53_230);
  string__53_231 = collect_node(string__53_231);
  string__53_232 = collect_node(string__53_232);
  string__53_237 = collect_node(string__53_237);
  func__53_239 = collect_node(func__53_239);
  string__53_244 = collect_node(string__53_244);
  string__53_245 = collect_node(string__53_245);
  string__53_248 = collect_node(string__53_248);
  string__53_251 = collect_node(string__53_251);
  string__53_254 = collect_node(string__53_254);
  string__53_256 = collect_node(string__53_256);
  string__53_259 = collect_node(string__53_259);
  string__53_262 = collect_node(string__53_262);
  string__53_263 = collect_node(string__53_263);
  string__53_264 = collect_node(string__53_264);
  string__53_269 = collect_node(string__53_269);
  string__53_270 = collect_node(string__53_270);
  string__53_275 = collect_node(string__53_275);
  string__53_276 = collect_node(string__53_276);
  string__53_277 = collect_node(string__53_277);
  string__53_278 = collect_node(string__53_278);
  string__53_281 = collect_node(string__53_281);
  string__53_285 = collect_node(string__53_285);
  string__53_286 = collect_node(string__53_286);
  string__53_287 = collect_node(string__53_287);
  string__53_290 = collect_node(string__53_290);
  string__53_293 = collect_node(string__53_293);
  string__53_294 = collect_node(string__53_294);
  string__53_295 = collect_node(string__53_295);
  string__53_296 = collect_node(string__53_296);
  string__53_297 = collect_node(string__53_297);
  string__53_298 = collect_node(string__53_298);
  string__53_299 = collect_node(string__53_299);
  string__53_300 = collect_node(string__53_300);
  string__53_303 = collect_node(string__53_303);
  string__53_304 = collect_node(string__53_304);
  string__53_305 = collect_node(string__53_305);
  string__53_306 = collect_node(string__53_306);
  string__53_307 = collect_node(string__53_307);
  string__53_308 = collect_node(string__53_308);
  string__53_309 = collect_node(string__53_309);
  string__53_316 = collect_node(string__53_316);
  string__53_317 = collect_node(string__53_317);
  string__53_318 = collect_node(string__53_318);
  string__53_319 = collect_node(string__53_319);
  string__53_320 = collect_node(string__53_320);
  string__53_329 = collect_node(string__53_329);
  string__53_332 = collect_node(string__53_332);
  string__53_341 = collect_node(string__53_341);
  string__53_344 = collect_node(string__53_344);
  func__53_343 = collect_node(func__53_343);
  func__53_345 = collect_node(func__53_345);
  string__53_347 = collect_node(string__53_347);
  string__53_348 = collect_node(string__53_348);
  string__53_350 = collect_node(string__53_350);
  string__53_355 = collect_node(string__53_355);
  string__53_358 = collect_node(string__53_358);
  string__53_359 = collect_node(string__53_359);
  string__53_360 = collect_node(string__53_360);
  string__53_363 = collect_node(string__53_363);
  string__53_364 = collect_node(string__53_364);
  string__53_369 = collect_node(string__53_369);
  string__53_370 = collect_node(string__53_370);
  string__53_381 = collect_node(string__53_381);
  string__53_382 = collect_node(string__53_382);
  string__53_383 = collect_node(string__53_383);
  string__53_390 = collect_node(string__53_390);
  string__53_391 = collect_node(string__53_391);
  string__53_393 = collect_node(string__53_393);
  string__53_394 = collect_node(string__53_394);
  string__53_395 = collect_node(string__53_395);
  string__53_396 = collect_node(string__53_396);
  string__53_397 = collect_node(string__53_397);
  func__53_1 = collect_node(func__53_1);
  var._assign_attributes = collect_node(var._assign_attributes);
  string__54_3 = collect_node(string__54_3);
  string__54_4 = collect_node(string__54_4);
  func__54_15 = collect_node(func__54_15);
  string__54_17 = collect_node(string__54_17);
  func__54_16 = collect_node(func__54_16);
  string__54_20 = collect_node(string__54_20);
  string__54_21 = collect_node(string__54_21);
  string__54_22 = collect_node(string__54_22);
  string__54_23 = collect_node(string__54_23);
  string__54_26 = collect_node(string__54_26);
  string__54_27 = collect_node(string__54_27);
  func__54_7 = collect_node(func__54_7);
  string__54_30 = collect_node(string__54_30);
  string__54_32 = collect_node(string__54_32);
  string__54_33 = collect_node(string__54_33);
  func__54_1 = collect_node(func__54_1);
  var.sim2c__generate_statement = collect_node(var.sim2c__generate_statement);
  string__55_6 = collect_node(string__55_6);
  func__55_5 = collect_node(func__55_5);
  string__55_10 = collect_node(string__55_10);
  func__55_9 = collect_node(func__55_9);
  string__55_12 = collect_node(string__55_12);
  func__55_11 = collect_node(func__55_11);
  string__55_43 = collect_node(string__55_43);
  string__55_44 = collect_node(string__55_44);
  string__55_50 = collect_node(string__55_50);
  string__55_54 = collect_node(string__55_54);
  string__55_55 = collect_node(string__55_55);
  string__55_58 = collect_node(string__55_58);
  func__55_57 = collect_node(func__55_57);
  string__55_61 = collect_node(string__55_61);
  string__55_62 = collect_node(string__55_62);
  string__55_66 = collect_node(string__55_66);
  func__55_65 = collect_node(func__55_65);
  string__55_68 = collect_node(string__55_68);
  string__55_70 = collect_node(string__55_70);
  string__55_71 = collect_node(string__55_71);
  string__55_74 = collect_node(string__55_74);
  string__55_85 = collect_node(string__55_85);
  string__55_86 = collect_node(string__55_86);
  string__55_87 = collect_node(string__55_87);
  func__55_1 = collect_node(func__55_1);
  character__92 = collect_node(character__92);
  character__47 = collect_node(character__47);
  character__160 = collect_node(character__160);
  character__10 = collect_node(character__10);
  number__0 = collect_node(number__0);
  number__3 = collect_node(number__3);
  character__126 = collect_node(character__126);
  character__95 = collect_node(character__95);
  character__40 = collect_node(character__40);
  character__34 = collect_node(character__34);
  character__255 = collect_node(character__255);
  number__5 = collect_node(number__5);
  character__39 = collect_node(character__39);
  character__32 = collect_node(character__32);
  number__9 = collect_node(number__9);
  character__125 = collect_node(character__125);
  character__41 = collect_node(character__41);
  character__59 = collect_node(character__59);
  number__1 = collect_node(number__1);
  number__2 = collect_node(number__2);
  character__42 = collect_node(character__42);
}

static int already_run_phase_1 = false;

EXPORT void phase_1__c_code_generator(void) {
  if (already_run_phase_1) return;
  already_run_phase_1 = true;
  register_module_info(&module_info);
  define_polymorphic_function("sim2c", "to_c", get__sim2c__to_c, &poly_idx__sim2c__to_c, &var.sim2c__to_c);
}

static int already_run_phase_2 = false;

EXPORT void phase_2__c_code_generator(void) {
  if (already_run_phase_2) return;
  already_run_phase_2 = true;
  set_module("c_code_generator");
  set_used_namespaces(used_namespaces);
  character__92 = create_future();
  character__47 = create_future();
  character__160 = create_future();
  character__10 = create_future();
  number__0 = create_future();
  number__3 = create_future();
  character__126 = create_future();
  character__95 = create_future();
  character__40 = create_future();
  character__34 = create_future();
  character__255 = create_future();
  number__5 = create_future();
  character__39 = create_future();
  character__32 = create_future();
  number__9 = create_future();
  character__125 = create_future();
  character__41 = create_future();
  character__59 = create_future();
  number__1 = create_future();
  number__2 = create_future();
  character__42 = create_future();
  define_single_assign_dynamic("sim2c", "suffix", get__sim2c__suffix, define__sim2c__suffix, &dyna_idx__sim2c__suffix);
  define__sim2c__suffix(create_future());
  register_dynamic(&dyna_idx__level);
  register_dynamic(&dyna_idx__current_locals);
  define__current_locals(create_future());
  register_dynamic(&dyna_idx__current_frame);
  define__current_frame(create_future());
  register_dynamic(&dyna_idx__is_a_shared_local);
  define__is_a_shared_local(create_future());
  register_dynamic(&dyna_idx__temporary_offset);
  define__temporary_offset(create_future());
  define_multi_assign_dynamic("sim2c", "delayed_code", get__sim2c__delayed_code, set__sim2c__delayed_code, define__sim2c__delayed_code, &dyna_idx__sim2c__delayed_code);
  define__sim2c__delayed_code(undefined);
  string__9_2 = from_latin_1_string("__", 2);
  func__9_1 = create_future();
  string__10_2 = from_latin_1_string("__", 2);
  string__10_5 = from_latin_1_string("var.", 4);
  string__10_8 = from_latin_1_string("var._", 5);
  func__10_1 = create_future();
  func__11_1 = create_future();
  func__12_1 = create_future();
  string__13_2 = from_latin_1_string("static void ", 12);
  string__13_3 = from_latin_1_string("(void);\012", 8);
  string__13_7 = from_latin_1_string("static void ", 12);
  string__13_8 = from_latin_1_string("(void) {\012", 9);
  string__13_11 = from_latin_1_string("  {", 3);
  string__13_12 = from_latin_1_string(", ", 2);
  string__13_17 = from_latin_1_string("&", 1);
  string__13_18 = from_latin_1_string(", ", 2);
  func__13_16 = create_future();
  string__13_21 = from_latin_1_string("NULL, ", 6);
  func__13_20 = create_future();
  func__13_1 = create_future();
  define_single_assign_static("sim2c", "begin_continuation", get__sim2c__begin_continuation, &var.sim2c__begin_continuation);
  string__14_4 = from_latin_1_string("},\012", 3);
  func__14_3 = create_future();
  string__14_8 = from_latin_1_string("},\012", 3);
  func__14_7 = create_future();
  func__14_1 = create_future();
  define_single_assign_static("sim2c", "end_continuation", get__sim2c__end_continuation, &var.sim2c__end_continuation);
  func__15_1 = create_future();
  define_single_assign_static("sim2c", "next_continuation", get__sim2c__next_continuation, &var.sim2c__next_continuation);
  func__16_1 = create_future();
  string__17_6 = from_latin_1_string("  argument_count += ", 20);
  string__17_7 = from_latin_1_string(";\012", 2);
  string__17_11 = from_latin_1_string("  argument_count = ", 19);
  string__17_12 = from_latin_1_string(";\012  arguments = node_p;\012", 24);
  string__17_20 = from_latin_1_string("  optional_item(", 16);
  string__17_21 = from_latin_1_string(");\012", 3);
  string__17_26 = from_latin_1_string("  unfold(", 9);
  string__17_27 = from_latin_1_string(");\012", 3);
  string__17_33 = from_latin_1_string("argument_count++", 16);
  func__17_32 = create_future();
  string__17_35 = from_latin_1_string("  arguments->slots[", 19);
  string__17_36 = from_latin_1_string("] = ", 4);
  string__17_37 = from_latin_1_string(";\012", 2);
  func__17_1 = create_future();
  func__18_7 = create_future();
  func__18_9 = create_future();
  string__18_13 = from_latin_1_string("  myself = ", 11);
  string__18_14 = from_latin_1_string(";\012  func = myself->type;", 24);
  string__18_15 = from_latin_1_string("\012  frame->cont = ", 17);
  string__18_16 = from_latin_1_string(";\012", 2);
  func__18_1 = create_future();
  string__19_2 = from_latin_1_string("  ", 2);
  string__19_10 = from_latin_1_string("initialize_future(", 18);
  string__19_11 = from_latin_1_string(", ", 2);
  string__19_12 = from_latin_1_string(");\012", 3);
  string__19_16 = from_latin_1_string(" = ", 3);
  string__19_17 = from_latin_1_string(";\012", 2);
  string__19_23 = from_latin_1_string("initialize_future(", 18);
  string__19_24 = from_latin_1_string(", ", 2);
  string__19_25 = from_latin_1_string(");\012", 3);
  string__19_30 = from_latin_1_string("define__", 8);
  string__19_31 = from_latin_1_string("(", 1);
  string__19_32 = from_latin_1_string(");\012", 3);
  string__19_39 = from_latin_1_string("set__", 5);
  string__19_40 = from_latin_1_string("(", 1);
  string__19_41 = from_latin_1_string(");\012", 3);
  string__19_44 = from_latin_1_string("define__", 8);
  string__19_45 = from_latin_1_string("(", 1);
  string__19_46 = from_latin_1_string(");\012", 3);
  string__19_50 = from_latin_1_string("get_", 4);
  string__19_55 = from_latin_1_string("set_", 4);
  string__19_56 = from_latin_1_string("(", 1);
  string__19_57 = from_latin_1_string(");\012", 3);
  string__19_60 = from_latin_1_string(" = ", 3);
  string__19_61 = from_latin_1_string(";\012", 2);
  func__19_1 = create_future();
  define_single_assign_static("sim2c", "assignment_to_c", get__sim2c__assignment_to_c, &var.sim2c__assignment_to_c);
  string__20_2 = from_latin_1_string("  ", 2);
  string__20_5 = from_latin_1_string("arguments", 9);
  string__20_12 = from_latin_1_string("frame->slots[", 13);
  string__20_13 = from_latin_1_string("] /* ", 5);
  string__20_14 = from_latin_1_string(" */ = create_cell_with_contents(", 32);
  string__20_15 = from_latin_1_string(");\012", 3);
  func__20_1 = create_future();
  string__21_31 = from_latin_1_string("  if (argument_count < ", 23);
  string__21_32 = from_latin_1_string(") {\012    too_few_", 16);
  string__21_33 = from_latin_1_string("_error();\012    return;\012  }\012", 26);
  string__21_37 = from_latin_1_string("  if (argument_count > ", 23);
  string__21_38 = from_latin_1_string(") {\012    too_many_", 17);
  string__21_39 = from_latin_1_string("_error();\012    return;\012  }\012", 26);
  string__21_42 = from_latin_1_string("  if (argument_count != ", 24);
  string__21_43 = from_latin_1_string(") {\012    invalid_", 16);
  string__21_44 = from_latin_1_string("_error();\012    return;\012  }\012", 26);
  string__21_47 = from_latin_1_string("results", 7);
  string__21_52 = from_latin_1_string("  allocate_arguments();", 23);
  func__21_51 = create_future();
  string__21_57 = from_latin_1_string("results", 7);
  string__21_68 = from_latin_1_string("arguments->slots[", 17);
  string__21_69 = from_latin_1_string("]", 1);
  string__21_76 = from_latin_1_string("arguments->slots[argument_count", 31);
  string__21_77 = from_latin_1_string("]", 1);
  string__21_85 = from_latin_1_string("from_arguments(", 15);
  string__21_86 = from_latin_1_string(", argument_count-", 17);
  string__21_87 = from_latin_1_string(")", 1);
  string__21_92 = from_latin_1_string("  switch(argument_count) {\012", 27);
  string__21_101 = from_latin_1_string("case ", 5);
  string__21_104 = from_latin_1_string("default", 7);
  func__21_103 = create_future();
  string__21_106 = from_latin_1_string("    ", 4);
  string__21_107 = from_latin_1_string(": ", 2);
  string__21_111 = from_latin_1_string("arguments->slots[", 17);
  string__21_112 = from_latin_1_string("]", 1);
  string__21_115 = from_latin_1_string("    case ", 9);
  string__21_116 = from_latin_1_string(":;\012  }\012  switch(argument_count) {\012", 34);
  string__21_127 = from_latin_1_string("case ", 5);
  string__21_130 = from_latin_1_string("default", 7);
  func__21_129 = create_future();
  string__21_134 = from_latin_1_string("    ", 4);
  string__21_135 = from_latin_1_string(":\012      func = cont", 19);
  string__21_136 = from_latin_1_string("_", 1);
  string__21_137 = from_latin_1_string(";\012      return;\012", 16);
  string__21_140 = from_latin_1_string("    case ", 9);
  string__21_141 = from_latin_1_string(":;\012  }\012", 7);
  func__21_155 = create_future();
  string__21_159 = from_latin_1_string("undefined", 9);
  string__21_163 = from_latin_1_string("  func = cont", 13);
  string__21_164 = from_latin_1_string("_", 1);
  string__21_165 = from_latin_1_string(";\012}\012", 4);
  string__21_168 = from_latin_1_string("cont", 4);
  string__21_169 = from_latin_1_string("_", 1);
  string__21_182 = from_latin_1_string("undefined", 9);
  func__21_181 = create_future();
  string__21_186 = from_latin_1_string("    case ", 9);
  string__21_187 = from_latin_1_string(": ", 2);
  string__21_190 = from_latin_1_string("  }\012", 4);
  func__21_1 = create_future();
  string__22_2 = from_latin_1_string("\012  // ", 6);
  string__22_5 = from_latin_1_string("  // ", 5);
  func__22_1 = create_future();
  func__23_1 = create_future();
  string__24_55 = from_latin_1_string(", ", 2);
  func__24_57 = create_future();
  string__24_59 = from_latin_1_string(", ", 2);
  string__24_60 = from_latin_1_string(", ", 2);
  string__24_61 = from_latin_1_string(", ", 2);
  string__24_66 = from_latin_1_string("  // ", 5);
  string__24_67 = from_latin_1_string(": ", 2);
  string__24_70 = from_latin_1_string("  ", 2);
  string__24_96 = from_latin_1_string("... ", 4);
  string__24_120 = from_latin_1_string("  // ...", 8);
  func__24_119 = create_future();
  func__24_1 = create_future();
  func__25_1 = create_future();
  define_single_assign_static("sim2c", "write_source_as_remark", get__sim2c__write_source_as_remark, &var.sim2c__write_source_as_remark);
  unique__26_1 = register_unique_item("EARLY");
  assign_value(&var._EARLY, unique__26_1);
  unique__27_1 = register_unique_item("STANDARD");
  assign_value(&var._STANDARD, unique__27_1);
  unique__28_1 = register_unique_item("UNKNOWN");
  assign_value(&var._UNKNOWN, unique__28_1);
  func__29_15 = create_future();
  func__29_16 = create_future();
  func__29_1 = create_future();
  string__30_2 = from_latin_1_string("generate expression", 19);
  string__30_4 = from_latin_1_string("???", 3);
  func__30_1 = create_future();
  string__31_2 = from_latin_1_string("generate body", 13);
  func__31_16 = create_future();
  func__31_7 = create_future();
  string__31_24 = from_latin_1_string("get_value_or_future__", 21);
  string__31_25 = from_latin_1_string("()", 2);
  string__31_30 = from_latin_1_string("create_future()", 15);
  func__31_29 = create_future();
  string__31_32 = from_latin_1_string("create_future()", 15);
  func__31_31 = create_future();
  func__31_18 = create_future();
  string__31_44 = from_latin_1_string("  argument_count = 0;\012  arguments = node_p;\012  myself = ", 55);
  string__31_45 = from_latin_1_string(";\012  func = myself->type;\012  frame->cont = invalid_continuation;\012", 63);
  string__31_50 = from_latin_1_string("  frame = frame->caller_frame;\012  func = frame->cont;\012  frame->cont = invalid_continuation;\012", 91);
  func__31_112 = create_future();
  string__31_138 = from_latin_1_string("static NODE *func", 17);
  string__31_139 = from_latin_1_string(";\012", 2);
  string__31_143 = from_latin_1_string("entry", 5);
  string__31_150 = from_latin_1_string("  allocate_arguments();\012", 24);
  func__31_149 = create_future();
  string__31_157 = from_latin_1_string("  caller_frame = frame;\012", 24);
  func__31_156 = create_future();
  string__31_159 = from_latin_1_string("  allocate_initialized_frame_gc(", 32);
  string__31_160 = from_latin_1_string(", ", 2);
  string__31_161 = from_latin_1_string(");\012", 3);
  string__31_164 = from_latin_1_string("  // slot allocations:", 22);
  string__31_167 = from_latin_1_string("static FRAME_INFO frame", 23);
  string__31_168 = from_latin_1_string(" = {", 4);
  string__31_169 = from_latin_1_string(", {", 3);
  string__31_173 = from_latin_1_string("  // ", 5);
  string__31_174 = from_latin_1_string(": ", 2);
  string__31_180 = from_latin_1_string(", ", 2);
  func__31_179 = create_future();
  string__31_182 = from_latin_1_string("\042", 1);
  string__31_183 = from_latin_1_string("\042", 1);
  func__31_172 = create_future();
  string__31_186 = from_latin_1_string("}};\012", 4);
  string__31_188 = from_latin_1_string("frame", 5);
  string__31_194 = from_latin_1_string("static void exit", 16);
  string__31_195 = from_latin_1_string("(void);\012", 8);
  string__31_198 = from_latin_1_string("create_continuation_with_exit(exit", 34);
  string__31_199 = from_latin_1_string(")", 1);
  string__31_202 = from_latin_1_string("create_continuation()", 21);
  func__31_201 = create_future();
  string__31_204 = from_latin_1_string("arguments", 9);
  string__31_210 = from_latin_1_string("  frame->slots[", 15);
  string__31_211 = from_latin_1_string("] = myself->closure.frame->slots[", 33);
  string__31_212 = from_latin_1_string("]; /* ", 6);
  string__31_213 = from_latin_1_string(" */\012", 4);
  string__31_223 = from_latin_1_string("_define ", 8);
  string__31_224 = from_latin_1_string(" ", 1);
  string__31_239 = from_latin_1_string("  frame->slots[", 15);
  string__31_240 = from_latin_1_string("] /* ", 5);
  string__31_241 = from_latin_1_string(" */ = create_cell();\012", 21);
  string__31_244 = from_latin_1_string("undefined", 9);
  string__31_265 = from_latin_1_string("  update_start_p = node_p;\012  def_attribute(&", 44);
  string__31_266 = from_latin_1_string(", poly_idx__", 12);
  string__31_267 = from_latin_1_string(", MAKE_ATTRIBUTE_VALUE(", 23);
  string__31_268 = from_latin_1_string("));\012", 4);
  string__31_279 = from_latin_1_string("  update_start_p = node_p;\012  def_attribute(&", 44);
  string__31_280 = from_latin_1_string(", poly_idx__", 12);
  string__31_281 = from_latin_1_string(", ", 2);
  string__31_282 = from_latin_1_string(");\012", 3);
  string__31_288 = from_latin_1_string("  update_start_p = node_p;\012  def_attribute(&", 44);
  string__31_289 = from_latin_1_string(", -1, ", 6);
  string__31_290 = from_latin_1_string(");\012", 3);
  string__31_295 = from_latin_1_string("arguments", 9);
  string__31_300 = from_latin_1_string("arguments", 9);
  string__31_301 = from_latin_1_string("myself", 6);
  string__31_310 = from_latin_1_string("  frame->slots[", 15);
  string__31_311 = from_latin_1_string("] /* ", 5);
  string__31_312 = from_latin_1_string(" */ = create_cell();\012", 21);
  func__31_317 = create_future();
  string__31_333 = from_latin_1_string("  myself = ", 11);
  string__31_334 = from_latin_1_string(";\012  func = myself->type;\012  frame->cont = invalid_continuation;\012", 63);
  string__31_340 = from_latin_1_string("  frame = frame->caller_frame;\012  func = frame->cont;\012  frame->cont = invalid_continuation;\012", 91);
  string__31_356 = from_latin_1_string("continuation_trampoline", 23);
  string__31_360 = from_latin_1_string("  frame->slots[0] = ", 20);
  string__31_361 = from_latin_1_string(";\012  if (frame->slots[0]->type != continuation_type_function)\012    invalid_continuation_error();\012  frame->slot_count = 1;\012  frame->caller_frame = NULL;\012  result_count = frame->slots[0]->continuation.result_count;\012", 211);
  string__31_365 = from_latin_1_string("  result_count =\012    frame->caller_result_count >= ", 51);
  string__31_366 = from_latin_1_string(" ?\012    frame->caller_result_count-", 34);
  string__31_367 = from_latin_1_string(" : -1;\012", 7);
  string__31_370 = from_latin_1_string("  result_count = -1;\012", 21);
  func__31_369 = create_future();
  string__31_372 = from_latin_1_string("  result_count = frame->caller_result_count;\012", 45);
  func__31_371 = create_future();
  string__31_378 = from_latin_1_string("cont", 4);
  string__31_379 = from_latin_1_string("_", 1);
  string__31_382 = from_latin_1_string("}\012", 2);
  string__31_384 = from_latin_1_string("cont", 4);
  string__31_385 = from_latin_1_string("_", 1);
  string__31_390 = from_latin_1_string("  myself = ", 11);
  string__31_391 = from_latin_1_string(";\012  func = myself->type;\012  frame->cont = invalid_continuation;\012", 63);
  string__31_398 = from_latin_1_string("cont", 4);
  string__31_399 = from_latin_1_string("_", 1);
  string__31_402 = from_latin_1_string("}\012", 2);
  string__31_404 = from_latin_1_string("cont", 4);
  string__31_405 = from_latin_1_string("_", 1);
  string__31_411 = from_latin_1_string("  int i = argument_count;\012  while (--i >= 0) {\012    arguments->slots[i+", 70);
  string__31_412 = from_latin_1_string("] = arguments->slots[i];\012  }\012", 29);
  string__31_416 = from_latin_1_string("  int i;\012  int n = argument_count;\012  FRAME *return_arguments = arguments;\012  allocate_arguments();\012", 98);
  string__31_419 = from_latin_1_string("  for (i = 0; i < n; ++i) {\012    arguments->slots[argument_count++] = return_arguments->slots[i];\012  }\012", 101);
  string__31_421 = from_latin_1_string("  frame = frame->caller_frame;\012  func = frame->cont;\012  frame->cont = invalid_continuation;\012", 91);
  string__31_423 = from_latin_1_string("frame->cont", 11);
  string__31_424 = from_latin_1_string("frame = frame->caller_frame;", 28);
  string__31_428 = from_latin_1_string("}\012", 2);
  string__31_437 = from_latin_1_string("static void exit", 16);
  string__31_438 = from_latin_1_string("(void) {\012  frame = ((CONTINUATION *)myself)->exit_frame;\012", 57);
  string__31_444 = from_latin_1_string("  int i = argument_count;\012  while (--i >= 0) {\012    arguments->slots[i+", 70);
  string__31_445 = from_latin_1_string("] = arguments->slots[i];\012  }\012", 29);
  string__31_449 = from_latin_1_string("  int i;\012  int n = argument_count;\012  FRAME *return_arguments = arguments;\012  allocate_arguments();\012", 98);
  string__31_452 = from_latin_1_string("  for (i = 0; i < n; ++i) {\012    arguments->slots[argument_count++] = return_arguments->slots[i];\012  }\012", 101);
  string__31_454 = from_latin_1_string("  func = continuation_type_function;\012}\012", 39);
  string__31_460 = from_latin_1_string("entry", 5);
  string__31_466 = from_latin_1_string("  func", 6);
  string__31_467 = from_latin_1_string(" = create_future();\012", 20);
  string__31_470 = from_latin_1_string("  assign_value(&func", 20);
  string__31_471 = from_latin_1_string(", create_function(entry", 23);
  string__31_472 = from_latin_1_string(", ", 2);
  string__31_473 = from_latin_1_string("));\012", 4);
  string__31_476 = from_latin_1_string("  func", 6);
  string__31_477 = from_latin_1_string(" = collect_node(func", 20);
  string__31_478 = from_latin_1_string(");\012", 3);
  string__31_481 = from_latin_1_string("func", 4);
  string__31_484 = from_latin_1_string("create_closure(entry", 20);
  string__31_485 = from_latin_1_string(", ", 2);
  string__31_486 = from_latin_1_string(")", 1);
  func__31_1 = create_future();
  string__32_2 = from_latin_1_string("generate definition", 19);
  string__32_12 = from_latin_1_string("var.", 4);
  string__32_13 = from_latin_1_string("__", 2);
  func__32_1 = create_future();
  string__33_2 = from_latin_1_string("generate attribute-value pair", 29);
  func__33_1 = create_future();
  string__34_2 = from_latin_1_string("generate attribute-function pair", 32);
  func__34_1 = create_future();
  string__35_2 = from_latin_1_string("generate numeric literal", 24);
  string__35_5 = from_latin_1_string("number__", 8);
  func__35_1 = create_future();
  string__36_2 = from_latin_1_string("generate character literal", 26);
  string__36_6 = from_latin_1_string("character__", 11);
  func__36_1 = create_future();
  string__37_19 = from_latin_1_string("0", 1);
  string__37_21 = from_latin_1_string("\134", 1);
  func__37_1 = create_future();
  string__38_6 = from_latin_1_string("string", 6);
  string__38_7 = from_latin_1_string("_", 1);
  string__38_9 = from_latin_1_string("static NODE *", 13);
  string__38_10 = from_latin_1_string(";\012", 2);
  string__38_16 = from_latin_1_string("  ", 2);
  string__38_17 = from_latin_1_string(" = from_latin_1_string(\042", 24);
  string__38_18 = from_latin_1_string("\042, ", 3);
  string__38_19 = from_latin_1_string(");\012", 3);
  string__38_22 = from_latin_1_string("  uint32_t ", 11);
  string__38_23 = from_latin_1_string("_literal[", 9);
  string__38_24 = from_latin_1_string("] = {", 5);
  string__38_58 = from_latin_1_string("0x", 2);
  func__38_27 = create_future();
  string__38_60 = from_latin_1_string(", ", 2);
  func__38_59 = create_future();
  string__38_62 = from_latin_1_string("};\012", 3);
  string__38_64 = from_latin_1_string("  ", 2);
  string__38_65 = from_latin_1_string(" = from_uint32_string(", 22);
  string__38_66 = from_latin_1_string("_literal, ", 10);
  string__38_67 = from_latin_1_string(");\012", 3);
  string__38_70 = from_latin_1_string("  ", 2);
  string__38_71 = from_latin_1_string(" = collect_node(", 16);
  string__38_72 = from_latin_1_string(");\012", 3);
  string__38_76 = from_latin_1_string("empty_string", 12);
  func__38_75 = create_future();
  func__38_1 = create_future();
  string__39_2 = from_latin_1_string("generate string literal", 23);
  func__39_1 = create_future();
  string__40_2 = from_latin_1_string("generate unique item", 20);
  string__40_5 = from_latin_1_string("unique", 6);
  string__40_6 = from_latin_1_string("_", 1);
  string__40_14 = from_latin_1_string("static NODE *", 13);
  string__40_15 = from_latin_1_string(";\012", 2);
  string__40_18 = from_latin_1_string("  ", 2);
  string__40_19 = from_latin_1_string(" = register_unique_item(\042", 25);
  string__40_20 = from_latin_1_string("\042);\012", 4);
  string__40_23 = from_latin_1_string("  ", 2);
  string__40_24 = from_latin_1_string(" = collect_node(", 16);
  string__40_25 = from_latin_1_string(");\012", 3);
  func__40_1 = create_future();
  string__41_2 = from_latin_1_string("generate identifier ", 20);
  string__41_10 = from_latin_1_string("__", 2);
  string__41_15 = from_latin_1_string("frame->slots[", 13);
  string__41_16 = from_latin_1_string("] /* ", 5);
  string__41_17 = from_latin_1_string(" */", 3);
  string__41_28 = from_latin_1_string("((CELL *)frame->slots[", 22);
  string__41_29 = from_latin_1_string("])->contents /* ", 16);
  string__41_30 = from_latin_1_string(" */", 3);
  string__41_34 = from_latin_1_string("frame->slots[", 13);
  string__41_35 = from_latin_1_string("] /* ", 5);
  string__41_36 = from_latin_1_string(" */", 3);
  string__41_43 = from_latin_1_string("get__", 5);
  string__41_44 = from_latin_1_string("()", 2);
  string__41_62 = from_latin_1_string("get__", 5);
  string__41_63 = from_latin_1_string("()", 2);
  func__41_1 = create_future();
  string__42_2 = from_latin_1_string("generate C-body", 15);
  string__42_13 = from_latin_1_string("CHECK_ARGUMENTS", 15);
  func__42_18 = create_future();
  string__42_21 = from_latin_1_string("static void entry", 17);
  string__42_22 = from_latin_1_string("(void);\012static NODE *func", 25);
  string__42_23 = from_latin_1_string(";\012", 2);
  string__42_28 = from_latin_1_string("  {entry", 8);
  string__42_29 = from_latin_1_string(", NULL, ", 8);
  string__42_30 = from_latin_1_string("},\012", 3);
  string__42_36 = from_latin_1_string("static void entry", 17);
  string__42_37 = from_latin_1_string("(void) {\012", 9);
  string__42_38 = from_latin_1_string("\012}\012", 3);
  string__42_41 = from_latin_1_string("  func", 6);
  string__42_42 = from_latin_1_string(" = create_future();\012", 20);
  string__42_45 = from_latin_1_string("  assign_value(&func", 20);
  string__42_46 = from_latin_1_string(", create_function(entry", 23);
  string__42_47 = from_latin_1_string(", ", 2);
  string__42_48 = from_latin_1_string("));\012", 4);
  string__42_51 = from_latin_1_string("func", 4);
  func__42_1 = create_future();
  func__43_1 = create_future();
  func__44_18 = create_future();
  func__44_1 = create_future();
  define_single_assign_static("sim2c", "is_single_assign", get__sim2c__is_single_assign, &var.sim2c__is_single_assign);
  func__45_18 = create_future();
  func__45_1 = create_future();
  define_single_assign_static("sim2c", "might_be_constant", get__sim2c__might_be_constant, &var.sim2c__might_be_constant);
  string__46_3 = from_latin_1_string("var.", 4);
  string__46_4 = from_latin_1_string("func__", 6);
  string__46_8 = from_latin_1_string("  assign_variable(&", 19);
  string__46_9 = from_latin_1_string(", &", 3);
  string__46_10 = from_latin_1_string(");\012", 3);
  string__46_13 = from_latin_1_string("unique__", 8);
  string__46_16 = from_latin_1_string("  assign_value(&", 16);
  string__46_17 = from_latin_1_string(", ", 2);
  string__46_18 = from_latin_1_string(");\012", 3);
  string__46_21 = from_latin_1_string("  assign_value(&", 16);
  string__46_22 = from_latin_1_string(", ", 2);
  string__46_23 = from_latin_1_string(");\012", 3);
  func__46_1 = create_future();
  string__47_7 = from_latin_1_string("  ", 2);
  string__47_8 = from_latin_1_string(" = collect_node(", 16);
  string__47_9 = from_latin_1_string(");\012", 3);
  string__47_24 = from_latin_1_string("  NODE *", 8);
  string__47_25 = from_latin_1_string(";\012", 2);
  string__47_28 = from_latin_1_string("static NODE *get__", 18);
  string__47_29 = from_latin_1_string("__", 2);
  string__47_30 = from_latin_1_string("(void) {\012  return var.", 22);
  string__47_31 = from_latin_1_string("__", 2);
  string__47_32 = from_latin_1_string(";\012}\012", 4);
  string__47_36 = from_latin_1_string("  define_single_assign_static(\042", 31);
  string__47_37 = from_latin_1_string("\042, \042", 4);
  string__47_38 = from_latin_1_string("\042, get__", 8);
  string__47_39 = from_latin_1_string(", &", 3);
  string__47_40 = from_latin_1_string(");\012", 3);
  string__47_43 = from_latin_1_string("  NODE *", 8);
  string__47_44 = from_latin_1_string(";\012", 2);
  string__47_47 = from_latin_1_string("static NODE *get__", 18);
  string__47_48 = from_latin_1_string("__", 2);
  string__47_49 = from_latin_1_string("(void) {\012  return var.", 22);
  string__47_50 = from_latin_1_string("__", 2);
  string__47_51 = from_latin_1_string(";\012}\012static void set__", 21);
  string__47_52 = from_latin_1_string("__", 2);
  string__47_53 = from_latin_1_string("(NODE *val) {\012  var.", 20);
  string__47_54 = from_latin_1_string("__", 2);
  string__47_55 = from_latin_1_string(" = val;\012}\012", 10);
  string__47_58 = from_latin_1_string("  define_multi_assign_static(\042", 30);
  string__47_59 = from_latin_1_string("\042, \042", 4);
  string__47_60 = from_latin_1_string("\042, get__", 8);
  string__47_61 = from_latin_1_string(", set__", 7);
  string__47_62 = from_latin_1_string(");\012", 3);
  string__47_65 = from_latin_1_string("static int dyna_idx__", 21);
  string__47_66 = from_latin_1_string(";\012static NODE *get__", 20);
  string__47_67 = from_latin_1_string("(void) {\012  return get_dynamic_slot(dyna_idx__", 45);
  string__47_68 = from_latin_1_string(");\012}\012static void define__", 25);
  string__47_69 = from_latin_1_string("(NODE *node) {\012  define_dynamic_slot(dyna_idx__", 47);
  string__47_70 = from_latin_1_string(", node);\012}\012", 11);
  string__47_73 = from_latin_1_string("  define_single_assign_dynamic(\042", 32);
  string__47_74 = from_latin_1_string("\042, \042", 4);
  string__47_75 = from_latin_1_string("\042, get__", 8);
  string__47_76 = from_latin_1_string(", define__", 10);
  string__47_77 = from_latin_1_string(", &dyna_idx__", 13);
  string__47_78 = from_latin_1_string(");\012", 3);
  string__47_81 = from_latin_1_string("static int dyna_idx__", 21);
  string__47_82 = from_latin_1_string(";\012static NODE *get__", 20);
  string__47_83 = from_latin_1_string("(void) {\012  return get_dynamic_cell(dyna_idx__", 45);
  string__47_84 = from_latin_1_string(");\012}\012static void set__", 22);
  string__47_85 = from_latin_1_string("(NODE *node) {\012  set_dynamic_cell(dyna_idx__", 44);
  string__47_86 = from_latin_1_string(", node);\012}\012static void define__", 31);
  string__47_87 = from_latin_1_string("(NODE *node) {\012  define_dynamic_cell(dyna_idx__", 47);
  string__47_88 = from_latin_1_string(", node);\012}\012", 11);
  string__47_91 = from_latin_1_string("  define_multi_assign_dynamic(\042", 31);
  string__47_92 = from_latin_1_string("\042, \042", 4);
  string__47_93 = from_latin_1_string("\042, get__", 8);
  string__47_94 = from_latin_1_string(", set__", 7);
  string__47_95 = from_latin_1_string(", define__", 10);
  string__47_96 = from_latin_1_string(", &dyna_idx__", 13);
  string__47_97 = from_latin_1_string(");\012  define__", 13);
  string__47_98 = from_latin_1_string("(undefined);\012", 13);
  string__47_102 = from_latin_1_string("  \042", 3);
  string__47_103 = from_latin_1_string("\042,\012", 3);
  string__47_107 = from_latin_1_string("  NODE *", 8);
  string__47_108 = from_latin_1_string(";\012", 2);
  string__47_114 = from_latin_1_string("  ", 2);
  string__47_115 = from_latin_1_string(" = create_future();\012", 20);
  string__47_118 = from_latin_1_string("  \042", 3);
  string__47_119 = from_latin_1_string("\042,\012", 3);
  string__47_123 = from_latin_1_string("  NODE *", 8);
  string__47_124 = from_latin_1_string(";\012", 2);
  string__47_127 = from_latin_1_string("static int dyna_idx__", 21);
  string__47_128 = from_latin_1_string(";\012static NODE *get__", 20);
  string__47_129 = from_latin_1_string("(void) {\012  return get_dynamic_slot(dyna_idx__", 45);
  string__47_130 = from_latin_1_string(");\012}\012static void define__", 25);
  string__47_131 = from_latin_1_string("(NODE *node) {\012  define_dynamic_slot(dyna_idx__", 47);
  string__47_132 = from_latin_1_string(", node);\012}\012", 11);
  string__47_135 = from_latin_1_string("  register_dynamic(&dyna_idx__", 30);
  string__47_136 = from_latin_1_string(");\012", 3);
  string__47_141 = from_latin_1_string("  define__", 10);
  string__47_142 = from_latin_1_string("(create_future());\012", 19);
  string__47_145 = from_latin_1_string("static int dyna_idx__", 21);
  string__47_146 = from_latin_1_string(";\012static NODE *get__", 20);
  string__47_147 = from_latin_1_string("(void) {\012  return get_dynamic_cell(dyna_idx__", 45);
  string__47_148 = from_latin_1_string(");\012}\012static void set__", 22);
  string__47_149 = from_latin_1_string("(NODE *node) {\012  set_dynamic_cell(dyna_idx__", 44);
  string__47_150 = from_latin_1_string(", node);\012}\012static void define__", 31);
  string__47_151 = from_latin_1_string("(NODE *node) {\012  define_dynamic_cell(dyna_idx__", 47);
  string__47_152 = from_latin_1_string(", node);\012}\012", 11);
  string__47_155 = from_latin_1_string("  register_dynamic(&dyna_idx__", 30);
  string__47_156 = from_latin_1_string(");\012  define__", 13);
  string__47_157 = from_latin_1_string("(undefined);\012", 13);
  string__47_168 = from_latin_1_string("  define__", 10);
  string__47_169 = from_latin_1_string("(", 1);
  string__47_170 = from_latin_1_string(");\012", 3);
  string__47_175 = from_latin_1_string("  define__", 10);
  string__47_176 = from_latin_1_string("(create_future());\012", 19);
  string__47_182 = from_latin_1_string("  maybe_initialize_future(get__", 31);
  string__47_183 = from_latin_1_string("(), ", 4);
  string__47_184 = from_latin_1_string(");\012", 3);
  string__47_188 = from_latin_1_string("  initialize_future(get__", 25);
  string__47_189 = from_latin_1_string("(), ", 4);
  string__47_190 = from_latin_1_string(");\012", 3);
  func__47_1 = create_future();
  define_single_assign_static("sim2c", "define_variable", get__sim2c__define_variable, &var.sim2c__define_variable);
  string__48_4 = from_latin_1_string("\042", 1);
  string__48_5 = from_latin_1_string("\042", 1);
  string__48_8 = from_latin_1_string("NULL", 4);
  func__48_7 = create_future();
  func__48_1 = create_future();
  string__49_9 = from_latin_1_string("var__", 5);
  string__49_10 = from_latin_1_string("__", 2);
  string__49_12 = from_latin_1_string("static NODE *", 13);
  string__49_13 = from_latin_1_string(";\012", 2);
  string__49_23 = from_latin_1_string("  define_attribute(", 19);
  string__49_24 = from_latin_1_string(", \042", 3);
  string__49_25 = from_latin_1_string("\042, poly_idx__", 13);
  string__49_26 = from_latin_1_string(", ", 2);
  string__49_27 = from_latin_1_string(");\012", 3);
  string__49_31 = from_latin_1_string("  update_start_p = node_p;\012  def_attribute(&", 44);
  string__49_32 = from_latin_1_string(", poly_idx__", 12);
  string__49_33 = from_latin_1_string(", MAKE_ATTRIBUTE_VALUE(", 23);
  string__49_34 = from_latin_1_string("));\012", 4);
  func__49_1 = create_future();
  define_single_assign_static("sim2c", "define_attribute", get__sim2c__define_attribute, &var.sim2c__define_attribute);
  string__50_9 = from_latin_1_string("var__", 5);
  string__50_10 = from_latin_1_string("__", 2);
  string__50_12 = from_latin_1_string("static NODE *", 13);
  string__50_13 = from_latin_1_string(";\012", 2);
  string__50_23 = from_latin_1_string("  define_method(", 16);
  string__50_24 = from_latin_1_string(", \042", 3);
  string__50_25 = from_latin_1_string("\042, poly_idx__", 13);
  string__50_26 = from_latin_1_string(", ", 2);
  string__50_27 = from_latin_1_string(");\012", 3);
  string__50_31 = from_latin_1_string("  update_start_p = node_p;\012  def_attribute(&", 44);
  string__50_32 = from_latin_1_string(", poly_idx__", 12);
  string__50_33 = from_latin_1_string(", ", 2);
  string__50_34 = from_latin_1_string(");\012", 3);
  func__50_1 = create_future();
  define_single_assign_static("sim2c", "define_method", get__sim2c__define_method, &var.sim2c__define_method);
  string__51_11 = from_latin_1_string("  define_type_function(", 23);
  string__51_12 = from_latin_1_string(", \042", 3);
  string__51_13 = from_latin_1_string("\042, ", 3);
  string__51_14 = from_latin_1_string(", ", 2);
  string__51_15 = from_latin_1_string(");\012", 3);
  string__51_19 = from_latin_1_string("  update_start_p = node_p;\012  def_attribute(&", 44);
  string__51_20 = from_latin_1_string(", -1, ", 6);
  string__51_21 = from_latin_1_string(");\012", 3);
  func__51_1 = create_future();
  define_single_assign_static("sim2c", "define_type_function", get__sim2c__define_type_function, &var.sim2c__define_type_function);
  string__52_4 = from_latin_1_string("_with_setter", 12);
  func__52_3 = create_future();
  func__52_5 = create_future();
  string__52_9 = from_latin_1_string("  NODE *", 8);
  string__52_10 = from_latin_1_string(";\012", 2);
  string__52_13 = from_latin_1_string("  \042", 3);
  string__52_14 = from_latin_1_string("\042,\012", 3);
  string__52_18 = from_latin_1_string("  NODE *", 8);
  string__52_19 = from_latin_1_string(";\012", 2);
  string__52_25 = from_latin_1_string(" = ", 3);
  func__52_27 = create_future();
  string__52_29 = from_latin_1_string("static int poly_idx__", 21);
  string__52_30 = from_latin_1_string(";\012", 2);
  string__52_35 = from_latin_1_string("  ", 2);
  string__52_36 = from_latin_1_string(" = collect_node(", 16);
  string__52_37 = from_latin_1_string(");\012", 3);
  string__52_42 = from_latin_1_string("  {type__", 9);
  string__52_43 = from_latin_1_string(", NULL, ", 8);
  string__52_44 = from_latin_1_string("},\012", 3);
  string__52_49 = from_latin_1_string("  assign_value(&", 16);
  string__52_50 = from_latin_1_string(", create_function(type__", 24);
  string__52_51 = from_latin_1_string(", -1));\012", 8);
  string__52_56 = from_latin_1_string("static NODE *get__", 18);
  string__52_57 = from_latin_1_string("__", 2);
  string__52_58 = from_latin_1_string("(void) {\012  return var.", 22);
  string__52_59 = from_latin_1_string("__", 2);
  string__52_60 = from_latin_1_string(";\012}\012", 4);
  string__52_66 = from_latin_1_string("  define_privileged_polymorphic_function(\042", 42);
  string__52_67 = from_latin_1_string("\042, \042", 4);
  string__52_68 = from_latin_1_string("\042, get__", 8);
  string__52_69 = from_latin_1_string(", ", 2);
  string__52_70 = from_latin_1_string(", &", 3);
  string__52_71 = from_latin_1_string(");\012", 3);
  string__52_76 = from_latin_1_string("  define_polymorphic_function", 29);
  string__52_77 = from_latin_1_string("(\042", 2);
  string__52_78 = from_latin_1_string("\042, \042", 4);
  string__52_79 = from_latin_1_string("\042, get__", 8);
  string__52_80 = from_latin_1_string(", &poly_idx__", 13);
  string__52_81 = from_latin_1_string(", &", 3);
  string__52_82 = from_latin_1_string(");\012", 3);
  string__52_86 = from_latin_1_string("  register_polymorphic_function", 31);
  string__52_87 = from_latin_1_string("(\042_", 3);
  string__52_88 = from_latin_1_string("::", 2);
  string__52_89 = from_latin_1_string("\042, &poly_idx__", 14);
  string__52_90 = from_latin_1_string(");\012", 3);
  func__52_1 = create_future();
  define_single_assign_static("sim2c", "define_polymorphic_function", get__sim2c__define_polymorphic_function, &var.sim2c__define_polymorphic_function);
  string__53_2 = from_latin_1_string("define C-code", 13);
  string__53_10 = from_latin_1_string(", ", 2);
  string__53_13 = from_latin_1_string("__", 2);
  string__53_16 = from_latin_1_string("  NODE *", 8);
  string__53_17 = from_latin_1_string(";\012", 2);
  string__53_20 = from_latin_1_string("  \042", 3);
  string__53_21 = from_latin_1_string("\042,\012", 3);
  string__53_25 = from_latin_1_string("  NODE *", 8);
  string__53_26 = from_latin_1_string(";\012", 2);
  string__53_31 = from_latin_1_string("  ", 2);
  string__53_32 = from_latin_1_string(" = collect_node(", 16);
  string__53_33 = from_latin_1_string(");\012", 3);
  string__53_38 = from_latin_1_string("  ", 2);
  string__53_39 = from_latin_1_string(" = create_future_with_prototype(create__", 40);
  string__53_40 = from_latin_1_string("(", 1);
  string__53_41 = from_latin_1_string("));\012", 4);
  string__53_45 = from_latin_1_string("  ", 2);
  string__53_46 = from_latin_1_string(" = create__", 11);
  string__53_47 = from_latin_1_string("(", 1);
  string__53_48 = from_latin_1_string(");\012", 3);
  string__53_54 = from_latin_1_string("static NODE *get__", 18);
  string__53_55 = from_latin_1_string("(void) {\012  return ", 18);
  string__53_56 = from_latin_1_string(";\012}\012", 4);
  string__53_61 = from_latin_1_string("runtime", 7);
  func__53_62 = create_future();
  string__53_63 = from_latin_1_string("global", 6);
  func__53_64 = create_future();
  string__53_65 = from_latin_1_string("extern", 6);
  string__53_67 = from_latin_1_string("extern ", 7);
  func__53_66 = create_future();
  string__53_69 = from_latin_1_string("static ", 7);
  func__53_68 = create_future();
  func__53_75 = create_future();
  func__53_80 = create_future();
  func__53_86 = create_future();
  func__53_93 = create_future();
  string__53_97 = from_latin_1_string("\012typedef struct ", 16);
  string__53_98 = from_latin_1_string(" ", 1);
  string__53_99 = from_latin_1_string(";\012struct ", 9);
  string__53_100 = from_latin_1_string(" {\012", 3);
  string__53_101 = from_latin_1_string("\012};\012", 4);
  string__53_105 = from_latin_1_string("\012typedef struct {\012  void *type;\012  ATTRIBUTES *attributes;\012", 58);
  string__53_106 = from_latin_1_string("\012} ", 3);
  string__53_107 = from_latin_1_string(";\012", 2);
  string__53_111 = from_latin_1_string("collect_", 8);
  string__53_115 = from_latin_1_string("void *", 6);
  string__53_116 = from_latin_1_string("(", 1);
  string__53_117 = from_latin_1_string(" *node) {\012  ", 12);
  string__53_118 = from_latin_1_string(" *new_node = allocate(sizeof(", 29);
  string__53_119 = from_latin_1_string("));\012  new_node->type = node->type;\012  *(void **)node = ENCODE_ADDRESS(new_node);\012  new_node->attributes = collect_attributes(node->attributes);\012", 143);
  string__53_123 = from_latin_1_string("//", 2);
  string__53_136 = from_latin_1_string(" *", 2);
  func__53_147 = create_future();
  func__53_146 = create_future();
  string__53_155 = from_latin_1_string("  new_node->", 12);
  string__53_156 = from_latin_1_string(" = collect_", 11);
  string__53_157 = from_latin_1_string("(node->", 7);
  string__53_158 = from_latin_1_string(");\012", 3);
  string__53_161 = from_latin_1_string("  new_node->", 12);
  string__53_162 = from_latin_1_string(" = node->", 9);
  string__53_163 = from_latin_1_string(";\012", 2);
  func__53_122 = create_future();
  string__53_166 = from_latin_1_string("  return new_node;\012}\012", 21);
  string__53_172 = from_latin_1_string("Missing definition for a node named \042", 37);
  string__53_173 = from_latin_1_string("\042!", 2);
  string__53_188 = from_latin_1_string("  define_single_assign_static(\042", 31);
  string__53_189 = from_latin_1_string("\042, \042", 4);
  string__53_190 = from_latin_1_string("\042, get__", 8);
  string__53_191 = from_latin_1_string(", &", 3);
  string__53_192 = from_latin_1_string(");\012", 3);
  string__53_197 = from_latin_1_string("//", 2);
  string__53_216 = from_latin_1_string("  node->", 8);
  string__53_217 = from_latin_1_string(".", 1);
  string__53_218 = from_latin_1_string(" = ", 3);
  string__53_219 = from_latin_1_string(";\012", 2);
  string__53_223 = from_latin_1_string(", ", 2);
  string__53_229 = from_latin_1_string("\012static VTABLE vtable__", 23);
  string__53_230 = from_latin_1_string(" = {\012  sizeof(", 14);
  string__53_231 = from_latin_1_string("),\012  (COLLECTOR *)&collect_", 27);
  string__53_232 = from_latin_1_string(",\012", 2);
  string__53_237 = from_latin_1_string("::", 2);
  func__53_239 = create_future();
  string__53_244 = from_latin_1_string("  &func__", 9);
  string__53_245 = from_latin_1_string("___", 3);
  string__53_248 = from_latin_1_string("  (void *)no_such_function", 26);
  string__53_251 = from_latin_1_string(",\012", 2);
  string__53_254 = from_latin_1_string("\012};\012", 4);
  string__53_256 = from_latin_1_string("types__undefined", 16);
  string__53_259 = from_latin_1_string("\012static ATTRIBUTES attributes__types__undefined = {\012  &vtable__types__undefined,\012  {\012    &no_attributes_level_1, &no_attributes_level_2,\012    &no_attributes_level_3, &no_attributes_level_4,\012    &no_attributes_level_5, &no_attributes_level_6,\012    &no_attributes_level_7\012  }\012};\012", 275);
  string__53_262 = from_latin_1_string("\012static ATTRIBUTES attributes__", 31);
  string__53_263 = from_latin_1_string(" = {\012  &vtable__", 16);
  string__53_264 = from_latin_1_string(",\012  {\012    &undefined_attributes_level_1, &undefined_attributes_level_2,\012    &undefined_attributes_level_3, &undefined_attributes_level_4,\012    &undefined_attributes_level_5, &undefined_attributes_level_6,\012    &undefined_attributes_level_7\012  }\012};\012", 245);
  string__53_269 = from_latin_1_string("  collect_static_attributes(&attributes__", 41);
  string__53_270 = from_latin_1_string(");\012", 3);
  string__53_275 = from_latin_1_string("\012", 1);
  string__53_276 = from_latin_1_string("void type__", 11);
  string__53_277 = from_latin_1_string("(void) {\012", 9);
  string__53_278 = from_latin_1_string("\012}\012", 3);
  string__53_281 = from_latin_1_string("create__", 8);
  string__53_285 = from_latin_1_string("NODE *", 6);
  string__53_286 = from_latin_1_string("(", 1);
  string__53_287 = from_latin_1_string(");\012", 3);
  string__53_290 = from_latin_1_string("SIMPLE_NODE", 11);
  string__53_293 = from_latin_1_string("SIMPLE_NODE ", 12);
  string__53_294 = from_latin_1_string("__node =\012  {\012    type__", 23);
  string__53_295 = from_latin_1_string(",\012    &attributes__", 19);
  string__53_296 = from_latin_1_string("\012  };\012\012", 7);
  string__53_297 = from_latin_1_string("NODE *", 6);
  string__53_298 = from_latin_1_string("(", 1);
  string__53_299 = from_latin_1_string(") {\012  return (NODE *)&", 22);
  string__53_300 = from_latin_1_string("__node;\012}\012", 10);
  string__53_303 = from_latin_1_string("NODE *", 6);
  string__53_304 = from_latin_1_string("(", 1);
  string__53_305 = from_latin_1_string(") {\012  NODE *node = allocate(sizeof(", 35);
  string__53_306 = from_latin_1_string("));\012  node->type = type__", 25);
  string__53_307 = from_latin_1_string(";\012  node->attributes = &attributes__", 36);
  string__53_308 = from_latin_1_string(";\012", 2);
  string__53_309 = from_latin_1_string("  return node;\012}\012", 17);
  string__53_316 = from_latin_1_string("  define_single_assign_static(\042", 31);
  string__53_317 = from_latin_1_string("\042, \042", 4);
  string__53_318 = from_latin_1_string("\042, get__", 8);
  string__53_319 = from_latin_1_string(", &", 3);
  string__53_320 = from_latin_1_string(");\012", 3);
  string__53_329 = from_latin_1_string("runtime", 7);
  string__53_332 = from_latin_1_string("runtime__", 9);
  string__53_341 = from_latin_1_string("::", 2);
  string__53_344 = from_latin_1_string("func__", 6);
  func__53_343 = create_future();
  func__53_345 = create_future();
  string__53_347 = from_latin_1_string("::", 2);
  string__53_348 = from_latin_1_string("__", 2);
  string__53_350 = from_latin_1_string("___", 3);
  string__53_355 = from_latin_1_string("runtime", 7);
  string__53_358 = from_latin_1_string("  define_c_function(\042", 21);
  string__53_359 = from_latin_1_string("\042, ", 3);
  string__53_360 = from_latin_1_string(");\012", 3);
  string__53_363 = from_latin_1_string("\012", 1);
  string__53_364 = from_latin_1_string(";\012", 2);
  string__53_369 = from_latin_1_string("\012", 1);
  string__53_370 = from_latin_1_string("\012", 1);
  string__53_381 = from_latin_1_string("typedef", 7);
  string__53_382 = from_latin_1_string("static ", 7);
  string__53_383 = from_latin_1_string("extern ", 7);
  string__53_390 = from_latin_1_string("Unknown kind (\042", 15);
  string__53_391 = from_latin_1_string("\042) in C-code declaration!", 25);
  string__53_393 = from_latin_1_string("struct", 6);
  string__53_394 = from_latin_1_string("node", 4);
  string__53_395 = from_latin_1_string("type", 4);
  string__53_396 = from_latin_1_string("object", 6);
  string__53_397 = from_latin_1_string("function", 8);
  func__53_1 = create_future();
  define_single_assign_static("sim2c", "define_c_code", get__sim2c__define_c_code, &var.sim2c__define_c_code);
  string__54_3 = from_latin_1_string("  {\012    NODE *temp = clone_object_and_attributes(", 49);
  string__54_4 = from_latin_1_string(");\012    update_start_p = node_p;\012", 32);
  func__54_15 = create_future();
  string__54_17 = from_latin_1_string("_value", 6);
  func__54_16 = create_future();
  string__54_20 = from_latin_1_string("    set_attribute", 17);
  string__54_21 = from_latin_1_string("(temp->attributes, poly_idx__", 29);
  string__54_22 = from_latin_1_string(", ", 2);
  string__54_23 = from_latin_1_string(");\012", 3);
  string__54_26 = from_latin_1_string("    temp->type = ", 17);
  string__54_27 = from_latin_1_string("->type;\012", 8);
  func__54_7 = create_future();
  string__54_30 = from_latin_1_string("temp", 4);
  string__54_32 = from_latin_1_string("  ", 2);
  string__54_33 = from_latin_1_string("\012  }\012", 5);
  func__54_1 = create_future();
  string__55_6 = from_latin_1_string("generate procedure call", 23);
  func__55_5 = create_future();
  string__55_10 = from_latin_1_string("generate assignment", 19);
  func__55_9 = create_future();
  string__55_12 = from_latin_1_string("generate unknown statement", 26);
  func__55_11 = create_future();
  string__55_43 = from_latin_1_string("  result_count = to_int(", 24);
  string__55_44 = from_latin_1_string(");", 2);
  string__55_50 = from_latin_1_string("Call with continuation followed by another statement", 52);
  string__55_54 = from_latin_1_string("  result_count = ", 17);
  string__55_55 = from_latin_1_string(";", 1);
  string__55_58 = from_latin_1_string("  result_count = -1;", 20);
  func__55_57 = create_future();
  string__55_61 = from_latin_1_string("cont", 4);
  string__55_62 = from_latin_1_string("_", 1);
  string__55_66 = from_latin_1_string("  goto *(func+4);\012", 18);
  func__55_65 = create_future();
  string__55_68 = from_latin_1_string("}\012", 2);
  string__55_70 = from_latin_1_string("cont", 4);
  string__55_71 = from_latin_1_string("_", 1);
  string__55_74 = from_latin_1_string("results", 7);
  string__55_85 = from_latin_1_string("  initialize_maybe_future(", 26);
  string__55_86 = from_latin_1_string(", ", 2);
  string__55_87 = from_latin_1_string(");\012", 3);
  func__55_1 = create_future();
  define_single_assign_static("sim2c", "generate_statement", get__sim2c__generate_statement, &var.sim2c__generate_statement);
}

static int already_run_phase_3 = false;

EXPORT void phase_3__c_code_generator(void) {
  if (already_run_phase_3) return;
  already_run_phase_3 = true;
  set_module("c_code_generator");
  set_used_namespaces(used_namespaces);
  use_read_only(NULL, "ATTRIBUTE_KIND", &get__ATTRIBUTE_KIND, &get_value_or_future__ATTRIBUTE_KIND);
  use_read_only(NULL, "CONTINUATION_PARAMETER", &get__CONTINUATION_PARAMETER, &get_value_or_future__CONTINUATION_PARAMETER);
  use_read_only(NULL, "DYNAMIC_MULTI", &get__DYNAMIC_MULTI, &get_value_or_future__DYNAMIC_MULTI);
  use_read_only(NULL, "DYNAMIC_SINGLE", &get__DYNAMIC_SINGLE, &get_value_or_future__DYNAMIC_SINGLE);
  use_read_only(NULL, "Error", &get__Error, &get_value_or_future__Error);
  use_read_only(NULL, "IN_OUT_PARAMETER", &get__IN_OUT_PARAMETER, &get_value_or_future__IN_OUT_PARAMETER);
  use_read_only(NULL, "METHOD_KIND", &get__METHOD_KIND, &get_value_or_future__METHOD_KIND);
  use_read_only(NULL, "MYSELF_PARAMETER", &get__MYSELF_PARAMETER, &get_value_or_future__MYSELF_PARAMETER);
  use_read_only(NULL, "NONE", &get__NONE, &get_value_or_future__NONE);
  use_read_only(NULL, "OUT_PARAMETER", &get__OUT_PARAMETER, &get_value_or_future__OUT_PARAMETER);
  use_read_only(NULL, "POLYMORPHIC", &get__POLYMORPHIC, &get_value_or_future__POLYMORPHIC);
  use_read_only(NULL, "STATIC_MULTI", &get__STATIC_MULTI, &get_value_or_future__STATIC_MULTI);
  use_read_only(NULL, "STATIC_SINGLE", &get__STATIC_SINGLE, &get_value_or_future__STATIC_SINGLE);
  use_read_only(NULL, "SyntaxError", &get__SyntaxError, &get_value_or_future__SyntaxError);
  use_read_only(NULL, "alt", &get__alt, &get_value_or_future__alt);
  use_read_only(NULL, "append", &get__append, &get_value_or_future__append);
  use_read_only(NULL, "arguments_of", &get__arguments_of, &get_value_or_future__arguments_of);
  use_read_only(NULL, "assignment_to_c", &get__assignment_to_c, &get_value_or_future__assignment_to_c);
  use_read_only(NULL, "attribute_kind_of", &get__attribute_kind_of, &get_value_or_future__attribute_kind_of);
  use_read_only(NULL, "attribute_of", &get__attribute_of, &get_value_or_future__attribute_of);
  use_read_only(NULL, "base_of", &get__base_of, &get_value_or_future__base_of);
  use_read_only(NULL, "before", &get__before, &get_value_or_future__before);
  use_read_only(NULL, "begin_continuation", &get__begin_continuation, &get_value_or_future__begin_continuation);
  use_read_only(NULL, "behind", &get__behind, &get_value_or_future__behind);
  use_read_only(NULL, "between", &get__between, &get_value_or_future__between);
  use_read_only(NULL, "case", &get__case, &get_value_or_future__case);
  use_read_only(NULL, "collect_output", &get__collect_output, &get_value_or_future__collect_output);
  use_read_only(NULL, "cond", &get__cond, &get_value_or_future__cond);
  use_read_only(NULL, "contains", &get__contains, &get_value_or_future__contains);
  use_read_only(NULL, "continuation_of", &get__continuation_of, &get_value_or_future__continuation_of);
  use_read_only(NULL, "converted", &get__converted, &get_value_or_future__converted);
  use_read_only(NULL, "count_character_occurrences", &get__count_character_occurrences, &get_value_or_future__count_character_occurrences);
  use_read_write(NULL, "current_continuation_info", &get__current_continuation_info, &set__current_continuation_info);
  use_read_only(NULL, "dec", &get__dec, &get_value_or_future__dec);
  use_read_only(NULL, "default_value", &get__default_value, &get_value_or_future__default_value);
  use_read_only(NULL, "default_value_of", &get__default_value_of, &get_value_or_future__default_value_of);
  use_read_only(NULL, "defined_functions", &get__defined_functions, &get_value_or_future__defined_functions);
  use_read_only(NULL, "defined_names_of", &get__defined_names_of, &get_value_or_future__defined_names_of);
  use_read_only(NULL, "defined_nodes", &get__defined_nodes, &get_value_or_future__defined_nodes);
  use_read_only(NULL, "defined_structs", &get__defined_structs, &get_value_or_future__defined_structs);
  use_read_only(NULL, "defines_a_dynamic", &get__defines_a_dynamic, &get_value_or_future__defines_a_dynamic);
  use_read_only(NULL, "definitions_of", &get__definitions_of, &get_value_or_future__definitions_of);
  use_read_write(NULL, "delayed_code", &get__delayed_code, &set__delayed_code);
  use_read_only(NULL, "do", &get__do, &get_value_or_future__do);
  use_read_only(NULL, "do_show_compiler_debug_infos", &get__do_show_compiler_debug_infos, &get_value_or_future__do_show_compiler_debug_infos);
  use_read_only(NULL, "do_use_goto", &get__do_use_goto, &get_value_or_future__do_use_goto);
  use_read_only(NULL, "dup", &get__dup, &get_value_or_future__dup);
  use_read_only(NULL, "empty_insert_order_table", &get__empty_insert_order_table, &get_value_or_future__empty_insert_order_table);
  use_read_only(NULL, "empty_list", &get__empty_list, &get_value_or_future__empty_list);
  use_read_only(NULL, "empty_set", &get__empty_set, &get_value_or_future__empty_set);
  use_read_only(NULL, "empty_table", &get__empty_table, &get_value_or_future__empty_table);
  use_read_only(NULL, "end_continuation", &get__end_continuation, &get_value_or_future__end_continuation);
  use_read_only(NULL, "end_position_of", &get__end_position_of, &get_value_or_future__end_position_of);
  use_read_only(NULL, "ewriteln", &get__ewriteln, &get_value_or_future__ewriteln);
  use_read_only(NULL, "exported_names", &get__exported_names, &get_value_or_future__exported_names);
  use_read_only(NULL, "false", &get__false, &get_value_or_future__false);
  use_read_only(NULL, "for_each", &get__for_each, &get_value_or_future__for_each);
  use_read_only(NULL, "for_each_from_to", &get__for_each_from_to, &get_value_or_future__for_each_from_to);
  use_read_only(NULL, "for_each_line", &get__for_each_line, &get_value_or_future__for_each_line);
  use_read_only(NULL, "fragment_of", &get__fragment_of, &get_value_or_future__fragment_of);
  use_read_only(NULL, "from", &get__from, &get_value_or_future__from);
  use_read_only(NULL, "from_down_to", &get__from_down_to, &get_value_or_future__from_down_to);
  use_read_only(NULL, "from_to", &get__from_to, &get_value_or_future__from_to);
  use_read_only(NULL, "functor_of", &get__functor_of, &get_value_or_future__functor_of);
  use_read_only(NULL, "generate_dispatcher_function", &get__generate_dispatcher_function, &get_value_or_future__generate_dispatcher_function);
  use_read_only(NULL, "generate_statement", &get__generate_statement, &get_value_or_future__generate_statement);
  use_read_only(NULL, "global_names", &get__global_names, &get_value_or_future__global_names);
  use_read_only(NULL, "has_prefix", &get__has_prefix, &get_value_or_future__has_prefix);
  use_read_only(NULL, "has_suffix", &get__has_suffix, &get_value_or_future__has_suffix);
  use_read_only(NULL, "hex", &get__hex, &get_value_or_future__hex);
  use_read_only(NULL, "identifier_of", &get__identifier_of, &get_value_or_future__identifier_of);
  use_read_only(NULL, "if", &get__if, &get_value_or_future__if);
  use_read_only(NULL, "inc", &get__inc, &get_value_or_future__inc);
  use_read_only(NULL, "indent_marker", &get__indent_marker, &get_value_or_future__indent_marker);
  use_read_only(NULL, "indented", &get__indented, &get_value_or_future__indented);
  use_read_only(NULL, "indents_of", &get__indents_of, &get_value_or_future__indents_of);
  use_read_write(NULL, "index", &get__index, &set__index);
  use_read_only(NULL, "inherited_names_of", &get__inherited_names_of, &get_value_or_future__inherited_names_of);
  use_read_only(NULL, "is_a_constant", &get__is_a_constant, &get_value_or_future__is_a_constant);
  use_read_only(NULL, "is_a_definition", &get__is_a_definition, &get_value_or_future__is_a_definition);
  use_read_only(NULL, "is_a_function_call", &get__is_a_function_call, &get_value_or_future__is_a_function_call);
  use_read_only(NULL, "is_a_key_value_pair", &get__is_a_key_value_pair, &get_value_or_future__is_a_key_value_pair);
  use_read_only(NULL, "is_a_latin_1_string", &get__is_a_latin_1_string, &get_value_or_future__is_a_latin_1_string);
  use_read_only(NULL, "is_a_multi_assign_definition", &get__is_a_multi_assign_definition, &get_value_or_future__is_a_multi_assign_definition);
  use_read_only(NULL, "is_a_parameter", &get__is_a_parameter, &get_value_or_future__is_a_parameter);
  use_read_only(NULL, "is_a_procedure_call", &get__is_a_procedure_call, &get_value_or_future__is_a_procedure_call);
  use_read_only(NULL, "is_a_return", &get__is_a_return, &get_value_or_future__is_a_return);
  use_read_only(NULL, "is_a_single_assign_definition", &get__is_a_single_assign_definition, &get_value_or_future__is_a_single_assign_definition);
  use_read_only(NULL, "is_a_static_definition", &get__is_a_static_definition, &get_value_or_future__is_a_static_definition);
  use_read_only(NULL, "is_a_temporary", &get__is_a_temporary, &get_value_or_future__is_a_temporary);
  use_read_only(NULL, "is_an_assignment", &get__is_an_assignment, &get_value_or_future__is_an_assignment);
  use_read_only(NULL, "is_an_attribute_function_pair", &get__is_an_attribute_function_pair, &get_value_or_future__is_an_attribute_function_pair);
  use_read_only(NULL, "is_an_attribute_value_pair", &get__is_an_attribute_value_pair, &get_value_or_future__is_an_attribute_value_pair);
  use_read_only(NULL, "is_an_expanded_item", &get__is_an_expanded_item, &get_value_or_future__is_an_expanded_item);
  use_read_only(NULL, "is_an_identifier", &get__is_an_identifier, &get_value_or_future__is_an_identifier);
  use_read_only(NULL, "is_an_initialization", &get__is_an_initialization, &get_value_or_future__is_an_initialization);
  use_read_only(NULL, "is_an_optional_item", &get__is_an_optional_item, &get_value_or_future__is_an_optional_item);
  use_read_only(NULL, "is_defined", &get__is_defined, &get_value_or_future__is_defined);
  use_read_only(NULL, "is_empty", &get__is_empty, &get_value_or_future__is_empty);
  use_read_only(NULL, "is_undefined", &get__is_undefined, &get_value_or_future__is_undefined);
  use_read_only(NULL, "key_of", &get__key_of, &get_value_or_future__key_of);
  use_read_only(NULL, "kind_of", &get__kind_of, &get_value_or_future__kind_of);
  use_read_only(NULL, "length_of", &get__length_of, &get_value_or_future__length_of);
  use_read_only(NULL, "line_no_of", &get__line_no_of, &get_value_or_future__line_no_of);
  use_read_only(NULL, "mangled_name_of", &get__mangled_name_of, &get_value_or_future__mangled_name_of);
  use_read_only(NULL, "max", &get__max, &get_value_or_future__max);
  use_read_only(NULL, "might_be_constant", &get__might_be_constant, &get_value_or_future__might_be_constant);
  use_read_only(NULL, "module_name", &get__module_name, &get_value_or_future__module_name);
  use_read_only(NULL, "name_of", &get__name_of, &get_value_or_future__name_of);
  use_read_only(NULL, "namespace_of", &get__namespace_of, &get_value_or_future__namespace_of);
  use_read_only(NULL, "needed_names", &get__needed_names, &get_value_or_future__needed_names);
  use_read_only(NULL, "newline", &get__newline, &get_value_or_future__newline);
  use_read_only(NULL, "next_continuation", &get__next_continuation, &get_value_or_future__next_continuation);
  use_read_only("node", "text_of", &get__node__text_of, &get_value_or_future__node__text_of);
  use_read_only("node", "type_of", &get__node__type_of, &get_value_or_future__node__type_of);
  use_read_only("node", "value_of", &get__node__value_of, &get_value_or_future__node__value_of);
  use_read_only(NULL, "node_of", &get__node_of, &get_value_or_future__node_of);
  use_read_only(NULL, "normalize", &get__normalize, &get_value_or_future__normalize);
  use_read_only(NULL, "not", &get__not, &get_value_or_future__not);
  use_read_only(NULL, "oct", &get__oct, &get_value_or_future__oct);
  use_read_only(NULL, "outdent_marker", &get__outdent_marker, &get_value_or_future__outdent_marker);
  use_read_only(NULL, "output_arguments_of", &get__output_arguments_of, &get_value_or_future__output_arguments_of);
  use_read_only(NULL, "pad_left", &get__pad_left, &get_value_or_future__pad_left);
  use_read_only(NULL, "parameter_count_of", &get__parameter_count_of, &get_value_or_future__parameter_count_of);
  use_read_only(NULL, "parameter_kind_of", &get__parameter_kind_of, &get_value_or_future__parameter_kind_of);
  use_read_only(NULL, "parameters_of", &get__parameters_of, &get_value_or_future__parameters_of);
  use_read_only(NULL, "plus", &get__plus, &get_value_or_future__plus);
  use_read_only(NULL, "privileged_polymorphic_functions", &get__privileged_polymorphic_functions, &get_value_or_future__privileged_polymorphic_functions);
  use_read_only(NULL, "push", &get__push, &get_value_or_future__push);
  use_read_only(NULL, "range", &get__range, &get_value_or_future__range);
  use_read_only(NULL, "replace_all", &get__replace_all, &get_value_or_future__replace_all);
  use_read_only(NULL, "result_count_of", &get__result_count_of, &get_value_or_future__result_count_of);
  use_read_only(NULL, "scope_of", &get__scope_of, &get_value_or_future__scope_of);
  use_read_only(NULL, "show_compiler_debug_info", &get__show_compiler_debug_info, &get_value_or_future__show_compiler_debug_info);
  use_read_only("sim2c", "attribute_function_pair", &get__sim2c__attribute_function_pair, &get_value_or_future__sim2c__attribute_function_pair);
  use_read_only("sim2c", "attribute_value_pair", &get__sim2c__attribute_value_pair, &get_value_or_future__sim2c__attribute_value_pair);
  use_read_only("sim2c", "body", &get__sim2c__body, &get_value_or_future__sim2c__body);
  use_read_only("sim2c", "c_body", &get__sim2c__c_body, &get_value_or_future__sim2c__c_body);
  use_read_only("sim2c", "character_literal", &get__sim2c__character_literal, &get_value_or_future__sim2c__character_literal);
  use_multi_assign_dynamic("sim2c", "current_continuation_info", &get__sim2c__current_continuation_info, &set__sim2c__current_continuation_info, &define__sim2c__current_continuation_info);
  use_read_only("sim2c", "definition", &get__sim2c__definition, &get_value_or_future__sim2c__definition);
  use_read_only("sim2c", "identifier", &get__sim2c__identifier, &get_value_or_future__sim2c__identifier);
  use_read_only("sim2c", "numeric_literal", &get__sim2c__numeric_literal, &get_value_or_future__sim2c__numeric_literal);
  use_read_only("sim2c", "string_literal", &get__sim2c__string_literal, &get_value_or_future__sim2c__string_literal);
  use_read_only("sim2c", "unique_item", &get__sim2c__unique_item, &get_value_or_future__sim2c__unique_item);
  use_read_only(NULL, "source_of", &get__source_of, &get_value_or_future__source_of);
  use_read_only(NULL, "source_position_of", &get__source_position_of, &get_value_or_future__source_position_of);
  use_read_only(NULL, "statements_of", &get__statements_of, &get_value_or_future__statements_of);
  use_read_only("std", "and", &get__std__and, &get_value_or_future__std__and);
  use_read_only("std", "equal", &get__std__equal, &get_value_or_future__std__equal);
  use_read_only("std", "key_value_pair", &get__std__key_value_pair, &get_value_or_future__std__key_value_pair);
  use_read_only("std", "less", &get__std__less, &get_value_or_future__std__less);
  use_read_only("std", "minus", &get__std__minus, &get_value_or_future__std__minus);
  use_read_only("std", "negate", &get__std__negate, &get_value_or_future__std__negate);
  use_read_only("std", "not", &get__std__not, &get_value_or_future__std__not);
  use_read_only("std", "or", &get__std__or, &get_value_or_future__std__or);
  use_read_only("std", "plus", &get__std__plus, &get_value_or_future__std__plus);
  use_read_only("std", "sequence", &get__std__sequence, &get_value_or_future__std__sequence);
  use_read_only("std", "string", &get__std__string, &get_value_or_future__std__string);
  use_read_only("std", "value_of", &get__std__value_of, &get_value_or_future__std__value_of);
  use_read_only(NULL, "string", &get__string, &get_value_or_future__string);
  use_read_only(NULL, "submodule_no_of", &get__submodule_no_of, &get_value_or_future__submodule_no_of);
  use_read_only(NULL, "suffix", &get__suffix, &get_value_or_future__suffix);
  use_read_only(NULL, "temporary_count_of", &get__temporary_count_of, &get_value_or_future__temporary_count_of);
  use_polymorphic_function(NULL, "to_c", &get__to_c, &poly_idx__to_c);
  use_read_only(NULL, "to_integer", &get__to_integer, &get_value_or_future__to_integer);
  use_read_only(NULL, "to_lower_case", &get__to_lower_case, &get_value_or_future__to_lower_case);
  use_read_only(NULL, "to_string", &get__to_string, &get_value_or_future__to_string);
  use_read_only(NULL, "trim", &get__trim, &get_value_or_future__trim);
  use_read_only(NULL, "true", &get__true, &get_value_or_future__true);
  use_read_only(NULL, "truncate_behind", &get__truncate_behind, &get_value_or_future__truncate_behind);
  use_read_only(NULL, "truncate_from", &get__truncate_from, &get_value_or_future__truncate_from);
  use_read_only(NULL, "truncate_until", &get__truncate_until, &get_value_or_future__truncate_until);
  use_read_only("types", "grammar_node", &get__types__grammar_node, &get_value_or_future__types__grammar_node);
  use_read_only(NULL, "undefined", &get__undefined, &get_value_or_future__undefined);
  use_read_only(NULL, "unless", &get__unless, &get_value_or_future__unless);
  use_read_only(NULL, "until", &get__until, &get_value_or_future__until);
  use_read_only(NULL, "use_literal", &get__use_literal, &get_value_or_future__use_literal);
  use_read_only(NULL, "variable_kind_of", &get__variable_kind_of, &get_value_or_future__variable_kind_of);
  use_read_only(NULL, "vtable_entries", &get__vtable_entries, &get_value_or_future__vtable_entries);
  use_read_only(NULL, "while", &get__while, &get_value_or_future__while);
  use_read_only(NULL, "without_suffix", &get__without_suffix, &get_value_or_future__without_suffix);
  use_read_only(NULL, "write", &get__write, &get_value_or_future__write);
  use_read_only(NULL, "write_source_as_remark", &get__write_source_as_remark, &get_value_or_future__write_source_as_remark);
  use_read_only(NULL, "write_to", &get__write_to, &get_value_or_future__write_to);
  use_single_assign_dynamic(NULL, "write_to_continuation_table", &get__write_to_continuation_table, &define__write_to_continuation_table);
  use_read_only(NULL, "write_to_declarations", &get__write_to_declarations, &get_value_or_future__write_to_declarations);
  use_read_only(NULL, "write_to_delayed_continuation_table", &get__write_to_delayed_continuation_table, &get_value_or_future__write_to_delayed_continuation_table);
  use_read_only(NULL, "write_to_generated_collections", &get__write_to_generated_collections, &get_value_or_future__write_to_generated_collections);
  use_read_only(NULL, "write_to_global_variable_declarations", &get__write_to_global_variable_declarations, &get_value_or_future__write_to_global_variable_declarations);
  use_read_only(NULL, "write_to_phase_1", &get__write_to_phase_1, &get_value_or_future__write_to_phase_1);
  use_read_only(NULL, "write_to_phase_2", &get__write_to_phase_2, &get_value_or_future__write_to_phase_2);
  use_read_only(NULL, "write_to_phase_3", &get__write_to_phase_3, &get_value_or_future__write_to_phase_3);
  use_read_only(NULL, "write_to_phase_4", &get__write_to_phase_4, &get_value_or_future__write_to_phase_4);
  use_read_only(NULL, "write_to_phase_5", &get__write_to_phase_5, &get_value_or_future__write_to_phase_5);
  use_read_only(NULL, "write_to_top_level_variable_declarations", &get__write_to_top_level_variable_declarations, &get_value_or_future__write_to_top_level_variable_declarations);
  use_read_only(NULL, "write_to_top_level_variable_names", &get__write_to_top_level_variable_names, &get_value_or_future__write_to_top_level_variable_names);
  use_read_only(NULL, "writeln", &get__writeln, &get_value_or_future__writeln);
  define_method("types", "grammar_node", poly_idx__to_c, func__30_1);
  define_method("sim2c", "body", poly_idx__to_c, func__31_1);
  define_method("sim2c", "definition", poly_idx__to_c, func__32_1);
  define_method("sim2c", "attribute_value_pair", poly_idx__to_c, func__33_1);
  define_method("sim2c", "attribute_function_pair", poly_idx__to_c, func__34_1);
  define_method("sim2c", "numeric_literal", poly_idx__to_c, func__35_1);
  define_method("sim2c", "character_literal", poly_idx__to_c, func__36_1);
  define_method("sim2c", "string_literal", poly_idx__to_c, func__39_1);
  define_method("sim2c", "unique_item", poly_idx__to_c, func__40_1);
  define_method("sim2c", "identifier", poly_idx__to_c, func__41_1);
  define_method("sim2c", "c_body", poly_idx__to_c, func__42_1);
}

static int already_run_phase_4 = false;

EXPORT void phase_4__c_code_generator(void) {
  if (already_run_phase_4) return;
  already_run_phase_4 = true;
  assign_value(&character__92, from_uchar32(92));
  assign_value(&character__47, from_uchar32(47));
  assign_value(&character__160, from_uchar32(160));
  assign_value(&character__10, from_uchar32(10));
  assign_value(&number__0, from_uint32(0U));
  assign_value(&number__3, from_uint32(3U));
  assign_value(&character__126, from_uchar32(126));
  assign_value(&character__95, from_uchar32(95));
  assign_value(&character__40, from_uchar32(40));
  assign_value(&character__34, from_uchar32(34));
  assign_value(&character__255, from_uchar32(255));
  assign_value(&number__5, from_uint32(5U));
  assign_value(&character__39, from_uchar32(39));
  assign_value(&character__32, from_uchar32(32));
  assign_value(&number__9, from_uint32(9U));
  assign_value(&character__125, from_uchar32(125));
  assign_value(&character__41, from_uchar32(41));
  assign_value(&character__59, from_uchar32(59));
  assign_value(&number__1, from_uint32(1U));
  assign_value(&number__2, from_uint32(2U));
  assign_value(&character__42, from_uchar32(42));
  assign_value(&var.sim2c__to_c, create_function(type__sim2c__to_c, -1));
  maybe_initialize_future(get__sim2c__suffix(), get__undefined());
  define__level(number__1);
  maybe_initialize_future(get__current_locals(), get__empty_table());
  maybe_initialize_future(get__current_frame(), get__undefined());
  maybe_initialize_future(get__is_a_shared_local(), get__empty_set());
  maybe_initialize_future(get__temporary_offset(), get__undefined());
  assign_variable(&var._var_name, &func__9_1);
  assign_variable(&var._var_entry, &func__10_1);
  assign_variable(&var._insert_delayed, &func__11_1);
  assign_variable(&var._delayed, &func__12_1);
  assign_variable(&var.sim2c__begin_continuation, &func__13_1);
  assign_variable(&var.sim2c__end_continuation, &func__14_1);
  assign_variable(&var.sim2c__next_continuation, &func__15_1);
  assign_variable(&var._count_arguments, &func__16_1);
  assign_variable(&var._generate_c_arguments, &func__17_1);
  assign_variable(&var._get_func_and_myself, &func__18_1);
  assign_variable(&var.sim2c__assignment_to_c, &func__19_1);
  assign_variable(&var._assign_argument_or_result, &func__20_1);
  assign_variable(&var._extract, &func__21_1);
  assign_variable(&var._write_as_remark, &func__22_1);
  assign_variable(&var._compute_column_no, &func__23_1);
  assign_variable(&var._compute_source_text_info, &func__24_1);
  assign_variable(&var.sim2c__write_source_as_remark, &func__25_1);
  assign_variable(&var._get_kind, &func__29_1);
  assign_variable(&var._to_c_string, &func__37_1);
  assign_variable(&var._register_string, &func__38_1);
  assign_variable(&var._extract_destination, &func__43_1);
  assign_variable(&var.sim2c__is_single_assign, &func__44_1);
  assign_variable(&var.sim2c__might_be_constant, &func__45_1);
  assign_variable(&var._assign, &func__46_1);
  assign_variable(&var.sim2c__define_variable, &func__47_1);
  assign_variable(&var._namespace_argument, &func__48_1);
  assign_variable(&var.sim2c__define_attribute, &func__49_1);
  assign_variable(&var.sim2c__define_method, &func__50_1);
  assign_variable(&var.sim2c__define_type_function, &func__51_1);
  assign_variable(&var.sim2c__define_polymorphic_function, &func__52_1);
  assign_variable(&var.sim2c__define_c_code, &func__53_1);
  assign_variable(&var._assign_attributes, &func__54_1);
  assign_variable(&var.sim2c__generate_statement, &func__55_1);
}

static int already_run_phase_5 = false;

EXPORT void phase_5__c_code_generator(void) {
  if (already_run_phase_5) return;
  already_run_phase_5 = true;
  assign_value(&func__9_1, create_function(entry__9_1, 1));
  assign_value(&func__10_1, create_function(entry__10_1, 1));
  assign_value(&func__11_1, create_function(entry__11_1, 0));
  assign_value(&func__12_1, create_function(entry__12_1, 1));
  assign_value(&func__13_16, create_function(entry__13_16, 0));
  assign_value(&func__13_20, create_function(entry__13_20, 0));
  assign_value(&func__13_1, create_function(entry__13_1, 1));
  assign_value(&func__14_3, create_function(entry__14_3, 0));
  assign_value(&func__14_7, create_function(entry__14_7, 0));
  assign_value(&func__14_1, create_function(entry__14_1, 0));
  assign_value(&func__15_1, create_function(entry__15_1, 1));
  assign_value(&func__16_1, create_function(entry__16_1, 1));
  assign_value(&func__17_32, create_function(entry__17_32, 0));
  assign_value(&func__17_1, create_function(entry__17_1, -1));
  assign_value(&func__18_7, create_function(entry__18_7, 0));
  assign_value(&func__18_9, create_function(entry__18_9, 0));
  assign_value(&func__18_1, create_function(entry__18_1, -1));
  assign_value(&func__19_1, create_function(entry__19_1, -1));
  assign_value(&func__20_1, create_function(entry__20_1, -1));
  assign_value(&func__21_51, create_function(entry__21_51, 0));
  assign_value(&func__21_103, create_function(entry__21_103, 0));
  assign_value(&func__21_129, create_function(entry__21_129, 0));
  assign_value(&func__21_155, create_function(entry__21_155, 1));
  assign_value(&func__21_181, create_function(entry__21_181, 0));
  assign_value(&func__21_1, create_function(entry__21_1, 2));
  assign_value(&func__22_1, create_function(entry__22_1, 1));
  assign_value(&func__23_1, create_function(entry__23_1, 1));
  assign_value(&func__24_57, create_function(entry__24_57, 0));
  assign_value(&func__24_119, create_function(entry__24_119, 0));
  assign_value(&func__24_1, create_function(entry__24_1, -1));
  assign_value(&func__25_1, create_function(entry__25_1, 1));
  assign_value(&func__29_15, create_function(entry__29_15, 0));
  assign_value(&func__29_16, create_function(entry__29_16, 0));
  assign_value(&func__29_1, create_function(entry__29_1, 1));
  assign_value(&func__30_1, create_function(entry__30_1, 1));
  assign_value(&func__31_16, create_function(entry__31_16, 0));
  assign_value(&func__31_7, create_function(entry__31_7, 1));
  assign_value(&func__31_29, create_function(entry__31_29, 0));
  assign_value(&func__31_31, create_function(entry__31_31, 0));
  assign_value(&func__31_18, create_function(entry__31_18, 1));
  assign_value(&func__31_112, create_function(entry__31_112, 0));
  assign_value(&func__31_149, create_function(entry__31_149, 0));
  assign_value(&func__31_156, create_function(entry__31_156, 0));
  assign_value(&func__31_179, create_function(entry__31_179, 0));
  assign_value(&func__31_172, create_function(entry__31_172, 2));
  assign_value(&func__31_201, create_function(entry__31_201, 0));
  assign_value(&func__31_317, create_function(entry__31_317, 1));
  assign_value(&func__31_369, create_function(entry__31_369, 0));
  assign_value(&func__31_371, create_function(entry__31_371, 0));
  assign_value(&func__31_1, create_function(entry__31_1, 1));
  assign_value(&func__32_1, create_function(entry__32_1, 1));
  assign_value(&func__33_1, create_function(entry__33_1, 1));
  assign_value(&func__34_1, create_function(entry__34_1, 1));
  assign_value(&func__35_1, create_function(entry__35_1, 1));
  assign_value(&func__36_1, create_function(entry__36_1, 1));
  assign_value(&func__37_1, create_function(entry__37_1, 1));
  assign_value(&func__38_27, create_function(entry__38_27, 1));
  assign_value(&func__38_59, create_function(entry__38_59, 0));
  assign_value(&func__38_75, create_function(entry__38_75, 0));
  assign_value(&func__38_1, create_function(entry__38_1, 1));
  assign_value(&func__39_1, create_function(entry__39_1, 1));
  assign_value(&func__40_1, create_function(entry__40_1, 1));
  assign_value(&func__41_1, create_function(entry__41_1, 1));
  assign_value(&func__42_18, create_function(entry__42_18, 0));
  assign_value(&func__42_1, create_function(entry__42_1, 1));
  assign_value(&func__43_1, create_function(entry__43_1, 1));
  assign_value(&func__44_18, create_function(entry__44_18, 0));
  assign_value(&func__44_1, create_function(entry__44_1, 1));
  assign_value(&func__45_18, create_function(entry__45_18, 0));
  assign_value(&func__45_1, create_function(entry__45_1, 1));
  assign_value(&func__46_1, create_function(entry__46_1, 2));
  assign_value(&func__47_1, create_function(entry__47_1, 2));
  assign_value(&func__48_7, create_function(entry__48_7, 0));
  assign_value(&func__48_1, create_function(entry__48_1, 1));
  assign_value(&func__49_1, create_function(entry__49_1, 2));
  assign_value(&func__50_1, create_function(entry__50_1, 2));
  assign_value(&func__51_1, create_function(entry__51_1, 2));
  assign_value(&func__52_3, create_function(entry__52_3, 0));
  assign_value(&func__52_5, create_function(entry__52_5, 0));
  assign_value(&func__52_27, create_function(entry__52_27, 0));
  assign_value(&func__52_1, create_function(entry__52_1, 2));
  assign_value(&func__53_62, create_function(entry__53_62, 0));
  assign_value(&func__53_64, create_function(entry__53_64, 0));
  assign_value(&func__53_66, create_function(entry__53_66, 0));
  assign_value(&func__53_68, create_function(entry__53_68, 0));
  assign_value(&func__53_75, create_function(entry__53_75, 0));
  assign_value(&func__53_80, create_function(entry__53_80, 0));
  assign_value(&func__53_86, create_function(entry__53_86, 0));
  assign_value(&func__53_93, create_function(entry__53_93, 0));
  assign_value(&func__53_147, create_function(entry__53_147, 0));
  assign_value(&func__53_146, create_function(entry__53_146, 0));
  assign_value(&func__53_122, create_function(entry__53_122, 1));
  assign_value(&func__53_239, create_function(entry__53_239, 0));
  assign_value(&func__53_343, create_function(entry__53_343, 0));
  assign_value(&func__53_345, create_function(entry__53_345, 0));
  assign_value(&func__53_1, create_function(entry__53_1, 1));
  assign_value(&func__54_15, create_function(entry__54_15, 0));
  assign_value(&func__54_16, create_function(entry__54_16, 0));
  assign_value(&func__54_7, create_function(entry__54_7, 1));
  assign_value(&func__54_1, create_function(entry__54_1, 3));
  assign_value(&func__55_5, create_function(entry__55_5, 0));
  assign_value(&func__55_9, create_function(entry__55_9, 0));
  assign_value(&func__55_11, create_function(entry__55_11, 0));
  assign_value(&func__55_57, create_function(entry__55_57, 0));
  assign_value(&func__55_65, create_function(entry__55_65, 0));
  assign_value(&func__55_1, create_function(entry__55_1, 1));
  register_collector(collect__c_code_generator);
}
