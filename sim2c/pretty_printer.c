/**********************
D E C L A R A T I O N S
**********************/

#ifndef IMPORT
  #define IMPORT extern
#endif

#ifndef EXPORT
  #define EXPORT
#endif

#ifndef NULL
  #define NULL ((void *)0)
#endif
#define false 0
#define true 1
typedef __INT8_TYPE__ int8_t;
typedef __INT16_TYPE__ int16_t;
typedef __INT32_TYPE__ int32_t;
typedef __INT64_TYPE__ int64_t;
typedef __INTPTR_TYPE__ intptr_t;

#ifdef __UINT8_TYPE__
  typedef __UINT8_TYPE__ uint8_t;
#else
  typedef unsigned __INT8_TYPE__ uint8_t;
#endif

#ifdef __UINT16_TYPE__
  typedef __UINT16_TYPE__ uint16_t;
#else
  typedef unsigned __INT16_TYPE__ uint16_t;
#endif

#ifdef __UINT32_TYPE__
  typedef __UINT32_TYPE__ uint32_t;
#else
  typedef unsigned __INT32_TYPE__ uint32_t;
#endif

#ifdef __UINT64_TYPE__
  typedef __UINT64_TYPE__ uint64_t;
#else
  typedef unsigned __INT64_TYPE__ uint64_t;
#endif

#ifdef __UINTPTR_TYPE__
  typedef __UINTPTR_TYPE__ uintptr_t;
#else
  typedef unsigned __INTPTR_TYPE__ uintptr_t;
#endif
typedef __SIZE_TYPE__ size_t;
typedef union NODE NODE;
IMPORT void *coll_node_buf;
IMPORT void *coll_node_buf_end;
typedef void (*DESTRUCTOR)(void *);
typedef struct MEMORY_BLOCK {
  struct MEMORY_BLOCK *link;
  long mark;
  DESTRUCTOR destructor;
} MEMORY_BLOCK;
IMPORT long current_mark;
typedef void (*FUNC)(void);
typedef NODE *(*NODE_GETTER)(void);
typedef void (*NODE_SETTER)(NODE *);
IMPORT NODE *get_dynamic_slot(int id);
IMPORT void define_dynamic_slot(int id, NODE *node);
typedef struct FRAME_INFO {
  int var_count;
  const char *var_names[];
} FRAME_INFO;
IMPORT NODE *get_dynamic_cell(int id);
IMPORT void set_dynamic_cell(int id, NODE *node);
IMPORT void define_dynamic_cell(int id, NODE *node);
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define REGISTER register
#else
  #define REGISTER IMPORT
#endif
typedef struct FRAME {
  FUNC cont;
  struct FRAME *caller_frame;
  long caller_result_count;
  long slot_count;
  NODE *slots[0];
} FRAME;
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define ASM(x) asm(x)
#else
  #define ASM(x)
#endif
REGISTER FRAME *arguments ASM("r12");
typedef struct CONTINUATION_INFO {
  FUNC continuation;
  struct FRAME_INFO *frame_info;
  uint16_t first_line;
  uint16_t last_line;
  uint8_t first_column;
  uint8_t last_column;
  uint8_t submodule_index;
  uint8_t unused;
} CONTINUATION_INFO;
typedef void *COLLECTOR(void *);
IMPORT uint32_t to_int8(NODE *node);
IMPORT uint64_t to_int16(NODE *node);
IMPORT uint32_t to_int32(NODE *node);
IMPORT uint64_t to_int64(NODE *node);
IMPORT uint32_t to_uint8(NODE *node);
IMPORT uint64_t to_uint16(NODE *node);
IMPORT uint32_t to_uint32(NODE *node);
IMPORT uint64_t to_uint64(NODE *node);
IMPORT uint32_t to_uchar32(NODE *node);
IMPORT int to_bool(NODE *node);
IMPORT int to_int(NODE *node);
IMPORT long to_long(NODE *node);
IMPORT double to_double(NODE *node);
IMPORT char *to_c_string(NODE *node);
IMPORT uint8_t *to_octets(NODE *node, long *size_p);
IMPORT NODE *get_item_of(NODE *node, long idx);
IMPORT long length_of(NODE *node);
IMPORT void unfold(NODE *node);
IMPORT long debug_string(NODE *node, int indent, int max_depth, char *buf);
typedef struct VTABLE {
  size_t size;
  COLLECTOR *collect;
  int8_t (*to_int8)(NODE *);
  int16_t (*to_int16)(NODE *);
  int32_t (*to_int32)(NODE *);
  int64_t (*to_int64)(NODE *);
  uint8_t (*to_uint8)(NODE *);
  uint16_t (*to_uint16)(NODE *);
  uint32_t (*to_uint32)(NODE *);
  uint64_t (*to_uint64)(NODE *);
  uint32_t (*to_uchar32)(NODE *);
  int (*to_bool)(NODE *);
  int (*to_int)(NODE *);
  long (*to_long)(NODE *);
  double (*to_double)(NODE *);
  char *(*to_c_string)(NODE *);
  uint8_t *(*to_octets)(NODE *, long *size_p);
  NODE *(*get_item_of)(NODE *, long idx);
  long (*length_of)(NODE *);
  void (*unfold)(NODE *);
  long (*debug_string)(NODE *, int indent, int max_depth, char *buf);
} VTABLE;
typedef struct OCTREE {
  struct OCTREE *nodes[8];
} OCTREE;
typedef struct ATTRIBUTES {
  struct VTABLE *vtable;
  struct OCTREE *nodes[7];
} ATTRIBUTES;
typedef struct DYNAMICS {
  struct OCTREE *nodes[8];
} DYNAMICS;
typedef struct CONTINUATION {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int result_count;
  struct FRAME *frame;
  struct DYNAMICS *dynamics;
  struct FRAME *exit_frame; // used by exit-functions
} CONTINUATION;
typedef struct CLOSURE {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int parameter_count;
  struct FRAME *frame;
} CLOSURE;
REGISTER NODE *myself ASM("r13");
IMPORT NODE *get_attribute(NODE *node, int idx);
REGISTER int argument_count ASM("ebx");
IMPORT void invalid_arguments_error(void);
IMPORT NODE *clone_object_and_attributes(NODE *node);
IMPORT void *update_start_p;
IMPORT void *node_p;
IMPORT void set_attribute_value(ATTRIBUTES *attributes, int idx, void *attr);
REGISTER FUNC func ASM("r14");
REGISTER FRAME *frame ASM("r15");
typedef struct MODULE_INFO {
  struct MODULE_INFO *link;
  const char *name;
  struct CONTINUATION_INFO *continuation_info;
  int continuation_count;
  NODE **var_tab;
  const char **var_names;
  int top_level_count;
  const char **used_namespaces;
  const char *filenames[];
} MODULE_INFO;
IMPORT void allocate_initialized_frame_gc(int slot_idx, int slot_count);
IMPORT void initialize_maybe_future(NODE *var, NODE *val);
IMPORT int result_count;
IMPORT void invalid_results_error(void);
IMPORT void initialize_future(NODE *var, NODE *val);
IMPORT NODE *undefined;
IMPORT NODE *create_closure(FUNC type, int par_count);
IMPORT NODE *create_cell(void);
IMPORT NODE *create_cell_with_contents(NODE *contents);
typedef struct CELL {
  FUNC type;
  struct ATTRIBUTES *attributes;
  NODE *contents;
} CELL;
IMPORT NODE *empty_string;
IMPORT NODE *create_continuation(void);
IMPORT NODE *create_future(void);
IMPORT NODE *zero;
IMPORT void too_few_arguments_error(void);
IMPORT void too_many_arguments_error(void);
IMPORT NODE *create_continuation_with_exit(FUNC exit_func);
IMPORT void continuation_type_function(void);
IMPORT NODE *collect_node(NODE *node);
IMPORT void register_module_info(MODULE_INFO *info);
IMPORT void register_polymorphic_function(const char *name, int *id_p);
IMPORT NODE *from_uchar32(unsigned int chr);
IMPORT NODE *from_uint32(uint32_t val);
IMPORT NODE *from_latin_1_string(const char *str, long len);
IMPORT void set_module(const char *name);
IMPORT void set_used_namespaces(const char **namespaces);
IMPORT NODE *register_unique_item(const char *name);
IMPORT void assign_value(NODE **dest, NODE *val);
IMPORT void define_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER definer,
  int *id_p
);
IMPORT void register_dynamic(int *id_p);
IMPORT void define_single_assign_static(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE **var_p
);
IMPORT void use_read_only(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_GETTER *get_value_or_future
);
IMPORT void use_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER *getter, int *id
);
IMPORT void use_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *definer
);
IMPORT void def_attribute(NODE **var_p, int idx, void *attr);
IMPORT void define_method(
  const char *namespace, const char *name,
  int id, NODE *method
);
IMPORT NODE *create_function(FUNC func, int par_count);
IMPORT void maybe_initialize_future(NODE *var, NODE *val);
IMPORT void assign_variable(NODE **dest, NODE **var_p);
IMPORT void register_collector(FUNC collector);


#if UINTPTR_MAX == 0xffffffffffffffff
  #define FIRST_INVALID_ADDRESS 0xc000000000000000UL
  #define SAMPLE_POINTER ((void *)0x123456789abcdef0UL)
#else
  #define FIRST_INVALID_ADDRESS 0xc0000000
  #define SAMPLE_POINTER ((void *)0x12345678)
#endif

#define MAKE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)+1))
#define RETRIEVE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)-1))
#define CONTAINS_AN_ATTRIBUTE_VALUE(node) (((uintptr_t)node)&1)

#define ENCODE_ADDRESS(addr) ((void *)((uintptr_t)addr | 2))
#define DECODE_ADDRESS(addr) ((void *)((uintptr_t)addr & -3))
#define IS_AN_INVALID_ADDRESS(addr) ((uintptr_t)addr & 2)

#define MSB (1L << (8*sizeof(void *)-1))
#define ENCODE_TO_LENGTH(addr) ((void *)(((uintptr_t)addr >> 1) | MSB))
#define DECODE_FROM_LENGTH(addr) ((void *)((uintptr_t)addr << 1))
#define IS_AN_INVALID_LENGTH(addr) ((uintptr_t)addr & MSB)

#define IS_COLLECTED(addr) (((void *)(addr)) >= coll_node_buf && ((void *)(addr)) < coll_node_buf_end)
#define IS_OLD(addr) false
#define MARK(addr) (((MEMORY_BLOCK *)(addr))-1)->mark = current_mark;

#define ALLOCATION_SIZE(size) (((size)+sizeof(void *)-1)&-sizeof(void *))
#define TYPEOF(node) (node)->type
#define SIZEOF(node) (node)->attributes->vtable->size

#ifdef WITHIN_LIBRARY
  #define DEBUG_FILENAME(filename) filename
#else
  #define DEBUG_FILENAME(filename) "./" filename
#endif

#ifdef __CYGWIN__
  extern FUNC invalid_continuation;
#else
  extern void invalid_continuation(void);
#endif
static NODE_GETTER get__ATTRIBUTE_KIND;
static NODE_GETTER get_value_or_future__ATTRIBUTE_KIND;
static NODE_GETTER get__CONTINUATION_PARAMETER;
static NODE_GETTER get_value_or_future__CONTINUATION_PARAMETER;
static NODE_GETTER get__HIGHEST_PRECEDENCE;
static NODE_GETTER get_value_or_future__HIGHEST_PRECEDENCE;
static NODE_GETTER get__INFIX_PRECEDENCE;
static NODE_GETTER get_value_or_future__INFIX_PRECEDENCE;
static NODE_GETTER get__IN_OUT_PARAMETER;
static NODE_GETTER get_value_or_future__IN_OUT_PARAMETER;
static NODE_GETTER get__IN_PARAMETER;
static NODE_GETTER get_value_or_future__IN_PARAMETER;
static NODE_GETTER get__METHOD_KIND;
static NODE_GETTER get_value_or_future__METHOD_KIND;
static NODE_GETTER get__MYSELF_PARAMETER;
static NODE_GETTER get_value_or_future__MYSELF_PARAMETER;
static NODE_GETTER get__OUT_PARAMETER;
static NODE_GETTER get_value_or_future__OUT_PARAMETER;
static NODE_GETTER get__all_of;
static NODE_GETTER get_value_or_future__all_of;
static NODE_GETTER get__alt;
static NODE_GETTER get_value_or_future__alt;
static NODE_GETTER get__any_of;
static NODE_GETTER get_value_or_future__any_of;
static NODE_GETTER get__append;
static NODE_GETTER get_value_or_future__append;
static NODE_GETTER get__arguments_of;
static NODE_GETTER get_value_or_future__arguments_of;
static NODE_GETTER get__attribute_kind_of;
static NODE_GETTER get_value_or_future__attribute_kind_of;
static NODE_GETTER get__attribute_of;
static NODE_GETTER get_value_or_future__attribute_of;
static NODE_GETTER get__base_of;
static NODE_GETTER get_value_or_future__base_of;
static NODE_GETTER get__case;
static NODE_GETTER get_value_or_future__case;
static NODE_GETTER get__character;
static NODE_GETTER get_value_or_future__character;
static NODE_GETTER get__character_names;
static NODE_GETTER get_value_or_future__character_names;
static NODE_GETTER get__cond;
static NODE_GETTER get_value_or_future__cond;
static NODE_GETTER get__contains;
static NODE_GETTER get_value_or_future__contains;
static NODE_GETTER get__default_value_of;
static NODE_GETTER get_value_or_future__default_value_of;
static NODE_GETTER get__do;
static NODE_GETTER get_value_or_future__do;
static NODE_GETTER get__do_while;
static NODE_GETTER get_value_or_future__do_while;
static NODE_GETTER get__dup;
static NODE_GETTER get_value_or_future__dup;
static NODE_GETTER get__empty_list;
static NODE_GETTER get_value_or_future__empty_list;
static NODE_GETTER get__empty_table;
static NODE_GETTER get_value_or_future__empty_table;
static NODE_GETTER get__enumeration_no_of;
static NODE_GETTER get_value_or_future__enumeration_no_of;
static NODE_GETTER get__false;
static NODE_GETTER get_value_or_future__false;
static NODE_GETTER get__for_each;
static NODE_GETTER get_value_or_future__for_each;
static NODE_GETTER get__for_each_from_to;
static NODE_GETTER get_value_or_future__for_each_from_to;
static NODE_GETTER get__for_each_line;
static NODE_GETTER get_value_or_future__for_each_line;
static NODE_GETTER get__from;
static NODE_GETTER get_value_or_future__from;
static NODE_GETTER get__from_down_to;
static NODE_GETTER get_value_or_future__from_down_to;
static NODE_GETTER get__functor_of;
static NODE_GETTER get_value_or_future__functor_of;
static int poly_idx__grammar__match;
static NODE_GETTER get__grammar__match;
static NODE_GETTER get__has_minimum_length;
static NODE_GETTER get_value_or_future__has_minimum_length;
static NODE_GETTER get__has_prefix;
static NODE_GETTER get_value_or_future__has_prefix;
static NODE_GETTER get__has_suffix;
static NODE_GETTER get_value_or_future__has_suffix;
static NODE_GETTER get__hex;
static NODE_GETTER get_value_or_future__hex;
static NODE_GETTER get__hide_body_statements;
static NODE_GETTER get_value_or_future__hide_body_statements;
static NODE_GETTER get__identifier_of;
static NODE_GETTER get_value_or_future__identifier_of;
static NODE_GETTER get__if;
static NODE_GETTER get_value_or_future__if;
static NODE_GETTER get__inc;
static NODE_GETTER get_value_or_future__inc;
static NODE_GETTER get__is_a_body;
static NODE_GETTER get_value_or_future__is_a_body;
static NODE_GETTER get__is_a_definition;
static NODE_GETTER get_value_or_future__is_a_definition;
static NODE_GETTER get__is_a_destination;
static NODE_GETTER get_value_or_future__is_a_destination;
static NODE_GETTER get__is_a_function_call;
static NODE_GETTER get_value_or_future__is_a_function_call;
static NODE_GETTER get__is_a_letter;
static NODE_GETTER get_value_or_future__is_a_letter;
static NODE_GETTER get__is_a_method_definition;
static NODE_GETTER get_value_or_future__is_a_method_definition;
static NODE_GETTER get__is_a_parameter;
static NODE_GETTER get_value_or_future__is_a_parameter;
static NODE_GETTER get__is_a_polymorphic_function_constant;
static NODE_GETTER get_value_or_future__is_a_polymorphic_function_constant;
static NODE_GETTER get__is_a_return;
static NODE_GETTER get_value_or_future__is_a_return;
static NODE_GETTER get__is_a_setter;
static NODE_GETTER get_value_or_future__is_a_setter;
static NODE_GETTER get__is_a_string_literal;
static NODE_GETTER get_value_or_future__is_a_string_literal;
static NODE_GETTER get__is_a_string_template;
static NODE_GETTER get_value_or_future__is_a_string_template;
static NODE_GETTER get__is_a_unique_item_constant;
static NODE_GETTER get_value_or_future__is_a_unique_item_constant;
static NODE_GETTER get__is_an_assignment;
static NODE_GETTER get_value_or_future__is_an_assignment;
static NODE_GETTER get__is_an_attribute_access;
static NODE_GETTER get_value_or_future__is_an_attribute_access;
static NODE_GETTER get__is_an_attribute_value_pair;
static NODE_GETTER get_value_or_future__is_an_attribute_value_pair;
static NODE_GETTER get__is_an_expanded_item;
static NODE_GETTER get_value_or_future__is_an_expanded_item;
static NODE_GETTER get__is_an_identifier;
static NODE_GETTER get_value_or_future__is_an_identifier;
static NODE_GETTER get__is_an_operator_symbol;
static NODE_GETTER get_value_or_future__is_an_operator_symbol;
static NODE_GETTER get__is_an_optional_item;
static NODE_GETTER get_value_or_future__is_an_optional_item;
static NODE_GETTER get__is_defined;
static NODE_GETTER get_value_or_future__is_defined;
static NODE_GETTER get__is_empty;
static NODE_GETTER get_value_or_future__is_empty;
static NODE_GETTER get__is_in_infix_notation;
static NODE_GETTER get_value_or_future__is_in_infix_notation;
static NODE_GETTER get__is_left_associative;
static NODE_GETTER get_value_or_future__is_left_associative;
static NODE_GETTER get__is_not_used;
static NODE_GETTER get_value_or_future__is_not_used;
static NODE_GETTER get__is_undefined;
static NODE_GETTER get_value_or_future__is_undefined;
static NODE_GETTER get__kind_of;
static NODE_GETTER get_value_or_future__kind_of;
static NODE_GETTER get__length_of;
static NODE_GETTER get_value_or_future__length_of;
static NODE_GETTER get__line_width;
static NODE_SETTER define__line_width;
static NODE_GETTER get__list;
static NODE_GETTER get_value_or_future__list;
static NODE_GETTER get__matches;
static NODE_GETTER get_value_or_future__matches;
static NODE_GETTER get__max;
static NODE_GETTER get_value_or_future__max;
static NODE_GETTER get__minus;
static NODE_GETTER get_value_or_future__minus;
static NODE_GETTER get__name_of;
static NODE_GETTER get_value_or_future__name_of;
static NODE_GETTER get__namespace_alias_of;
static NODE_GETTER get_value_or_future__namespace_alias_of;
static NODE_GETTER get__namespace_of;
static NODE_GETTER get_value_or_future__namespace_of;
static NODE_GETTER get__node__filemask_of;
static NODE_GETTER get_value_or_future__node__filemask_of;
static NODE_GETTER get__node__filename_of;
static NODE_GETTER get_value_or_future__node__filename_of;
static NODE_GETTER get__node__text_of;
static NODE_GETTER get_value_or_future__node__text_of;
static NODE_GETTER get__node__type_of;
static NODE_GETTER get_value_or_future__node__type_of;
static NODE_GETTER get__node__value_of;
static NODE_GETTER get_value_or_future__node__value_of;
static NODE_GETTER get__node_of;
static NODE_GETTER get_value_or_future__node_of;
static NODE_GETTER get__not;
static NODE_GETTER get_value_or_future__not;
static int poly_idx__output_arguments_of;
static NODE_GETTER get__output_arguments_of;
static NODE_GETTER get__parameter_kind_of;
static NODE_GETTER get_value_or_future__parameter_kind_of;
static NODE_GETTER get__parameters_of;
static NODE_GETTER get_value_or_future__parameters_of;
static NODE_GETTER get__pass;
static NODE_GETTER get_value_or_future__pass;
static NODE_GETTER get__plus;
static NODE_GETTER get_value_or_future__plus;
static NODE_GETTER get__precedence;
static NODE_GETTER get_value_or_future__precedence;
static NODE_GETTER get__push;
static NODE_GETTER get_value_or_future__push;
static NODE_GETTER get__put;
static NODE_GETTER get_value_or_future__put;
static NODE_GETTER get__range;
static NODE_GETTER get_value_or_future__range;
static NODE_GETTER get__remark_lines_behind_of;
static NODE_GETTER get_value_or_future__remark_lines_behind_of;
static NODE_GETTER get__remark_lines_of;
static NODE_GETTER get_value_or_future__remark_lines_of;
static NODE_GETTER get__scope_of;
static NODE_GETTER get_value_or_future__scope_of;
static NODE_GETTER get__sim2c__attribute_function_pair;
static NODE_GETTER get_value_or_future__sim2c__attribute_function_pair;
static NODE_GETTER get__sim2c__attribute_value_pair;
static NODE_GETTER get_value_or_future__sim2c__attribute_value_pair;
static NODE_GETTER get__sim2c__backquoted;
static NODE_GETTER get_value_or_future__sim2c__backquoted;
static NODE_GETTER get__sim2c__body;
static NODE_GETTER get_value_or_future__sim2c__body;
static NODE_GETTER get__sim2c__c_code;
static NODE_GETTER get_value_or_future__sim2c__c_code;
static NODE_GETTER get__sim2c__call;
static NODE_GETTER get_value_or_future__sim2c__call;
static NODE_GETTER get__sim2c__character_literal;
static NODE_GETTER get_value_or_future__sim2c__character_literal;
static NODE_GETTER get__sim2c__data_instruction;
static NODE_GETTER get_value_or_future__sim2c__data_instruction;
static NODE_GETTER get__sim2c__define_dynamic_multi;
static NODE_GETTER get_value_or_future__sim2c__define_dynamic_multi;
static NODE_GETTER get__sim2c__define_dynamic_single;
static NODE_GETTER get_value_or_future__sim2c__define_dynamic_single;
static NODE_GETTER get__sim2c__define_static_multi;
static NODE_GETTER get_value_or_future__sim2c__define_static_multi;
static NODE_GETTER get__sim2c__define_static_single;
static NODE_GETTER get_value_or_future__sim2c__define_static_single;
static NODE_GETTER get__sim2c__function_call;
static NODE_GETTER get_value_or_future__sim2c__function_call;
static NODE_GETTER get__sim2c__identifier;
static NODE_GETTER get_value_or_future__sim2c__identifier;
static NODE_GETTER get__sim2c__include_instruction;
static NODE_GETTER get_value_or_future__sim2c__include_instruction;
static NODE_GETTER get__sim2c__link_instruction;
static NODE_GETTER get_value_or_future__sim2c__link_instruction;
static NODE_GETTER get__sim2c__namespace_instruction;
static NODE_GETTER get_value_or_future__sim2c__namespace_instruction;
static NODE_GETTER get__sim2c__numeric_literal;
static NODE_GETTER get_value_or_future__sim2c__numeric_literal;
static NODE_GETTER get__sim2c__polymorphic_function;
static NODE_GETTER get_value_or_future__sim2c__polymorphic_function;
static NODE_GETTER get__sim2c__remark_statement;
static NODE_GETTER get_value_or_future__sim2c__remark_statement;
static NODE_GETTER get__sim2c__require_instruction;
static NODE_GETTER get_value_or_future__sim2c__require_instruction;
static NODE_GETTER get__sim2c__string_literal;
static NODE_GETTER get_value_or_future__sim2c__string_literal;
static NODE_GETTER get__sim2c__unique_item;
static NODE_GETTER get_value_or_future__sim2c__unique_item;
static NODE_GETTER get__sim2c__using_instruction;
static NODE_GETTER get_value_or_future__sim2c__using_instruction;
static NODE_GETTER get__some;
static NODE_GETTER get_value_or_future__some;
static NODE_GETTER get__source_of;
static NODE_GETTER get_value_or_future__source_of;
static NODE_GETTER get__statements_of;
static NODE_GETTER get_value_or_future__statements_of;
static NODE_GETTER get__std__and;
static NODE_GETTER get_value_or_future__std__and;
static NODE_GETTER get__std__equal;
static NODE_GETTER get_value_or_future__std__equal;
static NODE_GETTER get__std__less;
static NODE_GETTER get_value_or_future__std__less;
static NODE_GETTER get__std__minus;
static NODE_GETTER get_value_or_future__std__minus;
static NODE_GETTER get__std__negate;
static NODE_GETTER get_value_or_future__std__negate;
static NODE_GETTER get__std__not;
static NODE_GETTER get_value_or_future__std__not;
static NODE_GETTER get__std__or;
static NODE_GETTER get_value_or_future__std__or;
static NODE_GETTER get__std__plus;
static NODE_GETTER get_value_or_future__std__plus;
static NODE_GETTER get__std__sequence;
static NODE_GETTER get_value_or_future__std__sequence;
static NODE_GETTER get__std__shift_right;
static NODE_GETTER get_value_or_future__std__shift_right;
static NODE_GETTER get__std__spaces;
static NODE_GETTER get_value_or_future__std__spaces;
static NODE_GETTER get__std__string;
static NODE_GETTER get_value_or_future__std__string;
static NODE_GETTER get__std__times;
static NODE_GETTER get_value_or_future__std__times;
static NODE_GETTER get__string;
static NODE_GETTER get_value_or_future__string;
static NODE_GETTER get__to_integer;
static NODE_GETTER get_value_or_future__to_integer;
static int poly_idx__to_string;
static NODE_GETTER get__to_string;
static NODE_GETTER get__true;
static NODE_GETTER get_value_or_future__true;
static NODE_GETTER get__truncate_from;
static NODE_GETTER get_value_or_future__truncate_from;
static NODE_GETTER get__types__grammar_node;
static NODE_GETTER get_value_or_future__types__grammar_node;
static NODE_GETTER get__types__grammar_object;
static NODE_GETTER get_value_or_future__types__grammar_object;
static NODE_GETTER get__undefined;
static NODE_GETTER get_value_or_future__undefined;
static NODE_GETTER get__unless;
static NODE_GETTER get_value_or_future__unless;
static NODE_GETTER get__while;
static NODE_GETTER get_value_or_future__while;
static NODE_GETTER get__write_to;
static NODE_GETTER get_value_or_future__write_to;
static NODE_GETTER get__writeln;
static NODE_GETTER get_value_or_future__writeln;
static NODE_GETTER get__writeln_to;
static NODE_GETTER get_value_or_future__writeln_to;
static struct {
  NODE *_needs_parenthesis;
  NODE *_ALWAYS;
  NODE *_SHEBANG;
  NODE *_REMARK;
  NODE *_CODE_EXCLUSION;
  NODE *_REQUIRE;
  NODE *_NAMESPACE;
  NODE *_USING;
  NODE *_INCLUDE;
  NODE *_LINK;
  NODE *_DATA;
  NODE *_POLYMORPHIC_FUNCTION;
  NODE *_UNIQUE;
  NODE *_PROC;
  NODE *_FUNC;
  NODE *_UNLIMITED;
  NODE *_INDENTATION_MARKER;
  NODE *_INDENTATION_MARKER_HIGH;
  NODE *_INDENTATION;
  NODE *_indentation_string;
  NODE *_line_start_remark_to_string;
  NODE *_add_remark_lines;
  NODE *_add_remark;
  NODE *_add_statement_remark;
  NODE *_add_indented_remark;
  NODE *_all_arguments_of;
  NODE *_argument_to_string;
  NODE *_arguments_to_string;
  NODE *_call_with_remark_to_string;
  NODE *_definition_to_string;
  NODE *_precedence_of;
  NODE *_operator_of;
  NODE *_pair_to_string;
  NODE *_character_to_name;
  NODE *_create_character_table;
  NODE *_escaped_character;
  NODE *_analyze_string_literal;
  NODE *_print_string_literal;
  NODE *_string_template_to_string;
  NODE *sim2c__print_trees;
} var;
static const char *var_names[] = {
  "needs_parenthesis",
  "ALWAYS",
  "SHEBANG",
  "REMARK",
  "CODE_EXCLUSION",
  "REQUIRE",
  "NAMESPACE",
  "USING",
  "INCLUDE",
  "LINK",
  "DATA",
  "POLYMORPHIC_FUNCTION",
  "UNIQUE",
  "PROC",
  "FUNC",
  "UNLIMITED",
  "INDENTATION_MARKER",
  "INDENTATION_MARKER_HIGH",
  "INDENTATION",
  "indentation_string",
  "line_start_remark_to_string",
  "add_remark_lines",
  "add_remark",
  "add_statement_remark",
  "add_indented_remark",
  "all_arguments_of",
  "argument_to_string",
  "arguments_to_string",
  "call_with_remark_to_string",
  "definition_to_string",
  "precedence_of",
  "operator_of",
  "pair_to_string",
  "character_to_name",
  "create_character_table",
  "escaped_character",
  "analyze_string_literal",
  "print_string_literal",
  "string_template_to_string"
};
static int poly_idx__needs_parenthesis;
static void type__needs_parenthesis(void);
static NODE *unique__2_1;
static NODE *unique__3_1;
static NODE *unique__4_1;
static NODE *unique__5_1;
static NODE *unique__6_1;
static NODE *unique__7_1;
static NODE *unique__8_1;
static NODE *unique__9_1;
static NODE *unique__10_1;
static NODE *unique__11_1;
static NODE *unique__12_1;
static NODE *unique__13_1;
static NODE *unique__14_1;
static NODE *unique__15_1;
static int dyna_idx__sim2c__hide_body_statements;
static NODE *get__sim2c__hide_body_statements(void) {
  return get_dynamic_slot(dyna_idx__sim2c__hide_body_statements);
}
static void define__sim2c__hide_body_statements(NODE *node) {
  define_dynamic_slot(dyna_idx__sim2c__hide_body_statements, node);
}
static int dyna_idx__sim2c__line_width;
static NODE *get__sim2c__line_width(void) {
  return get_dynamic_slot(dyna_idx__sim2c__line_width);
}
static void define__sim2c__line_width(NODE *node) {
  define_dynamic_slot(dyna_idx__sim2c__line_width, node);
}
static int dyna_idx__expression_indent;
static NODE *get__expression_indent(void) {
  return get_dynamic_slot(dyna_idx__expression_indent);
}
static void define__expression_indent(NODE *node) {
  define_dynamic_slot(dyna_idx__expression_indent, node);
}
static int dyna_idx__line_end_expression_width;
static NODE *get__line_end_expression_width(void) {
  return get_dynamic_slot(dyna_idx__line_end_expression_width);
}
static void define__line_end_expression_width(NODE *node) {
  define_dynamic_slot(dyna_idx__line_end_expression_width, node);
}
static NODE *func__24_1;
static void entry__24_1(void);
static FRAME_INFO frame__24_1 = {2, {"self", "stream"}};
static void cont__24_2(void);
static NODE *func__24_3;
static void entry__24_3(void);
static FRAME_INFO frame__24_3 = {1, {"stream"}};
static void cont__24_4(void);
static void cont__24_5(void);
static void cont__24_6(void);
static NODE *func__24_7;
static void entry__24_7(void);
static FRAME_INFO frame__24_7 = {1, {"stream"}};
static void cont__24_8(void);
static void cont__24_9(void);
static void cont__24_10(void);
static void cont__24_11(void);
static void cont__24_12(void);
static NODE *func__24_13;
static void entry__24_13(void);
static FRAME_INFO frame__24_13 = {0, {}};
static NODE *func__24_14;
static void entry__24_14(void);
static FRAME_INFO frame__24_14 = {0, {}};
static int dyna_idx__statement_tag;
static NODE *get__statement_tag(void) {
  return get_dynamic_cell(dyna_idx__statement_tag);
}
static void set__statement_tag(NODE *node) {
  set_dynamic_cell(dyna_idx__statement_tag, node);
}
static void define__statement_tag(NODE *node) {
  define_dynamic_cell(dyna_idx__statement_tag, node);
}
static int dyna_idx__spaces;
static NODE *get__spaces(void) {
  return get_dynamic_slot(dyna_idx__spaces);
}
static void define__spaces(NODE *node) {
  define_dynamic_slot(dyna_idx__spaces, node);
}
static NODE *func__27_1;
static void entry__27_1(void);
static FRAME_INFO frame__27_1 = {2, {"indent", "indentation"}};
static NODE *func__27_2;
static void entry__27_2(void);
static FRAME_INFO frame__27_2 = {2, {"indent", "indentation"}};
static void cont__27_3(void);
static void cont__27_4(void);
static NODE *func__27_5;
static void entry__27_5(void);
static FRAME_INFO frame__27_5 = {2, {"indentation", "indent"}};
static void cont__27_6(void);
static void cont__27_7(void);
static void cont__27_8(void);
static void cont__27_9(void);
static NODE *func__28_1;
static void entry__28_1(void);
static FRAME_INFO frame__28_1 = {2, {"trees", "return__1"}};
static NODE *func__28_2;
static void entry__28_2(void);
static FRAME_INFO frame__28_2 = {1, {"indent"}};
static void cont__28_3(void);
static void cont__28_4(void);
static void cont__28_5(void);
static NODE *func__28_6;
static void entry__28_6(void);
static FRAME_INFO frame__28_6 = {7, {"idx", "tree", "previous_statement_tag", "str", "lines", "add_line", "n"}};
static NODE *func__28_7;
static void entry__28_7(void);
static FRAME_INFO frame__28_7 = {2, {"line", "lines"}};
static void cont__28_8(void);
static void cont__28_9(void);
static NODE *func__28_10;
static void entry__28_10(void);
static FRAME_INFO frame__28_10 = {4, {"line", "lines", "indent", "text"}};
static void cont__28_11(void);
static void cont__28_12(void);
static void cont__28_13(void);
static void cont__28_14(void);
static void cont__28_15(void);
static void cont__28_16(void);
static void cont__28_17(void);
static void cont__28_18(void);
static NODE *func__28_19;
static void entry__28_19(void);
static FRAME_INFO frame__28_19 = {1, {"lines"}};
static void cont__28_20(void);
static void cont__28_21(void);
static void cont__28_22(void);
static NODE *func__28_23;
static void entry__28_23(void);
static FRAME_INFO frame__28_23 = {1, {"previous_statement_tag"}};
static void cont__28_24(void);
static NODE *func__28_25;
static void entry__28_25(void);
static FRAME_INFO frame__28_25 = {1, {"previous_statement_tag"}};
static void cont__28_26(void);
static void cont__28_27(void);
static void cont__28_28(void);
static void cont__28_29(void);
static NODE *func__28_30;
static void entry__28_30(void);
static FRAME_INFO frame__28_30 = {0, {}};
static void cont__28_31(void);
static void cont__28_32(void);
static NODE *func__28_33;
static void entry__28_33(void);
static FRAME_INFO frame__28_33 = {4, {"i", "str", "add_line", "n"}};
static void cont__28_34(void);
static void cont__28_35(void);
static NODE *func__28_36;
static void entry__28_36(void);
static FRAME_INFO frame__28_36 = {4, {"add_line", "str", "i", "n"}};
static void cont__28_37(void);
static void cont__28_38(void);
static void cont__28_39(void);
static void cont__28_40(void);
static void cont__28_41(void);
static void cont__28_42(void);
static void cont__28_43(void);
static void cont__28_44(void);
static void cont__28_45(void);
static NODE *func__28_46;
static void entry__28_46(void);
static FRAME_INFO frame__28_46 = {1, {"line"}};
static void cont__28_47(void);
static NODE *get__sim2c__print_trees(void) {
  return var.sim2c__print_trees;
}
static NODE *func__29_1;
static void entry__29_1(void);
static FRAME_INFO frame__29_1 = {4, {"remark_lines", "indent", "buf", "indentation"}};
static NODE *string__29_2;
static void cont__29_3(void);
static void cont__29_4(void);
static void cont__29_5(void);
static void cont__29_6(void);
static void cont__29_7(void);
static void cont__29_8(void);
static NODE *func__29_9;
static void entry__29_9(void);
static FRAME_INFO frame__29_9 = {3, {"remark_line", "buf", "indentation"}};
static void cont__29_10(void);
static void cont__29_11(void);
static NODE *func__30_1;
static void entry__30_1(void);
static FRAME_INFO frame__30_1 = {4, {"str", "remark_lines", "is_a_statement", "remark_prefix"}};
static void cont__30_2(void);
static NODE *func__30_3;
static void entry__30_3(void);
static FRAME_INFO frame__30_3 = {0, {}};
static NODE *string__30_4;
static NODE *func__30_5;
static void entry__30_5(void);
static FRAME_INFO frame__30_5 = {0, {}};
static NODE *string__30_6;
static void cont__30_7(void);
static void cont__30_8(void);
static void cont__30_9(void);
static NODE *func__30_10;
static void entry__30_10(void);
static FRAME_INFO frame__30_10 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__30_11(void);
static void cont__30_12(void);
static void cont__30_13(void);
static void cont__30_14(void);
static void cont__30_15(void);
static void cont__30_16(void);
static void cont__30_17(void);
static void cont__30_18(void);
static void cont__30_19(void);
static NODE *func__30_20;
static void entry__30_20(void);
static FRAME_INFO frame__30_20 = {5, {"str", "is_a_statement", "remark_lines", "indent", "buf"}};
static void cont__30_21(void);
static void cont__30_22(void);
static NODE *func__30_23;
static void entry__30_23(void);
static FRAME_INFO frame__30_23 = {1, {"str"}};
static NODE *string__30_24;
static void cont__30_25(void);
static void cont__30_26(void);
static void cont__30_27(void);
static NODE *func__30_28;
static void entry__30_28(void);
static FRAME_INFO frame__30_28 = {4, {"is_a_statement", "buf", "str", "indent"}};
static NODE *func__30_29;
static void entry__30_29(void);
static FRAME_INFO frame__30_29 = {2, {"buf", "str"}};
static void cont__30_30(void);
static void cont__30_31(void);
static void cont__30_32(void);
static void cont__30_33(void);
static void cont__30_34(void);
static void cont__30_35(void);
static void cont__30_36(void);
static NODE *func__30_37;
static void entry__30_37(void);
static FRAME_INFO frame__30_37 = {4, {"str", "remark_prefix", "remark_lines", "is_a_statement"}};
static void cont__30_38(void);
static void cont__30_39(void);
static void cont__30_40(void);
static void cont__30_41(void);
static void cont__30_42(void);
static void cont__30_43(void);
static void cont__30_44(void);
static NODE *func__30_45;
static void entry__30_45(void);
static FRAME_INFO frame__30_45 = {4, {"str", "remark_lines", "is_a_statement", "remark_prefix"}};
static NODE *string__30_46;
static void cont__30_47(void);
static NODE *func__30_48;
static void entry__30_48(void);
static FRAME_INFO frame__30_48 = {2, {"str", "remark_lines"}};
static void cont__30_49(void);
static void cont__30_50(void);
static void cont__30_51(void);
static NODE *func__30_52;
static void entry__30_52(void);
static FRAME_INFO frame__30_52 = {4, {"is_a_statement", "str", "remark_prefix", "remark_lines"}};
static NODE *func__30_53;
static void entry__30_53(void);
static FRAME_INFO frame__30_53 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__30_54(void);
static void cont__30_55(void);
static NODE *func__30_56;
static void entry__30_56(void);
static FRAME_INFO frame__30_56 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__30_57(void);
static void cont__30_58(void);
static void cont__30_59(void);
static void cont__30_60(void);
static NODE *func__30_61;
static void entry__30_61(void);
static FRAME_INFO frame__30_61 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__30_62(void);
static void cont__30_63(void);
static NODE *func__31_1;
static void entry__31_1(void);
static FRAME_INFO frame__31_1 = {3, {"self", "str", "remark_lines"}};
static void cont__31_2(void);
static void cont__31_3(void);
static NODE *func__31_4;
static void entry__31_4(void);
static FRAME_INFO frame__31_4 = {1, {"str"}};
static NODE *func__31_5;
static void entry__31_5(void);
static FRAME_INFO frame__31_5 = {2, {"str", "remark_lines"}};
static void cont__31_6(void);
static NODE *func__32_1;
static void entry__32_1(void);
static FRAME_INFO frame__32_1 = {3, {"self", "str", "remark_lines"}};
static void cont__32_2(void);
static void cont__32_3(void);
static NODE *func__32_4;
static void entry__32_4(void);
static FRAME_INFO frame__32_4 = {1, {"str"}};
static NODE *func__32_5;
static void entry__32_5(void);
static FRAME_INFO frame__32_5 = {2, {"str", "remark_lines"}};
static void cont__32_6(void);
static NODE *func__33_1;
static void entry__33_1(void);
static FRAME_INFO frame__33_1 = {3, {"self", "str", "indent"}};
static NODE *func__33_2;
static void entry__33_2(void);
static FRAME_INFO frame__33_2 = {4, {"return__1", "indent", "self", "str"}};
static void cont__33_3(void);
static void cont__33_4(void);
static NODE *func__34_1;
static void entry__34_1(void);
static FRAME_INFO frame__34_1 = {1, {"self"}};
static NODE *string__34_2;
static NODE *func__35_1;
static void entry__35_1(void);
static FRAME_INFO frame__35_1 = {1, {"self"}};
static void cont__35_2(void);
static NODE *string__35_3;
static NODE *string__35_4;
static void cont__35_5(void);
static void cont__35_6(void);
static NODE *func__36_1;
static void entry__36_1(void);
static FRAME_INFO frame__36_1 = {1, {"self"}};
static void cont__36_2(void);
static void cont__36_3(void);
static NODE *func__36_4;
static void entry__36_4(void);
static FRAME_INFO frame__36_4 = {1, {"self"}};
static void cont__36_5(void);
static void cont__36_6(void);
static NODE *string__36_7;
static NODE *string__36_8;
static NODE *string__36_9;
static void cont__36_10(void);
static NODE *func__36_11;
static void entry__36_11(void);
static FRAME_INFO frame__36_11 = {1, {"self"}};
static void cont__36_12(void);
static NODE *string__36_13;
static NODE *string__36_14;
static void cont__36_15(void);
static void cont__36_16(void);
static void cont__36_17(void);
static NODE *func__37_1;
static void entry__37_1(void);
static FRAME_INFO frame__37_1 = {1, {"self"}};
static void cont__37_2(void);
static NODE *string__37_3;
static NODE *string__37_4;
static void cont__37_5(void);
static void cont__37_6(void);
static NODE *func__38_1;
static void entry__38_1(void);
static FRAME_INFO frame__38_1 = {1, {"self"}};
static void cont__38_2(void);
static NODE *string__38_3;
static NODE *string__38_4;
static void cont__38_5(void);
static void cont__38_6(void);
static NODE *func__39_1;
static void entry__39_1(void);
static FRAME_INFO frame__39_1 = {1, {"self"}};
static void cont__39_2(void);
static NODE *string__39_3;
static NODE *string__39_4;
static void cont__39_5(void);
static void cont__39_6(void);
static NODE *func__40_1;
static void entry__40_1(void);
static FRAME_INFO frame__40_1 = {1, {"self"}};
static void cont__40_2(void);
static NODE *string__40_3;
static NODE *string__40_4;
static void cont__40_5(void);
static void cont__40_6(void);
static NODE *func__41_1;
static void entry__41_1(void);
static FRAME_INFO frame__41_1 = {3, {"self", "remark_lines", "buf"}};
static void cont__41_2(void);
static NODE *func__41_3;
static void entry__41_3(void);
static FRAME_INFO frame__41_3 = {1, {"remark_lines"}};
static void cont__41_4(void);
static void cont__41_5(void);
static NODE *func__41_6;
static void entry__41_6(void);
static FRAME_INFO frame__41_6 = {0, {}};
static NODE *func__41_7;
static void entry__41_7(void);
static FRAME_INFO frame__41_7 = {1, {"remark_lines"}};
static void cont__41_8(void);
static void cont__41_9(void);
static void cont__41_10(void);
static NODE *func__41_11;
static void entry__41_11(void);
static FRAME_INFO frame__41_11 = {1, {"remark_lines"}};
static void cont__41_12(void);
static void cont__41_13(void);
static void cont__41_14(void);
static void cont__41_15(void);
static NODE *func__41_16;
static void entry__41_16(void);
static FRAME_INFO frame__41_16 = {1, {"remark_lines"}};
static void cont__41_17(void);
static void cont__41_18(void);
static void cont__41_19(void);
static void cont__41_20(void);
static void cont__41_21(void);
static void cont__41_22(void);
static NODE *func__41_23;
static void entry__41_23(void);
static FRAME_INFO frame__41_23 = {0, {}};
static NODE *func__41_24;
static void entry__41_24(void);
static FRAME_INFO frame__41_24 = {1, {"remark_lines"}};
static void cont__41_25(void);
static void cont__41_26(void);
static NODE *func__41_27;
static void entry__41_27(void);
static FRAME_INFO frame__41_27 = {0, {}};
static NODE *func__41_28;
static void entry__41_28(void);
static FRAME_INFO frame__41_28 = {0, {}};
static NODE *func__41_29;
static void entry__41_29(void);
static FRAME_INFO frame__41_29 = {0, {}};
static void cont__41_30(void);
static void cont__41_31(void);
static void cont__41_32(void);
static void cont__41_33(void);
static void cont__41_34(void);
static NODE *func__41_35;
static void entry__41_35(void);
static FRAME_INFO frame__41_35 = {3, {"remark_lines", "buf", "indent"}};
static void cont__41_36(void);
static void cont__41_37(void);
static NODE *func__41_38;
static void entry__41_38(void);
static FRAME_INFO frame__41_38 = {3, {"line", "buf", "indent"}};
static void cont__41_39(void);
static void cont__41_40(void);
static void cont__41_41(void);
static NODE *func__41_42;
static void entry__41_42(void);
static FRAME_INFO frame__41_42 = {3, {"buf", "indent", "line"}};
static void cont__41_43(void);
static void cont__41_44(void);
static void cont__41_45(void);
static NODE *func__42_1;
static void entry__42_1(void);
static FRAME_INFO frame__42_1 = {4, {"self", "indent", "remark_lines", "parameters"}};
static void cont__42_2(void);
static void cont__42_3(void);
static void cont__42_4(void);
static void cont__42_5(void);
static NODE *func__42_6;
static void entry__42_6(void);
static FRAME_INFO frame__42_6 = {1, {"self"}};
static void cont__42_7(void);
static void cont__42_8(void);
static void cont__42_9(void);
static NODE *func__42_10;
static void entry__42_10(void);
static FRAME_INFO frame__42_10 = {1, {"self"}};
static void cont__42_11(void);
static void cont__42_12(void);
static void cont__42_13(void);
static void cont__42_14(void);
static void cont__42_15(void);
static NODE *func__42_16;
static void entry__42_16(void);
static FRAME_INFO frame__42_16 = {3, {"self", "indent", "str"}};
static void cont__42_17(void);
static void cont__42_18(void);
static void cont__42_19(void);
static void cont__42_20(void);
static NODE *func__42_21;
static void entry__42_21(void);
static FRAME_INFO frame__42_21 = {1, {"str"}};
static void cont__42_22(void);
static void cont__42_23(void);
static NODE *func__42_24;
static void entry__42_24(void);
static FRAME_INFO frame__42_24 = {2, {"indent", "str"}};
static void cont__42_25(void);
static void cont__42_26(void);
static NODE *func__42_27;
static void entry__42_27(void);
static FRAME_INFO frame__42_27 = {1, {"str"}};
static NODE *func__42_28;
static void entry__42_28(void);
static FRAME_INFO frame__42_28 = {9, {"indent", "parameters", "remark_lines", "self", "buf", "check_for_line_end_expression", "handle_simple_parameters", "handle_complex_parameters", "outer_line_end_expression_width"}};
static NODE *func__42_29;
static void entry__42_29(void);
static FRAME_INFO frame__42_29 = {2, {"buf", "indent"}};
static void cont__42_30(void);
static NODE *func__42_31;
static void entry__42_31(void);
static FRAME_INFO frame__42_31 = {1, {"buf"}};
static NODE *string__42_32;
static NODE *func__42_33;
static void entry__42_33(void);
static FRAME_INFO frame__42_33 = {2, {"buf", "indent"}};
static void cont__42_34(void);
static NODE *string__42_35;
static void cont__42_36(void);
static void cont__42_37(void);
static NODE *func__42_38;
static void entry__42_38(void);
static FRAME_INFO frame__42_38 = {7, {"parameters", "remark_lines", "buf", "indent", "handle_complex_parameters", "parameter_text", "parameter_text_length"}};
static NODE *string__42_39;
static NODE *func__42_40;
static void entry__42_40(void);
static FRAME_INFO frame__42_40 = {2, {"parameter", "parameter_text"}};
static void cont__42_41(void);
static void cont__42_42(void);
static NODE *func__42_43;
static void entry__42_43(void);
static FRAME_INFO frame__42_43 = {1, {"parameter_text"}};
static void cont__42_44(void);
static void cont__42_45(void);
static void cont__42_46(void);
static void cont__42_47(void);
static NODE *func__42_48;
static void entry__42_48(void);
static FRAME_INFO frame__42_48 = {2, {"parameter_text", "remark_lines"}};
static void cont__42_49(void);
static void cont__42_50(void);
static void cont__42_51(void);
static void cont__42_52(void);
static void cont__42_53(void);
static NODE *func__42_54;
static void entry__42_54(void);
static FRAME_INFO frame__42_54 = {2, {"buf", "parameter_text"}};
static NODE *func__42_55;
static void entry__42_55(void);
static FRAME_INFO frame__42_55 = {5, {"indent", "parameter_text_length", "buf", "parameter_text", "handle_complex_parameters"}};
static void cont__42_56(void);
static void cont__42_57(void);
static void cont__42_58(void);
static NODE *func__42_59;
static void entry__42_59(void);
static FRAME_INFO frame__42_59 = {3, {"buf", "indent", "parameter_text"}};
static void cont__42_60(void);
static NODE *string__42_61;
static void cont__42_62(void);
static void cont__42_63(void);
static NODE *func__42_64;
static void entry__42_64(void);
static FRAME_INFO frame__42_64 = {1, {"handle_complex_parameters"}};
static NODE *func__42_65;
static void entry__42_65(void);
static FRAME_INFO frame__42_65 = {6, {"check_for_line_end_expression", "indent", "remark_lines", "buf", "parameters", "parameter_indentation"}};
static void cont__42_66(void);
static void cont__42_67(void);
static void cont__42_68(void);
static void cont__42_69(void);
static NODE *func__42_70;
static void entry__42_70(void);
static FRAME_INFO frame__42_70 = {2, {"buf", "remark_lines"}};
static void cont__42_71(void);
static void cont__42_72(void);
static void cont__42_73(void);
static void cont__42_74(void);
static NODE *string__42_75;
static void cont__42_76(void);
static NODE *func__42_77;
static void entry__42_77(void);
static FRAME_INFO frame__42_77 = {3, {"parameter", "buf", "parameter_indentation"}};
static void cont__42_78(void);
static void cont__42_79(void);
static void cont__42_80(void);
static NODE *func__42_81;
static void entry__42_81(void);
static FRAME_INFO frame__42_81 = {2, {"buf", "parameter"}};
static void cont__42_82(void);
static NODE *func__42_83;
static void entry__42_83(void);
static FRAME_INFO frame__42_83 = {3, {"buf", "parameter_indentation", "parameter"}};
static void cont__42_84(void);
static void cont__42_85(void);
static void cont__42_86(void);
static void cont__42_87(void);
static void cont__42_88(void);
static void cont__42_89(void);
static NODE *func__42_90;
static void entry__42_90(void);
static FRAME_INFO frame__42_90 = {3, {"check_for_line_end_expression", "remark_lines", "buf"}};
static void cont__42_91(void);
static void cont__42_92(void);
static NODE *func__42_93;
static void entry__42_93(void);
static FRAME_INFO frame__42_93 = {2, {"buf", "remark_lines"}};
static void cont__42_94(void);
static NODE *func__42_95;
static void entry__42_95(void);
static FRAME_INFO frame__42_95 = {4, {"parameters", "handle_simple_parameters", "handle_complex_parameters", "has_simple_parameters"}};
static void cont__42_96(void);
static void cont__42_97(void);
static NODE *func__42_98;
static void entry__42_98(void);
static FRAME_INFO frame__42_98 = {1, {"parameters"}};
static NODE *func__42_99;
static void entry__42_99(void);
static FRAME_INFO frame__42_99 = {1, {"parameter"}};
static void cont__42_100(void);
static void cont__42_101(void);
static void cont__42_102(void);
static NODE *func__42_103;
static void entry__42_103(void);
static FRAME_INFO frame__42_103 = {1, {"parameter"}};
static void cont__42_104(void);
static void cont__42_105(void);
static void cont__42_106(void);
static void cont__42_107(void);
static void cont__42_108(void);
static void cont__42_109(void);
static NODE *func__42_110;
static void entry__42_110(void);
static FRAME_INFO frame__42_110 = {1, {"parameters"}};
static NODE *func__42_111;
static void entry__42_111(void);
static FRAME_INFO frame__42_111 = {1, {"parameter"}};
static void cont__42_112(void);
static void cont__42_113(void);
static void cont__42_114(void);
static void cont__42_115(void);
static NODE *func__42_116;
static void entry__42_116(void);
static FRAME_INFO frame__42_116 = {1, {"handle_simple_parameters"}};
static NODE *func__42_117;
static void entry__42_117(void);
static FRAME_INFO frame__42_117 = {1, {"handle_complex_parameters"}};
static void cont__42_118(void);
static NODE *func__42_119;
static void entry__42_119(void);
static FRAME_INFO frame__42_119 = {6, {"return__2", "indent", "buf", "self", "outer_line_end_expression_width", "indentation"}};
static void cont__42_120(void);
static NODE *func__42_121;
static void entry__42_121(void);
static FRAME_INFO frame__42_121 = {2, {"buf", "indentation"}};
static NODE *string__42_122;
static void cont__42_123(void);
static NODE *func__42_124;
static void entry__42_124(void);
static FRAME_INFO frame__42_124 = {7, {"return__1", "self", "buf", "outer_line_end_expression_width", "indentation", "statements", "n"}};
static void cont__42_125(void);
static void cont__42_126(void);
static void cont__42_127(void);
static NODE *func__42_128;
static void entry__42_128(void);
static FRAME_INFO frame__42_128 = {8, {"idx", "statement", "buf", "n", "outer_line_end_expression_width", "indentation", "previous_statement_tag", "str"}};
static void cont__42_129(void);
static void cont__42_130(void);
static NODE *func__42_131;
static void entry__42_131(void);
static FRAME_INFO frame__42_131 = {1, {"previous_statement_tag"}};
static void cont__42_132(void);
static NODE *func__42_133;
static void entry__42_133(void);
static FRAME_INFO frame__42_133 = {1, {"previous_statement_tag"}};
static void cont__42_134(void);
static void cont__42_135(void);
static void cont__42_136(void);
static void cont__42_137(void);
static NODE *func__42_138;
static void entry__42_138(void);
static FRAME_INFO frame__42_138 = {1, {"buf"}};
static void cont__42_139(void);
static void cont__42_140(void);
static void cont__42_141(void);
static NODE *func__42_142;
static void entry__42_142(void);
static FRAME_INFO frame__42_142 = {3, {"buf", "str", "outer_line_end_expression_width"}};
static void cont__42_143(void);
static NODE *func__42_144;
static void entry__42_144(void);
static FRAME_INFO frame__42_144 = {3, {"str", "outer_line_end_expression_width", "buf"}};
static void cont__42_145(void);
static NODE *func__42_146;
static void entry__42_146(void);
static FRAME_INFO frame__42_146 = {3, {"outer_line_end_expression_width", "buf", "str"}};
static void cont__42_147(void);
static void cont__42_148(void);
static void cont__42_149(void);
static void cont__42_150(void);
static void cont__42_151(void);
static void cont__42_152(void);
static void cont__42_153(void);
static void cont__42_154(void);
static NODE *func__42_155;
static void entry__42_155(void);
static FRAME_INFO frame__42_155 = {3, {"buf", "indentation", "str"}};
static void cont__42_156(void);
static NODE *func__42_157;
static void entry__42_157(void);
static FRAME_INFO frame__42_157 = {2, {"buf", "str"}};
static void cont__42_158(void);
static void cont__42_159(void);
static void cont__42_160(void);
static void cont__42_161(void);
static NODE *func__43_1;
static void entry__43_1(void);
static FRAME_INFO frame__43_1 = {5, {"self", "return", "output_arguments", "input_arguments", "all_arguments"}};
static void cont__43_2(void);
static void cont__43_3(void);
static NODE *func__43_4;
static void entry__43_4(void);
static FRAME_INFO frame__43_4 = {2, {"return", "output_arguments"}};
static void cont__43_5(void);
static void cont__43_6(void);
static NODE *func__43_7;
static void entry__43_7(void);
static FRAME_INFO frame__43_7 = {3, {"output_arguments", "input_arguments", "all_arguments"}};
static void cont__43_8(void);
static void cont__43_9(void);
static void cont__43_10(void);
static void cont__43_11(void);
static NODE *func__43_12;
static void entry__43_12(void);
static FRAME_INFO frame__43_12 = {4, {"continue", "output_arguments", "all_arguments", "input_arguments"}};
static void cont__43_13(void);
static NODE *func__43_14;
static void entry__43_14(void);
static FRAME_INFO frame__43_14 = {6, {"output_arguments", "all_arguments", "continue", "input_arguments", "next_output_argument", "output_enumeration_no"}};
static void cont__43_15(void);
static void cont__43_16(void);
static void cont__43_17(void);
static NODE *func__43_18;
static void entry__43_18(void);
static FRAME_INFO frame__43_18 = {4, {"all_arguments", "next_output_argument", "output_arguments", "continue"}};
static void cont__43_19(void);
static void cont__43_20(void);
static void cont__43_21(void);
static void cont__43_22(void);
static void cont__43_23(void);
static NODE *func__43_24;
static void entry__43_24(void);
static FRAME_INFO frame__43_24 = {6, {"input_arguments", "all_arguments", "continue", "output_enumeration_no", "next_input_argument", "input_enumeration_no"}};
static void cont__43_25(void);
static void cont__43_26(void);
static void cont__43_27(void);
static NODE *func__43_28;
static void entry__43_28(void);
static FRAME_INFO frame__43_28 = {4, {"all_arguments", "next_input_argument", "input_arguments", "continue"}};
static void cont__43_29(void);
static void cont__43_30(void);
static void cont__43_31(void);
static void cont__43_32(void);
static void cont__43_33(void);
static NODE *func__43_34;
static void entry__43_34(void);
static FRAME_INFO frame__43_34 = {4, {"all_arguments", "next_input_argument", "input_arguments", "continue"}};
static void cont__43_35(void);
static void cont__43_36(void);
static void cont__43_37(void);
static void cont__43_38(void);
static void cont__43_39(void);
static void cont__43_40(void);
static void cont__43_41(void);
static void cont__43_42(void);
static void cont__43_43(void);
static void cont__43_44(void);
static NODE *func__44_1;
static void entry__44_1(void);
static FRAME_INFO frame__44_1 = {2, {"argument", "width"}};
static NODE *func__44_2;
static void entry__44_2(void);
static FRAME_INFO frame__44_2 = {5, {"return__1", "argument", "width", "str", "first_chr"}};
static void cont__44_3(void);
static NODE *func__44_4;
static void entry__44_4(void);
static FRAME_INFO frame__44_4 = {1, {"argument"}};
static void cont__44_5(void);
static NODE *func__44_6;
static void entry__44_6(void);
static FRAME_INFO frame__44_6 = {1, {"argument"}};
static void cont__44_7(void);
static void cont__44_8(void);
static void cont__44_9(void);
static NODE *func__44_10;
static void entry__44_10(void);
static FRAME_INFO frame__44_10 = {1, {"width"}};
static NODE *func__44_11;
static void entry__44_11(void);
static FRAME_INFO frame__44_11 = {0, {}};
static void cont__44_12(void);
static void cont__44_13(void);
static NODE *func__44_14;
static void entry__44_14(void);
static FRAME_INFO frame__44_14 = {2, {"argument", "str"}};
static void cont__44_15(void);
static NODE *func__44_16;
static void entry__44_16(void);
static FRAME_INFO frame__44_16 = {2, {"argument", "str"}};
static void cont__44_17(void);
static void cont__44_18(void);
static NODE *func__44_19;
static void entry__44_19(void);
static FRAME_INFO frame__44_19 = {1, {"str"}};
static void cont__44_20(void);
static void cont__44_21(void);
static void cont__44_22(void);
static NODE *func__44_23;
static void entry__44_23(void);
static FRAME_INFO frame__44_23 = {2, {"argument", "str"}};
static void cont__44_24(void);
static NODE *func__44_25;
static void entry__44_25(void);
static FRAME_INFO frame__44_25 = {2, {"argument", "str"}};
static void cont__44_26(void);
static void cont__44_27(void);
static NODE *func__44_28;
static void entry__44_28(void);
static FRAME_INFO frame__44_28 = {1, {"str"}};
static void cont__44_29(void);
static void cont__44_30(void);
static void cont__44_31(void);
static void cont__44_32(void);
static void cont__44_33(void);
static void cont__44_34(void);
static NODE *func__44_35;
static void entry__44_35(void);
static FRAME_INFO frame__44_35 = {1, {"first_chr"}};
static void cont__44_36(void);
static void cont__44_37(void);
static NODE *func__44_38;
static void entry__44_38(void);
static FRAME_INFO frame__44_38 = {1, {"first_chr"}};
static void cont__44_39(void);
static void cont__44_40(void);
static void cont__44_41(void);
static void cont__44_42(void);
static NODE *func__44_43;
static void entry__44_43(void);
static FRAME_INFO frame__44_43 = {1, {"str"}};
static void cont__44_44(void);
static NODE *func__44_45;
static void entry__44_45(void);
static FRAME_INFO frame__44_45 = {1, {"str"}};
static void cont__44_46(void);
static NODE *func__45_1;
static void entry__45_1(void);
static FRAME_INFO frame__45_1 = {12, {"self", "mode", "available_width", "return", "line_end_width", "arguments", "len", "do_use_multiple_lines", "total_length", "strings", "do_skip_next", "buf"}};
static void cont__45_2(void);
static void cont__45_3(void);
static NODE *func__45_4;
static void entry__45_4(void);
static FRAME_INFO frame__45_4 = {1, {"return"}};
static void cont__45_5(void);
static void cont__45_6(void);
static void cont__45_7(void);
static NODE *func__45_8;
static void entry__45_8(void);
static FRAME_INFO frame__45_8 = {1, {"arguments"}};
static void cont__45_9(void);
static void cont__45_10(void);
static void cont__45_11(void);
static NODE *func__45_12;
static void entry__45_12(void);
static FRAME_INFO frame__45_12 = {1, {"do_use_multiple_lines"}};
static void cont__45_13(void);
static NODE *func__45_14;
static void entry__45_14(void);
static FRAME_INFO frame__45_14 = {12, {"idx", "argument", "do_skip_next", "mode", "len", "total_length", "line_end_width", "do_use_multiple_lines", "self", "arguments", "available_width", "strings"}};
static NODE *func__45_15;
static void entry__45_15(void);
static FRAME_INFO frame__45_15 = {1, {"do_skip_next"}};
static NODE *func__45_16;
static void entry__45_16(void);
static FRAME_INFO frame__45_16 = {15, {"return__1", "argument", "mode", "idx", "len", "total_length", "line_end_width", "do_use_multiple_lines", "self", "arguments", "do_skip_next", "available_width", "strings", "remark_lines_behind", "str"}};
static void cont__45_17(void);
static void cont__45_18(void);
static NODE *func__45_19;
static void entry__45_19(void);
static FRAME_INFO frame__45_19 = {6, {"idx", "len", "total_length", "line_end_width", "do_use_multiple_lines", "self"}};
static void cont__45_20(void);
static NODE *func__45_21;
static void entry__45_21(void);
static FRAME_INFO frame__45_21 = {4, {"total_length", "line_end_width", "do_use_multiple_lines", "self"}};
static void cont__45_22(void);
static NODE *func__45_23;
static void entry__45_23(void);
static FRAME_INFO frame__45_23 = {2, {"do_use_multiple_lines", "self"}};
static void cont__45_24(void);
static NODE *func__45_25;
static void entry__45_25(void);
static FRAME_INFO frame__45_25 = {1, {"self"}};
static void cont__45_26(void);
static void cont__45_27(void);
static NODE *func__45_28;
static void entry__45_28(void);
static FRAME_INFO frame__45_28 = {1, {"self"}};
static void cont__45_29(void);
static void cont__45_30(void);
static void cont__45_31(void);
static void cont__45_32(void);
static void cont__45_33(void);
static void cont__45_34(void);
static void cont__45_35(void);
static NODE *func__45_36;
static void entry__45_36(void);
static FRAME_INFO frame__45_36 = {2, {"line_end_width", "total_length"}};
static void cont__45_37(void);
static NODE *func__45_38;
static void entry__45_38(void);
static FRAME_INFO frame__45_38 = {0, {}};
static void cont__45_39(void);
static void cont__45_40(void);
static void cont__45_41(void);
static void cont__45_42(void);
static NODE *func__45_43;
static void entry__45_43(void);
static FRAME_INFO frame__45_43 = {4, {"idx", "len", "arguments", "argument"}};
static void cont__45_44(void);
static NODE *func__45_45;
static void entry__45_45(void);
static FRAME_INFO frame__45_45 = {3, {"arguments", "idx", "argument"}};
static void cont__45_46(void);
static void cont__45_47(void);
static void cont__45_48(void);
static void cont__45_49(void);
static void cont__45_50(void);
static void cont__45_51(void);
static void cont__45_52(void);
static NODE *func__45_53;
static void entry__45_53(void);
static FRAME_INFO frame__45_53 = {2, {"str", "do_skip_next"}};
static void cont__45_54(void);
static void cont__45_55(void);
static void cont__45_56(void);
static NODE *func__45_57;
static void entry__45_57(void);
static FRAME_INFO frame__45_57 = {2, {"str", "do_use_multiple_lines"}};
static void cont__45_58(void);
static void cont__45_59(void);
static NODE *func__45_60;
static void entry__45_60(void);
static FRAME_INFO frame__45_60 = {1, {"do_use_multiple_lines"}};
static NODE *func__45_61;
static void entry__45_61(void);
static FRAME_INFO frame__45_61 = {7, {"idx", "len", "mode", "total_length", "str", "available_width", "do_use_multiple_lines"}};
static void cont__45_62(void);
static NODE *func__45_63;
static void entry__45_63(void);
static FRAME_INFO frame__45_63 = {6, {"mode", "idx", "total_length", "str", "available_width", "do_use_multiple_lines"}};
static void cont__45_64(void);
static NODE *func__45_65;
static void entry__45_65(void);
static FRAME_INFO frame__45_65 = {1, {"idx"}};
static void cont__45_66(void);
static void cont__45_67(void);
static NODE *func__45_68;
static void entry__45_68(void);
static FRAME_INFO frame__45_68 = {1, {"total_length"}};
static void cont__45_69(void);
static void cont__45_70(void);
static void cont__45_71(void);
static void cont__45_72(void);
static NODE *string__45_73;
static void cont__45_74(void);
static NODE *func__45_75;
static void entry__45_75(void);
static FRAME_INFO frame__45_75 = {1, {"total_length"}};
static void cont__45_76(void);
static void cont__45_77(void);
static void cont__45_78(void);
static NODE *func__45_79;
static void entry__45_79(void);
static FRAME_INFO frame__45_79 = {1, {"do_use_multiple_lines"}};
static NODE *func__45_80;
static void entry__45_80(void);
static FRAME_INFO frame__45_80 = {6, {"mode", "idx", "str", "total_length", "available_width", "do_use_multiple_lines"}};
static void cont__45_81(void);
static NODE *func__45_82;
static void entry__45_82(void);
static FRAME_INFO frame__45_82 = {1, {"idx"}};
static void cont__45_83(void);
static void cont__45_84(void);
static NODE *func__45_85;
static void entry__45_85(void);
static FRAME_INFO frame__45_85 = {1, {"str"}};
static void cont__45_86(void);
static void cont__45_87(void);
static void cont__45_88(void);
static void cont__45_89(void);
static NODE *func__45_90;
static void entry__45_90(void);
static FRAME_INFO frame__45_90 = {1, {"total_length"}};
static void cont__45_91(void);
static void cont__45_92(void);
static void cont__45_93(void);
static void cont__45_94(void);
static void cont__45_95(void);
static NODE *func__45_96;
static void entry__45_96(void);
static FRAME_INFO frame__45_96 = {1, {"do_use_multiple_lines"}};
static void cont__45_97(void);
static void cont__45_98(void);
static void cont__45_99(void);
static NODE *func__45_100;
static void entry__45_100(void);
static FRAME_INFO frame__45_100 = {6, {"remark_lines_behind", "strings", "idx", "len", "do_use_multiple_lines", "remark"}};
static void cont__45_101(void);
static void cont__45_102(void);
static void cont__45_103(void);
static void cont__45_104(void);
static NODE *func__45_105;
static void entry__45_105(void);
static FRAME_INFO frame__45_105 = {1, {"remark"}};
static void cont__45_106(void);
static void cont__45_107(void);
static void cont__45_108(void);
static void cont__45_109(void);
static void cont__45_110(void);
static void cont__45_111(void);
static NODE *func__45_112;
static void entry__45_112(void);
static FRAME_INFO frame__45_112 = {1, {"strings"}};
static NODE *string__45_113;
static void cont__45_114(void);
static void cont__45_115(void);
static void cont__45_116(void);
static void cont__45_117(void);
static void cont__45_118(void);
static NODE *func__45_119;
static void entry__45_119(void);
static FRAME_INFO frame__45_119 = {2, {"self", "do_use_multiple_lines"}};
static void cont__45_120(void);
static void cont__45_121(void);
static NODE *func__45_122;
static void entry__45_122(void);
static FRAME_INFO frame__45_122 = {1, {"do_use_multiple_lines"}};
static void cont__45_123(void);
static void cont__45_124(void);
static void cont__45_125(void);
static NODE *func__45_126;
static void entry__45_126(void);
static FRAME_INFO frame__45_126 = {2, {"mode", "self"}};
static void cont__45_127(void);
static NODE *func__45_128;
static void entry__45_128(void);
static FRAME_INFO frame__45_128 = {1, {"self"}};
static void cont__45_129(void);
static void cont__45_130(void);
static void cont__45_131(void);
static void cont__45_132(void);
static void cont__45_133(void);
static NODE *func__45_134;
static void entry__45_134(void);
static FRAME_INFO frame__45_134 = {2, {"strings", "do_use_multiple_lines"}};
static NODE *string__45_135;
static void cont__45_136(void);
static void cont__45_137(void);
static NODE *func__45_138;
static void entry__45_138(void);
static FRAME_INFO frame__45_138 = {6, {"mode", "strings", "available_width", "buf", "indentation", "line_end_conversion_is_allowed"}};
static void cont__45_139(void);
static void cont__45_140(void);
static NODE *func__45_141;
static void entry__45_141(void);
static FRAME_INFO frame__45_141 = {3, {"strings", "available_width", "buf"}};
static NODE *func__45_142;
static void entry__45_142(void);
static FRAME_INFO frame__45_142 = {3, {"strings", "available_width", "buf"}};
static void cont__45_143(void);
static void cont__45_144(void);
static NODE *func__45_145;
static void entry__45_145(void);
static FRAME_INFO frame__45_145 = {2, {"strings", "available_width"}};
static void cont__45_146(void);
static void cont__45_147(void);
static void cont__45_148(void);
static NODE *func__45_149;
static void entry__45_149(void);
static FRAME_INFO frame__45_149 = {2, {"strings", "available_width"}};
static void cont__45_150(void);
static void cont__45_151(void);
static void cont__45_152(void);
static void cont__45_153(void);
static void cont__45_154(void);
static NODE *func__45_155;
static void entry__45_155(void);
static FRAME_INFO frame__45_155 = {3, {"buf", "strings", "available_width"}};
static void cont__45_156(void);
static void cont__45_157(void);
static NODE *func__45_158;
static void entry__45_158(void);
static FRAME_INFO frame__45_158 = {1, {"buf"}};
static void cont__45_159(void);
static void cont__45_160(void);
static void cont__45_161(void);
static void cont__45_162(void);
static void cont__45_163(void);
static void cont__45_164(void);
static void cont__45_165(void);
static void cont__45_166(void);
static void cont__45_167(void);
static void cont__45_168(void);
static void cont__45_169(void);
static NODE *func__45_170;
static void entry__45_170(void);
static FRAME_INFO frame__45_170 = {6, {"idx", "str", "line_end_conversion_is_allowed", "strings", "buf", "indentation"}};
static NODE *func__45_171;
static void entry__45_171(void);
static FRAME_INFO frame__45_171 = {1, {"str"}};
static void cont__45_172(void);
static void cont__45_173(void);
static NODE *func__45_174;
static void entry__45_174(void);
static FRAME_INFO frame__45_174 = {4, {"str", "idx", "strings", "buf"}};
static void cont__45_175(void);
static void cont__45_176(void);
static NODE *func__45_177;
static void entry__45_177(void);
static FRAME_INFO frame__45_177 = {3, {"idx", "strings", "str"}};
static void cont__45_178(void);
static NODE *func__45_179;
static void entry__45_179(void);
static FRAME_INFO frame__45_179 = {2, {"strings", "idx"}};
static void cont__45_180(void);
static void cont__45_181(void);
static void cont__45_182(void);
static void cont__45_183(void);
static void cont__45_184(void);
static NODE *func__45_185;
static void entry__45_185(void);
static FRAME_INFO frame__45_185 = {3, {"strings", "idx", "str"}};
static void cont__45_186(void);
static void cont__45_187(void);
static void cont__45_188(void);
static void cont__45_189(void);
static void cont__45_190(void);
static void cont__45_191(void);
static void cont__45_192(void);
static void cont__45_193(void);
static void cont__45_194(void);
static void cont__45_195(void);
static void cont__45_196(void);
static void cont__45_197(void);
static NODE *func__45_198;
static void entry__45_198(void);
static FRAME_INFO frame__45_198 = {2, {"buf", "str"}};
static void cont__45_199(void);
static void cont__45_200(void);
static NODE *func__45_201;
static void entry__45_201(void);
static FRAME_INFO frame__45_201 = {2, {"buf", "str"}};
static void cont__45_202(void);
static NODE *func__45_203;
static void entry__45_203(void);
static FRAME_INFO frame__45_203 = {4, {"str", "buf", "indentation", "line_end_conversion_is_allowed"}};
static void cont__45_204(void);
static void cont__45_205(void);
static NODE *func__45_206;
static void entry__45_206(void);
static FRAME_INFO frame__45_206 = {2, {"buf", "indentation"}};
static void cont__45_207(void);
static void cont__45_208(void);
static void cont__45_209(void);
static void cont__45_210(void);
static void cont__45_211(void);
static void cont__45_212(void);
static void cont__45_213(void);
static NODE *func__45_214;
static void entry__45_214(void);
static FRAME_INFO frame__45_214 = {1, {"str"}};
static NODE *string__45_215;
static void cont__45_216(void);
static void cont__45_217(void);
static void cont__45_218(void);
static NODE *func__45_219;
static void entry__45_219(void);
static FRAME_INFO frame__45_219 = {3, {"strings", "buf", "n"}};
static void cont__45_220(void);
static NODE *func__45_221;
static void entry__45_221(void);
static FRAME_INFO frame__45_221 = {4, {"idx", "str", "buf", "n"}};
static void cont__45_222(void);
static NODE *func__45_223;
static void entry__45_223(void);
static FRAME_INFO frame__45_223 = {1, {"str"}};
static void cont__45_224(void);
static void cont__45_225(void);
static NODE *func__45_226;
static void entry__45_226(void);
static FRAME_INFO frame__45_226 = {1, {"str"}};
static void cont__45_227(void);
static void cont__45_228(void);
static void cont__45_229(void);
static void cont__45_230(void);
static NODE *func__45_231;
static void entry__45_231(void);
static FRAME_INFO frame__45_231 = {1, {"buf"}};
static void cont__45_232(void);
static void cont__45_233(void);
static void cont__45_234(void);
static NODE *func__45_235;
static void entry__45_235(void);
static FRAME_INFO frame__45_235 = {1, {"str"}};
static NODE *string__45_236;
static void cont__45_237(void);
static NODE *func__45_238;
static void entry__45_238(void);
static FRAME_INFO frame__45_238 = {1, {"str"}};
static void cont__45_239(void);
static void cont__45_240(void);
static void cont__45_241(void);
static void cont__45_242(void);
static NODE *func__45_243;
static void entry__45_243(void);
static FRAME_INFO frame__45_243 = {2, {"buf", "str"}};
static void cont__45_244(void);
static void cont__45_245(void);
static void cont__45_246(void);
static NODE *func__45_247;
static void entry__45_247(void);
static FRAME_INFO frame__45_247 = {2, {"buf", "str"}};
static void cont__45_248(void);
static void cont__45_249(void);
static NODE *func__46_1;
static void entry__46_1(void);
static FRAME_INFO frame__46_1 = {4, {"functor", "arguments", "remark_lines", "remark"}};
static void cont__46_2(void);
static void cont__46_3(void);
static void cont__46_4(void);
static NODE *func__46_5;
static void entry__46_5(void);
static FRAME_INFO frame__46_5 = {1, {"remark"}};
static void cont__46_6(void);
static void cont__46_7(void);
static void cont__46_8(void);
static void cont__46_9(void);
static NODE *func__46_10;
static void entry__46_10(void);
static FRAME_INFO frame__46_10 = {1, {"arguments"}};
static void cont__46_11(void);
static void cont__46_12(void);
static void cont__46_13(void);
static void cont__46_14(void);
static NODE *func__47_1;
static void entry__47_1(void);
static FRAME_INFO frame__47_1 = {3, {"self", "indent", "outer_line_end_expression_width"}};
static void cont__47_2(void);
static NODE *func__47_3;
static void entry__47_3(void);
static FRAME_INFO frame__47_3 = {6, {"return__2", "self", "outer_line_end_expression_width", "indent", "has_no_remarks", "arguments"}};
static void cont__47_4(void);
static void cont__47_5(void);
static NODE *func__47_6;
static void entry__47_6(void);
static FRAME_INFO frame__47_6 = {1, {"self"}};
static void cont__47_7(void);
static void cont__47_8(void);
static void cont__47_9(void);
static void cont__47_10(void);
static NODE *func__47_11;
static void entry__47_11(void);
static FRAME_INFO frame__47_11 = {1, {"has_no_remarks"}};
static void cont__47_12(void);
static NODE *func__47_13;
static void entry__47_13(void);
static FRAME_INFO frame__47_13 = {1, {"indent"}};
static NODE *func__47_14;
static void entry__47_14(void);
static FRAME_INFO frame__47_14 = {1, {"indent"}};
static void cont__47_15(void);
static void cont__47_16(void);
static void cont__47_17(void);
static void cont__47_18(void);
static void cont__47_19(void);
static NODE *func__47_20;
static void entry__47_20(void);
static FRAME_INFO frame__47_20 = {1, {"arguments"}};
static void cont__47_21(void);
static void cont__47_22(void);
static NODE *func__47_23;
static void entry__47_23(void);
static FRAME_INFO frame__47_23 = {1, {"arguments"}};
static NODE *string__47_24;
static void cont__47_25(void);
static NODE *func__47_26;
static void entry__47_26(void);
static FRAME_INFO frame__47_26 = {1, {"arguments"}};
static NODE *string__47_27;
static void cont__47_28(void);
static NODE *func__47_29;
static void entry__47_29(void);
static FRAME_INFO frame__47_29 = {5, {"return__1", "self", "indent", "arguments", "remark_lines"}};
static void cont__47_30(void);
static void cont__47_31(void);
static void cont__47_32(void);
static void cont__47_33(void);
static NODE *func__47_34;
static void entry__47_34(void);
static FRAME_INFO frame__47_34 = {3, {"remark_lines", "arguments", "functor"}};
static NODE *string__47_35;
static void cont__47_36(void);
static void cont__47_37(void);
static void cont__47_38(void);
static NODE *func__47_39;
static void entry__47_39(void);
static FRAME_INFO frame__47_39 = {2, {"functor", "arguments"}};
static void cont__47_40(void);
static void cont__47_41(void);
static NODE *string__47_42;
static void cont__47_43(void);
static NODE *func__47_44;
static void entry__47_44(void);
static FRAME_INFO frame__47_44 = {1, {"arguments"}};
static void cont__47_45(void);
static void cont__47_46(void);
static void cont__47_47(void);
static void cont__47_48(void);
static void cont__47_49(void);
static NODE *func__47_50;
static void entry__47_50(void);
static FRAME_INFO frame__47_50 = {1, {"arguments"}};
static void cont__47_51(void);
static void cont__47_52(void);
static void cont__47_53(void);
static void cont__47_54(void);
static NODE *func__47_55;
static void entry__47_55(void);
static FRAME_INFO frame__47_55 = {3, {"arguments", "remark_lines", "indent"}};
static void cont__47_56(void);
static void cont__47_57(void);
static void cont__47_58(void);
static void cont__47_59(void);
static NODE *func__47_60;
static void entry__47_60(void);
static FRAME_INFO frame__47_60 = {3, {"arguments", "remark_lines", "indent"}};
static void cont__47_61(void);
static void cont__47_62(void);
static NODE *string__47_63;
static void cont__47_64(void);
static NODE *func__47_65;
static void entry__47_65(void);
static FRAME_INFO frame__47_65 = {2, {"arguments", "remark_lines"}};
static NODE *string__47_66;
static void cont__47_67(void);
static void cont__47_68(void);
static void cont__47_69(void);
static void cont__47_70(void);
static NODE *func__47_71;
static void entry__47_71(void);
static FRAME_INFO frame__47_71 = {7, {"return__5", "indent", "self", "functor", "this_is_a_definition", "arguments", "remark_lines"}};
static void cont__47_72(void);
static NODE *func__47_73;
static void entry__47_73(void);
static FRAME_INFO frame__47_73 = {4, {"return__3", "self", "functor", "this_is_a_definition"}};
static void cont__47_74(void);
static NODE *func__47_75;
static void entry__47_75(void);
static FRAME_INFO frame__47_75 = {4, {"functor", "self", "this_is_a_definition", "source"}};
static void cont__47_76(void);
static void cont__47_77(void);
static void cont__47_78(void);
static void cont__47_79(void);
static void cont__47_80(void);
static void cont__47_81(void);
static NODE *func__47_82;
static void entry__47_82(void);
static FRAME_INFO frame__47_82 = {1, {"source"}};
static void cont__47_83(void);
static NODE *func__47_84;
static void entry__47_84(void);
static FRAME_INFO frame__47_84 = {0, {}};
static NODE *func__47_85;
static void entry__47_85(void);
static FRAME_INFO frame__47_85 = {1, {"source"}};
static void cont__47_86(void);
static NODE *func__47_87;
static void entry__47_87(void);
static FRAME_INFO frame__47_87 = {0, {}};
static NODE *func__47_88;
static void entry__47_88(void);
static FRAME_INFO frame__47_88 = {1, {"source"}};
static void cont__47_89(void);
static NODE *func__47_90;
static void entry__47_90(void);
static FRAME_INFO frame__47_90 = {0, {}};
static NODE *func__47_91;
static void entry__47_91(void);
static FRAME_INFO frame__47_91 = {2, {"functor", "self"}};
static void cont__47_92(void);
static void cont__47_93(void);
static void cont__47_94(void);
static void cont__47_95(void);
static void cont__47_96(void);
static void cont__47_97(void);
static void cont__47_98(void);
static void cont__47_99(void);
static NODE *func__47_100;
static void entry__47_100(void);
static FRAME_INFO frame__47_100 = {1, {"arguments"}};
static void cont__47_101(void);
static void cont__47_102(void);
static NODE *func__47_103;
static void entry__47_103(void);
static FRAME_INFO frame__47_103 = {0, {}};
static void cont__47_104(void);
static void cont__47_105(void);
static void cont__47_106(void);
static void cont__47_107(void);
static void cont__47_108(void);
static NODE *func__47_109;
static void entry__47_109(void);
static FRAME_INFO frame__47_109 = {2, {"arguments", "functor"}};
static void cont__47_110(void);
static NODE *func__47_111;
static void entry__47_111(void);
static FRAME_INFO frame__47_111 = {1, {"arguments"}};
static void cont__47_112(void);
static void cont__47_113(void);
static NODE *func__47_114;
static void entry__47_114(void);
static FRAME_INFO frame__47_114 = {1, {"arguments"}};
static void cont__47_115(void);
static void cont__47_116(void);
static void cont__47_117(void);
static void cont__47_118(void);
static NODE *func__47_119;
static void entry__47_119(void);
static FRAME_INFO frame__47_119 = {2, {"functor", "arguments"}};
static void cont__47_120(void);
static NODE *func__47_121;
static void entry__47_121(void);
static FRAME_INFO frame__47_121 = {2, {"functor", "arguments"}};
static void cont__47_122(void);
static void cont__47_123(void);
static NODE *func__47_124;
static void entry__47_124(void);
static FRAME_INFO frame__47_124 = {5, {"arguments", "functor", "remark_lines", "self", "indent"}};
static NODE *func__47_125;
static void entry__47_125(void);
static FRAME_INFO frame__47_125 = {3, {"arguments", "functor", "remark_lines"}};
static void cont__47_126(void);
static NODE *func__47_127;
static void entry__47_127(void);
static FRAME_INFO frame__47_127 = {3, {"functor", "remark_lines", "arguments"}};
static void cont__47_128(void);
static void cont__47_129(void);
static NODE *func__47_130;
static void entry__47_130(void);
static FRAME_INFO frame__47_130 = {4, {"arguments", "self", "functor", "remark_lines"}};
static void cont__47_131(void);
static NODE *func__47_132;
static void entry__47_132(void);
static FRAME_INFO frame__47_132 = {1, {"self"}};
static void cont__47_133(void);
static NODE *func__47_134;
static void entry__47_134(void);
static FRAME_INFO frame__47_134 = {1, {"argument"}};
static void cont__47_135(void);
static void cont__47_136(void);
static void cont__47_137(void);
static NODE *func__47_138;
static void entry__47_138(void);
static FRAME_INFO frame__47_138 = {3, {"functor", "arguments", "remark_lines"}};
static void cont__47_139(void);
static NODE *func__47_140;
static void entry__47_140(void);
static FRAME_INFO frame__47_140 = {4, {"indent", "functor", "arguments", "remark_lines"}};
static NODE *func__47_141;
static void entry__47_141(void);
static FRAME_INFO frame__47_141 = {5, {"return__4", "indent", "functor", "arguments", "remark_lines"}};
static void cont__47_142(void);
static void cont__47_143(void);
static void cont__47_144(void);
static NODE *func__48_1;
static void entry__48_1(void);
static FRAME_INFO frame__48_1 = {3, {"prefix", "definition", "buf"}};
static void cont__48_2(void);
static void cont__48_3(void);
static NODE *func__48_4;
static void entry__48_4(void);
static FRAME_INFO frame__48_4 = {1, {"buf"}};
static NODE *string__48_5;
static void cont__48_6(void);
static void cont__48_7(void);
static void cont__48_8(void);
static void cont__48_9(void);
static void cont__48_10(void);
static void cont__48_11(void);
static void cont__48_12(void);
static NODE *func__48_13;
static void entry__48_13(void);
static FRAME_INFO frame__48_13 = {2, {"definition", "buf"}};
static void cont__48_14(void);
static void cont__48_15(void);
static NODE *func__48_16;
static void entry__48_16(void);
static FRAME_INFO frame__48_16 = {1, {"buf"}};
static void cont__48_17(void);
static void cont__48_18(void);
static NODE *func__48_19;
static void entry__48_19(void);
static FRAME_INFO frame__48_19 = {2, {"definition", "buf"}};
static void cont__48_20(void);
static NODE *func__48_21;
static void entry__48_21(void);
static FRAME_INFO frame__48_21 = {2, {"definition", "buf"}};
static void cont__48_22(void);
static void cont__48_23(void);
static NODE *func__48_24;
static void entry__48_24(void);
static FRAME_INFO frame__48_24 = {2, {"buf", "definition"}};
static void cont__48_25(void);
static NODE *string__48_26;
static void cont__48_27(void);
static NODE *func__48_28;
static void entry__48_28(void);
static FRAME_INFO frame__48_28 = {1, {"buf"}};
static void cont__48_29(void);
static NODE *func__48_30;
static void entry__48_30(void);
static FRAME_INFO frame__48_30 = {2, {"definition", "buf"}};
static void cont__48_31(void);
static NODE *func__48_32;
static void entry__48_32(void);
static FRAME_INFO frame__48_32 = {1, {"buf"}};
static void cont__48_33(void);
static void cont__48_34(void);
static NODE *func__49_1;
static void entry__49_1(void);
static FRAME_INFO frame__49_1 = {3, {"self", "prefix", "buf"}};
static void cont__49_2(void);
static void cont__49_3(void);
static NODE *func__49_4;
static void entry__49_4(void);
static FRAME_INFO frame__49_4 = {0, {}};
static NODE *func__49_5;
static void entry__49_5(void);
static FRAME_INFO frame__49_5 = {0, {}};
static NODE *string__49_6;
static void cont__49_7(void);
static void cont__49_8(void);
static void cont__49_9(void);
static NODE *func__49_10;
static void entry__49_10(void);
static FRAME_INFO frame__49_10 = {2, {"buf", "self"}};
static void cont__49_11(void);
static void cont__49_12(void);
static NODE *func__49_13;
static void entry__49_13(void);
static FRAME_INFO frame__49_13 = {2, {"buf", "self"}};
static void cont__49_14(void);
static void cont__49_15(void);
static void cont__49_16(void);
static NODE *func__49_17;
static void entry__49_17(void);
static FRAME_INFO frame__49_17 = {2, {"buf", "self"}};
static void cont__49_18(void);
static void cont__49_19(void);
static void cont__49_20(void);
static NODE *func__50_1;
static void entry__50_1(void);
static FRAME_INFO frame__50_1 = {2, {"self", "prefix"}};
static void cont__50_2(void);
static void cont__50_3(void);
static NODE *func__50_4;
static void entry__50_4(void);
static FRAME_INFO frame__50_4 = {0, {}};
static NODE *string__50_5;
static NODE *func__50_6;
static void entry__50_6(void);
static FRAME_INFO frame__50_6 = {0, {}};
static NODE *string__50_7;
static NODE *func__50_8;
static void entry__50_8(void);
static FRAME_INFO frame__50_8 = {0, {}};
static NODE *string__50_9;
static NODE *func__50_10;
static void entry__50_10(void);
static FRAME_INFO frame__50_10 = {0, {}};
static NODE *string__50_11;
static void cont__50_12(void);
static void cont__50_13(void);
static NODE *func__51_1;
static void entry__51_1(void);
static FRAME_INFO frame__51_1 = {1, {"self"}};
static NODE *string__51_2;
static void cont__51_3(void);
static NODE *func__52_1;
static void entry__52_1(void);
static FRAME_INFO frame__52_1 = {1, {"self"}};
static NODE *string__52_2;
static void cont__52_3(void);
static NODE *func__53_1;
static void entry__53_1(void);
static FRAME_INFO frame__53_1 = {1, {"expr"}};
static void cont__53_2(void);
static NODE *func__53_3;
static void entry__53_3(void);
static FRAME_INFO frame__53_3 = {1, {"expr"}};
static void cont__53_4(void);
static void cont__53_5(void);
static void cont__53_6(void);
static void cont__53_7(void);
static NODE *func__53_8;
static void entry__53_8(void);
static FRAME_INFO frame__53_8 = {1, {"expr"}};
static void cont__53_9(void);
static void cont__53_10(void);
static NODE *func__53_11;
static void entry__53_11(void);
static FRAME_INFO frame__53_11 = {1, {"expr"}};
static void cont__53_12(void);
static void cont__53_13(void);
static void cont__53_14(void);
static NODE *func__53_15;
static void entry__53_15(void);
static FRAME_INFO frame__53_15 = {1, {"expr"}};
static void cont__53_16(void);
static NODE *func__53_17;
static void entry__53_17(void);
static FRAME_INFO frame__53_17 = {0, {}};
static NODE *func__53_18;
static void entry__53_18(void);
static FRAME_INFO frame__53_18 = {0, {}};
static NODE *func__53_19;
static void entry__53_19(void);
static FRAME_INFO frame__53_19 = {0, {}};
static NODE *func__54_1;
static void entry__54_1(void);
static FRAME_INFO frame__54_1 = {1, {"expr"}};
static void cont__54_2(void);
static NODE *func__54_3;
static void entry__54_3(void);
static FRAME_INFO frame__54_3 = {1, {"expr"}};
static void cont__54_4(void);
static void cont__54_5(void);
static void cont__54_6(void);
static NODE *func__54_7;
static void entry__54_7(void);
static FRAME_INFO frame__54_7 = {1, {"expr"}};
static void cont__54_8(void);
static void cont__54_9(void);
static void cont__54_10(void);
static void cont__54_11(void);
static NODE *func__54_12;
static void entry__54_12(void);
static FRAME_INFO frame__54_12 = {1, {"expr"}};
static void cont__54_13(void);
static void cont__54_14(void);
static NODE *func__54_15;
static void entry__54_15(void);
static FRAME_INFO frame__54_15 = {0, {}};
static NODE *func__55_1;
static void entry__55_1(void);
static FRAME_INFO frame__55_1 = {6, {"self", "indent", "functor", "functor_string", "default_call", "arguments"}};
static NODE *func__55_2;
static void entry__55_2(void);
static FRAME_INFO frame__55_2 = {6, {"return__3", "indent", "self", "functor_string", "arguments_string", "remark_lines"}};
static void cont__55_3(void);
static void cont__55_4(void);
static void cont__55_5(void);
static void cont__55_6(void);
static void cont__55_7(void);
static void cont__55_8(void);
static void cont__55_9(void);
static void cont__55_10(void);
static void cont__55_11(void);
static void cont__55_12(void);
static void cont__55_13(void);
static NODE *func__55_14;
static void entry__55_14(void);
static FRAME_INFO frame__55_14 = {3, {"arguments_string", "indent", "functor_string"}};
static void cont__55_15(void);
static NODE *func__55_16;
static void entry__55_16(void);
static FRAME_INFO frame__55_16 = {3, {"indent", "functor_string", "arguments_string"}};
static void cont__55_17(void);
static void cont__55_18(void);
static NODE *func__55_19;
static void entry__55_19(void);
static FRAME_INFO frame__55_19 = {2, {"functor_string", "arguments_string"}};
static void cont__55_20(void);
static NODE *func__55_21;
static void entry__55_21(void);
static FRAME_INFO frame__55_21 = {4, {"arguments_string", "remark_lines", "indent", "functor_string"}};
static void cont__55_22(void);
static NODE *func__55_23;
static void entry__55_23(void);
static FRAME_INFO frame__55_23 = {5, {"remark_lines", "indent", "functor_string", "arguments_string", "remark"}};
static void cont__55_24(void);
static void cont__55_25(void);
static void cont__55_26(void);
static NODE *func__55_27;
static void entry__55_27(void);
static FRAME_INFO frame__55_27 = {1, {"remark"}};
static void cont__55_28(void);
static void cont__55_29(void);
static void cont__55_30(void);
static void cont__55_31(void);
static void cont__55_32(void);
static NODE *func__55_33;
static void entry__55_33(void);
static FRAME_INFO frame__55_33 = {5, {"return__2", "indent", "functor_string", "arguments_string", "remark_lines"}};
static void cont__55_34(void);
static void cont__55_35(void);
static void cont__55_36(void);
static void cont__55_37(void);
static void cont__55_38(void);
static NODE *func__55_39;
static void entry__55_39(void);
static FRAME_INFO frame__55_39 = {2, {"return__1", "self"}};
static void cont__55_40(void);
static void cont__55_41(void);
static NODE *func__55_42;
static void entry__55_42(void);
static FRAME_INFO frame__55_42 = {0, {}};
static void cont__55_43(void);
static void cont__55_44(void);
static NODE *func__55_45;
static void entry__55_45(void);
static FRAME_INFO frame__55_45 = {3, {"self", "arguments", "functor_string"}};
static void cont__55_46(void);
static NODE *func__55_47;
static void entry__55_47(void);
static FRAME_INFO frame__55_47 = {4, {"return__4", "arguments", "functor_string", "argument"}};
static void cont__55_48(void);
static void cont__55_49(void);
static NODE *func__55_50;
static void entry__55_50(void);
static FRAME_INFO frame__55_50 = {2, {"argument", "functor_string"}};
static void cont__55_51(void);
static NODE *func__55_52;
static void entry__55_52(void);
static FRAME_INFO frame__55_52 = {1, {"argument"}};
static void cont__55_53(void);
static void cont__55_54(void);
static NODE *func__55_55;
static void entry__55_55(void);
static FRAME_INFO frame__55_55 = {3, {"self", "arguments", "functor_string"}};
static void cont__55_56(void);
static NODE *func__55_57;
static void entry__55_57(void);
static FRAME_INFO frame__55_57 = {3, {"arguments", "functor_string", "argument"}};
static void cont__55_58(void);
static void cont__55_59(void);
static void cont__55_60(void);
static NODE *func__55_61;
static void entry__55_61(void);
static FRAME_INFO frame__55_61 = {1, {"argument"}};
static void cont__55_62(void);
static void cont__55_63(void);
static void cont__55_64(void);
static NODE *func__55_65;
static void entry__55_65(void);
static FRAME_INFO frame__55_65 = {5, {"functor_string", "self", "arguments", "default_call", "functor"}};
static void cont__55_66(void);
static NODE *func__55_67;
static void entry__55_67(void);
static FRAME_INFO frame__55_67 = {5, {"self", "arguments", "functor_string", "default_call", "functor"}};
static NODE *func__55_68;
static void entry__55_68(void);
static FRAME_INFO frame__55_68 = {4, {"self", "arguments", "functor_string", "default_call"}};
static void cont__55_69(void);
static NODE *func__55_70;
static void entry__55_70(void);
static FRAME_INFO frame__55_70 = {9, {"arguments", "functor_string", "self", "default_call", "left_argument", "right_argument", "left", "right", "length"}};
static void cont__55_71(void);
static void cont__55_72(void);
static void cont__55_73(void);
static void cont__55_74(void);
static void cont__55_75(void);
static void cont__55_76(void);
static NODE *func__55_77;
static void entry__55_77(void);
static FRAME_INFO frame__55_77 = {1, {"left"}};
static void cont__55_78(void);
static void cont__55_79(void);
static void cont__55_80(void);
static void cont__55_81(void);
static void cont__55_82(void);
static NODE *func__55_83;
static void entry__55_83(void);
static FRAME_INFO frame__55_83 = {1, {"right"}};
static void cont__55_84(void);
static void cont__55_85(void);
static void cont__55_86(void);
static void cont__55_87(void);
static void cont__55_88(void);
static void cont__55_89(void);
static void cont__55_90(void);
static void cont__55_91(void);
static void cont__55_92(void);
static void cont__55_93(void);
static void cont__55_94(void);
static NODE *func__55_95;
static void entry__55_95(void);
static FRAME_INFO frame__55_95 = {4, {"self", "left", "functor_string", "right"}};
static NODE *string__55_96;
static NODE *string__55_97;
static void cont__55_98(void);
static void cont__55_99(void);
static NODE *func__55_100;
static void entry__55_100(void);
static FRAME_INFO frame__55_100 = {1, {"self"}};
static void cont__55_101(void);
static NODE *func__55_102;
static void entry__55_102(void);
static FRAME_INFO frame__55_102 = {1, {"self"}};
static void cont__55_103(void);
static void cont__55_104(void);
static NODE *func__55_105;
static void entry__55_105(void);
static FRAME_INFO frame__55_105 = {1, {"self"}};
static void cont__55_106(void);
static NODE *func__55_107;
static void entry__55_107(void);
static FRAME_INFO frame__55_107 = {2, {"return__5", "self"}};
static void cont__55_108(void);
static void cont__55_109(void);
static NODE *func__55_110;
static void entry__55_110(void);
static FRAME_INFO frame__55_110 = {2, {"functor", "arguments"}};
static void cont__55_111(void);
static NODE *func__55_112;
static void entry__55_112(void);
static FRAME_INFO frame__55_112 = {2, {"functor", "arguments"}};
static void cont__55_113(void);
static NODE *string__55_114;
static void cont__55_115(void);
static NODE *func__55_116;
static void entry__55_116(void);
static FRAME_INFO frame__55_116 = {2, {"functor", "arguments"}};
static void cont__55_117(void);
static NODE *string__55_118;
static void cont__55_119(void);
static NODE *func__55_120;
static void entry__55_120(void);
static FRAME_INFO frame__55_120 = {1, {"arguments"}};
static void cont__55_121(void);
static void cont__55_122(void);
static NODE *func__55_123;
static void entry__55_123(void);
static FRAME_INFO frame__55_123 = {1, {"arguments"}};
static void cont__55_124(void);
static void cont__55_125(void);
static NODE *func__55_126;
static void entry__55_126(void);
static FRAME_INFO frame__55_126 = {1, {"arguments"}};
static void cont__55_127(void);
static void cont__55_128(void);
static NODE *func__55_129;
static void entry__55_129(void);
static FRAME_INFO frame__55_129 = {1, {"arguments"}};
static void cont__55_130(void);
static void cont__55_131(void);
static NODE *string__55_132;
static void cont__55_133(void);
static NODE *func__55_134;
static void entry__55_134(void);
static FRAME_INFO frame__55_134 = {1, {"arguments"}};
static void cont__55_135(void);
static void cont__55_136(void);
static NODE *string__55_137;
static void cont__55_138(void);
static void cont__55_139(void);
static void cont__55_140(void);
static void cont__55_141(void);
static void cont__55_142(void);
static void cont__55_143(void);
static void cont__55_144(void);
static void cont__55_145(void);
static NODE *func__55_146;
static void entry__55_146(void);
static FRAME_INFO frame__55_146 = {1, {"arguments"}};
static void cont__55_147(void);
static NODE *string__55_148;
static void cont__55_149(void);
static NODE *func__55_150;
static void entry__55_150(void);
static FRAME_INFO frame__55_150 = {1, {"default_call"}};
static NODE *func__55_151;
static void entry__55_151(void);
static FRAME_INFO frame__55_151 = {3, {"indent", "arguments", "functor_string"}};
static NODE *func__55_152;
static void entry__55_152(void);
static FRAME_INFO frame__55_152 = {4, {"return__7", "indent", "arguments", "functor_string"}};
static void cont__55_153(void);
static void cont__55_154(void);
static void cont__55_155(void);
static NODE *func__55_156;
static void entry__55_156(void);
static FRAME_INFO frame__55_156 = {3, {"arguments", "functor_string", "argument"}};
static void cont__55_157(void);
static void cont__55_158(void);
static void cont__55_159(void);
static NODE *func__55_160;
static void entry__55_160(void);
static FRAME_INFO frame__55_160 = {2, {"functor_string", "argument"}};
static void cont__55_161(void);
static NODE *func__55_162;
static void entry__55_162(void);
static FRAME_INFO frame__55_162 = {2, {"functor_string", "argument"}};
static void cont__55_163(void);
static NODE *func__55_164;
static void entry__55_164(void);
static FRAME_INFO frame__55_164 = {13, {"return__6", "functor_string", "arguments", "indent", "prec", "left", "right", "stringify_le", "stringify_lt", "strings", "inline_functor", "total_width", "buf"}};
static NODE *func__55_165;
static void entry__55_165(void);
static FRAME_INFO frame__55_165 = {3, {"expr", "prec", "str"}};
static void cont__55_166(void);
static void cont__55_167(void);
static void cont__55_168(void);
static void cont__55_169(void);
static NODE *func__55_170;
static void entry__55_170(void);
static FRAME_INFO frame__55_170 = {1, {"str"}};
static NODE *func__55_171;
static void entry__55_171(void);
static FRAME_INFO frame__55_171 = {1, {"str"}};
static NODE *func__55_172;
static void entry__55_172(void);
static FRAME_INFO frame__55_172 = {3, {"expr", "prec", "str"}};
static void cont__55_173(void);
static void cont__55_174(void);
static void cont__55_175(void);
static NODE *func__55_176;
static void entry__55_176(void);
static FRAME_INFO frame__55_176 = {1, {"str"}};
static NODE *func__55_177;
static void entry__55_177(void);
static FRAME_INFO frame__55_177 = {1, {"str"}};
static void cont__55_178(void);
static void cont__55_179(void);
static void cont__55_180(void);
static void cont__55_181(void);
static NODE *func__55_182;
static void entry__55_182(void);
static FRAME_INFO frame__55_182 = {6, {"strings", "stringify_le", "right", "left", "functor_string", "stringify_lt"}};
static void cont__55_183(void);
static void cont__55_184(void);
static NODE *func__55_185;
static void entry__55_185(void);
static FRAME_INFO frame__55_185 = {4, {"left", "functor_string", "strings", "stringify_le"}};
static void cont__55_186(void);
static void cont__55_187(void);
static NODE *func__55_188;
static void entry__55_188(void);
static FRAME_INFO frame__55_188 = {4, {"left", "strings", "stringify_le", "left_operands"}};
static void cont__55_189(void);
static void cont__55_190(void);
static void cont__55_191(void);
static void cont__55_192(void);
static void cont__55_193(void);
static void cont__55_194(void);
static void cont__55_195(void);
static void cont__55_196(void);
static NODE *func__55_197;
static void entry__55_197(void);
static FRAME_INFO frame__55_197 = {6, {"strings", "stringify_le", "left", "right", "functor_string", "stringify_lt"}};
static void cont__55_198(void);
static void cont__55_199(void);
static NODE *func__55_200;
static void entry__55_200(void);
static FRAME_INFO frame__55_200 = {4, {"right", "functor_string", "strings", "stringify_le"}};
static void cont__55_201(void);
static void cont__55_202(void);
static NODE *func__55_203;
static void entry__55_203(void);
static FRAME_INFO frame__55_203 = {4, {"right", "strings", "stringify_le", "right_operands"}};
static void cont__55_204(void);
static void cont__55_205(void);
static void cont__55_206(void);
static void cont__55_207(void);
static void cont__55_208(void);
static void cont__55_209(void);
static void cont__55_210(void);
static void cont__55_211(void);
static void cont__55_212(void);
static NODE *func__55_213;
static void entry__55_213(void);
static FRAME_INFO frame__55_213 = {3, {"break", "strings", "total_width"}};
static NODE *func__55_214;
static void entry__55_214(void);
static FRAME_INFO frame__55_214 = {3, {"str", "total_width", "break"}};
static void cont__55_215(void);
static void cont__55_216(void);
static NODE *func__55_217;
static void entry__55_217(void);
static FRAME_INFO frame__55_217 = {2, {"total_width", "break"}};
static void cont__55_218(void);
static void cont__55_219(void);
static void cont__55_220(void);
static void cont__55_221(void);
static NODE *func__55_222;
static void entry__55_222(void);
static FRAME_INFO frame__55_222 = {1, {"total_width"}};
static void cont__55_223(void);
static void cont__55_224(void);
static void cont__55_225(void);
static void cont__55_226(void);
static NODE *func__55_227;
static void entry__55_227(void);
static FRAME_INFO frame__55_227 = {5, {"inline_functor", "functor_string", "total_width", "strings", "indent"}};
static NODE *string__55_228;
static NODE *string__55_229;
static NODE *string__55_230;
static NODE *string__55_231;
static void cont__55_232(void);
static NODE *func__55_233;
static void entry__55_233(void);
static FRAME_INFO frame__55_233 = {1, {"functor_string"}};
static NODE *func__55_234;
static void entry__55_234(void);
static FRAME_INFO frame__55_234 = {1, {"functor_string"}};
static void cont__55_235(void);
static NODE *func__55_236;
static void entry__55_236(void);
static FRAME_INFO frame__55_236 = {1, {"functor_string"}};
static void cont__55_237(void);
static NODE *string__55_238;
static void cont__55_239(void);
static void cont__55_240(void);
static void cont__55_241(void);
static void cont__55_242(void);
static void cont__55_243(void);
static void cont__55_244(void);
static void cont__55_245(void);
static void cont__55_246(void);
static NODE *func__55_247;
static void entry__55_247(void);
static FRAME_INFO frame__55_247 = {1, {"total_width"}};
static void cont__55_248(void);
static void cont__55_249(void);
static NODE *func__55_250;
static void entry__55_250(void);
static FRAME_INFO frame__55_250 = {3, {"strings", "buf", "inline_functor"}};
static NODE *func__55_251;
static void entry__55_251(void);
static FRAME_INFO frame__55_251 = {2, {"str", "buf"}};
static void cont__55_252(void);
static NODE *func__55_253;
static void entry__55_253(void);
static FRAME_INFO frame__55_253 = {1, {"buf"}};
static void cont__55_254(void);
static void cont__55_255(void);
static void cont__55_256(void);
static void cont__55_257(void);
static NODE *func__55_258;
static void entry__55_258(void);
static FRAME_INFO frame__55_258 = {1, {"buf"}};
static void cont__55_259(void);
static NODE *func__55_260;
static void entry__55_260(void);
static FRAME_INFO frame__55_260 = {2, {"buf", "inline_functor"}};
static void cont__55_261(void);
static NODE *func__55_262;
static void entry__55_262(void);
static FRAME_INFO frame__55_262 = {5, {"functor_string", "buf", "indent", "strings", "indentation"}};
static NODE *func__55_263;
static void entry__55_263(void);
static FRAME_INFO frame__55_263 = {1, {"functor_string"}};
static NODE *string__55_264;
static NODE *string__55_265;
static void cont__55_266(void);
static void cont__55_267(void);
static void cont__55_268(void);
static void cont__55_269(void);
static NODE *func__55_270;
static void entry__55_270(void);
static FRAME_INFO frame__55_270 = {3, {"str", "buf", "indentation"}};
static void cont__55_271(void);
static void cont__55_272(void);
static NODE *func__55_273;
static void entry__55_273(void);
static FRAME_INFO frame__55_273 = {2, {"buf", "indentation"}};
static void cont__55_274(void);
static void cont__55_275(void);
static void cont__55_276(void);
static void cont__55_277(void);
static void cont__55_278(void);
static void cont__55_279(void);
static NODE *func__56_1;
static void entry__56_1(void);
static FRAME_INFO frame__56_1 = {1, {"self"}};
static void cont__56_2(void);
static void cont__56_3(void);
static NODE *func__57_1;
static void entry__57_1(void);
static FRAME_INFO frame__57_1 = {3, {"self", "symbol", "indent"}};
static NODE *func__57_2;
static void entry__57_2(void);
static FRAME_INFO frame__57_2 = {7, {"return__1", "indent", "self", "symbol", "identifier", "value", "separator"}};
static void cont__57_3(void);
static void cont__57_4(void);
static void cont__57_5(void);
static NODE *func__57_6;
static void entry__57_6(void);
static FRAME_INFO frame__57_6 = {1, {"identifier"}};
static void cont__57_7(void);
static NODE *func__57_8;
static void entry__57_8(void);
static FRAME_INFO frame__57_8 = {1, {"identifier"}};
static void cont__57_9(void);
static void cont__57_10(void);
static void cont__57_11(void);
static void cont__57_12(void);
static void cont__57_13(void);
static void cont__57_14(void);
static void cont__57_15(void);
static void cont__57_16(void);
static void cont__57_17(void);
static void cont__57_18(void);
static NODE *func__57_19;
static void entry__57_19(void);
static FRAME_INFO frame__57_19 = {0, {}};
static NODE *func__57_20;
static void entry__57_20(void);
static FRAME_INFO frame__57_20 = {0, {}};
static NODE *string__57_21;
static void cont__57_22(void);
static NODE *func__57_23;
static void entry__57_23(void);
static FRAME_INFO frame__57_23 = {4, {"value", "indent", "symbol", "identifier"}};
static void cont__57_24(void);
static void cont__57_25(void);
static NODE *func__57_26;
static void entry__57_26(void);
static FRAME_INFO frame__57_26 = {4, {"indent", "symbol", "identifier", "value"}};
static void cont__57_27(void);
static void cont__57_28(void);
static NODE *func__57_29;
static void entry__57_29(void);
static FRAME_INFO frame__57_29 = {5, {"value", "indent", "symbol", "identifier", "separator"}};
static void cont__57_30(void);
static NODE *func__57_31;
static void entry__57_31(void);
static FRAME_INFO frame__57_31 = {5, {"indent", "symbol", "identifier", "separator", "value"}};
static void cont__57_32(void);
static void cont__57_33(void);
static NODE *func__57_34;
static void entry__57_34(void);
static FRAME_INFO frame__57_34 = {4, {"indent", "identifier", "value", "symbol"}};
static void cont__57_35(void);
static void cont__57_36(void);
static void cont__57_37(void);
static void cont__57_38(void);
static void cont__57_39(void);
static void cont__57_40(void);
static void cont__57_41(void);
static NODE *func__57_42;
static void entry__57_42(void);
static FRAME_INFO frame__57_42 = {4, {"indent", "symbol", "identifier", "value"}};
static void cont__57_43(void);
static void cont__57_44(void);
static void cont__57_45(void);
static NODE *func__57_46;
static void entry__57_46(void);
static FRAME_INFO frame__57_46 = {4, {"symbol", "identifier", "separator", "value"}};
static NODE *func__57_47;
static void entry__57_47(void);
static FRAME_INFO frame__57_47 = {4, {"symbol", "identifier", "separator", "value"}};
static void cont__57_48(void);
static void cont__57_49(void);
static NODE *func__58_1;
static void entry__58_1(void);
static FRAME_INFO frame__58_1 = {1, {"self"}};
static NODE *func__59_1;
static void entry__59_1(void);
static FRAME_INFO frame__59_1 = {1, {"self"}};
static NODE *func__60_1;
static void entry__60_1(void);
static FRAME_INFO frame__60_1 = {1, {"self"}};
static void cont__60_2(void);
static NODE *func__62_1;
static void entry__62_1(void);
static FRAME_INFO frame__62_1 = {0, {}};
static NODE *func__62_2;
static void entry__62_2(void);
static FRAME_INFO frame__62_2 = {2, {"name", "chr"}};
static void cont__62_3(void);
static NODE *func__62_4;
static void entry__62_4(void);
static FRAME_INFO frame__62_4 = {1, {"chr"}};
static void cont__62_5(void);
static void cont__62_6(void);
static NODE *func__62_7;
static void entry__62_7(void);
static FRAME_INFO frame__62_7 = {2, {"chr", "name"}};
static void cont__62_8(void);
static void cont__62_9(void);
static void cont__62_10(void);
static NODE *func__63_1;
static void entry__63_1(void);
static FRAME_INFO frame__63_1 = {2, {"chr", "name"}};
static void cont__63_2(void);
static void cont__63_3(void);
static void cont__63_4(void);
static void cont__63_5(void);
static NODE *func__63_6;
static void entry__63_6(void);
static FRAME_INFO frame__63_6 = {1, {"name"}};
static NODE *func__63_7;
static void entry__63_7(void);
static FRAME_INFO frame__63_7 = {1, {"name"}};
static void cont__63_8(void);
static NODE *string__63_9;
static NODE *func__63_10;
static void entry__63_10(void);
static FRAME_INFO frame__63_10 = {0, {}};
static NODE *string__63_11;
static NODE *string__63_12;
static NODE *func__63_13;
static void entry__63_13(void);
static FRAME_INFO frame__63_13 = {0, {}};
static NODE *string__63_14;
static NODE *func__63_15;
static void entry__63_15(void);
static FRAME_INFO frame__63_15 = {1, {"chr"}};
static void cont__63_16(void);
static void cont__63_17(void);
static NODE *func__63_18;
static void entry__63_18(void);
static FRAME_INFO frame__63_18 = {1, {"chr"}};
static void cont__63_19(void);
static void cont__63_20(void);
static NODE *func__63_21;
static void entry__63_21(void);
static FRAME_INFO frame__63_21 = {1, {"chr"}};
static void cont__63_22(void);
static void cont__63_23(void);
static void cont__63_24(void);
static void cont__63_25(void);
static NODE *func__63_26;
static void entry__63_26(void);
static FRAME_INFO frame__63_26 = {1, {"chr"}};
static void cont__63_27(void);
static void cont__63_28(void);
static NODE *string__63_29;
static void cont__63_30(void);
static NODE *func__63_31;
static void entry__63_31(void);
static FRAME_INFO frame__63_31 = {1, {"chr"}};
static void cont__63_32(void);
static NODE *func__64_1;
static void entry__64_1(void);
static FRAME_INFO frame__64_1 = {1, {"self"}};
static void cont__64_2(void);
static void cont__64_3(void);
static void cont__64_4(void);
static NODE *func__65_1;
static void entry__65_1(void);
static FRAME_INFO frame__65_1 = {7, {"text", "return", "lines", "is_inline", "use_single_line_form", "part", "s"}};
static void exit__65_1(void);
static void cont__65_2(void);
static NODE *func__65_3;
static void entry__65_3(void);
static FRAME_INFO frame__65_3 = {2, {"lines", "return"}};
static void cont__65_4(void);
static void cont__65_5(void);
static void cont__65_6(void);
static void cont__65_7(void);
static NODE *func__65_8;
static void entry__65_8(void);
static FRAME_INFO frame__65_8 = {3, {"lines", "text", "return"}};
static void cont__65_9(void);
static NODE *string__65_10;
static void cont__65_11(void);
static void cont__65_12(void);
static void cont__65_13(void);
static void cont__65_14(void);
static NODE *func__65_15;
static void entry__65_15(void);
static FRAME_INFO frame__65_15 = {1, {"text"}};
static void cont__65_16(void);
static void cont__65_17(void);
static void cont__65_18(void);
static void cont__65_19(void);
static NODE *func__65_20;
static void entry__65_20(void);
static FRAME_INFO frame__65_20 = {8, {"idx", "chr", "part", "text", "s", "use_single_line_form", "lines", "is_inline"}};
static NODE *func__65_21;
static void entry__65_21(void);
static FRAME_INFO frame__65_21 = {6, {"part", "text", "s", "idx", "use_single_line_form", "lines"}};
static void cont__65_22(void);
static void cont__65_23(void);
static void cont__65_24(void);
static NODE *func__65_25;
static void entry__65_25(void);
static FRAME_INFO frame__65_25 = {1, {"part"}};
static NODE *string__65_26;
static void cont__65_27(void);
static NODE *func__65_28;
static void entry__65_28(void);
static FRAME_INFO frame__65_28 = {2, {"lines", "part"}};
static void cont__65_29(void);
static void cont__65_30(void);
static void cont__65_31(void);
static NODE *func__65_32;
static void entry__65_32(void);
static FRAME_INFO frame__65_32 = {6, {"use_single_line_form", "part", "text", "s", "idx", "is_inline"}};
static NODE *func__65_33;
static void entry__65_33(void);
static FRAME_INFO frame__65_33 = {4, {"part", "text", "s", "idx"}};
static void cont__65_34(void);
static void cont__65_35(void);
static void cont__65_36(void);
static NODE *string__65_37;
static void cont__65_38(void);
static void cont__65_39(void);
static NODE *func__65_40;
static void entry__65_40(void);
static FRAME_INFO frame__65_40 = {1, {"is_inline"}};
static NODE *func__65_41;
static void entry__65_41(void);
static FRAME_INFO frame__65_41 = {4, {"part", "text", "s", "idx"}};
static void cont__65_42(void);
static void cont__65_43(void);
static void cont__65_44(void);
static NODE *string__65_45;
static void cont__65_46(void);
static void cont__65_47(void);
static NODE *func__65_48;
static void entry__65_48(void);
static FRAME_INFO frame__65_48 = {6, {"chr", "part", "text", "s", "idx", "escaped"}};
static void cont__65_49(void);
static void cont__65_50(void);
static void cont__65_51(void);
static NODE *func__65_52;
static void entry__65_52(void);
static FRAME_INFO frame__65_52 = {5, {"part", "text", "s", "idx", "escaped"}};
static void cont__65_53(void);
static void cont__65_54(void);
static void cont__65_55(void);
static void cont__65_56(void);
static void cont__65_57(void);
static void cont__65_58(void);
static void cont__65_59(void);
static void cont__65_60(void);
static void cont__65_61(void);
static void cont__65_62(void);
static NODE *func__65_63;
static void entry__65_63(void);
static FRAME_INFO frame__65_63 = {1, {"is_inline"}};
static NODE *func__65_64;
static void entry__65_64(void);
static FRAME_INFO frame__65_64 = {4, {"lines", "part", "is_inline", "max_width"}};
static void cont__65_65(void);
static void cont__65_66(void);
static void cont__65_67(void);
static void cont__65_68(void);
static NODE *func__65_69;
static void entry__65_69(void);
static FRAME_INFO frame__65_69 = {0, {}};
static NODE *func__65_70;
static void entry__65_70(void);
static FRAME_INFO frame__65_70 = {0, {}};
static void cont__65_71(void);
static void cont__65_72(void);
static void cont__65_73(void);
static NODE *func__65_74;
static void entry__65_74(void);
static FRAME_INFO frame__65_74 = {2, {"max_width", "part"}};
static void cont__65_75(void);
static void cont__65_76(void);
static void cont__65_77(void);
static void cont__65_78(void);
static void cont__65_79(void);
static NODE *func__65_80;
static void entry__65_80(void);
static FRAME_INFO frame__65_80 = {1, {"is_inline"}};
static void cont__65_81(void);
static NODE *func__65_82;
static void entry__65_82(void);
static FRAME_INFO frame__65_82 = {2, {"lines", "part"}};
static void cont__65_83(void);
static NODE *func__65_84;
static void entry__65_84(void);
static FRAME_INFO frame__65_84 = {2, {"lines", "part"}};
static void cont__65_85(void);
static void cont__65_86(void);
static void cont__65_87(void);
static NODE *func__66_1;
static void entry__66_1(void);
static FRAME_INFO frame__66_1 = {2, {"lines", "is_inline"}};
static NODE *func__66_2;
static void entry__66_2(void);
static FRAME_INFO frame__66_2 = {2, {"lines", "is_inline"}};
static void cont__66_3(void);
static NODE *func__66_4;
static void entry__66_4(void);
static FRAME_INFO frame__66_4 = {2, {"lines", "is_inline"}};
static void cont__66_5(void);
static void cont__66_6(void);
static void cont__66_7(void);
static void cont__66_8(void);
static void cont__66_9(void);
static NODE *func__66_10;
static void entry__66_10(void);
static FRAME_INFO frame__66_10 = {2, {"lines", "is_inline"}};
static void cont__66_11(void);
static void cont__66_12(void);
static void cont__66_13(void);
static void cont__66_14(void);
static NODE *func__66_15;
static void entry__66_15(void);
static FRAME_INFO frame__66_15 = {1, {"lines"}};
static void cont__66_16(void);
static void cont__66_17(void);
static NODE *func__66_18;
static void entry__66_18(void);
static FRAME_INFO frame__66_18 = {7, {"lines", "max_width", "has_leading_spaces", "split_lines", "buf", "indent", "indentation"}};
static void cont__66_19(void);
static void cont__66_20(void);
static void cont__66_21(void);
static void cont__66_22(void);
static NODE *func__66_23;
static void entry__66_23(void);
static FRAME_INFO frame__66_23 = {0, {}};
static NODE *func__66_24;
static void entry__66_24(void);
static FRAME_INFO frame__66_24 = {0, {}};
static void cont__66_25(void);
static void cont__66_26(void);
static void cont__66_27(void);
static void cont__66_28(void);
static void cont__66_29(void);
static void cont__66_30(void);
static NODE *func__66_31;
static void entry__66_31(void);
static FRAME_INFO frame__66_31 = {4, {"line", "has_leading_spaces", "max_width", "split_lines"}};
static void cont__66_32(void);
static void cont__66_33(void);
static NODE *func__66_34;
static void entry__66_34(void);
static FRAME_INFO frame__66_34 = {1, {"line"}};
static void cont__66_35(void);
static void cont__66_36(void);
static void cont__66_37(void);
static void cont__66_38(void);
static NODE *func__66_39;
static void entry__66_39(void);
static FRAME_INFO frame__66_39 = {1, {"has_leading_spaces"}};
static void cont__66_40(void);
static NODE *func__66_41;
static void entry__66_41(void);
static FRAME_INFO frame__66_41 = {3, {"max_width", "line", "split_lines"}};
static void cont__66_42(void);
static void cont__66_43(void);
static NODE *func__66_44;
static void entry__66_44(void);
static FRAME_INFO frame__66_44 = {9, {"line", "max_width", "split_lines", "skip_till_end_of_string", "skip_till_close", "skip_special", "best_split_pos", "last_valid_pos", "pos"}};
static NODE *func__66_45;
static void entry__66_45(void);
static FRAME_INFO frame__66_45 = {3, {"pos", "line", "skip_special"}};
static NODE *func__66_46;
static void entry__66_46(void);
static FRAME_INFO frame__66_46 = {3, {"pos", "line", "skip_special"}};
static void cont__66_47(void);
static void cont__66_48(void);
static void cont__66_49(void);
static NODE *func__66_50;
static void entry__66_50(void);
static FRAME_INFO frame__66_50 = {2, {"skip_special", "pos"}};
static void cont__66_51(void);
static void cont__66_52(void);
static void cont__66_53(void);
static void cont__66_54(void);
static void cont__66_55(void);
static void cont__66_56(void);
static NODE *func__66_57;
static void entry__66_57(void);
static FRAME_INFO frame__66_57 = {4, {"pos", "line", "skip_till_close", "skip_till_end_of_string"}};
static NODE *func__66_58;
static void entry__66_58(void);
static FRAME_INFO frame__66_58 = {4, {"pos", "line", "skip_till_close", "skip_till_end_of_string"}};
static void cont__66_59(void);
static void cont__66_60(void);
static void cont__66_61(void);
static NODE *func__66_62;
static void entry__66_62(void);
static FRAME_INFO frame__66_62 = {2, {"skip_till_close", "pos"}};
static void cont__66_63(void);
static void cont__66_64(void);
static void cont__66_65(void);
static void cont__66_66(void);
static void cont__66_67(void);
static NODE *func__66_68;
static void entry__66_68(void);
static FRAME_INFO frame__66_68 = {2, {"skip_till_end_of_string", "pos"}};
static void cont__66_69(void);
static void cont__66_70(void);
static void cont__66_71(void);
static void cont__66_72(void);
static void cont__66_73(void);
static void cont__66_74(void);
static NODE *func__66_75;
static void entry__66_75(void);
static FRAME_INFO frame__66_75 = {3, {"pos", "line", "skip_till_close"}};
static void cont__66_76(void);
static void cont__66_77(void);
static void cont__66_78(void);
static NODE *func__66_79;
static void entry__66_79(void);
static FRAME_INFO frame__66_79 = {3, {"line", "pos", "skip_till_close"}};
static void cont__66_80(void);
static void cont__66_81(void);
static NODE *func__66_82;
static void entry__66_82(void);
static FRAME_INFO frame__66_82 = {1, {"skip_till_close"}};
static NODE *func__66_83;
static void entry__66_83(void);
static FRAME_INFO frame__66_83 = {2, {"line", "pos"}};
static NODE *func__66_84;
static void entry__66_84(void);
static FRAME_INFO frame__66_84 = {2, {"line", "pos"}};
static void cont__66_85(void);
static void cont__66_86(void);
static void cont__66_87(void);
static NODE *func__66_88;
static void entry__66_88(void);
static FRAME_INFO frame__66_88 = {1, {"pos"}};
static void cont__66_89(void);
static NODE *func__66_90;
static void entry__66_90(void);
static FRAME_INFO frame__66_90 = {6, {"pos", "max_width", "line", "best_split_pos", "skip_special", "last_valid_pos"}};
static void cont__66_91(void);
static NODE *func__66_92;
static void entry__66_92(void);
static FRAME_INFO frame__66_92 = {7, {"line", "pos", "best_split_pos", "skip_special", "max_width", "last_valid_pos", "chr"}};
static void cont__66_93(void);
static void cont__66_94(void);
static NODE *func__66_95;
static void entry__66_95(void);
static FRAME_INFO frame__66_95 = {2, {"best_split_pos", "pos"}};
static NODE *func__66_96;
static void entry__66_96(void);
static FRAME_INFO frame__66_96 = {7, {"chr", "skip_special", "pos", "max_width", "line", "best_split_pos", "last_valid_pos"}};
static void cont__66_97(void);
static NODE *func__66_98;
static void entry__66_98(void);
static FRAME_INFO frame__66_98 = {6, {"skip_special", "pos", "max_width", "line", "best_split_pos", "last_valid_pos"}};
static void cont__66_99(void);
static NODE *func__66_100;
static void entry__66_100(void);
static FRAME_INFO frame__66_100 = {4, {"pos", "max_width", "line", "best_split_pos"}};
static void cont__66_101(void);
static NODE *func__66_102;
static void entry__66_102(void);
static FRAME_INFO frame__66_102 = {2, {"line", "pos"}};
static void cont__66_103(void);
static void cont__66_104(void);
static void cont__66_105(void);
static NODE *func__66_106;
static void entry__66_106(void);
static FRAME_INFO frame__66_106 = {2, {"best_split_pos", "pos"}};
static NODE *func__66_107;
static void entry__66_107(void);
static FRAME_INFO frame__66_107 = {2, {"last_valid_pos", "pos"}};
static void cont__66_108(void);
static NODE *func__66_109;
static void entry__66_109(void);
static FRAME_INFO frame__66_109 = {2, {"last_valid_pos", "pos"}};
static NODE *func__66_110;
static void entry__66_110(void);
static FRAME_INFO frame__66_110 = {2, {"last_valid_pos", "pos"}};
static void cont__66_111(void);
static void cont__66_112(void);
static void cont__66_113(void);
static void cont__66_114(void);
static NODE *func__66_115;
static void entry__66_115(void);
static FRAME_INFO frame__66_115 = {2, {"best_split_pos", "last_valid_pos"}};
static void cont__66_116(void);
static void cont__66_117(void);
static void cont__66_118(void);
static void cont__66_119(void);
static void cont__66_120(void);
static void cont__66_121(void);
static void cont__66_122(void);
static void cont__66_123(void);
static void cont__66_124(void);
static void cont__66_125(void);
static NODE *func__66_126;
static void entry__66_126(void);
static FRAME_INFO frame__66_126 = {1, {"lines"}};
static NODE *string__66_127;
static void cont__66_128(void);
static void cont__66_129(void);
static void cont__66_130(void);
static void cont__66_131(void);
static void cont__66_132(void);
static NODE *func__66_133;
static void entry__66_133(void);
static FRAME_INFO frame__66_133 = {1, {"lines"}};
static NODE *string__66_134;
static void cont__66_135(void);
static void cont__66_136(void);
static void cont__66_137(void);
static void cont__66_138(void);
static void cont__66_139(void);
static NODE *func__66_140;
static void entry__66_140(void);
static FRAME_INFO frame__66_140 = {1, {"buf"}};
static NODE *string__66_141;
static NODE *func__66_142;
static void entry__66_142(void);
static FRAME_INFO frame__66_142 = {2, {"buf", "indent"}};
static void cont__66_143(void);
static void cont__66_144(void);
static void cont__66_145(void);
static void cont__66_146(void);
static void cont__66_147(void);
static NODE *func__66_148;
static void entry__66_148(void);
static FRAME_INFO frame__66_148 = {3, {"line", "buf", "indentation"}};
static void cont__66_149(void);
static void cont__66_150(void);
static NODE *func__66_151;
static void entry__66_151(void);
static FRAME_INFO frame__66_151 = {3, {"buf", "indentation", "line"}};
static void cont__66_152(void);
static void cont__66_153(void);
static void cont__66_154(void);
static NODE *func__67_1;
static void entry__67_1(void);
static FRAME_INFO frame__67_1 = {5, {"self", "lines", "template_is_inline", "add_part", "add_lines"}};
static NODE *func__67_2;
static void entry__67_2(void);
static FRAME_INFO frame__67_2 = {3, {"part", "lines", "template_is_inline"}};
static void cont__67_3(void);
static NODE *func__67_4;
static void entry__67_4(void);
static FRAME_INFO frame__67_4 = {2, {"lines", "part"}};
static void cont__67_5(void);
static NODE *func__67_6;
static void entry__67_6(void);
static FRAME_INFO frame__67_6 = {3, {"template_is_inline", "lines", "part"}};
static NODE *func__67_7;
static void entry__67_7(void);
static FRAME_INFO frame__67_7 = {2, {"lines", "part"}};
static void cont__67_8(void);
static void cont__67_9(void);
static void cont__67_10(void);
static NODE *func__67_11;
static void entry__67_11(void);
static FRAME_INFO frame__67_11 = {2, {"part", "lines"}};
static void cont__67_12(void);
static void cont__67_13(void);
static void cont__67_14(void);
static void cont__67_15(void);
static NODE *func__67_16;
static void entry__67_16(void);
static FRAME_INFO frame__67_16 = {2, {"lines", "part"}};
static void cont__67_17(void);
static void cont__67_18(void);
static void cont__67_19(void);
static void cont__67_20(void);
static void cont__67_21(void);
static void cont__67_22(void);
static void cont__67_23(void);
static NODE *func__67_24;
static void entry__67_24(void);
static FRAME_INFO frame__67_24 = {2, {"lines", "part"}};
static void cont__67_25(void);
static NODE *func__67_26;
static void entry__67_26(void);
static FRAME_INFO frame__67_26 = {3, {"more_lines", "lines", "template_is_inline"}};
static void cont__67_27(void);
static NODE *func__67_28;
static void entry__67_28(void);
static FRAME_INFO frame__67_28 = {2, {"lines", "more_lines"}};
static NODE *func__67_29;
static void entry__67_29(void);
static FRAME_INFO frame__67_29 = {3, {"template_is_inline", "more_lines", "lines"}};
static NODE *func__67_30;
static void entry__67_30(void);
static FRAME_INFO frame__67_30 = {2, {"more_lines", "lines"}};
static void cont__67_31(void);
static void cont__67_32(void);
static void cont__67_33(void);
static void cont__67_34(void);
static NODE *func__67_35;
static void entry__67_35(void);
static FRAME_INFO frame__67_35 = {2, {"lines", "more_lines"}};
static void cont__67_36(void);
static void cont__67_37(void);
static void cont__67_38(void);
static void cont__67_39(void);
static void cont__67_40(void);
static void cont__67_41(void);
static void cont__67_42(void);
static void cont__67_43(void);
static void cont__67_44(void);
static void cont__67_45(void);
static void cont__67_46(void);
static void cont__67_47(void);
static void cont__67_48(void);
static NODE *func__67_49;
static void entry__67_49(void);
static FRAME_INFO frame__67_49 = {3, {"argument", "add_part", "add_lines"}};
static void cont__67_50(void);
static NODE *func__67_51;
static void entry__67_51(void);
static FRAME_INFO frame__67_51 = {5, {"argument", "add_part", "add_lines", "more_lines", "is_inline"}};
static void cont__67_52(void);
static void cont__67_53(void);
static NODE *func__67_54;
static void entry__67_54(void);
static FRAME_INFO frame__67_54 = {2, {"add_part", "more_lines"}};
static void cont__67_55(void);
static NODE *func__67_56;
static void entry__67_56(void);
static FRAME_INFO frame__67_56 = {2, {"add_lines", "more_lines"}};
static NODE *func__67_57;
static void entry__67_57(void);
static FRAME_INFO frame__67_57 = {3, {"return__1", "add_part", "argument"}};
static void cont__67_58(void);
static NODE *string__67_59;
static void cont__67_60(void);
static void cont__67_61(void);
static void cont__67_62(void);
static void cont__67_63(void);
static void cont__67_64(void);
static NODE *string__67_65;
static void cont__67_66(void);
static NODE *func__67_67;
static void entry__67_67(void);
static FRAME_INFO frame__67_67 = {1, {"lines"}};
static void cont__67_68(void);
static void cont__67_69(void);
static void cont__67_70(void);
static void cont__67_71(void);
static void cont__67_72(void);
static void cont__67_73(void);
static void cont__67_74(void);
static NODE *func__68_1;
static void entry__68_1(void);
static FRAME_INFO frame__68_1 = {1, {"self"}};
static void cont__68_2(void);
static void cont__68_3(void);
static NODE *func__68_4;
static void entry__68_4(void);
static FRAME_INFO frame__68_4 = {3, {"self", "lines", "is_inline"}};
static void cont__68_5(void);
static void cont__68_6(void);
static NODE *func__68_7;
static void entry__68_7(void);
static FRAME_INFO frame__68_7 = {4, {"return__1", "self", "lines", "is_inline"}};
static void cont__68_8(void);
static void cont__68_9(void);
static void cont__68_10(void);
static void cont__68_11(void);
static NODE *func__69_1;
static void entry__69_1(void);
static FRAME_INFO frame__69_1 = {1, {"self"}};
static NODE *string__69_2;
static NODE *func__70_1;
static void entry__70_1(void);
static FRAME_INFO frame__70_1 = {1, {"self"}};
static void cont__70_2(void);
static NODE *func__70_3;
static void entry__70_3(void);
static FRAME_INFO frame__70_3 = {0, {}};
static NODE *string__70_4;
static NODE *func__70_5;
static void entry__70_5(void);
static FRAME_INFO frame__70_5 = {0, {}};
static NODE *string__70_6;
static void cont__70_7(void);
static NODE *func__71_1;
static void entry__71_1(void);
static FRAME_INFO frame__71_1 = {1, {"self"}};
static NODE *func__71_2;
static void entry__71_2(void);
static FRAME_INFO frame__71_2 = {1, {"self"}};
static void cont__71_3(void);
static void cont__71_4(void);
static NODE *func__71_5;
static void entry__71_5(void);
static FRAME_INFO frame__71_5 = {1, {"self"}};
static void cont__71_6(void);
static void cont__71_7(void);
static NODE *string__71_8;
static void cont__71_9(void);
static NODE *func__71_10;
static void entry__71_10(void);
static FRAME_INFO frame__71_10 = {1, {"self"}};
static void cont__71_11(void);
static NODE *func__71_12;
static void entry__71_12(void);
static FRAME_INFO frame__71_12 = {1, {"self"}};
static void cont__71_13(void);
static void cont__71_14(void);
static NODE *func__71_15;
static void entry__71_15(void);
static FRAME_INFO frame__71_15 = {1, {"self"}};
static NODE *func__71_16;
static void entry__71_16(void);
static FRAME_INFO frame__71_16 = {1, {"self"}};
static void cont__71_17(void);
static void cont__71_18(void);
static NODE *func__72_1;
static void entry__72_1(void);
static FRAME_INFO frame__72_1 = {1, {"self"}};
static NODE *func__72_2;
static void entry__72_2(void);
static FRAME_INFO frame__72_2 = {4, {"self", "buf", "indent", "indentation"}};
static void cont__72_3(void);
static NODE *func__72_4;
static void entry__72_4(void);
static FRAME_INFO frame__72_4 = {0, {}};
static void cont__72_5(void);
static NODE *string__72_6;
static void cont__72_7(void);
static NODE *func__72_8;
static void entry__72_8(void);
static FRAME_INFO frame__72_8 = {0, {}};
static NODE *string__72_9;
static void cont__72_10(void);
static void cont__72_11(void);
static void cont__72_12(void);
static void cont__72_13(void);
static void cont__72_14(void);
static NODE *func__72_15;
static void entry__72_15(void);
static FRAME_INFO frame__72_15 = {3, {"buf", "indentation", "self"}};
static void cont__72_16(void);
static NODE *string__72_17;
static NODE *string__72_18;
static void cont__72_19(void);
static void cont__72_20(void);
static void cont__72_21(void);
static void cont__72_22(void);
static void cont__72_23(void);
static NODE *func__72_24;
static void entry__72_24(void);
static FRAME_INFO frame__72_24 = {3, {"buf", "indentation", "self"}};
static void cont__72_25(void);
static NODE *string__72_26;
static NODE *string__72_27;
static void cont__72_28(void);
static void cont__72_29(void);
static void cont__72_30(void);
static void cont__72_31(void);
static void cont__72_32(void);
static NODE *func__72_33;
static void entry__72_33(void);
static FRAME_INFO frame__72_33 = {3, {"buf", "indentation", "self"}};
static void cont__72_34(void);
static NODE *string__72_35;
static NODE *string__72_36;
static void cont__72_37(void);
static void cont__72_38(void);
static void cont__72_39(void);
static void cont__72_40(void);
static void cont__72_41(void);
static NODE *func__72_42;
static void entry__72_42(void);
static FRAME_INFO frame__72_42 = {3, {"buf", "indentation", "self"}};
static void cont__72_43(void);
static NODE *string__72_44;
static NODE *string__72_45;
static void cont__72_46(void);
static void cont__72_47(void);
static void cont__72_48(void);
static void cont__72_49(void);
static void cont__72_50(void);
static NODE *func__72_51;
static void entry__72_51(void);
static FRAME_INFO frame__72_51 = {3, {"buf", "indentation", "self"}};
static void cont__72_52(void);
static NODE *string__72_53;
static NODE *string__72_54;
static void cont__72_55(void);
static void cont__72_56(void);
static void cont__72_57(void);
static void cont__72_58(void);
static void cont__72_59(void);
static NODE *func__72_60;
static void entry__72_60(void);
static FRAME_INFO frame__72_60 = {1, {"self"}};
static void cont__72_61(void);
static NODE *string__72_62;
static void cont__72_63(void);
static void cont__72_64(void);
static void cont__72_65(void);
static NODE *func__72_66;
static void entry__72_66(void);
static FRAME_INFO frame__72_66 = {3, {"buf", "indentation", "self"}};
static void cont__72_67(void);
static NODE *string__72_68;
static NODE *string__72_69;
static void cont__72_70(void);
static void cont__72_71(void);
static void cont__72_72(void);
static void cont__72_73(void);
static NODE *func__72_74;
static void entry__72_74(void);
static FRAME_INFO frame__72_74 = {3, {"argument", "buf", "indentation"}};
static NODE *string__72_75;
static NODE *string__72_76;
static void cont__72_77(void);
static void cont__72_78(void);
static void cont__72_79(void);
static void cont__72_80(void);
static void cont__72_81(void);
static NODE *func__72_82;
static void entry__72_82(void);
static FRAME_INFO frame__72_82 = {3, {"buf", "self", "indentation"}};
static void cont__72_83(void);
static void cont__72_84(void);
static NODE *func__72_85;
static void entry__72_85(void);
static FRAME_INFO frame__72_85 = {3, {"remark_line", "buf", "indentation"}};
static NODE *string__72_86;
static void cont__72_87(void);
static void cont__72_88(void);
static void cont__72_89(void);
static void cont__72_90(void);
static NODE *func__72_91;
static void entry__72_91(void);
static FRAME_INFO frame__72_91 = {3, {"buf", "self", "indentation"}};
static void cont__72_92(void);
static void cont__72_93(void);
static NODE *func__72_94;
static void entry__72_94(void);
static FRAME_INFO frame__72_94 = {1, {"buf"}};
static void cont__72_95(void);
static void cont__72_96(void);
static void cont__72_97(void);
static NODE *func__72_98;
static void entry__72_98(void);
static FRAME_INFO frame__72_98 = {3, {"line", "buf", "indentation"}};
static void cont__72_99(void);
static void cont__72_100(void);
static void cont__72_101(void);
static void cont__72_102(void);
static void cont__72_103(void);
static NODE *func__72_104;
static void entry__72_104(void);
static FRAME_INFO frame__72_104 = {0, {}};
static NODE *string__72_105;
static void cont__93_1(void);
static void cont__94_1(void);
void run__pretty_printer(void);

static CONTINUATION_INFO continuation_info[] = {
  {type__needs_parenthesis, NULL, 29, 29, 2, 18},
  {run__pretty_printer, NULL, 134, 134, 1, 35},
  {cont__93_1, NULL, 135, 135, 1, 40},
  {cont__94_1, NULL, 1137, 1137, 1, 29},
  {entry__24_7, NULL, 145, 145, 7, 15},
  {cont__24_8, &frame__24_7, 145, 145, 7, 42},
  {cont__24_9, &frame__24_7, 145, 145, 7, 42},
  {cont__24_10, &frame__24_7, 145, 145, 7, 42},
  {entry__24_3, NULL, 144, 144, 7, 15},
  {cont__24_4, &frame__24_3, 144, 144, 7, 37},
  {cont__24_5, &frame__24_3, 144, 144, 7, 37},
  {cont__24_6, &frame__24_3, 145, 145, 7, 42},
  {cont__24_11, &frame__24_3, },
  {entry__24_13, NULL, 146, 146, 5, 8},
  {entry__24_14, NULL, 147, 147, 5, 8},
  {entry__24_1, NULL, 143, 143, 7, 35},
  {cont__24_2, &frame__24_1, },
  {cont__24_12, &frame__24_1, 141, 147, 3, 8},
  {entry__27_5, NULL, 162, 162, 5, 28},
  {cont__27_6, &frame__27_5, 163, 163, 5, 19},
  {cont__27_7, &frame__27_5, 163, 163, 19, 19},
  {entry__27_2, NULL, 161, 161, 12, 22},
  {cont__27_3, &frame__27_2, 161, 161, 12, 22},
  {cont__27_4, &frame__27_2, 161, 163, 9, 19},
  {entry__27_1, NULL, 161, 163, 3, 19},
  {cont__27_8, &frame__27_1, 164, 164, 22, 40},
  {cont__27_9, &frame__27_1, 164, 164, 3, 40},
  {entry__28_2, NULL, 172, 172, 35, 45},
  {cont__28_3, &frame__28_2, 172, 172, 15, 45},
  {cont__28_4, &frame__28_2, 172, 172, 8, 47},
  {cont__28_5, &frame__28_2, 172, 172, 5, 47},
  {entry__28_10, NULL, 189, 189, 22, 28},
  {cont__28_11, &frame__28_10, 189, 189, 22, 47},
  {cont__28_12, &frame__28_10, 189, 189, 11, 48},
  {cont__28_13, &frame__28_10, 190, 190, 31, 31},
  {cont__28_14, &frame__28_10, 190, 190, 11, 32},
  {cont__28_15, &frame__28_10, 191, 191, 29, 54},
  {cont__28_16, &frame__28_10, 191, 191, 22, 60},
  {cont__28_17, &frame__28_10, 191, 191, 11, 60},
  {cont__28_18, &frame__28_10, 191, 191, 60, 60},
  {entry__28_19, NULL, 193, 193, 11, 23},
  {cont__28_20, &frame__28_19, 193, 193, 23, 23},
  {entry__28_7, NULL, 188, 188, 9, 23},
  {cont__28_8, &frame__28_7, 188, 188, 9, 27},
  {cont__28_9, &frame__28_7, 187, 193, 7, 24},
  {entry__28_25, NULL, 181, 181, 36, 74},
  {cont__28_26, &frame__28_25, 181, 181, 36, 74},
  {cont__28_27, &frame__28_25, 181, 181, 36, 74},
  {entry__28_23, NULL, 181, 181, 9, 31},
  {cont__28_24, &frame__28_23, 181, 181, 9, 74},
  {cont__28_28, &frame__28_23, 181, 181, 9, 74},
  {entry__28_30, NULL, 183, 183, 9, 15},
  {entry__28_36, NULL, 198, 198, 28, 30},
  {cont__28_37, &frame__28_36, 198, 198, 18, 33},
  {cont__28_38, &frame__28_36, 198, 198, 9, 33},
  {cont__28_39, &frame__28_36, 199, 199, 9, 14},
  {cont__28_40, &frame__28_36, 199, 199, 14, 14},
  {entry__28_33, NULL, 197, 197, 10, 15},
  {cont__28_34, &frame__28_33, 197, 197, 10, 25},
  {cont__28_35, &frame__28_33, 197, 199, 7, 14},
  {entry__28_46, NULL, 204, 204, 28, 39},
  {entry__28_6, NULL, 177, 177, 5, 23},
  {cont__28_21, &frame__28_6, 180, 180, 9, 15},
  {cont__28_22, &frame__28_6, 179, 181, 7, 73},
  {cont__28_29, &frame__28_6, 178, 183, 5, 16},
  {cont__28_31, &frame__28_6, 195, 195, 5, 22},
  {cont__28_32, &frame__28_6, 196, 199, 5, 15},
  {cont__28_41, &frame__28_6, 202, 202, 9, 17},
  {cont__28_42, &frame__28_6, 203, 203, 9, 22},
  {cont__28_43, &frame__28_6, 201, 203, 7, 21},
  {cont__28_44, &frame__28_6, 200, 203, 5, 23},
  {cont__28_45, &frame__28_6, 204, 204, 5, 39},
  {entry__28_1, NULL, 174, 204, 3, 39},
  {cont__28_47, &frame__28_1, 204, 204, 39, 39},
  {entry__29_9, NULL, 211, 211, 5, 48},
  {cont__29_10, &frame__29_9, 211, 211, 48, 48},
  {entry__29_1, NULL, 208, 208, 23, 30},
  {cont__29_3, &frame__29_1, 208, 208, 3, 31},
  {cont__29_4, &frame__29_1, 209, 209, 17, 30},
  {cont__29_5, &frame__29_1, 209, 209, 36, 50},
  {cont__29_6, &frame__29_1, 209, 209, 3, 50},
  {cont__29_7, &frame__29_1, 210, 210, 36, 36},
  {cont__29_8, &frame__29_1, 210, 211, 3, 48},
  {cont__29_11, &frame__29_1, 212, 212, 3, 8},
  {entry__30_3, NULL, 227, 227, 32, 37},
  {entry__30_5, NULL, 227, 227, 40, 46},
  {entry__30_10, NULL, 234, 234, 11, 24},
  {cont__30_11, &frame__30_10, },
  {cont__30_12, &frame__30_10, 235, 235, 11, 34},
  {cont__30_13, &frame__30_10, },
  {cont__30_14, &frame__30_10, 236, 236, 21, 35},
  {cont__30_15, &frame__30_10, 236, 236, 11, 36},
  {cont__30_16, &frame__30_10, },
  {cont__30_17, &frame__30_10, 231, 237, 7, 17},
  {cont__30_18, &frame__30_10, 231, 237, 7, 17},
  {entry__30_23, NULL, 241, 241, 23, 32},
  {cont__30_25, &frame__30_23, 241, 241, 23, 32},
  {cont__30_26, &frame__30_23, 241, 241, 23, 32},
  {entry__30_29, NULL, 242, 242, 51, 75},
  {cont__30_30, &frame__30_29, 242, 242, 32, 80},
  {cont__30_31, &frame__30_29, 242, 242, 80, 80},
  {entry__30_28, NULL, 242, 242, 9, 80},
  {cont__30_32, &frame__30_28, 243, 243, 9, 22},
  {cont__30_33, &frame__30_28, 243, 243, 22, 22},
  {entry__30_20, NULL, 241, 241, 10, 18},
  {cont__30_21, &frame__30_20, 241, 241, 10, 18},
  {cont__30_22, &frame__30_20, 241, 241, 10, 32},
  {cont__30_27, &frame__30_20, 241, 243, 7, 22},
  {cont__30_34, &frame__30_20, 244, 244, 21, 68},
  {cont__30_35, &frame__30_20, 244, 244, 10, 69},
  {cont__30_36, &frame__30_20, 244, 244, 7, 69},
  {entry__30_48, NULL, 253, 253, 34, 58},
  {cont__30_49, &frame__30_48, 253, 253, 64, 78},
  {cont__30_50, &frame__30_48, 253, 253, 16, 79},
  {cont__30_51, &frame__30_48, 253, 253, 13, 79},
  {entry__30_53, NULL, 257, 257, 45, 59},
  {cont__30_54, &frame__30_53, 257, 257, 20, 60},
  {cont__30_55, &frame__30_53, 257, 257, 17, 60},
  {entry__30_56, NULL, 261, 261, 21, 45},
  {cont__30_57, &frame__30_56, 264, 264, 21, 35},
  {cont__30_58, &frame__30_56, 259, 264, 19, 34},
  {cont__30_59, &frame__30_56, 258, 264, 17, 36},
  {entry__30_52, NULL, 255, 264, 15, 36},
  {cont__30_60, &frame__30_52, 254, 264, 13, 38},
  {entry__30_45, NULL, 252, 252, 13, 22},
  {cont__30_47, &frame__30_45, 251, 264, 11, 39},
  {entry__30_61, NULL, 265, 265, 37, 51},
  {cont__30_62, &frame__30_61, 265, 265, 12, 52},
  {cont__30_63, &frame__30_61, 265, 265, 9, 52},
  {entry__30_37, NULL, 248, 248, 11, 24},
  {cont__30_38, &frame__30_37, 248, 248, 26, 49},
  {cont__30_39, &frame__30_37, 248, 248, 11, 49},
  {cont__30_40, &frame__30_37, 248, 248, 61, 75},
  {cont__30_41, &frame__30_37, 248, 248, 51, 76},
  {cont__30_42, &frame__30_37, 248, 248, 11, 76},
  {cont__30_43, &frame__30_37, 247, 249, 9, 34},
  {cont__30_44, &frame__30_37, 246, 265, 7, 52},
  {entry__30_1, NULL, 227, 227, 21, 29},
  {cont__30_2, &frame__30_1, 227, 227, 3, 47},
  {cont__30_7, &frame__30_1, 230, 230, 7, 29},
  {cont__30_8, &frame__30_1, 230, 230, 7, 33},
  {cont__30_9, &frame__30_1, 229, 237, 5, 18},
  {cont__30_19, &frame__30_1, 228, 265, 3, 54},
  {entry__31_4, NULL, 269, 269, 29, 34},
  {entry__31_5, NULL, 269, 269, 40, 73},
  {cont__31_6, &frame__31_5, 269, 269, 37, 73},
  {entry__31_1, NULL, 268, 268, 3, 37},
  {cont__31_2, &frame__31_1, 269, 269, 6, 26},
  {cont__31_3, &frame__31_1, 269, 269, 3, 73},
  {entry__32_4, NULL, 273, 273, 29, 34},
  {entry__32_5, NULL, 273, 273, 40, 78},
  {cont__32_6, &frame__32_5, 273, 273, 37, 78},
  {entry__32_1, NULL, 272, 272, 3, 37},
  {cont__32_2, &frame__32_1, 273, 273, 6, 26},
  {cont__32_3, &frame__32_1, 273, 273, 3, 78},
  {entry__33_2, NULL, 278, 278, 5, 31},
  {cont__33_3, &frame__33_2, 279, 279, 5, 23},
  {cont__33_4, &frame__33_2, 279, 279, 23, 23},
  {entry__33_1, NULL, 277, 279, 3, 23},
  {entry__34_1, NULL, 284, 284, 41, 50},
  {entry__35_1, NULL, 291, 291, 44, 66},
  {cont__35_2, &frame__35_1, 291, 291, 32, 69},
  {cont__35_5, &frame__35_1, 291, 291, 6, 70},
  {cont__35_6, &frame__35_1, 291, 291, 3, 70},
  {entry__36_4, NULL, 300, 300, 26, 49},
  {cont__36_5, &frame__36_4, 300, 300, 56, 73},
  {cont__36_6, &frame__36_4, 300, 300, 12, 76},
  {cont__36_10, &frame__36_4, 300, 300, 9, 76},
  {entry__36_11, NULL, 301, 301, 26, 43},
  {cont__36_12, &frame__36_11, 301, 301, 12, 46},
  {cont__36_15, &frame__36_11, 301, 301, 9, 46},
  {entry__36_1, NULL, 299, 299, 9, 32},
  {cont__36_2, &frame__36_1, 299, 299, 9, 43},
  {cont__36_3, &frame__36_1, 298, 301, 7, 45},
  {cont__36_16, &frame__36_1, 296, 301, 5, 46},
  {cont__36_17, &frame__36_1, 295, 301, 3, 48},
  {entry__37_1, NULL, 305, 305, 42, 59},
  {cont__37_2, &frame__37_1, 305, 305, 32, 62},
  {cont__37_5, &frame__37_1, 305, 305, 6, 63},
  {cont__37_6, &frame__37_1, 305, 305, 3, 63},
  {entry__38_1, NULL, 309, 309, 44, 66},
  {cont__38_2, &frame__38_1, 309, 309, 32, 69},
  {cont__38_5, &frame__38_1, 309, 309, 6, 70},
  {cont__38_6, &frame__38_1, 309, 309, 3, 70},
  {entry__39_1, NULL, 313, 313, 41, 63},
  {cont__39_2, &frame__39_1, 313, 313, 32, 66},
  {cont__39_5, &frame__39_1, 313, 313, 6, 67},
  {cont__39_6, &frame__39_1, 313, 313, 3, 67},
  {entry__40_1, NULL, 317, 317, 41, 63},
  {cont__40_2, &frame__40_1, 317, 317, 32, 66},
  {cont__40_5, &frame__40_1, 317, 317, 6, 67},
  {cont__40_6, &frame__40_1, 317, 317, 3, 67},
  {entry__41_6, NULL, 326, 326, 43, 52},
  {entry__41_3, NULL, 326, 326, 10, 24},
  {cont__41_4, &frame__41_3, 326, 326, 10, 41},
  {cont__41_5, &frame__41_3, 326, 326, 7, 52},
  {entry__41_16, NULL, 331, 331, 11, 25},
  {cont__41_17, &frame__41_16, 331, 331, 11, 28},
  {cont__41_18, &frame__41_16, 331, 331, 11, 35},
  {cont__41_19, &frame__41_16, 331, 331, 11, 35},
  {cont__41_20, &frame__41_16, 331, 331, 11, 35},
  {entry__41_11, NULL, 330, 330, 11, 25},
  {cont__41_12, &frame__41_11, 330, 330, 11, 28},
  {cont__41_13, &frame__41_11, 330, 330, 11, 35},
  {cont__41_14, &frame__41_11, 330, 330, 11, 35},
  {cont__41_15, &frame__41_11, 331, 331, 11, 35},
  {cont__41_21, &frame__41_11, },
  {entry__41_23, NULL, 332, 332, 9, 25},
  {entry__41_7, NULL, 329, 329, 11, 25},
  {cont__41_8, &frame__41_7, 329, 329, 11, 31},
  {cont__41_9, &frame__41_7, 329, 329, 11, 31},
  {cont__41_10, &frame__41_7, },
  {cont__41_22, &frame__41_7, 327, 332, 7, 25},
  {entry__41_27, NULL, 333, 333, 39, 47},
  {entry__41_24, NULL, 333, 333, 10, 32},
  {cont__41_25, &frame__41_24, 333, 333, 10, 37},
  {cont__41_26, &frame__41_24, 333, 333, 7, 47},
  {entry__41_29, NULL, 334, 334, 15, 23},
  {entry__41_28, NULL, 334, 334, 7, 23},
  {entry__41_42, NULL, 340, 340, 36, 49},
  {cont__41_43, &frame__41_42, 340, 340, 22, 54},
  {cont__41_44, &frame__41_42, 340, 340, 54, 54},
  {entry__41_38, NULL, 339, 339, 7, 22},
  {cont__41_39, &frame__41_38, 340, 340, 10, 19},
  {cont__41_40, &frame__41_38, 340, 340, 10, 19},
  {cont__41_41, &frame__41_38, 340, 340, 7, 54},
  {entry__41_35, NULL, 337, 337, 5, 31},
  {cont__41_36, &frame__41_35, 338, 338, 38, 38},
  {cont__41_37, &frame__41_35, 338, 340, 5, 54},
  {entry__41_1, NULL, 323, 323, 3, 37},
  {cont__41_2, &frame__41_1, 324, 334, 3, 24},
  {cont__41_30, &frame__41_1, 335, 335, 20, 34},
  {cont__41_31, &frame__41_1, 335, 335, 3, 35},
  {cont__41_32, &frame__41_1, 336, 336, 6, 28},
  {cont__41_33, &frame__41_1, 336, 336, 6, 32},
  {cont__41_34, &frame__41_1, 336, 340, 3, 55},
  {cont__41_45, &frame__41_1, 341, 341, 3, 8},
  {entry__42_10, NULL, 356, 356, 7, 25},
  {cont__42_11, &frame__42_10, 356, 356, 7, 28},
  {cont__42_12, &frame__42_10, 356, 356, 7, 40},
  {cont__42_13, &frame__42_10, 356, 356, 7, 40},
  {entry__42_6, NULL, 355, 355, 17, 35},
  {cont__42_7, &frame__42_6, 355, 355, 7, 36},
  {cont__42_8, &frame__42_6, 355, 355, 7, 41},
  {cont__42_9, &frame__42_6, 356, 356, 7, 40},
  {cont__42_14, &frame__42_6, },
  {entry__42_21, NULL, 360, 360, 43, 63},
  {cont__42_22, &frame__42_21, 360, 360, 43, 63},
  {entry__42_24, NULL, 361, 361, 26, 39},
  {cont__42_25, &frame__42_24, 361, 361, 12, 44},
  {cont__42_26, &frame__42_24, 361, 361, 9, 44},
  {entry__42_27, NULL, 362, 362, 9, 14},
  {entry__42_16, NULL, 358, 358, 12, 30},
  {cont__42_17, &frame__42_16, 358, 358, 12, 33},
  {cont__42_18, &frame__42_16, 358, 358, 7, 43},
  {cont__42_19, &frame__42_16, 360, 360, 9, 38},
  {cont__42_20, &frame__42_16, 360, 360, 9, 63},
  {cont__42_23, &frame__42_16, 359, 362, 7, 14},
  {entry__42_31, NULL, 369, 369, 20, 20},
  {entry__42_33, NULL, 371, 371, 32, 45},
  {cont__42_34, &frame__42_33, 371, 371, 13, 50},
  {cont__42_36, &frame__42_33, 372, 372, 13, 26},
  {cont__42_37, &frame__42_33, 372, 372, 26, 26},
  {entry__42_29, NULL, 368, 368, 11, 39},
  {cont__42_30, &frame__42_29, 367, 372, 9, 27},
  {entry__42_40, NULL, 378, 378, 36, 54},
  {cont__42_41, &frame__42_40, 378, 378, 13, 54},
  {cont__42_42, &frame__42_40, 378, 378, 54, 54},
  {entry__42_43, NULL, 380, 380, 13, 36},
  {cont__42_44, &frame__42_43, 380, 380, 36, 36},
  {entry__42_48, NULL, 383, 383, 11, 60},
  {cont__42_49, &frame__42_48, 383, 383, 60, 60},
  {entry__42_54, NULL, 387, 387, 31, 31},
  {entry__42_59, NULL, 391, 391, 36, 49},
  {cont__42_60, &frame__42_59, 391, 391, 17, 65},
  {cont__42_62, &frame__42_59, 392, 392, 17, 30},
  {cont__42_63, &frame__42_59, 392, 392, 30, 30},
  {entry__42_64, NULL, 394, 394, 17, 41},
  {entry__42_55, NULL, 390, 390, 15, 42},
  {cont__42_56, &frame__42_55, 390, 390, 15, 56},
  {cont__42_57, &frame__42_55, 390, 390, 15, 56},
  {cont__42_58, &frame__42_55, 389, 394, 13, 42},
  {entry__42_38, NULL, 376, 380, 9, 37},
  {cont__42_45, &frame__42_38, 381, 381, 9, 32},
  {cont__42_46, &frame__42_38, 382, 382, 16, 36},
  {cont__42_47, &frame__42_38, 382, 383, 9, 60},
  {cont__42_50, &frame__42_38, 384, 384, 9, 56},
  {cont__42_51, &frame__42_38, 386, 386, 11, 60},
  {cont__42_52, &frame__42_38, 386, 386, 11, 60},
  {cont__42_53, &frame__42_38, 385, 394, 9, 44},
  {entry__42_70, NULL, 399, 399, 39, 72},
  {cont__42_71, &frame__42_70, 399, 399, 72, 72},
  {entry__42_81, NULL, 406, 406, 15, 35},
  {cont__42_82, &frame__42_81, 406, 406, 35, 35},
  {entry__42_83, NULL, 408, 408, 15, 66},
  {cont__42_84, &frame__42_83, 408, 408, 66, 66},
  {entry__42_77, NULL, 403, 403, 11, 30},
  {cont__42_78, &frame__42_77, 405, 405, 13, 24},
  {cont__42_79, &frame__42_77, 405, 405, 13, 34},
  {cont__42_80, &frame__42_77, 404, 408, 11, 67},
  {entry__42_65, NULL, 397, 397, 9, 37},
  {cont__42_66, &frame__42_65, 398, 398, 39, 46},
  {cont__42_67, &frame__42_65, 398, 398, 9, 47},
  {cont__42_68, &frame__42_65, 399, 399, 16, 36},
  {cont__42_69, &frame__42_65, 399, 399, 9, 72},
  {cont__42_72, &frame__42_65, 400, 400, 9, 24},
  {cont__42_73, &frame__42_65, 401, 401, 23, 36},
  {cont__42_74, &frame__42_65, 401, 401, 9, 40},
  {cont__42_76, &frame__42_65, 402, 408, 9, 68},
  {cont__42_85, &frame__42_65, 409, 409, 30, 43},
  {cont__42_86, &frame__42_65, 409, 409, 9, 47},
  {cont__42_87, &frame__42_65, 409, 409, 47, 47},
  {entry__42_93, NULL, 414, 414, 41, 79},
  {cont__42_94, &frame__42_93, 414, 414, 79, 79},
  {entry__42_90, NULL, 413, 413, 11, 39},
  {cont__42_91, &frame__42_90, 414, 414, 18, 38},
  {cont__42_92, &frame__42_90, 414, 414, 11, 79},
  {entry__42_103, NULL, 426, 426, 27, 53},
  {cont__42_104, &frame__42_103, 426, 426, 27, 64},
  {cont__42_105, &frame__42_103, 426, 426, 27, 64},
  {entry__42_99, NULL, 425, 425, 27, 54},
  {cont__42_100, &frame__42_99, 425, 425, 27, 70},
  {cont__42_101, &frame__42_99, 425, 425, 27, 70},
  {cont__42_102, &frame__42_99, 424, 426, 25, 63},
  {cont__42_106, &frame__42_99, 423, 426, 23, 65},
  {entry__42_98, NULL, 421, 426, 19, 66},
  {cont__42_107, &frame__42_98, 420, 426, 17, 67},
  {cont__42_108, &frame__42_98, 420, 426, 17, 67},
  {entry__42_111, NULL, 429, 429, 22, 47},
  {cont__42_112, &frame__42_111, 429, 429, 22, 56},
  {cont__42_113, &frame__42_111, 429, 429, 19, 56},
  {entry__42_110, NULL, 427, 429, 15, 56},
  {cont__42_114, &frame__42_110, 427, 429, 15, 56},
  {entry__42_116, NULL, 433, 433, 15, 38},
  {entry__42_117, NULL, 435, 435, 15, 39},
  {entry__42_95, NULL, 419, 419, 17, 37},
  {cont__42_96, &frame__42_95, 419, 419, 17, 42},
  {cont__42_97, &frame__42_95, 418, 426, 15, 68},
  {cont__42_109, &frame__42_95, 416, 429, 11, 59},
  {cont__42_115, &frame__42_95, 431, 435, 11, 40},
  {entry__42_121, NULL, 442, 443, 13, 17},
  {cont__42_123, &frame__42_121, 443, 443, 18, 18},
  {entry__42_133, NULL, 458, 458, 21, 59},
  {cont__42_134, &frame__42_133, 458, 458, 21, 59},
  {cont__42_135, &frame__42_133, 458, 458, 21, 59},
  {entry__42_131, NULL, 457, 457, 21, 43},
  {cont__42_132, &frame__42_131, 456, 458, 19, 58},
  {cont__42_136, &frame__42_131, 456, 458, 19, 58},
  {entry__42_138, NULL, 460, 460, 19, 33},
  {cont__42_139, &frame__42_138, 460, 460, 33, 33},
  {entry__42_146, NULL, 467, 467, 21, 34},
  {cont__42_147, &frame__42_146, 467, 467, 21, 36},
  {cont__42_148, &frame__42_146, 467, 467, 38, 51},
  {cont__42_149, &frame__42_146, 467, 467, 21, 51},
  {cont__42_150, &frame__42_146, 466, 468, 19, 50},
  {cont__42_151, &frame__42_146, 466, 468, 19, 50},
  {entry__42_144, NULL, 465, 465, 19, 39},
  {cont__42_145, &frame__42_144, 466, 468, 19, 50},
  {cont__42_152, &frame__42_144, },
  {entry__42_142, NULL, 464, 464, 19, 39},
  {cont__42_143, &frame__42_142, },
  {cont__42_153, &frame__42_142, },
  {entry__42_155, NULL, 470, 470, 19, 54},
  {cont__42_156, &frame__42_155, 470, 470, 54, 54},
  {entry__42_157, NULL, 472, 472, 19, 39},
  {cont__42_158, &frame__42_157, 472, 472, 39, 39},
  {entry__42_128, NULL, 452, 452, 15, 38},
  {cont__42_129, &frame__42_128, 455, 455, 19, 25},
  {cont__42_130, &frame__42_128, 454, 458, 17, 59},
  {cont__42_137, &frame__42_128, 453, 460, 15, 34},
  {cont__42_140, &frame__42_128, 463, 463, 19, 23},
  {cont__42_141, &frame__42_128, },
  {cont__42_154, &frame__42_128, 461, 472, 15, 40},
  {entry__42_124, NULL, 446, 446, 13, 43},
  {cont__42_125, &frame__42_124, 447, 447, 13, 36},
  {cont__42_126, &frame__42_124, 449, 449, 22, 40},
  {cont__42_127, &frame__42_124, 449, 472, 13, 41},
  {cont__42_159, &frame__42_124, 472, 472, 41, 41},
  {entry__42_119, NULL, 439, 439, 9, 35},
  {cont__42_120, &frame__42_119, 440, 472, 9, 43},
  {cont__42_160, &frame__42_119, 472, 472, 43, 43},
  {entry__42_28, NULL, 412, 412, 9, 29},
  {cont__42_88, &frame__42_28, 412, 412, 9, 34},
  {cont__42_89, &frame__42_28, 411, 435, 7, 42},
  {cont__42_118, &frame__42_28, 437, 472, 7, 44},
  {cont__42_161, &frame__42_28, 473, 473, 7, 12},
  {entry__42_1, NULL, 350, 350, 3, 37},
  {cont__42_2, &frame__42_1, 351, 351, 3, 33},
  {cont__42_3, &frame__42_1, 354, 354, 7, 27},
  {cont__42_4, &frame__42_1, 354, 354, 7, 32},
  {cont__42_5, &frame__42_1, },
  {cont__42_15, &frame__42_1, 352, 473, 3, 13},
  {entry__43_4, NULL, 484, 484, 37, 59},
  {entry__43_18, NULL, 496, 496, 9, 48},
  {cont__43_19, &frame__43_18, 497, 497, 36, 36},
  {cont__43_20, &frame__43_18, 497, 497, 9, 36},
  {cont__43_21, &frame__43_18, 498, 498, 9, 16},
  {entry__43_28, NULL, 505, 505, 11, 49},
  {cont__43_29, &frame__43_28, 506, 506, 37, 37},
  {cont__43_30, &frame__43_28, 506, 506, 11, 37},
  {cont__43_31, &frame__43_28, 507, 507, 11, 18},
  {entry__43_34, NULL, 514, 514, 11, 49},
  {cont__43_35, &frame__43_34, 515, 515, 37, 37},
  {cont__43_36, &frame__43_34, 515, 515, 11, 37},
  {cont__43_37, &frame__43_34, 516, 516, 11, 18},
  {entry__43_24, NULL, 500, 500, 9, 47},
  {cont__43_25, &frame__43_24, 501, 501, 9, 68},
  {cont__43_26, &frame__43_24, 502, 502, 12, 44},
  {cont__43_27, &frame__43_24, 502, 507, 9, 18},
  {cont__43_32, &frame__43_24, 513, 513, 12, 55},
  {cont__43_33, &frame__43_24, 513, 516, 9, 18},
  {entry__43_14, NULL, 491, 491, 7, 47},
  {cont__43_15, &frame__43_14, 492, 492, 7, 68},
  {cont__43_16, &frame__43_14, 493, 493, 10, 43},
  {cont__43_17, &frame__43_14, 493, 498, 7, 16},
  {cont__43_22, &frame__43_14, 499, 499, 14, 37},
  {cont__43_23, &frame__43_14, 499, 516, 7, 19},
  {cont__43_38, &frame__43_14, 520, 520, 7, 46},
  {cont__43_39, &frame__43_14, 521, 521, 34, 34},
  {cont__43_40, &frame__43_14, 521, 521, 7, 34},
  {cont__43_41, &frame__43_14, 522, 522, 7, 14},
  {entry__43_12, NULL, 488, 488, 12, 36},
  {cont__43_13, &frame__43_12, 488, 522, 5, 14},
  {cont__43_42, &frame__43_12, 526, 526, 5, 41},
  {cont__43_43, &frame__43_12, 527, 527, 31, 31},
  {entry__43_7, NULL, 487, 487, 12, 38},
  {cont__43_8, &frame__43_7, 487, 487, 40, 65},
  {cont__43_9, &frame__43_7, 487, 487, 12, 65},
  {cont__43_10, &frame__43_7, 487, 487, 12, 69},
  {cont__43_11, &frame__43_7, 487, 527, 9, 31},
  {entry__43_1, NULL, 483, 483, 3, 46},
  {cont__43_2, &frame__43_1, 484, 484, 6, 34},
  {cont__43_3, &frame__43_1, 484, 484, 3, 59},
  {cont__43_5, &frame__43_1, 485, 485, 3, 38},
  {cont__43_6, &frame__43_1, 487, 527, 3, 31},
  {cont__43_44, &frame__43_1, 528, 528, 3, 18},
  {entry__44_6, NULL, 538, 538, 11, 38},
  {cont__44_7, &frame__44_6, 538, 538, 11, 38},
  {entry__44_4, NULL, 537, 537, 11, 38},
  {cont__44_5, &frame__44_4, 538, 538, 11, 38},
  {cont__44_8, &frame__44_4, },
  {entry__44_10, NULL, 540, 540, 9, 16},
  {entry__44_11, NULL, 539, 539, 9, 20},
  {entry__44_19, NULL, 546, 546, 11, 34},
  {cont__44_20, &frame__44_19, 546, 546, 34, 34},
  {entry__44_16, NULL, 545, 545, 12, 34},
  {cont__44_17, &frame__44_16, 545, 545, 12, 55},
  {cont__44_18, &frame__44_16, 545, 546, 9, 34},
  {cont__44_21, &frame__44_16, 547, 547, 9, 21},
  {cont__44_22, &frame__44_16, 547, 547, 21, 21},
  {entry__44_14, NULL, 544, 544, 10, 37},
  {cont__44_15, &frame__44_14, 544, 547, 7, 21},
  {entry__44_28, NULL, 550, 550, 11, 34},
  {cont__44_29, &frame__44_28, 550, 550, 34, 34},
  {entry__44_25, NULL, 549, 549, 12, 34},
  {cont__44_26, &frame__44_25, 549, 549, 12, 55},
  {cont__44_27, &frame__44_25, 549, 550, 9, 34},
  {cont__44_30, &frame__44_25, 551, 551, 9, 21},
  {cont__44_31, &frame__44_25, 551, 551, 21, 21},
  {entry__44_23, NULL, 548, 548, 10, 37},
  {cont__44_24, &frame__44_23, 548, 551, 7, 21},
  {entry__44_38, NULL, 554, 554, 56, 71},
  {cont__44_39, &frame__44_38, 554, 554, 56, 71},
  {cont__44_40, &frame__44_38, 554, 554, 56, 71},
  {entry__44_35, NULL, 554, 554, 36, 51},
  {cont__44_36, &frame__44_35, 554, 554, 36, 51},
  {cont__44_37, &frame__44_35, 554, 554, 36, 71},
  {cont__44_41, &frame__44_35, 554, 554, 36, 71},
  {entry__44_43, NULL, 555, 555, 10, 24},
  {cont__44_44, &frame__44_43, 555, 555, 7, 24},
  {entry__44_45, NULL, 556, 556, 7, 12},
  {entry__44_2, NULL, 536, 536, 11, 35},
  {cont__44_3, &frame__44_2, },
  {cont__44_9, &frame__44_2, 533, 540, 5, 17},
  {cont__44_12, &frame__44_2, 542, 542, 5, 28},
  {cont__44_13, &frame__44_2, 543, 551, 5, 22},
  {cont__44_32, &frame__44_2, 552, 552, 5, 21},
  {cont__44_33, &frame__44_2, 554, 554, 7, 31},
  {cont__44_34, &frame__44_2, 554, 554, 7, 71},
  {cont__44_42, &frame__44_2, 553, 556, 5, 12},
  {cont__44_46, &frame__44_2, 556, 556, 12, 12},
  {entry__44_1, NULL, 532, 556, 3, 13},
  {entry__45_4, NULL, 567, 567, 26, 34},
  {entry__45_8, NULL, 573, 573, 22, 33},
  {cont__45_9, &frame__45_8, 573, 573, 22, 60},
  {cont__45_10, &frame__45_8, 573, 573, 22, 60},
  {entry__45_12, NULL, 574, 574, 31, 31},
  {entry__45_15, NULL, 578, 578, 27, 27},
  {entry__45_28, NULL, 590, 590, 15, 42},
  {cont__45_29, &frame__45_28, 590, 590, 15, 51},
  {cont__45_30, &frame__45_28, 590, 590, 15, 51},
  {entry__45_25, NULL, 589, 589, 15, 35},
  {cont__45_26, &frame__45_25, 589, 589, 15, 44},
  {cont__45_27, &frame__45_25, 590, 590, 15, 51},
  {cont__45_31, &frame__45_25, },
  {entry__45_23, NULL, 588, 588, 15, 40},
  {cont__45_24, &frame__45_23, },
  {cont__45_32, &frame__45_23, },
  {entry__45_21, NULL, 587, 587, 15, 43},
  {cont__45_22, &frame__45_21, },
  {cont__45_33, &frame__45_21, },
  {entry__45_19, NULL, 586, 586, 15, 24},
  {cont__45_20, &frame__45_19, },
  {cont__45_34, &frame__45_19, },
  {entry__45_36, NULL, 591, 591, 16, 42},
  {cont__45_37, &frame__45_36, 591, 591, 13, 42},
  {entry__45_38, NULL, 592, 592, 13, 16},
  {entry__45_45, NULL, 599, 599, 41, 45},
  {cont__45_46, &frame__45_45, 599, 599, 31, 46},
  {cont__45_47, &frame__45_45, 599, 599, 13, 47},
  {cont__45_48, &frame__45_45, 599, 599, 52, 78},
  {cont__45_49, &frame__45_45, 599, 599, 13, 78},
  {cont__45_50, &frame__45_45, 599, 599, 13, 78},
  {entry__45_43, NULL, 598, 598, 13, 21},
  {cont__45_44, &frame__45_43, 599, 599, 13, 78},
  {cont__45_51, &frame__45_43, },
  {entry__45_53, NULL, 601, 601, 13, 19},
  {cont__45_54, &frame__45_53, 602, 602, 30, 30},
  {entry__45_60, NULL, 605, 605, 60, 60},
  {entry__45_57, NULL, 605, 605, 16, 21},
  {cont__45_58, &frame__45_57, 605, 605, 16, 31},
  {cont__45_59, &frame__45_57, 605, 605, 13, 60},
  {entry__45_65, NULL, 609, 609, 36, 42},
  {cont__45_66, &frame__45_65, 609, 609, 36, 42},
  {entry__45_68, NULL, 609, 609, 45, 80},
  {cont__45_69, &frame__45_68, 609, 609, 80, 80},
  {entry__45_75, NULL, 612, 612, 19, 58},
  {cont__45_76, &frame__45_75, 612, 612, 58, 58},
  {entry__45_79, NULL, 613, 613, 78, 78},
  {entry__45_63, NULL, 609, 609, 20, 31},
  {cont__45_64, &frame__45_63, 609, 609, 20, 42},
  {cont__45_67, &frame__45_63, 609, 609, 17, 80},
  {cont__45_70, &frame__45_63, 610, 610, 36, 49},
  {cont__45_71, &frame__45_63, 610, 610, 17, 49},
  {cont__45_72, &frame__45_63, 611, 611, 20, 40},
  {cont__45_74, &frame__45_63, 611, 612, 17, 58},
  {cont__45_77, &frame__45_63, 613, 613, 20, 49},
  {cont__45_78, &frame__45_63, 613, 613, 17, 78},
  {entry__45_82, NULL, 615, 615, 37, 43},
  {cont__45_83, &frame__45_82, 615, 615, 37, 43},
  {entry__45_85, NULL, 615, 615, 49, 54},
  {cont__45_86, &frame__45_85, 615, 615, 49, 61},
  {cont__45_87, &frame__45_85, 615, 615, 49, 61},
  {cont__45_88, &frame__45_85, 615, 615, 49, 61},
  {entry__45_90, NULL, 616, 616, 19, 54},
  {cont__45_91, &frame__45_90, 616, 616, 54, 54},
  {entry__45_96, NULL, 618, 618, 78, 78},
  {entry__45_80, NULL, 615, 615, 21, 32},
  {cont__45_81, &frame__45_80, 615, 615, 21, 43},
  {cont__45_84, &frame__45_80, 615, 615, 21, 61},
  {cont__45_89, &frame__45_80, 615, 616, 17, 54},
  {cont__45_92, &frame__45_80, 617, 617, 36, 49},
  {cont__45_93, &frame__45_80, 617, 617, 17, 49},
  {cont__45_94, &frame__45_80, 618, 618, 20, 49},
  {cont__45_95, &frame__45_80, 618, 618, 17, 78},
  {entry__45_61, NULL, 608, 608, 15, 23},
  {cont__45_62, &frame__45_61, 607, 618, 13, 79},
  {entry__45_105, NULL, 623, 623, 35, 59},
  {cont__45_106, &frame__45_105, 623, 623, 13, 67},
  {cont__45_107, &frame__45_105, 623, 623, 67, 67},
  {entry__45_112, NULL, 625, 625, 25, 64},
  {cont__45_114, &frame__45_112, 625, 625, 64, 64},
  {entry__45_100, NULL, 621, 621, 11, 59},
  {cont__45_101, &frame__45_100, 622, 622, 14, 22},
  {cont__45_102, &frame__45_100, 622, 622, 14, 32},
  {cont__45_103, &frame__45_100, 622, 622, 14, 32},
  {cont__45_104, &frame__45_100, 622, 623, 11, 67},
  {cont__45_108, &frame__45_100, 624, 624, 25, 45},
  {cont__45_109, &frame__45_100, 624, 624, 11, 45},
  {cont__45_110, &frame__45_100, 625, 625, 14, 22},
  {cont__45_111, &frame__45_100, 625, 625, 11, 64},
  {cont__45_115, &frame__45_100, 626, 626, 37, 37},
  {entry__45_16, NULL, 580, 580, 9, 61},
  {cont__45_17, &frame__45_16, 585, 585, 15, 26},
  {cont__45_18, &frame__45_16, },
  {cont__45_35, &frame__45_16, 582, 592, 9, 17},
  {cont__45_39, &frame__45_16, 594, 594, 9, 42},
  {cont__45_40, &frame__45_16, 597, 597, 13, 18},
  {cont__45_41, &frame__45_16, 597, 597, 13, 25},
  {cont__45_42, &frame__45_16, },
  {cont__45_52, &frame__45_16, 595, 602, 9, 31},
  {cont__45_55, &frame__45_16, 604, 604, 11, 31},
  {cont__45_56, &frame__45_16, 603, 618, 9, 81},
  {cont__45_97, &frame__45_16, 619, 619, 9, 25},
  {cont__45_98, &frame__45_16, 620, 620, 16, 43},
  {cont__45_99, &frame__45_16, 620, 626, 9, 37},
  {cont__45_116, &frame__45_16, 626, 626, 37, 37},
  {entry__45_14, NULL, 576, 626, 5, 39},
  {entry__45_122, NULL, 631, 631, 43, 68},
  {cont__45_123, &frame__45_122, 631, 631, 43, 68},
  {entry__45_119, NULL, 631, 631, 9, 29},
  {cont__45_120, &frame__45_119, 631, 631, 9, 38},
  {cont__45_121, &frame__45_119, 631, 631, 9, 68},
  {cont__45_124, &frame__45_119, 631, 631, 9, 68},
  {entry__45_128, NULL, 632, 632, 46, 61},
  {cont__45_129, &frame__45_128, 632, 632, 23, 62},
  {cont__45_130, &frame__45_128, 632, 632, 23, 71},
  {cont__45_131, &frame__45_128, 632, 632, 23, 71},
  {entry__45_126, NULL, 632, 632, 7, 18},
  {cont__45_127, &frame__45_126, 632, 632, 7, 71},
  {cont__45_132, &frame__45_126, 632, 632, 7, 71},
  {entry__45_134, NULL, 634, 634, 7, 49},
  {cont__45_136, &frame__45_134, 635, 635, 33, 33},
  {entry__45_149, NULL, 650, 650, 25, 34},
  {cont__45_150, &frame__45_149, 650, 650, 15, 35},
  {cont__45_151, &frame__45_149, 650, 650, 15, 53},
  {cont__45_152, &frame__45_149, 650, 650, 15, 53},
  {entry__45_145, NULL, 649, 649, 15, 24},
  {cont__45_146, &frame__45_145, 649, 649, 39, 50},
  {cont__45_147, &frame__45_145, 649, 649, 15, 50},
  {cont__45_148, &frame__45_145, 650, 650, 15, 53},
  {cont__45_153, &frame__45_145, },
  {entry__45_158, NULL, 652, 652, 29, 41},
  {cont__45_159, &frame__45_158, 652, 652, 41, 41},
  {entry__45_155, NULL, 652, 652, 18, 26},
  {cont__45_156, &frame__45_155, 652, 652, 18, 26},
  {cont__45_157, &frame__45_155, 652, 652, 15, 41},
  {cont__45_160, &frame__45_155, 653, 653, 27, 36},
  {cont__45_161, &frame__45_155, 653, 653, 15, 36},
  {cont__45_162, &frame__45_155, 654, 654, 33, 33},
  {cont__45_163, &frame__45_155, 654, 654, 15, 33},
  {cont__45_164, &frame__45_155, 655, 655, 48, 57},
  {cont__45_165, &frame__45_155, 655, 655, 38, 58},
  {cont__45_166, &frame__45_155, 655, 655, 38, 60},
  {cont__45_167, &frame__45_155, 655, 655, 15, 60},
  {cont__45_168, &frame__45_155, 655, 655, 60, 60},
  {entry__45_142, NULL, 648, 648, 15, 32},
  {cont__45_143, &frame__45_142, 648, 648, 15, 36},
  {cont__45_144, &frame__45_142, },
  {cont__45_154, &frame__45_142, 646, 655, 11, 61},
  {entry__45_141, NULL, 643, 655, 9, 62},
  {entry__45_171, NULL, 659, 659, 45, 65},
  {cont__45_172, &frame__45_171, 659, 659, 45, 65},
  {entry__45_179, NULL, 665, 665, 40, 44},
  {cont__45_180, &frame__45_179, 665, 665, 32, 45},
  {cont__45_181, &frame__45_179, 665, 665, 32, 63},
  {cont__45_182, &frame__45_179, 665, 665, 28, 64},
  {cont__45_183, &frame__45_179, 665, 665, 28, 64},
  {entry__45_185, NULL, 669, 669, 39, 43},
  {cont__45_186, &frame__45_185, 669, 669, 31, 44},
  {cont__45_187, &frame__45_185, 669, 669, 21, 45},
  {cont__45_188, &frame__45_185, },
  {cont__45_189, &frame__45_185, 670, 670, 31, 44},
  {cont__45_190, &frame__45_185, 670, 670, 31, 67},
  {cont__45_191, &frame__45_185, 670, 670, 21, 68},
  {cont__45_192, &frame__45_185, },
  {cont__45_193, &frame__45_185, 666, 671, 17, 27},
  {cont__45_194, &frame__45_185, 666, 671, 17, 27},
  {cont__45_195, &frame__45_185, 666, 671, 17, 27},
  {entry__45_177, NULL, 665, 665, 17, 23},
  {cont__45_178, &frame__45_177, 665, 665, 17, 64},
  {cont__45_184, &frame__45_177, 666, 671, 17, 27},
  {cont__45_196, &frame__45_177, },
  {entry__45_198, NULL, 673, 673, 29, 42},
  {cont__45_199, &frame__45_198, 673, 673, 17, 42},
  {cont__45_200, &frame__45_198, 673, 673, 42, 42},
  {entry__45_201, NULL, 675, 675, 17, 31},
  {cont__45_202, &frame__45_201, 675, 675, 31, 31},
  {entry__45_174, NULL, 664, 664, 35, 58},
  {cont__45_175, &frame__45_174, 664, 664, 17, 58},
  {cont__45_176, &frame__45_174, },
  {cont__45_197, &frame__45_174, 662, 675, 13, 32},
  {entry__45_206, NULL, 678, 678, 15, 30},
  {cont__45_207, &frame__45_206, 679, 679, 15, 37},
  {cont__45_208, &frame__45_206, 679, 679, 37, 37},
  {entry__45_214, NULL, 682, 682, 36, 56},
  {cont__45_216, &frame__45_214, 682, 682, 32, 57},
  {cont__45_217, &frame__45_214, 682, 682, 32, 57},
  {entry__45_203, NULL, 677, 677, 20, 25},
  {cont__45_204, &frame__45_203, 677, 677, 20, 35},
  {cont__45_205, &frame__45_203, 677, 679, 13, 37},
  {cont__45_209, &frame__45_203, 680, 680, 13, 27},
  {cont__45_210, &frame__45_203, 682, 682, 15, 20},
  {cont__45_211, &frame__45_203, 682, 682, 15, 27},
  {cont__45_212, &frame__45_203, 682, 682, 15, 27},
  {cont__45_213, &frame__45_203, 681, 682, 13, 57},
  {cont__45_218, &frame__45_203, 682, 682, 58, 58},
  {entry__45_170, NULL, 659, 659, 11, 65},
  {cont__45_173, &frame__45_170, 658, 682, 9, 59},
  {entry__45_138, NULL, 641, 641, 7, 44},
  {cont__45_139, &frame__45_138, 642, 642, 10, 21},
  {cont__45_140, &frame__45_138, 642, 655, 7, 63},
  {cont__45_169, &frame__45_138, 657, 682, 7, 60},
  {entry__45_226, NULL, 688, 688, 49, 54},
  {cont__45_227, &frame__45_226, 688, 688, 49, 64},
  {cont__45_228, &frame__45_226, 688, 688, 49, 64},
  {entry__45_223, NULL, 688, 688, 32, 37},
  {cont__45_224, &frame__45_223, 688, 688, 32, 44},
  {cont__45_225, &frame__45_223, 688, 688, 32, 64},
  {cont__45_229, &frame__45_223, 688, 688, 32, 64},
  {entry__45_231, NULL, 688, 688, 67, 79},
  {cont__45_232, &frame__45_231, 688, 688, 79, 79},
  {entry__45_238, NULL, 690, 690, 51, 71},
  {cont__45_239, &frame__45_238, 690, 690, 47, 72},
  {cont__45_240, &frame__45_238, 690, 690, 47, 72},
  {entry__45_235, NULL, 690, 690, 22, 42},
  {cont__45_237, &frame__45_235, 690, 690, 22, 72},
  {cont__45_241, &frame__45_235, 690, 690, 22, 72},
  {entry__45_243, NULL, 691, 691, 13, 25},
  {cont__45_244, &frame__45_243, 692, 692, 13, 27},
  {cont__45_245, &frame__45_243, 693, 693, 13, 25},
  {cont__45_246, &frame__45_243, 693, 693, 25, 25},
  {entry__45_247, NULL, 695, 695, 13, 27},
  {cont__45_248, &frame__45_247, 695, 695, 27, 27},
  {entry__45_221, NULL, 688, 688, 16, 27},
  {cont__45_222, &frame__45_221, 688, 688, 16, 64},
  {cont__45_230, &frame__45_221, 688, 688, 9, 79},
  {cont__45_233, &frame__45_221, 690, 690, 11, 17},
  {cont__45_234, &frame__45_221, 690, 690, 11, 72},
  {cont__45_242, &frame__45_221, 689, 695, 9, 28},
  {entry__45_219, NULL, 686, 686, 7, 27},
  {cont__45_220, &frame__45_219, 687, 695, 7, 29},
  {entry__45_1, NULL, 566, 566, 3, 35},
  {cont__45_2, &frame__45_1, 567, 567, 6, 23},
  {cont__45_3, &frame__45_1, 567, 567, 3, 34},
  {cont__45_5, &frame__45_1, 568, 568, 3, 27},
  {cont__45_6, &frame__45_1, 573, 573, 6, 17},
  {cont__45_7, &frame__45_1, 573, 573, 6, 60},
  {cont__45_11, &frame__45_1, 573, 574, 3, 31},
  {cont__45_13, &frame__45_1, 575, 626, 3, 40},
  {cont__45_117, &frame__45_1, 630, 630, 9, 20},
  {cont__45_118, &frame__45_1, 629, 631, 7, 67},
  {cont__45_125, &frame__45_1, 628, 632, 5, 70},
  {cont__45_133, &frame__45_1, 627, 635, 3, 34},
  {cont__45_137, &frame__45_1, 637, 695, 3, 31},
  {cont__45_249, &frame__45_1, 696, 696, 3, 8},
  {entry__46_5, NULL, 701, 701, 27, 51},
  {cont__46_6, &frame__46_5, 701, 701, 5, 59},
  {cont__46_7, &frame__46_5, 701, 701, 59, 59},
  {entry__46_10, NULL, 703, 703, 30, 54},
  {cont__46_11, &frame__46_10, 703, 703, 5, 65},
  {cont__46_12, &frame__46_10, 703, 703, 65, 65},
  {entry__46_1, NULL, 699, 699, 3, 44},
  {cont__46_2, &frame__46_1, 700, 700, 10, 18},
  {cont__46_3, &frame__46_1, 700, 700, 10, 28},
  {cont__46_4, &frame__46_1, 700, 701, 3, 59},
  {cont__46_8, &frame__46_1, 702, 702, 10, 36},
  {cont__46_9, &frame__46_1, 702, 703, 3, 65},
  {cont__46_13, &frame__46_1, 704, 704, 6, 37},
  {cont__46_14, &frame__46_1, 704, 704, 3, 37},
  {entry__47_6, NULL, 712, 712, 43, 70},
  {cont__47_7, &frame__47_6, 712, 712, 43, 79},
  {cont__47_8, &frame__47_6, 712, 712, 43, 79},
  {entry__47_11, NULL, 716, 716, 50, 63},
  {entry__47_13, NULL, 717, 717, 11, 19},
  {entry__47_14, NULL, 718, 718, 14, 21},
  {cont__47_15, &frame__47_14, 718, 718, 11, 21},
  {entry__47_23, NULL, 726, 726, 16, 37},
  {cont__47_25, &frame__47_23, 726, 726, 13, 37},
  {entry__47_26, NULL, 727, 727, 16, 38},
  {cont__47_28, &frame__47_26, 727, 727, 13, 38},
  {entry__47_20, NULL, 725, 725, 13, 24},
  {cont__47_21, &frame__47_20, 725, 725, 13, 34},
  {cont__47_22, &frame__47_20, 724, 727, 11, 38},
  {entry__47_44, NULL, 741, 741, 75, 75},
  {cont__47_45, &frame__47_44, 741, 741, 55, 75},
  {cont__47_46, &frame__47_44, 741, 741, 75, 75},
  {entry__47_39, NULL, 740, 740, 40, 64},
  {cont__47_40, &frame__47_39, 740, 740, 17, 73},
  {cont__47_41, &frame__47_39, 741, 741, 20, 52},
  {cont__47_43, &frame__47_39, 741, 741, 17, 75},
  {entry__47_50, NULL, 743, 743, 42, 66},
  {cont__47_51, &frame__47_50, 743, 743, 17, 77},
  {cont__47_52, &frame__47_50, 743, 743, 77, 77},
  {entry__47_34, NULL, 735, 735, 15, 59},
  {cont__47_36, &frame__47_34, 739, 739, 22, 31},
  {cont__47_37, &frame__47_34, 739, 739, 22, 41},
  {cont__47_38, &frame__47_34, 739, 741, 15, 75},
  {cont__47_47, &frame__47_34, 742, 742, 22, 33},
  {cont__47_48, &frame__47_34, 742, 742, 22, 43},
  {cont__47_49, &frame__47_34, 742, 743, 15, 77},
  {cont__47_53, &frame__47_34, 744, 744, 18, 42},
  {cont__47_54, &frame__47_34, 744, 744, 15, 42},
  {entry__47_60, NULL, 752, 752, 62, 69},
  {cont__47_61, &frame__47_60, 752, 752, 21, 70},
  {cont__47_62, &frame__47_60, 749, 752, 19, 69},
  {cont__47_64, &frame__47_60, 748, 752, 17, 71},
  {entry__47_65, NULL, 753, 753, 37, 59},
  {cont__47_67, &frame__47_65, 753, 753, 20, 78},
  {cont__47_68, &frame__47_65, 753, 753, 17, 78},
  {entry__47_55, NULL, 747, 747, 19, 38},
  {cont__47_56, &frame__47_55, 747, 747, 17, 38},
  {cont__47_57, &frame__47_55, 747, 747, 17, 67},
  {cont__47_58, &frame__47_55, 747, 747, 17, 67},
  {cont__47_59, &frame__47_55, 746, 753, 15, 78},
  {entry__47_29, NULL, 730, 730, 20, 40},
  {cont__47_30, &frame__47_29, 730, 730, 42, 69},
  {cont__47_31, &frame__47_29, 729, 730, 11, 70},
  {cont__47_32, &frame__47_29, 734, 734, 13, 39},
  {cont__47_33, &frame__47_29, 733, 753, 11, 80},
  {cont__47_69, &frame__47_29, 753, 753, 80, 80},
  {entry__47_3, NULL, 712, 712, 9, 29},
  {cont__47_4, &frame__47_3, 712, 712, 9, 38},
  {cont__47_5, &frame__47_3, 711, 712, 7, 79},
  {cont__47_9, &frame__47_3, 716, 716, 11, 45},
  {cont__47_10, &frame__47_3, 716, 716, 11, 63},
  {cont__47_12, &frame__47_3, 714, 718, 7, 22},
  {cont__47_16, &frame__47_3, 720, 720, 34, 50},
  {cont__47_17, &frame__47_3, 720, 720, 7, 59},
  {cont__47_18, &frame__47_3, 721, 721, 7, 74},
  {cont__47_19, &frame__47_3, 722, 753, 7, 82},
  {cont__47_70, &frame__47_3, 753, 753, 82, 82},
  {entry__47_84, NULL, 768, 768, 56, 56},
  {entry__47_82, NULL, 768, 768, 18, 33},
  {cont__47_83, &frame__47_82, 768, 768, 15, 56},
  {entry__47_87, NULL, 769, 769, 72, 72},
  {entry__47_85, NULL, 769, 769, 18, 49},
  {cont__47_86, &frame__47_85, 769, 769, 15, 72},
  {entry__47_90, NULL, 771, 771, 51, 51},
  {entry__47_88, NULL, 770, 770, 18, 58},
  {cont__47_89, &frame__47_88, 770, 771, 15, 51},
  {entry__47_75, NULL, 762, 762, 22, 46},
  {cont__47_76, &frame__47_75, 762, 762, 13, 49},
  {cont__47_77, &frame__47_75, 763, 763, 13, 57},
  {cont__47_78, &frame__47_75, 764, 764, 13, 39},
  {cont__47_79, &frame__47_75, 766, 766, 21, 38},
  {cont__47_80, &frame__47_75, 766, 766, 13, 41},
  {cont__47_81, &frame__47_75, 767, 771, 13, 52},
  {entry__47_91, NULL, 773, 773, 22, 37},
  {cont__47_92, &frame__47_91, 773, 773, 13, 47},
  {cont__47_93, &frame__47_91, 773, 773, 47, 47},
  {entry__47_73, NULL, 761, 761, 11, 31},
  {cont__47_74, &frame__47_73, 760, 773, 9, 48},
  {cont__47_94, &frame__47_73, 773, 773, 48, 48},
  {entry__47_100, NULL, 776, 776, 34, 60},
  {cont__47_101, &frame__47_100, 776, 776, 34, 60},
  {entry__47_103, NULL, 777, 777, 29, 29},
  {entry__47_114, NULL, 783, 783, 55, 66},
  {cont__47_115, &frame__47_114, 783, 783, 55, 76},
  {cont__47_116, &frame__47_114, 783, 783, 55, 76},
  {entry__47_111, NULL, 783, 783, 32, 43},
  {cont__47_112, &frame__47_111, 783, 783, 32, 50},
  {cont__47_113, &frame__47_111, 783, 783, 32, 76},
  {cont__47_117, &frame__47_111, 783, 783, 32, 76},
  {entry__47_119, NULL, 784, 784, 16, 40},
  {cont__47_120, &frame__47_119, 784, 784, 13, 40},
  {entry__47_121, NULL, 785, 785, 16, 44},
  {cont__47_122, &frame__47_121, 785, 785, 13, 44},
  {entry__47_109, NULL, 783, 783, 13, 27},
  {cont__47_110, &frame__47_109, 783, 783, 13, 76},
  {cont__47_118, &frame__47_109, 782, 785, 11, 43},
  {cont__47_123, &frame__47_109, 781, 785, 9, 45},
  {entry__47_127, NULL, 790, 790, 25, 67},
  {cont__47_128, &frame__47_127, 790, 790, 18, 78},
  {cont__47_129, &frame__47_127, 790, 790, 15, 78},
  {entry__47_125, NULL, 789, 789, 15, 29},
  {cont__47_126, &frame__47_125, 788, 790, 13, 78},
  {entry__47_134, NULL, 796, 796, 24, 41},
  {cont__47_135, &frame__47_134, 796, 796, 21, 41},
  {entry__47_132, NULL, 795, 795, 19, 36},
  {cont__47_133, &frame__47_132, 794, 796, 17, 41},
  {cont__47_136, &frame__47_132, 794, 796, 17, 41},
  {entry__47_138, NULL, 797, 797, 18, 75},
  {cont__47_139, &frame__47_138, 797, 797, 15, 75},
  {entry__47_130, NULL, 793, 793, 17, 43},
  {cont__47_131, &frame__47_130, 792, 796, 15, 42},
  {cont__47_137, &frame__47_130, 791, 797, 13, 75},
  {entry__47_141, NULL, 802, 802, 19, 47},
  {cont__47_142, &frame__47_141, 801, 804, 17, 21},
  {cont__47_143, &frame__47_141, 800, 804, 15, 23},
  {entry__47_140, NULL, 798, 804, 13, 24},
  {entry__47_124, NULL, 787, 804, 11, 25},
  {entry__47_71, NULL, 755, 755, 7, 33},
  {cont__47_72, &frame__47_71, 758, 773, 7, 49},
  {cont__47_95, &frame__47_71, 774, 774, 34, 50},
  {cont__47_96, &frame__47_71, 774, 774, 52, 69},
  {cont__47_97, &frame__47_71, 774, 774, 7, 69},
  {cont__47_98, &frame__47_71, 775, 775, 7, 73},
  {cont__47_99, &frame__47_71, 776, 776, 10, 60},
  {cont__47_102, &frame__47_71, 776, 777, 7, 29},
  {cont__47_104, &frame__47_71, 778, 778, 28, 48},
  {cont__47_105, &frame__47_71, 778, 778, 50, 77},
  {cont__47_106, &frame__47_71, 778, 778, 7, 78},
  {cont__47_107, &frame__47_71, 780, 780, 9, 29},
  {cont__47_108, &frame__47_71, 779, 804, 7, 27},
  {cont__47_144, &frame__47_71, 804, 804, 27, 27},
  {entry__47_1, NULL, 710, 710, 5, 20},
  {cont__47_2, &frame__47_1, 709, 804, 3, 29},
  {entry__48_4, NULL, 808, 808, 63, 79},
  {cont__48_6, &frame__48_4, 808, 808, 79, 79},
  {entry__48_16, NULL, 812, 812, 59, 71},
  {cont__48_17, &frame__48_16, 812, 812, 71, 71},
  {entry__48_24, NULL, 817, 817, 33, 60},
  {cont__48_25, &frame__48_24, 817, 817, 13, 60},
  {cont__48_27, &frame__48_24, 817, 817, 60, 60},
  {entry__48_28, NULL, 819, 819, 13, 25},
  {cont__48_29, &frame__48_28, 819, 819, 25, 25},
  {entry__48_21, NULL, 816, 816, 11, 38},
  {cont__48_22, &frame__48_21, 816, 816, 11, 49},
  {cont__48_23, &frame__48_21, 815, 819, 9, 26},
  {entry__48_19, NULL, 814, 814, 10, 39},
  {cont__48_20, &frame__48_19, 814, 819, 7, 27},
  {entry__48_32, NULL, 820, 820, 42, 54},
  {cont__48_33, &frame__48_32, 820, 820, 54, 54},
  {entry__48_30, NULL, 820, 820, 10, 39},
  {cont__48_31, &frame__48_30, 820, 820, 7, 54},
  {entry__48_13, NULL, 812, 812, 8, 36},
  {cont__48_14, &frame__48_13, 812, 812, 8, 56},
  {cont__48_15, &frame__48_13, 812, 812, 5, 71},
  {cont__48_18, &frame__48_13, 813, 820, 5, 54},
  {entry__48_1, NULL, 808, 808, 6, 34},
  {cont__48_2, &frame__48_1, 808, 808, 6, 60},
  {cont__48_3, &frame__48_1, 808, 808, 3, 79},
  {cont__48_7, &frame__48_1, 809, 809, 3, 20},
  {cont__48_8, &frame__48_1, 810, 810, 15, 39},
  {cont__48_9, &frame__48_1, 810, 810, 15, 49},
  {cont__48_10, &frame__48_1, 810, 810, 3, 49},
  {cont__48_11, &frame__48_1, 811, 811, 6, 30},
  {cont__48_12, &frame__48_1, 811, 820, 3, 55},
  {cont__48_34, &frame__48_1, 821, 821, 3, 8},
  {entry__49_4, NULL, 831, 831, 7, 11},
  {entry__49_5, NULL, 832, 832, 7, 12},
  {entry__49_10, NULL, 838, 838, 25, 42},
  {cont__49_11, &frame__49_10, 838, 838, 7, 42},
  {cont__49_12, &frame__49_10, 838, 838, 42, 42},
  {entry__49_17, NULL, 841, 841, 55, 72},
  {cont__49_18, &frame__49_17, 841, 841, 41, 72},
  {cont__49_19, &frame__49_17, 841, 841, 72, 72},
  {entry__49_13, NULL, 840, 840, 7, 19},
  {cont__49_14, &frame__49_13, 841, 841, 10, 27},
  {cont__49_15, &frame__49_13, 841, 841, 10, 38},
  {cont__49_16, &frame__49_13, 841, 841, 7, 72},
  {entry__49_1, NULL, 829, 829, 7, 29},
  {cont__49_2, &frame__49_1, 830, 830, 7, 60},
  {cont__49_3, &frame__49_1, 827, 832, 3, 13},
  {cont__49_7, &frame__49_1, 834, 834, 3, 40},
  {cont__49_8, &frame__49_1, 836, 836, 5, 27},
  {cont__49_9, &frame__49_1, 835, 841, 3, 73},
  {cont__49_20, &frame__49_1, 842, 842, 3, 30},
  {entry__50_4, NULL, 852, 852, 7, 12},
  {entry__50_6, NULL, 854, 854, 7, 12},
  {entry__50_8, NULL, 856, 856, 7, 12},
  {entry__50_10, NULL, 857, 857, 7, 13},
  {entry__50_1, NULL, 850, 850, 7, 29},
  {cont__50_2, &frame__50_1, 851, 851, 7, 60},
  {cont__50_3, &frame__50_1, 848, 857, 3, 14},
  {cont__50_12, &frame__50_1, 859, 859, 28, 60},
  {cont__50_13, &frame__50_1, 859, 859, 3, 60},
  {entry__51_1, NULL, 865, 865, 28, 57},
  {cont__51_3, &frame__51_1, 865, 865, 3, 57},
  {entry__52_1, NULL, 871, 871, 28, 58},
  {cont__52_3, &frame__52_1, 871, 871, 3, 58},
  {entry__53_3, NULL, 878, 878, 42, 59},
  {cont__53_4, &frame__53_3, 878, 878, 32, 60},
  {cont__53_5, &frame__53_3, 878, 878, 32, 65},
  {cont__53_6, &frame__53_3, 878, 878, 32, 65},
  {entry__53_11, NULL, 881, 881, 31, 46},
  {cont__53_12, &frame__53_11, 881, 881, 23, 47},
  {cont__53_13, &frame__53_11, 881, 881, 12, 48},
  {cont__53_14, &frame__53_11, 881, 881, 9, 48},
  {entry__53_17, NULL, 885, 885, 13, 31},
  {entry__53_18, NULL, 886, 886, 13, 33},
  {entry__53_15, NULL, 884, 884, 13, 37},
  {cont__53_16, &frame__53_15, 883, 886, 11, 33},
  {entry__53_8, NULL, 880, 880, 9, 24},
  {cont__53_9, &frame__53_8, 880, 880, 9, 46},
  {cont__53_10, &frame__53_8, 879, 886, 7, 35},
  {entry__53_19, NULL, 887, 887, 5, 25},
  {entry__53_1, NULL, 878, 878, 5, 27},
  {cont__53_2, &frame__53_1, 878, 878, 5, 65},
  {cont__53_7, &frame__53_1, 877, 887, 3, 25},
  {entry__54_7, NULL, 894, 894, 7, 22},
  {cont__54_8, &frame__54_7, 894, 894, 7, 44},
  {cont__54_9, &frame__54_7, 894, 894, 7, 44},
  {entry__54_3, NULL, 893, 893, 17, 34},
  {cont__54_4, &frame__54_3, 893, 893, 7, 35},
  {cont__54_5, &frame__54_3, 893, 893, 7, 40},
  {cont__54_6, &frame__54_3, 894, 894, 7, 44},
  {cont__54_10, &frame__54_3, },
  {entry__54_12, NULL, 895, 895, 8, 23},
  {cont__54_13, &frame__54_12, 895, 895, 8, 33},
  {cont__54_14, &frame__54_12, 895, 895, 5, 33},
  {entry__54_15, NULL, 896, 896, 5, 16},
  {entry__54_1, NULL, 892, 892, 7, 29},
  {cont__54_2, &frame__54_1, },
  {cont__54_11, &frame__54_1, 890, 896, 3, 16},
  {entry__55_16, NULL, 928, 928, 28, 41},
  {cont__55_17, &frame__55_16, 928, 928, 14, 74},
  {cont__55_18, &frame__55_16, 928, 928, 11, 74},
  {entry__55_19, NULL, 929, 929, 14, 60},
  {cont__55_20, &frame__55_19, 929, 929, 11, 60},
  {entry__55_14, NULL, 927, 927, 11, 44},
  {cont__55_15, &frame__55_14, 926, 929, 9, 60},
  {entry__55_27, NULL, 935, 935, 37, 61},
  {cont__55_28, &frame__55_27, 935, 935, 15, 69},
  {cont__55_29, &frame__55_27, 935, 935, 69, 69},
  {entry__55_23, NULL, 933, 933, 13, 54},
  {cont__55_24, &frame__55_23, 934, 934, 20, 28},
  {cont__55_25, &frame__55_23, 934, 934, 20, 38},
  {cont__55_26, &frame__55_23, 934, 935, 13, 69},
  {cont__55_30, &frame__55_23, 939, 939, 17, 30},
  {cont__55_31, &frame__55_23, 937, 942, 15, 31},
  {cont__55_32, &frame__55_23, 936, 942, 13, 33},
  {entry__55_33, NULL, 947, 947, 17, 63},
  {cont__55_34, &frame__55_33, 946, 948, 15, 27},
  {cont__55_35, &frame__55_33, 945, 948, 13, 29},
  {entry__55_21, NULL, 932, 932, 11, 44},
  {cont__55_22, &frame__55_21, 931, 948, 9, 31},
  {entry__55_2, NULL, 913, 913, 5, 31},
  {cont__55_3, &frame__55_2, 919, 919, 9, 25},
  {cont__55_4, &frame__55_2, 919, 919, 27, 51},
  {cont__55_5, &frame__55_2, 919, 919, 9, 51},
  {cont__55_6, &frame__55_2, 919, 919, 9, 53},
  {cont__55_7, &frame__55_2, 915, 919, 5, 54},
  {cont__55_8, &frame__55_2, 922, 922, 14, 34},
  {cont__55_9, &frame__55_2, 922, 922, 59, 74},
  {cont__55_10, &frame__55_2, 922, 922, 36, 75},
  {cont__55_11, &frame__55_2, 921, 922, 5, 76},
  {cont__55_12, &frame__55_2, 925, 925, 7, 27},
  {cont__55_13, &frame__55_2, 924, 948, 5, 33},
  {cont__55_36, &frame__55_2, 948, 948, 33, 33},
  {entry__55_39, NULL, 909, 909, 19, 34},
  {cont__55_40, &frame__55_39, 909, 909, 9, 34},
  {cont__55_41, &frame__55_39, 909, 909, 34, 34},
  {entry__55_42, NULL, 910, 910, 7, 18},
  {entry__55_50, NULL, 957, 957, 12, 46},
  {cont__55_51, &frame__55_50, 957, 957, 9, 46},
  {entry__55_52, NULL, 958, 958, 12, 31},
  {cont__55_53, &frame__55_52, 958, 958, 9, 31},
  {entry__55_47, NULL, 954, 954, 7, 28},
  {cont__55_48, &frame__55_47, 956, 956, 9, 33},
  {cont__55_49, &frame__55_47, 955, 958, 7, 31},
  {cont__55_54, &frame__55_47, 958, 958, 31, 31},
  {entry__55_45, NULL, 952, 952, 8, 34},
  {cont__55_46, &frame__55_45, 952, 958, 5, 32},
  {entry__55_61, NULL, 962, 962, 9, 42},
  {cont__55_62, &frame__55_61, 962, 962, 42, 42},
  {entry__55_57, NULL, 960, 960, 7, 29},
  {cont__55_58, &frame__55_57, 961, 961, 10, 32},
  {cont__55_59, &frame__55_57, 961, 961, 10, 53},
  {cont__55_60, &frame__55_57, 961, 962, 7, 42},
  {cont__55_63, &frame__55_57, 963, 963, 10, 44},
  {cont__55_64, &frame__55_57, 963, 963, 7, 44},
  {entry__55_55, NULL, 959, 959, 8, 34},
  {cont__55_56, &frame__55_55, 959, 963, 5, 44},
  {entry__55_77, NULL, 972, 972, 13, 38},
  {cont__55_78, &frame__55_77, 972, 972, 38, 38},
  {entry__55_83, NULL, 974, 974, 13, 40},
  {cont__55_84, &frame__55_83, 974, 974, 40, 40},
  {entry__55_95, NULL, 978, 978, 32, 74},
  {cont__55_98, &frame__55_95, 978, 978, 16, 75},
  {cont__55_99, &frame__55_95, 978, 978, 13, 75},
  {entry__55_70, NULL, 967, 967, 11, 37},
  {cont__55_71, &frame__55_70, 968, 968, 11, 38},
  {cont__55_72, &frame__55_70, 969, 969, 11, 40},
  {cont__55_73, &frame__55_70, 970, 970, 11, 42},
  {cont__55_74, &frame__55_70, 971, 971, 14, 41},
  {cont__55_75, &frame__55_70, 971, 971, 14, 60},
  {cont__55_76, &frame__55_70, 971, 972, 11, 38},
  {cont__55_79, &frame__55_70, 973, 973, 14, 42},
  {cont__55_80, &frame__55_70, 973, 973, 14, 62},
  {cont__55_81, &frame__55_70, 973, 973, 14, 62},
  {cont__55_82, &frame__55_70, 973, 974, 11, 40},
  {cont__55_85, &frame__55_70, 975, 975, 19, 33},
  {cont__55_86, &frame__55_70, 975, 975, 35, 59},
  {cont__55_87, &frame__55_70, 975, 975, 19, 59},
  {cont__55_88, &frame__55_70, 975, 975, 61, 76},
  {cont__55_89, &frame__55_70, 975, 975, 19, 76},
  {cont__55_90, &frame__55_70, 975, 975, 11, 78},
  {cont__55_91, &frame__55_70, 977, 977, 13, 36},
  {cont__55_92, &frame__55_70, 977, 977, 13, 50},
  {cont__55_93, &frame__55_70, 977, 977, 13, 50},
  {cont__55_94, &frame__55_70, 976, 979, 11, 24},
  {entry__55_68, NULL, 966, 966, 12, 36},
  {cont__55_69, &frame__55_68, 966, 979, 9, 25},
  {entry__55_105, NULL, 983, 983, 16, 46},
  {cont__55_106, &frame__55_105, 983, 983, 13, 46},
  {entry__55_107, NULL, 986, 986, 31, 61},
  {cont__55_108, &frame__55_107, 986, 986, 15, 61},
  {cont__55_109, &frame__55_107, 986, 986, 61, 61},
  {entry__55_102, NULL, 982, 982, 13, 33},
  {cont__55_103, &frame__55_102, 982, 982, 13, 42},
  {cont__55_104, &frame__55_102, 981, 986, 11, 62},
  {entry__55_100, NULL, 980, 980, 12, 36},
  {cont__55_101, &frame__55_100, 980, 986, 9, 63},
  {entry__55_134, NULL, 996, 996, 21, 32},
  {cont__55_135, &frame__55_134, 996, 996, 13, 33},
  {cont__55_136, &frame__55_134, 996, 996, 13, 43},
  {cont__55_138, &frame__55_134, 996, 996, 13, 43},
  {entry__55_129, NULL, 995, 995, 26, 37},
  {cont__55_130, &frame__55_129, 995, 995, 13, 38},
  {cont__55_131, &frame__55_129, 995, 995, 13, 47},
  {cont__55_133, &frame__55_129, 996, 996, 13, 43},
  {cont__55_139, &frame__55_129, },
  {entry__55_126, NULL, 994, 994, 13, 24},
  {cont__55_127, &frame__55_126, 994, 994, 13, 41},
  {cont__55_128, &frame__55_126, },
  {cont__55_140, &frame__55_126, },
  {entry__55_123, NULL, 993, 993, 13, 24},
  {cont__55_124, &frame__55_123, 993, 993, 13, 41},
  {cont__55_125, &frame__55_123, },
  {cont__55_141, &frame__55_123, },
  {entry__55_120, NULL, 992, 992, 13, 32},
  {cont__55_121, &frame__55_120, 992, 992, 13, 37},
  {cont__55_122, &frame__55_120, },
  {cont__55_142, &frame__55_120, },
  {entry__55_116, NULL, 991, 991, 13, 28},
  {cont__55_117, &frame__55_116, 991, 991, 13, 48},
  {cont__55_119, &frame__55_116, },
  {cont__55_143, &frame__55_116, },
  {entry__55_112, NULL, 990, 990, 13, 33},
  {cont__55_113, &frame__55_112, 990, 990, 13, 42},
  {cont__55_115, &frame__55_112, },
  {cont__55_144, &frame__55_112, },
  {entry__55_146, NULL, 997, 997, 19, 30},
  {cont__55_147, &frame__55_146, 997, 997, 14, 32},
  {cont__55_149, &frame__55_146, 997, 997, 11, 32},
  {entry__55_110, NULL, 989, 989, 13, 36},
  {cont__55_111, &frame__55_110, },
  {cont__55_145, &frame__55_110, 987, 997, 9, 32},
  {entry__55_150, NULL, 998, 998, 9, 28},
  {entry__55_67, NULL, 965, 998, 7, 28},
  {entry__55_65, NULL, 964, 964, 8, 41},
  {cont__55_66, &frame__55_65, 964, 998, 5, 29},
  {entry__55_160, NULL, 1006, 1006, 16, 54},
  {cont__55_161, &frame__55_160, 1006, 1006, 13, 54},
  {entry__55_162, NULL, 1007, 1007, 16, 46},
  {cont__55_163, &frame__55_162, 1007, 1007, 13, 46},
  {entry__55_156, NULL, 1003, 1003, 11, 32},
  {cont__55_157, &frame__55_156, 1005, 1005, 13, 35},
  {cont__55_158, &frame__55_156, 1005, 1005, 13, 56},
  {cont__55_159, &frame__55_156, 1004, 1007, 11, 46},
  {entry__55_170, NULL, 1018, 1018, 15, 45},
  {entry__55_171, NULL, 1019, 1019, 15, 46},
  {entry__55_165, NULL, 1015, 1015, 13, 31},
  {cont__55_166, &frame__55_165, 1017, 1017, 15, 33},
  {cont__55_167, &frame__55_165, 1017, 1017, 15, 41},
  {cont__55_168, &frame__55_165, 1017, 1017, 15, 41},
  {cont__55_169, &frame__55_165, 1016, 1019, 13, 46},
  {entry__55_176, NULL, 1025, 1025, 15, 45},
  {entry__55_177, NULL, 1026, 1026, 15, 46},
  {entry__55_172, NULL, 1022, 1022, 13, 31},
  {cont__55_173, &frame__55_172, 1024, 1024, 15, 33},
  {cont__55_174, &frame__55_172, 1024, 1024, 15, 40},
  {cont__55_175, &frame__55_172, 1023, 1026, 13, 46},
  {entry__55_188, NULL, 1033, 1033, 17, 49},
  {cont__55_189, &frame__55_188, 1034, 1034, 43, 58},
  {cont__55_190, &frame__55_188, 1034, 1034, 30, 59},
  {cont__55_191, &frame__55_188, 1034, 1034, 17, 59},
  {cont__55_192, &frame__55_188, 1035, 1035, 17, 38},
  {cont__55_193, &frame__55_188, 1035, 1035, 38, 38},
  {entry__55_185, NULL, 1032, 1032, 24, 40},
  {cont__55_186, &frame__55_185, 1032, 1032, 24, 58},
  {cont__55_187, &frame__55_185, 1032, 1035, 21, 38},
  {entry__55_182, NULL, 1031, 1031, 28, 46},
  {cont__55_183, &frame__55_182, 1031, 1031, 15, 46},
  {cont__55_184, &frame__55_182, 1032, 1035, 15, 38},
  {cont__55_194, &frame__55_182, 1036, 1036, 28, 45},
  {cont__55_195, &frame__55_182, 1036, 1036, 15, 45},
  {cont__55_196, &frame__55_182, 1036, 1036, 45, 45},
  {entry__55_203, NULL, 1040, 1040, 17, 51},
  {cont__55_204, &frame__55_203, 1041, 1041, 44, 60},
  {cont__55_205, &frame__55_203, 1041, 1041, 31, 61},
  {cont__55_206, &frame__55_203, 1041, 1041, 17, 61},
  {cont__55_207, &frame__55_203, 1042, 1042, 17, 40},
  {cont__55_208, &frame__55_203, 1042, 1042, 40, 40},
  {entry__55_200, NULL, 1039, 1039, 24, 41},
  {cont__55_201, &frame__55_200, 1039, 1039, 24, 59},
  {cont__55_202, &frame__55_200, 1039, 1042, 21, 40},
  {entry__55_197, NULL, 1038, 1038, 29, 46},
  {cont__55_198, &frame__55_197, 1038, 1038, 15, 46},
  {cont__55_199, &frame__55_197, 1039, 1042, 15, 40},
  {cont__55_209, &frame__55_197, 1043, 1043, 29, 47},
  {cont__55_210, &frame__55_197, 1043, 1043, 15, 47},
  {cont__55_211, &frame__55_197, 1043, 1043, 47, 47},
  {entry__55_217, NULL, 1050, 1050, 17, 21},
  {entry__55_222, NULL, 1052, 1052, 41, 59},
  {cont__55_223, &frame__55_222, 1052, 1052, 59, 59},
  {entry__55_214, NULL, 1048, 1048, 18, 23},
  {cont__55_215, &frame__55_214, 1048, 1048, 18, 33},
  {cont__55_216, &frame__55_214, 1048, 1050, 15, 21},
  {cont__55_218, &frame__55_214, 1051, 1051, 33, 46},
  {cont__55_219, &frame__55_214, 1051, 1051, 15, 46},
  {cont__55_220, &frame__55_214, 1052, 1052, 18, 38},
  {cont__55_221, &frame__55_214, 1052, 1052, 15, 59},
  {entry__55_213, NULL, 1047, 1052, 13, 59},
  {cont__55_224, &frame__55_213, 1052, 1052, 59, 59},
  {entry__55_233, NULL, 1058, 1058, 17, 33},
  {entry__55_234, NULL, 1060, 1060, 20, 45},
  {cont__55_235, &frame__55_234, 1060, 1060, 17, 45},
  {entry__55_236, NULL, 1061, 1061, 20, 49},
  {cont__55_237, &frame__55_236, 1061, 1061, 17, 49},
  {entry__55_247, NULL, 1063, 1063, 70, 70},
  {entry__55_227, NULL, 1057, 1057, 17, 34},
  {cont__55_232, &frame__55_227, 1054, 1061, 13, 50},
  {cont__55_239, &frame__55_227, 1062, 1062, 32, 49},
  {cont__55_240, &frame__55_227, 1062, 1062, 32, 51},
  {cont__55_241, &frame__55_227, 1062, 1062, 54, 78},
  {cont__55_242, &frame__55_227, 1062, 1062, 32, 78},
  {cont__55_243, &frame__55_227, 1062, 1062, 13, 78},
  {cont__55_244, &frame__55_227, 1063, 1063, 16, 33},
  {cont__55_245, &frame__55_227, 1063, 1063, 16, 46},
  {cont__55_246, &frame__55_227, 1063, 1063, 13, 70},
  {entry__55_253, NULL, 1069, 1069, 45, 57},
  {cont__55_254, &frame__55_253, 1069, 1069, 57, 57},
  {entry__55_258, NULL, 1071, 1071, 45, 57},
  {cont__55_259, &frame__55_258, 1071, 1071, 57, 57},
  {entry__55_251, NULL, 1069, 1069, 22, 42},
  {cont__55_252, &frame__55_251, 1069, 1069, 19, 57},
  {cont__55_255, &frame__55_251, 1070, 1070, 19, 33},
  {cont__55_256, &frame__55_251, 1071, 1071, 22, 42},
  {cont__55_257, &frame__55_251, 1071, 1071, 19, 57},
  {entry__55_260, NULL, 1073, 1073, 19, 44},
  {cont__55_261, &frame__55_260, 1073, 1073, 44, 44},
  {entry__55_250, NULL, 1067, 1073, 15, 45},
  {entry__55_263, NULL, 1075, 1075, 65, 65},
  {entry__55_273, NULL, 1080, 1080, 19, 34},
  {cont__55_274, &frame__55_273, 1081, 1081, 19, 41},
  {cont__55_275, &frame__55_273, 1081, 1081, 41, 41},
  {entry__55_270, NULL, 1079, 1079, 24, 29},
  {cont__55_271, &frame__55_270, 1079, 1079, 24, 39},
  {cont__55_272, &frame__55_270, 1079, 1081, 17, 41},
  {cont__55_276, &frame__55_270, 1082, 1082, 17, 31},
  {cont__55_277, &frame__55_270, 1082, 1082, 31, 31},
  {entry__55_262, NULL, 1075, 1075, 15, 65},
  {cont__55_266, &frame__55_262, 1076, 1076, 15, 52},
  {cont__55_267, &frame__55_262, 1077, 1077, 34, 47},
  {cont__55_268, &frame__55_262, 1077, 1077, 15, 63},
  {cont__55_269, &frame__55_262, 1078, 1082, 15, 31},
  {entry__55_164, NULL, 1010, 1010, 11, 42},
  {cont__55_178, &frame__55_164, 1011, 1011, 11, 29},
  {cont__55_179, &frame__55_164, 1012, 1012, 11, 30},
  {cont__55_180, &frame__55_164, 1030, 1030, 13, 36},
  {cont__55_181, &frame__55_164, 1029, 1043, 11, 48},
  {cont__55_212, &frame__55_164, 1046, 1052, 11, 60},
  {cont__55_225, &frame__55_164, 1053, 1053, 14, 35},
  {cont__55_226, &frame__55_164, 1053, 1063, 11, 70},
  {cont__55_248, &frame__55_164, 1066, 1066, 13, 34},
  {cont__55_249, &frame__55_164, 1065, 1082, 11, 33},
  {cont__55_278, &frame__55_164, 1083, 1083, 11, 16},
  {entry__55_152, NULL, 1000, 1000, 7, 33},
  {cont__55_153, &frame__55_152, 1002, 1002, 9, 28},
  {cont__55_154, &frame__55_152, 1002, 1002, 9, 33},
  {cont__55_155, &frame__55_152, 1001, 1083, 7, 17},
  {cont__55_279, &frame__55_152, 1083, 1083, 17, 17},
  {entry__55_151, NULL, 999, 1083, 5, 18},
  {entry__55_1, NULL, 903, 903, 3, 27},
  {cont__55_37, &frame__55_1, 907, 907, 7, 24},
  {cont__55_38, &frame__55_1, 905, 910, 3, 19},
  {cont__55_43, &frame__55_1, 950, 950, 3, 31},
  {cont__55_44, &frame__55_1, 951, 1083, 3, 19},
  {entry__56_1, NULL, 1088, 1088, 52, 70},
  {cont__56_2, &frame__56_1, 1088, 1088, 41, 71},
  {cont__56_3, &frame__56_1, 1088, 1088, 38, 71},
  {entry__57_6, NULL, 1100, 1100, 9, 29},
  {cont__57_7, &frame__57_6, 1100, 1100, 29, 29},
  {entry__57_8, NULL, 1102, 1102, 22, 22},
  {entry__57_19, NULL, 1105, 1105, 36, 40},
  {entry__57_20, NULL, 1105, 1105, 43, 48},
  {entry__57_26, NULL, 1109, 1109, 26, 39},
  {cont__57_27, &frame__57_26, 1109, 1109, 12, 64},
  {cont__57_28, &frame__57_26, 1109, 1109, 9, 64},
  {entry__57_23, NULL, 1108, 1108, 9, 16},
  {cont__57_24, &frame__57_23, 1108, 1108, 9, 26},
  {cont__57_25, &frame__57_23, 1107, 1109, 7, 64},
  {entry__57_31, NULL, 1113, 1113, 26, 39},
  {cont__57_32, &frame__57_31, 1113, 1113, 12, 74},
  {cont__57_33, &frame__57_31, 1113, 1113, 9, 74},
  {entry__57_29, NULL, 1112, 1112, 9, 31},
  {cont__57_30, &frame__57_29, 1111, 1113, 7, 74},
  {entry__57_42, NULL, 1117, 1117, 11, 24},
  {cont__57_43, &frame__57_42, 1121, 1121, 11, 35},
  {cont__57_44, &frame__57_42, 1115, 1122, 9, 14},
  {cont__57_45, &frame__57_42, 1114, 1122, 73, 16},
  {entry__57_34, NULL, 1114, 1114, 10, 17},
  {cont__57_35, &frame__57_34, 1114, 1114, 19, 39},
  {cont__57_36, &frame__57_34, 1114, 1114, 10, 39},
  {cont__57_37, &frame__57_34, 1114, 1114, 10, 41},
  {cont__57_38, &frame__57_34, 1114, 1114, 43, 58},
  {cont__57_39, &frame__57_34, 1114, 1114, 10, 58},
  {cont__57_40, &frame__57_34, 1114, 1114, 10, 71},
  {cont__57_41, &frame__57_34, 1114, 1122, 7, 16},
  {entry__57_47, NULL, 1123, 1123, 18, 58},
  {cont__57_48, &frame__57_47, 1123, 1123, 15, 58},
  {entry__57_46, NULL, 1123, 1123, 7, 58},
  {entry__57_2, NULL, 1096, 1096, 5, 31},
  {cont__57_3, &frame__57_2, 1097, 1097, 5, 36},
  {cont__57_4, &frame__57_2, 1099, 1099, 7, 27},
  {cont__57_5, &frame__57_2, 1098, 1102, 5, 23},
  {cont__57_9, &frame__57_2, 1103, 1103, 51, 71},
  {cont__57_10, &frame__57_2, 1103, 1103, 44, 71},
  {cont__57_11, &frame__57_2, 1103, 1103, 44, 73},
  {cont__57_12, &frame__57_2, 1103, 1103, 5, 74},
  {cont__57_13, &frame__57_2, 1104, 1104, 12, 29},
  {cont__57_14, &frame__57_2, 1104, 1104, 12, 32},
  {cont__57_15, &frame__57_2, 1104, 1104, 5, 42},
  {cont__57_16, &frame__57_2, 1105, 1105, 19, 26},
  {cont__57_17, &frame__57_2, 1105, 1105, 19, 33},
  {cont__57_18, &frame__57_2, 1105, 1105, 5, 49},
  {cont__57_22, &frame__57_2, 1106, 1123, 5, 58},
  {cont__57_49, &frame__57_2, 1123, 1123, 58, 58},
  {entry__57_1, NULL, 1095, 1123, 3, 59},
  {entry__58_1, NULL, 1125, 1125, 48, 70},
  {entry__59_1, NULL, 1127, 1127, 51, 73},
  {entry__60_1, NULL, 1132, 1132, 59, 78},
  {cont__60_2, &frame__60_1, 1132, 1132, 43, 78},
  {entry__62_4, NULL, 1142, 1142, 26, 40},
  {cont__62_5, &frame__62_4, 1142, 1142, 26, 40},
  {entry__62_7, NULL, 1142, 1142, 43, 65},
  {cont__62_8, &frame__62_7, 1142, 1142, 70, 70},
  {entry__62_2, NULL, 1142, 1142, 8, 21},
  {cont__62_3, &frame__62_2, 1142, 1142, 8, 40},
  {cont__62_6, &frame__62_2, 1142, 1142, 5, 70},
  {entry__62_1, NULL, 1141, 1142, 3, 70},
  {cont__62_9, &frame__62_1, 1146, 1146, 3, 25},
  {cont__62_10, &frame__62_1, 1146, 1146, 35, 35},
  {entry__63_7, NULL, 1157, 1157, 52, 72},
  {cont__63_8, &frame__63_7, 1157, 1157, 49, 72},
  {entry__63_10, NULL, 1157, 1157, 23, 31},
  {entry__63_13, NULL, 1157, 1157, 41, 46},
  {entry__63_6, NULL, 1157, 1157, 7, 72},
  {entry__63_21, NULL, 1160, 1160, 48, 62},
  {cont__63_22, &frame__63_21, 1160, 1160, 48, 62},
  {cont__63_23, &frame__63_21, 1160, 1160, 48, 62},
  {entry__63_18, NULL, 1160, 1160, 29, 43},
  {cont__63_19, &frame__63_18, 1160, 1160, 29, 43},
  {cont__63_20, &frame__63_18, 1160, 1160, 29, 62},
  {cont__63_24, &frame__63_18, 1160, 1160, 29, 62},
  {entry__63_26, NULL, 1161, 1161, 30, 43},
  {cont__63_27, &frame__63_26, 1161, 1161, 26, 44},
  {cont__63_28, &frame__63_26, 1161, 1161, 12, 49},
  {cont__63_30, &frame__63_26, 1161, 1161, 9, 49},
  {entry__63_31, NULL, 1162, 1162, 12, 24},
  {cont__63_32, &frame__63_31, 1162, 1162, 9, 24},
  {entry__63_15, NULL, 1160, 1160, 9, 24},
  {cont__63_16, &frame__63_15, 1160, 1160, 9, 24},
  {cont__63_17, &frame__63_15, 1160, 1160, 9, 62},
  {cont__63_25, &frame__63_15, 1159, 1162, 7, 24},
  {entry__63_1, NULL, 1153, 1153, 10, 37},
  {cont__63_2, &frame__63_1, 1153, 1153, 3, 60},
  {cont__63_3, &frame__63_1, 1154, 1154, 3, 30},
  {cont__63_4, &frame__63_1, 1156, 1156, 5, 19},
  {cont__63_5, &frame__63_1, 1155, 1162, 3, 26},
  {entry__64_1, NULL, 1167, 1167, 39, 58},
  {cont__64_2, &frame__64_1, 1167, 1167, 21, 59},
  {cont__64_3, &frame__64_1, 1167, 1167, 5, 69},
  {cont__64_4, &frame__64_1, 1165, 1167, 3, 69},
  {entry__65_3, NULL, 1181, 1181, 5, 19},
  {cont__65_4, &frame__65_3, 1182, 1182, 5, 10},
  {entry__65_8, NULL, 1186, 1186, 29, 43},
  {cont__65_9, &frame__65_8, 1186, 1186, 17, 44},
  {cont__65_11, &frame__65_8, 1186, 1186, 5, 45},
  {cont__65_12, &frame__65_8, 1187, 1187, 5, 10},
  {entry__65_15, NULL, 1189, 1189, 52, 66},
  {cont__65_16, &frame__65_15, 1189, 1189, 52, 71},
  {cont__65_17, &frame__65_15, 1189, 1189, 52, 71},
  {cont__65_18, &frame__65_15, 1189, 1189, 52, 71},
  {entry__65_25, NULL, 1201, 1201, 13, 32},
  {cont__65_27, &frame__65_25, 1201, 1201, 32, 32},
  {entry__65_28, NULL, 1203, 1203, 13, 28},
  {cont__65_29, &frame__65_28, 1204, 1204, 20, 20},
  {entry__65_21, NULL, 1196, 1196, 35, 39},
  {cont__65_22, &frame__65_21, 1196, 1196, 22, 40},
  {cont__65_23, &frame__65_21, 1196, 1196, 9, 40},
  {cont__65_24, &frame__65_21, 1197, 1204, 9, 21},
  {cont__65_30, &frame__65_21, 1205, 1205, 9, 16},
  {cont__65_31, &frame__65_21, 1205, 1205, 16, 16},
  {entry__65_33, NULL, 1209, 1209, 39, 43},
  {cont__65_34, &frame__65_33, 1209, 1209, 26, 44},
  {cont__65_35, &frame__65_33, 1209, 1209, 13, 44},
  {cont__65_36, &frame__65_33, 1213, 1213, 13, 34},
  {cont__65_38, &frame__65_33, 1214, 1214, 13, 20},
  {cont__65_39, &frame__65_33, 1214, 1214, 20, 20},
  {entry__65_40, NULL, 1216, 1216, 28, 28},
  {entry__65_32, NULL, 1207, 1216, 9, 29},
  {entry__65_41, NULL, 1218, 1218, 35, 39},
  {cont__65_42, &frame__65_41, 1218, 1218, 22, 40},
  {cont__65_43, &frame__65_41, 1218, 1218, 9, 40},
  {cont__65_44, &frame__65_41, 1219, 1219, 9, 27},
  {cont__65_46, &frame__65_41, 1220, 1220, 9, 16},
  {cont__65_47, &frame__65_41, 1220, 1220, 16, 16},
  {entry__65_52, NULL, 1225, 1225, 37, 41},
  {cont__65_53, &frame__65_52, 1225, 1225, 24, 42},
  {cont__65_54, &frame__65_52, 1225, 1225, 11, 42},
  {cont__65_55, &frame__65_52, 1226, 1226, 11, 30},
  {cont__65_56, &frame__65_52, 1227, 1227, 11, 18},
  {cont__65_57, &frame__65_52, 1227, 1227, 18, 18},
  {entry__65_48, NULL, 1223, 1223, 9, 39},
  {cont__65_49, &frame__65_48, 1224, 1224, 12, 29},
  {cont__65_50, &frame__65_48, 1224, 1224, 12, 33},
  {cont__65_51, &frame__65_48, 1224, 1227, 9, 18},
  {entry__65_20, NULL, 1193, 1227, 5, 20},
  {entry__65_63, NULL, 1233, 1233, 22, 22},
  {entry__65_69, NULL, 1242, 1242, 46, 49},
  {entry__65_70, NULL, 1242, 1242, 52, 55},
  {entry__65_74, NULL, 1244, 1244, 32, 46},
  {cont__65_75, &frame__65_74, 1244, 1244, 32, 48},
  {cont__65_76, &frame__65_74, 1244, 1244, 32, 61},
  {cont__65_77, &frame__65_74, 1244, 1244, 32, 61},
  {cont__65_78, &frame__65_74, 1244, 1244, 32, 61},
  {entry__65_80, NULL, 1244, 1244, 79, 79},
  {entry__65_82, NULL, 1247, 1247, 11, 26},
  {cont__65_83, &frame__65_82, 1247, 1247, 26, 26},
  {entry__65_84, NULL, 1249, 1249, 23, 39},
  {cont__65_85, &frame__65_84, 1249, 1249, 11, 39},
  {cont__65_86, &frame__65_84, 1249, 1249, 39, 39},
  {entry__65_64, NULL, 1241, 1241, 15, 42},
  {cont__65_65, &frame__65_64, 1241, 1241, 11, 46},
  {cont__65_66, &frame__65_64, 1242, 1242, 14, 43},
  {cont__65_67, &frame__65_64, 1242, 1242, 14, 43},
  {cont__65_68, &frame__65_64, 1242, 1242, 11, 56},
  {cont__65_71, &frame__65_64, 1237, 1242, 7, 57},
  {cont__65_72, &frame__65_64, 1244, 1244, 14, 27},
  {cont__65_73, &frame__65_64, 1244, 1244, 14, 61},
  {cont__65_79, &frame__65_64, 1244, 1244, 7, 79},
  {cont__65_81, &frame__65_64, 1245, 1249, 7, 40},
  {entry__65_1, NULL, 1180, 1180, 6, 15},
  {cont__65_2, &frame__65_1, 1180, 1182, 3, 10},
  {cont__65_5, &frame__65_1, 1183, 1183, 21, 32},
  {cont__65_6, &frame__65_1, 1183, 1183, 6, 32},
  {cont__65_7, &frame__65_1, 1183, 1187, 3, 10},
  {cont__65_13, &frame__65_1, 1189, 1189, 25, 47},
  {cont__65_14, &frame__65_1, 1189, 1189, 3, 71},
  {cont__65_19, &frame__65_1, 1192, 1227, 3, 21},
  {cont__65_58, &frame__65_1, 1228, 1228, 30, 30},
  {cont__65_59, &frame__65_1, 1228, 1228, 16, 31},
  {cont__65_60, &frame__65_1, 1228, 1228, 3, 31},
  {cont__65_61, &frame__65_1, 1230, 1230, 5, 14},
  {cont__65_62, &frame__65_1, 1229, 1249, 3, 42},
  {cont__65_87, &frame__65_1, 1249, 1249, 42, 42},
  {entry__66_10, NULL, 1255, 1255, 15, 22},
  {cont__66_11, &frame__66_10, 1255, 1255, 9, 27},
  {cont__66_12, &frame__66_10, 1255, 1255, 14, 22},
  {cont__66_13, &frame__66_10, 1256, 1256, 24, 24},
  {entry__66_4, NULL, 1254, 1254, 34, 61},
  {cont__66_5, &frame__66_4, 1254, 1254, 20, 27},
  {cont__66_6, &frame__66_4, 1254, 1254, 10, 28},
  {cont__66_7, &frame__66_4, 1254, 1254, 10, 30},
  {cont__66_8, &frame__66_4, 1254, 1254, 10, 61},
  {cont__66_9, &frame__66_4, 1254, 1256, 7, 24},
  {entry__66_2, NULL, 1253, 1253, 12, 34},
  {cont__66_3, &frame__66_2, 1253, 1256, 5, 25},
  {entry__66_15, NULL, 1257, 1257, 36, 43},
  {cont__66_16, &frame__66_15, 1257, 1257, 20, 53},
  {cont__66_17, &frame__66_15, 1257, 1257, 17, 53},
  {entry__66_23, NULL, 1263, 1263, 44, 47},
  {entry__66_24, NULL, 1263, 1263, 50, 53},
  {entry__66_34, NULL, 1271, 1271, 24, 30},
  {cont__66_35, &frame__66_34, 1271, 1271, 24, 37},
  {cont__66_36, &frame__66_34, 1271, 1271, 24, 37},
  {cont__66_37, &frame__66_34, 1271, 1271, 24, 37},
  {entry__66_39, NULL, 1271, 1271, 64, 64},
  {entry__66_50, NULL, 1279, 1279, 15, 26},
  {cont__66_51, &frame__66_50, 1280, 1280, 15, 22},
  {cont__66_52, &frame__66_50, 1280, 1280, 22, 22},
  {entry__66_46, NULL, 1277, 1277, 13, 20},
  {cont__66_47, &frame__66_46, 1278, 1278, 16, 24},
  {cont__66_48, &frame__66_46, 1278, 1278, 16, 32},
  {cont__66_49, &frame__66_46, 1278, 1280, 13, 22},
  {cont__66_53, &frame__66_46, 1281, 1281, 16, 24},
  {cont__66_54, &frame__66_46, 1281, 1281, 16, 36},
  {cont__66_55, &frame__66_46, 1281, 1281, 16, 36},
  {cont__66_56, &frame__66_46, 1281, 1281, 13, 36},
  {entry__66_45, NULL, 1276, 1281, 11, 36},
  {entry__66_62, NULL, 1287, 1287, 15, 29},
  {cont__66_63, &frame__66_62, 1288, 1288, 15, 22},
  {cont__66_64, &frame__66_62, 1288, 1288, 22, 22},
  {entry__66_68, NULL, 1290, 1290, 15, 37},
  {cont__66_69, &frame__66_68, 1291, 1291, 15, 22},
  {cont__66_70, &frame__66_68, 1291, 1291, 22, 22},
  {entry__66_58, NULL, 1285, 1285, 13, 20},
  {cont__66_59, &frame__66_58, 1286, 1286, 16, 24},
  {cont__66_60, &frame__66_58, 1286, 1286, 16, 31},
  {cont__66_61, &frame__66_58, 1286, 1288, 13, 22},
  {cont__66_65, &frame__66_58, 1289, 1289, 16, 24},
  {cont__66_66, &frame__66_58, 1289, 1289, 16, 36},
  {cont__66_67, &frame__66_58, 1289, 1291, 13, 22},
  {cont__66_71, &frame__66_58, 1292, 1292, 16, 24},
  {cont__66_72, &frame__66_58, 1292, 1292, 16, 31},
  {cont__66_73, &frame__66_58, 1292, 1292, 16, 31},
  {cont__66_74, &frame__66_58, 1292, 1292, 13, 31},
  {entry__66_57, NULL, 1284, 1292, 11, 31},
  {entry__66_82, NULL, 1299, 1299, 17, 31},
  {entry__66_88, NULL, 1301, 1301, 44, 51},
  {cont__66_89, &frame__66_88, 1301, 1301, 51, 51},
  {entry__66_84, NULL, 1301, 1301, 26, 34},
  {cont__66_85, &frame__66_84, 1301, 1301, 26, 41},
  {cont__66_86, &frame__66_84, 1301, 1301, 26, 41},
  {cont__66_87, &frame__66_84, 1301, 1301, 23, 51},
  {entry__66_83, NULL, 1301, 1301, 17, 51},
  {entry__66_79, NULL, 1298, 1298, 15, 23},
  {cont__66_80, &frame__66_79, 1298, 1298, 15, 30},
  {cont__66_81, &frame__66_79, 1297, 1301, 13, 52},
  {entry__66_75, NULL, 1295, 1295, 11, 18},
  {cont__66_76, &frame__66_75, 1296, 1296, 18, 26},
  {cont__66_77, &frame__66_75, 1296, 1296, 18, 34},
  {cont__66_78, &frame__66_75, 1296, 1301, 11, 53},
  {entry__66_95, NULL, 1310, 1310, 33, 33},
  {entry__66_102, NULL, 1316, 1316, 43, 51},
  {cont__66_103, &frame__66_102, 1316, 1316, 43, 58},
  {cont__66_104, &frame__66_102, 1316, 1316, 43, 58},
  {entry__66_106, NULL, 1316, 1316, 79, 79},
  {entry__66_100, NULL, 1316, 1316, 24, 38},
  {cont__66_101, &frame__66_100, 1316, 1316, 24, 58},
  {cont__66_105, &frame__66_100, 1316, 1316, 21, 79},
  {entry__66_109, NULL, 1317, 1317, 71, 71},
  {entry__66_107, NULL, 1317, 1317, 24, 50},
  {cont__66_108, &frame__66_107, 1317, 1317, 21, 71},
  {entry__66_98, NULL, 1314, 1314, 19, 30},
  {cont__66_99, &frame__66_98, 1315, 1317, 19, 71},
  {entry__66_110, NULL, 1319, 1319, 37, 37},
  {entry__66_96, NULL, 1313, 1313, 17, 27},
  {cont__66_97, &frame__66_96, 1312, 1319, 15, 38},
  {entry__66_92, NULL, 1307, 1307, 11, 24},
  {cont__66_93, &frame__66_92, 1309, 1309, 13, 22},
  {cont__66_94, &frame__66_92, 1308, 1319, 11, 40},
  {cont__66_111, &frame__66_92, 1320, 1320, 11, 18},
  {cont__66_112, &frame__66_92, 1320, 1320, 18, 18},
  {entry__66_90, NULL, 1306, 1306, 18, 32},
  {cont__66_91, &frame__66_90, 1306, 1320, 15, 18},
  {entry__66_115, NULL, 1321, 1321, 70, 70},
  {entry__66_44, NULL, 1306, 1320, 9, 18},
  {cont__66_113, &frame__66_44, 1321, 1321, 12, 38},
  {cont__66_114, &frame__66_44, 1321, 1321, 9, 70},
  {cont__66_116, &frame__66_44, 1322, 1322, 32, 59},
  {cont__66_117, &frame__66_44, 1322, 1322, 27, 65},
  {cont__66_118, &frame__66_44, 1322, 1322, 9, 65},
  {cont__66_119, &frame__66_44, 1323, 1323, 21, 36},
  {cont__66_120, &frame__66_44, 1323, 1323, 39, 39},
  {cont__66_121, &frame__66_44, 1323, 1323, 9, 39},
  {cont__66_122, &frame__66_44, 1323, 1323, 39, 39},
  {entry__66_41, NULL, 1272, 1272, 16, 30},
  {cont__66_42, &frame__66_41, 1272, 1272, 16, 42},
  {cont__66_43, &frame__66_41, 1272, 1323, 13, 39},
  {entry__66_31, NULL, 1271, 1271, 10, 19},
  {cont__66_32, &frame__66_31, 1271, 1271, 10, 19},
  {cont__66_33, &frame__66_31, 1271, 1271, 10, 37},
  {cont__66_38, &frame__66_31, 1271, 1271, 7, 64},
  {cont__66_40, &frame__66_31, 1272, 1323, 7, 39},
  {cont__66_123, &frame__66_31, 1324, 1324, 7, 28},
  {cont__66_124, &frame__66_31, 1324, 1324, 28, 28},
  {entry__66_126, NULL, 1331, 1331, 7, 21},
  {cont__66_128, &frame__66_126, 1331, 1331, 21, 21},
  {entry__66_133, NULL, 1337, 1337, 15, 15},
  {cont__66_135, &frame__66_133, 1337, 1337, 7, 16},
  {cont__66_136, &frame__66_133, 1337, 1337, 22, 22},
  {entry__66_140, NULL, 1342, 1342, 21, 21},
  {entry__66_142, NULL, 1344, 1344, 28, 41},
  {cont__66_143, &frame__66_142, 1344, 1344, 9, 51},
  {cont__66_144, &frame__66_142, 1345, 1345, 9, 22},
  {cont__66_145, &frame__66_142, 1345, 1345, 22, 22},
  {entry__66_151, NULL, 1350, 1350, 9, 31},
  {cont__66_152, &frame__66_151, 1351, 1351, 9, 24},
  {cont__66_153, &frame__66_151, 1351, 1351, 24, 24},
  {entry__66_148, NULL, 1348, 1348, 7, 22},
  {cont__66_149, &frame__66_148, 1349, 1349, 14, 23},
  {cont__66_150, &frame__66_148, 1349, 1351, 7, 24},
  {entry__66_18, NULL, 1262, 1262, 13, 40},
  {cont__66_19, &frame__66_18, 1262, 1262, 9, 44},
  {cont__66_20, &frame__66_18, 1263, 1263, 12, 41},
  {cont__66_21, &frame__66_18, 1263, 1263, 12, 41},
  {cont__66_22, &frame__66_18, 1263, 1263, 9, 54},
  {cont__66_25, &frame__66_18, 1258, 1263, 5, 55},
  {cont__66_26, &frame__66_18, 1265, 1265, 33, 33},
  {cont__66_27, &frame__66_18, 1265, 1265, 26, 34},
  {cont__66_28, &frame__66_18, 1265, 1265, 26, 40},
  {cont__66_29, &frame__66_18, 1265, 1265, 5, 40},
  {cont__66_30, &frame__66_18, 1270, 1324, 5, 28},
  {cont__66_125, &frame__66_18, 1326, 1331, 5, 21},
  {cont__66_129, &frame__66_18, 1332, 1332, 15, 15},
  {cont__66_130, &frame__66_18, 1332, 1332, 8, 16},
  {cont__66_131, &frame__66_18, 1332, 1332, 8, 22},
  {cont__66_132, &frame__66_18, 1332, 1337, 5, 22},
  {cont__66_137, &frame__66_18, 1341, 1341, 7, 36},
  {cont__66_138, &frame__66_18, 1341, 1341, 7, 36},
  {cont__66_139, &frame__66_18, 1340, 1345, 5, 23},
  {cont__66_146, &frame__66_18, 1346, 1346, 5, 31},
  {cont__66_147, &frame__66_18, 1347, 1351, 5, 25},
  {cont__66_154, &frame__66_18, 1352, 1352, 5, 10},
  {entry__66_1, NULL, 1252, 1256, 3, 26},
  {cont__66_14, &frame__66_1, 1257, 1352, 3, 10},
  {entry__67_4, NULL, 1361, 1361, 9, 71},
  {cont__67_5, &frame__67_4, 1361, 1361, 71, 71},
  {entry__67_7, NULL, 1365, 1365, 21, 28},
  {cont__67_8, &frame__67_7, 1365, 1365, 13, 63},
  {cont__67_9, &frame__67_7, 1365, 1365, 20, 28},
  {cont__67_10, &frame__67_7, 1365, 1365, 63, 63},
  {entry__67_16, NULL, 1374, 1374, 48, 48},
  {cont__67_17, &frame__67_16, 1374, 1374, 41, 49},
  {cont__67_18, &frame__67_16, 1374, 1374, 54, 54},
  {cont__67_19, &frame__67_16, 1374, 1374, 35, 55},
  {cont__67_20, &frame__67_16, 1374, 1374, 17, 61},
  {cont__67_21, &frame__67_16, 1374, 1374, 25, 25},
  {cont__67_22, &frame__67_16, 1374, 1374, 17, 26},
  {cont__67_23, &frame__67_16, 1374, 1374, 61, 61},
  {entry__67_24, NULL, 1378, 1378, 17, 32},
  {cont__67_25, &frame__67_24, 1378, 1378, 32, 32},
  {entry__67_11, NULL, 1367, 1367, 13, 77},
  {cont__67_12, &frame__67_11, 1369, 1369, 22, 22},
  {cont__67_13, &frame__67_11, 1369, 1369, 15, 23},
  {cont__67_14, &frame__67_11, 1369, 1369, 15, 41},
  {cont__67_15, &frame__67_11, 1368, 1378, 13, 33},
  {entry__67_6, NULL, 1363, 1378, 9, 35},
  {entry__67_2, NULL, 1360, 1360, 7, 20},
  {cont__67_3, &frame__67_2, 1359, 1378, 5, 37},
  {entry__67_28, NULL, 1383, 1383, 25, 25},
  {entry__67_30, NULL, 1389, 1389, 35, 42},
  {cont__67_31, &frame__67_30, 1389, 1389, 44, 56},
  {cont__67_32, &frame__67_30, 1389, 1389, 13, 57},
  {cont__67_33, &frame__67_30, 1389, 1389, 13, 26},
  {cont__67_34, &frame__67_30, 1390, 1390, 29, 29},
  {entry__67_35, NULL, 1401, 1401, 44, 44},
  {cont__67_36, &frame__67_35, 1401, 1401, 37, 45},
  {cont__67_37, &frame__67_35, 1401, 1401, 50, 50},
  {cont__67_38, &frame__67_35, 1401, 1401, 31, 51},
  {cont__67_39, &frame__67_35, 1401, 1401, 53, 65},
  {cont__67_40, &frame__67_35, 1401, 1401, 13, 66},
  {cont__67_41, &frame__67_35, 1401, 1401, 21, 21},
  {cont__67_42, &frame__67_35, 1401, 1401, 13, 22},
  {cont__67_43, &frame__67_35, 1402, 1402, 47, 47},
  {cont__67_44, &frame__67_35, 1402, 1402, 27, 48},
  {cont__67_45, &frame__67_35, 1402, 1402, 13, 48},
  {cont__67_46, &frame__67_35, 1402, 1402, 48, 48},
  {entry__67_29, NULL, 1385, 1402, 9, 49},
  {entry__67_26, NULL, 1382, 1382, 7, 20},
  {cont__67_27, &frame__67_26, 1381, 1402, 5, 51},
  {cont__67_47, &frame__67_26, 1403, 1403, 29, 29},
  {entry__67_54, NULL, 1413, 1413, 22, 34},
  {cont__67_55, &frame__67_54, 1413, 1413, 13, 34},
  {entry__67_56, NULL, 1415, 1415, 13, 32},
  {entry__67_51, NULL, 1410, 1410, 55, 77},
  {cont__67_52, &frame__67_51, 1410, 1410, 9, 77},
  {cont__67_53, &frame__67_51, 1411, 1415, 9, 33},
  {entry__67_57, NULL, 1418, 1418, 31, 48},
  {cont__67_58, &frame__67_57, 1418, 1418, 18, 53},
  {cont__67_60, &frame__67_57, 1418, 1418, 9, 53},
  {cont__67_61, &frame__67_57, 1418, 1418, 53, 53},
  {entry__67_49, NULL, 1409, 1409, 7, 34},
  {cont__67_50, &frame__67_49, 1408, 1418, 5, 54},
  {entry__67_67, NULL, 1419, 1419, 54, 54},
  {cont__67_68, &frame__67_67, 1419, 1419, 47, 55},
  {cont__67_69, &frame__67_67, 1419, 1419, 60, 60},
  {cont__67_70, &frame__67_67, 1419, 1419, 40, 78},
  {cont__67_71, &frame__67_67, 1419, 1419, 54, 54},
  {cont__67_72, &frame__67_67, 1419, 1419, 46, 55},
  {cont__67_73, &frame__67_67, 1419, 1419, 78, 78},
  {entry__67_1, NULL, 1407, 1407, 12, 29},
  {cont__67_48, &frame__67_1, 1407, 1418, 3, 55},
  {cont__67_62, &frame__67_1, 1419, 1419, 13, 13},
  {cont__67_63, &frame__67_1, 1419, 1419, 6, 14},
  {cont__67_64, &frame__67_1, 1419, 1419, 6, 37},
  {cont__67_66, &frame__67_1, 1419, 1419, 3, 78},
  {cont__67_74, &frame__67_1, 1420, 1420, 3, 47},
  {entry__68_4, NULL, 1425, 1425, 48, 66},
  {cont__68_5, &frame__68_4, 1425, 1425, 7, 66},
  {cont__68_6, &frame__68_4, 1426, 1426, 7, 42},
  {entry__68_7, NULL, 1429, 1429, 48, 66},
  {cont__68_8, &frame__68_7, 1429, 1429, 7, 66},
  {cont__68_9, &frame__68_7, 1430, 1430, 23, 59},
  {cont__68_10, &frame__68_7, 1430, 1430, 7, 59},
  {cont__68_11, &frame__68_7, 1430, 1430, 59, 59},
  {entry__68_1, NULL, 1424, 1424, 5, 25},
  {cont__68_2, &frame__68_1, 1424, 1424, 5, 34},
  {cont__68_3, &frame__68_1, 1423, 1430, 3, 60},
  {entry__69_1, NULL, 1435, 1435, 39, 57},
  {entry__70_3, NULL, 1441, 1441, 40, 47},
  {entry__70_5, NULL, 1441, 1441, 50, 56},
  {entry__70_1, NULL, 1441, 1441, 22, 37},
  {cont__70_2, &frame__70_1, 1441, 1441, 19, 57},
  {cont__70_7, &frame__70_1, 1441, 1441, 3, 57},
  {entry__71_5, NULL, 1452, 1452, 19, 36},
  {cont__71_6, &frame__71_5, 1452, 1452, 43, 55},
  {cont__71_7, &frame__71_5, 1452, 1452, 12, 56},
  {cont__71_9, &frame__71_5, 1452, 1452, 9, 56},
  {entry__71_2, NULL, 1451, 1451, 9, 26},
  {cont__71_3, &frame__71_2, 1451, 1451, 9, 37},
  {cont__71_4, &frame__71_2, 1450, 1452, 7, 56},
  {entry__71_12, NULL, 1453, 1453, 41, 53},
  {cont__71_13, &frame__71_12, 1453, 1453, 30, 54},
  {cont__71_14, &frame__71_12, 1453, 1453, 27, 54},
  {entry__71_10, NULL, 1453, 1453, 10, 25},
  {cont__71_11, &frame__71_10, 1453, 1453, 7, 54},
  {entry__71_16, NULL, 1454, 1454, 18, 30},
  {cont__71_17, &frame__71_16, 1454, 1454, 15, 30},
  {entry__71_15, NULL, 1454, 1454, 7, 30},
  {entry__71_1, NULL, 1449, 1454, 5, 29},
  {cont__71_18, &frame__71_1, 1447, 1454, 3, 31},
  {entry__72_4, NULL, 1465, 1465, 26, 50},
  {cont__72_5, &frame__72_4, 1465, 1465, 12, 59},
  {cont__72_7, &frame__72_4, 1465, 1465, 9, 59},
  {entry__72_8, NULL, 1466, 1466, 9, 18},
  {entry__72_15, NULL, 1471, 1471, 44, 56},
  {cont__72_16, &frame__72_15, 1471, 1471, 35, 59},
  {cont__72_19, &frame__72_15, 1471, 1471, 7, 59},
  {cont__72_20, &frame__72_15, 1471, 1471, 59, 59},
  {entry__72_24, NULL, 1473, 1473, 44, 62},
  {cont__72_25, &frame__72_24, 1473, 1473, 35, 65},
  {cont__72_28, &frame__72_24, 1473, 1473, 7, 65},
  {cont__72_29, &frame__72_24, 1473, 1473, 65, 65},
  {entry__72_33, NULL, 1475, 1475, 44, 56},
  {cont__72_34, &frame__72_33, 1475, 1475, 35, 59},
  {cont__72_37, &frame__72_33, 1475, 1475, 7, 59},
  {cont__72_38, &frame__72_33, 1475, 1475, 59, 59},
  {entry__72_42, NULL, 1477, 1477, 44, 62},
  {cont__72_43, &frame__72_42, 1477, 1477, 35, 65},
  {cont__72_46, &frame__72_42, 1477, 1477, 7, 65},
  {cont__72_47, &frame__72_42, 1477, 1477, 65, 65},
  {entry__72_51, NULL, 1479, 1479, 44, 56},
  {cont__72_52, &frame__72_51, 1479, 1479, 35, 59},
  {cont__72_55, &frame__72_51, 1479, 1479, 7, 59},
  {cont__72_56, &frame__72_51, 1479, 1479, 59, 59},
  {entry__72_60, NULL, 1480, 1480, 37, 50},
  {cont__72_61, &frame__72_60, 1480, 1480, 37, 61},
  {cont__72_63, &frame__72_60, 1480, 1480, 37, 61},
  {cont__72_64, &frame__72_60, 1480, 1480, 37, 61},
  {entry__72_66, NULL, 1481, 1481, 45, 58},
  {cont__72_67, &frame__72_66, 1481, 1481, 35, 61},
  {cont__72_70, &frame__72_66, 1481, 1481, 7, 61},
  {cont__72_71, &frame__72_66, 1481, 1481, 61, 61},
  {entry__72_74, NULL, 1483, 1483, 35, 58},
  {cont__72_77, &frame__72_74, 1483, 1483, 7, 58},
  {cont__72_78, &frame__72_74, 1483, 1483, 58, 58},
  {entry__72_85, NULL, 1487, 1487, 9, 52},
  {cont__72_87, &frame__72_85, 1487, 1487, 52, 52},
  {entry__72_82, NULL, 1485, 1485, 7, 22},
  {cont__72_83, &frame__72_82, 1486, 1486, 16, 36},
  {cont__72_84, &frame__72_82, 1486, 1487, 7, 52},
  {entry__72_94, NULL, 1489, 1489, 30, 44},
  {cont__72_95, &frame__72_94, 1489, 1489, 44, 44},
  {entry__72_98, NULL, 1490, 1490, 45, 76},
  {cont__72_99, &frame__72_98, 1490, 1490, 76, 76},
  {entry__72_91, NULL, 1489, 1489, 10, 23},
  {cont__72_92, &frame__72_91, 1489, 1489, 10, 27},
  {cont__72_93, &frame__72_91, 1489, 1489, 7, 44},
  {cont__72_96, &frame__72_91, 1490, 1490, 21, 35},
  {cont__72_97, &frame__72_91, 1490, 1490, 7, 76},
  {entry__72_2, NULL, 1464, 1464, 9, 29},
  {cont__72_3, &frame__72_2, 1462, 1466, 5, 19},
  {cont__72_10, &frame__72_2, 1468, 1468, 5, 31},
  {cont__72_11, &frame__72_2, 1469, 1469, 5, 31},
  {cont__72_12, &frame__72_2, 1470, 1470, 8, 20},
  {cont__72_13, &frame__72_2, 1470, 1470, 8, 31},
  {cont__72_14, &frame__72_2, 1470, 1471, 5, 59},
  {cont__72_21, &frame__72_2, 1472, 1472, 8, 26},
  {cont__72_22, &frame__72_2, 1472, 1472, 8, 37},
  {cont__72_23, &frame__72_2, 1472, 1473, 5, 65},
  {cont__72_30, &frame__72_2, 1474, 1474, 8, 20},
  {cont__72_31, &frame__72_2, 1474, 1474, 8, 31},
  {cont__72_32, &frame__72_2, 1474, 1475, 5, 59},
  {cont__72_39, &frame__72_2, 1476, 1476, 8, 26},
  {cont__72_40, &frame__72_2, 1476, 1476, 8, 37},
  {cont__72_41, &frame__72_2, 1476, 1477, 5, 65},
  {cont__72_48, &frame__72_2, 1478, 1478, 8, 20},
  {cont__72_49, &frame__72_2, 1478, 1478, 8, 31},
  {cont__72_50, &frame__72_2, 1478, 1479, 5, 59},
  {cont__72_57, &frame__72_2, 1480, 1480, 8, 21},
  {cont__72_58, &frame__72_2, 1480, 1480, 8, 32},
  {cont__72_59, &frame__72_2, 1480, 1480, 8, 61},
  {cont__72_65, &frame__72_2, 1480, 1481, 5, 61},
  {cont__72_72, &frame__72_2, 1482, 1482, 14, 31},
  {cont__72_73, &frame__72_2, 1482, 1483, 5, 58},
  {cont__72_79, &frame__72_2, 1484, 1484, 12, 32},
  {cont__72_80, &frame__72_2, 1484, 1484, 12, 41},
  {cont__72_81, &frame__72_2, 1484, 1487, 5, 53},
  {cont__72_88, &frame__72_2, 1488, 1488, 8, 22},
  {cont__72_89, &frame__72_2, 1488, 1488, 8, 33},
  {cont__72_90, &frame__72_2, 1488, 1490, 5, 76},
  {cont__72_100, &frame__72_2, 1491, 1491, 24, 48},
  {cont__72_101, &frame__72_2, 1491, 1491, 17, 53},
  {cont__72_102, &frame__72_2, 1491, 1491, 5, 53},
  {cont__72_103, &frame__72_2, 1492, 1492, 5, 10},
  {entry__72_104, NULL, 1461, 1461, 28, 37},
  {entry__72_1, NULL, 1461, 1492, 3, 10}
};

union NODE {
  struct {
    FUNC type;
    ATTRIBUTES *attributes;
  };
  CONTINUATION continuation;
  CLOSURE closure;
};
static void type__needs_parenthesis(void) {
  myself = get_attribute(arguments->slots[0], poly_idx__needs_parenthesis);
  if (CONTAINS_AN_ATTRIBUTE_VALUE(myself)) {
    if (argument_count != 1) {
      if (argument_count != 2) invalid_arguments_error();
      NODE *attr = arguments->slots[1];
      NODE *temp = clone_object_and_attributes(arguments->slots[0]);
      update_start_p = node_p;
      set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, attr);
      arguments = node_p;
      argument_count = 1;
      arguments->slots[0] = temp;
    } else {
      arguments = node_p;
      arguments->slots[0] = RETRIEVE_ATTRIBUTE_VALUE(myself);
    }
    func = frame->cont;
    frame->cont = invalid_continuation;
  } else {
    func = myself->type;
  }
}
static NODE *character__9;
static NODE *number__6;
static NODE *character__35;
static NODE *character__38;
static NODE *character__47;
static NODE *character__94;
static NODE *number__80;
static NODE *character__160;
static NODE *character__96;
static NODE *character__688;
static NODE *character__63;
static NODE *character__10;
static NODE *number__999999;
static NODE *character__58;
static NODE *number__0;
static NODE *number__3;
static NODE *number__4;
static NODE *character__37;
static NODE *character__95;
static NODE *number__0x80;
static NODE *character__33;
static NODE *number__8;
static NODE *character__64;
static NODE *character__40;
static NODE *character__34;
static NODE *character__36;
static NODE *character__39;
static NODE *character__32;
static NODE *character__125;
static NODE *character__41;
static NODE *character__59;
static NODE *number__1;
static NODE *number__0x9f;
static NODE *character__46;
static NODE *number__2;
static NODE *number__20;
static NODE *character__42;
static NODE *character__128;

static const char *used_namespaces[] = {
  "std",
  "sim2c",
  "node",
  NULL
};

static MODULE_INFO module_info = {
  NULL,
  "pretty_printer",
  continuation_info,
  sizeof(continuation_info)/sizeof(CONTINUATION_INFO),
  (NODE **)&var,
  var_names,
  sizeof(var_names)/sizeof(const char *),
  used_namespaces,
  {DEBUG_FILENAME("pretty_printer.sim")}
};

/******
C O D E
******/

static int already_run = false;

EXPORT void run__pretty_printer(void) {
  if (already_run) {
    func = frame->cont;
    frame->cont = invalid_continuation;
    return;
  }
  already_run = true;
  allocate_initialized_frame_gc(0, 0);
  // 77: %sim2c::hide_body_statements false
  initialize_maybe_future(get__sim2c__hide_body_statements(), get__false());
  // 134: $INDENTATION_MARKER character(0x80)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0x80;
  result_count = 1;
  myself = get__character();
  func = myself->type;
  frame->cont = cont__93_1;
}
static void cont__93_1(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(var._INDENTATION_MARKER, arguments->slots[0]);
  // 135: $INDENTATION_MARKER_HIGH character(0x9f)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0x9f;
  result_count = 1;
  myself = get__character();
  func = myself->type;
  frame->cont = cont__94_1;
}
static void cont__94_1(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(var._INDENTATION_MARKER_HIGH, arguments->slots[0]);
  // 136: $INDENTATION types::grammar_object
  initialize_maybe_future(var._INDENTATION, get__types__grammar_object());
  // 149: %%statement_tag undefined
  set__statement_tag(get__undefined());
  // 155: %spaces std::spaces
  initialize_maybe_future(get__spaces(), get__std__spaces());
  // 1137: $$character_to_name undefined
  var._character_to_name = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_13(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 146: -> 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_14(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 147: -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__24_1(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // self: 0
  // stream: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 143: stream .has_minimum_length. 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* stream */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__has_minimum_length();
  func = myself->type;
  frame->cont = cont__24_2;
}
static void cont__24_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__3 */ = create_closure(entry__24_3, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__24_12;
}
static void entry__24_3(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // stream: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* stream */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 144: stream(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* stream */;
  func = myself->type;
  frame->cont = cont__24_4;
}
static void cont__24_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 144: stream(1) >= INDENTATION_MARKER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = var._INDENTATION_MARKER;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__24_5;
}
static void cont__24_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 144: stream(1) >= INDENTATION_MARKER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__24_6;
}
static void cont__24_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 145: stream(1) <= INDENTATION_MARKER_HIGH
  frame->slots[5] /* temp__5 */ = create_closure(entry__24_7, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__24_11;
}
static void entry__24_7(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // stream: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* stream */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 145: stream(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* stream */;
  func = myself->type;
  frame->cont = cont__24_8;
}
static void cont__24_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 145: stream(1) <= INDENTATION_MARKER_HIGH
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = var._INDENTATION_MARKER_HIGH;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__24_9;
}
static void cont__24_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 145: stream(1) <= INDENTATION_MARKER_HIGH
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__24_10;
}
static void cont__24_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 145: stream(1) <= INDENTATION_MARKER_HIGH
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__24_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 141: if
  // 142:   &&
  // 143:     stream .has_minimum_length. 1
  // 144:     stream(1) >= INDENTATION_MARKER
  // 145:     stream(1) <= INDENTATION_MARKER_HIGH
  // 146:   -> 1
  // 147:   -> 0
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = func__24_13;
  arguments->slots[2] = func__24_14;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__27_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // indent: 0
  // indentation: 1
  frame->slots[1] /* indentation */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* indent */ = create_cell_with_contents(arguments->slots[0]);
  // 160: $$indentation ""
  ((CELL *)frame->slots[1])->contents /* indentation */ = empty_string;
  // 161: ... -> indent >= 8:
  // 162:   push &indentation '@ht;'
  // 163:   minus &indent 8
  frame->slots[2] /* temp__1 */ = create_closure(entry__27_2, 0);
  // 161: while -> indent >= 8:
  // 162:   push &indentation '@ht;'
  // 163:   minus &indent 8
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__27_8;
}
static void entry__27_5(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // indentation: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* indentation */
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 162: push &indentation '@ht;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indentation */;
  arguments->slots[1] = character__9;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__27_6;
}
static void cont__27_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* indentation */ = arguments->slots[0];
  // 163: minus &indent 8
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__8;
  result_count = 1;
  myself = get__minus();
  func = myself->type;
  frame->cont = cont__27_7;
}
static void cont__27_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__27_2(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // indent: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 161: ... indent >= 8
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  arguments->slots[1] = number__8;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__27_3;
}
static void cont__27_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 161: ... indent >= 8
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__27_4;
}
static void cont__27_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 161: ... :
  // 162:   push &indentation '@ht;'
  // 163:   minus &indent 8
  frame->slots[4] /* temp__3 */ = create_closure(entry__27_5, 0);
  // 161: ... -> indent >= 8:
  // 162:   push &indentation '@ht;'
  // 163:   minus &indent 8
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__27_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 164: ... std::spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__std__spaces();
  func = myself->type;
  frame->cont = cont__27_9;
}
static void cont__27_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 164: append indentation std::spaces(indent)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indentation */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__append();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__28_1(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // trees: 0
  // return__1: 1
  frame->slots[1] /* return__1 */ = create_continuation();
  // _define %spaces 
  // : (indent)
  // std::shift_right temp__3 indent 1
  // std::plus temp__2 INDENTATION_MARKER temp__3
  // string temp__1 temp__2
  // -> temp__1
  define__spaces(func__28_2);
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 174: for_each trees: (idx tree)
  // 175:   $previous_statement_tag statement_tag
  // 176:   !statement_tag undefined
  // 177:   $str tree.to_string
  // 178:   if
  // 179:     &&
  // 180:       idx > 1
  // 181:       statement_tag == ALWAYS || previous_statement_tag != statement_tag
  // 182:     :
  // 183:       writeln
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* trees */;
  arguments->slots[1] = func__28_6;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__28_47;
}
static void entry__28_46(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // line: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 204: ... writeln line
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__28_2(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // indent: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 172: ... indent >> 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__shift_right();
  func = myself->type;
  frame->cont = cont__28_3;
}
static void cont__28_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 172: ... INDENTATION_MARKER+(indent >> 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = var._INDENTATION_MARKER;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__28_4;
}
static void cont__28_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 172: ... string(INDENTATION_MARKER+(indent >> 1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__28_5;
}
static void cont__28_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 172: -> string(INDENTATION_MARKER+(indent >> 1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__28_6(void) {
  allocate_initialized_frame_gc(2, 10);
  // slot allocations:
  // idx: 0
  // tree: 1
  // previous_statement_tag: 2
  // str: 3
  // lines: 4
  // add_line: 5
  // n: 6
  frame->slots[5] /* add_line */ = create_future();
  frame->slots[2] /* previous_statement_tag */ = create_future();
  frame->slots[3] /* str */ = create_future();
  frame->slots[4] /* lines */ = create_cell();
  frame->slots[6] /* n */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 186: ... : (line)
  // 187:   if
  // 188:     length_of(line) > 1:
  // 189:       $indent 2*(line(1)-INDENTATION_MARKER)
  // 190:       $text range(line 2 -1)
  // 191:       put &lines string(indentation_string(indent) text)
  // 192:     :
  // 193:       put &lines ""
  frame->slots[7] /* temp__1 */ = create_closure(entry__28_7, 1);
  // 186: $add_line: (line)
  // 187:   if
  // 188:     length_of(line) > 1:
  // 189:       $indent 2*(line(1)-INDENTATION_MARKER)
  // 190:       $text range(line 2 -1)
  // 191:       put &lines string(indentation_string(indent) text)
  // 192:     :
  // 193:       put &lines ""
  initialize_future(frame->slots[5] /* add_line */, frame->slots[7] /* temp__1 */);
  // 175: $previous_statement_tag statement_tag
  initialize_future(frame->slots[2] /* previous_statement_tag */, get__statement_tag());
  // 176: !statement_tag undefined
  set__statement_tag(get__undefined());
  // 177: $str tree.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* tree */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__28_21;
}
static void entry__28_10(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // lines: 1
  // indent: 2
  // text: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] /* indent */ = create_future();
  frame->slots[3] /* text */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 189: ... line(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* line */;
  func = myself->type;
  frame->cont = cont__28_11;
}
static void cont__28_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 189: ... line(1)-INDENTATION_MARKER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = var._INDENTATION_MARKER;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__28_12;
}
static void cont__28_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 189: $indent 2*(line(1)-INDENTATION_MARKER)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__std__times();
  func = myself->type;
  frame->cont = cont__28_13;
}
static void cont__28_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* indent */, arguments->slots[0]);
  // 190: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__28_14;
}
static void cont__28_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 190: $text range(line 2 -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__28_15;
}
static void cont__28_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* text */, arguments->slots[0]);
  // 191: ... indentation_string(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* indent */;
  result_count = 1;
  myself = var._indentation_string;
  func = myself->type;
  frame->cont = cont__28_16;
}
static void cont__28_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 191: ... string(indentation_string(indent) text)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* text */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__28_17;
}
static void cont__28_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 191: put &lines string(indentation_string(indent) text)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__28_18;
}
static void cont__28_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__28_19(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 193: put &lines ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__28_20;
}
static void cont__28_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__28_7(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // lines: 1
  frame->slots[1] = myself->closure.frame->slots[4]; /* lines */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 188: length_of(line)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__28_8;
}
static void cont__28_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 188: length_of(line) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__28_9;
}
static void cont__28_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 188: ... :
  // 189:   $indent 2*(line(1)-INDENTATION_MARKER)
  // 190:   $text range(line 2 -1)
  // 191:   put &lines string(indentation_string(indent) text)
  frame->slots[4] /* temp__3 */ = create_closure(entry__28_10, 0);
  // 192: :
  // 193:   put &lines ""
  frame->slots[5] /* temp__4 */ = create_closure(entry__28_19, 0);
  // 187: if
  // 188:   length_of(line) > 1:
  // 189:     $indent 2*(line(1)-INDENTATION_MARKER)
  // 190:     $text range(line 2 -1)
  // 191:     put &lines string(indentation_string(indent) text)
  // 192:   :
  // 193:     put &lines ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__28_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* str */, arguments->slots[0]);
  // 180: idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__28_22;
}
static void cont__28_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 181: statement_tag == ALWAYS || previous_statement_tag != statement_tag
  frame->slots[9] /* temp__3 */ = create_closure(entry__28_23, 0);
  // 179: &&
  // 180:   idx > 1
  // 181:   statement_tag == ALWAYS || previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__28_29;
}
static void entry__28_23(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 181: statement_tag == ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__statement_tag();
  arguments->slots[1] = var._ALWAYS;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__28_24;
}
static void cont__28_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 181: ... previous_statement_tag != statement_tag
  frame->slots[3] /* temp__3 */ = create_closure(entry__28_25, 0);
  // 181: statement_tag == ALWAYS || previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__28_28;
}
static void entry__28_25(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 181: ... previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* previous_statement_tag */;
  arguments->slots[1] = get__statement_tag();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__28_26;
}
static void cont__28_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 181: ... previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__28_27;
}
static void cont__28_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 181: ... previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__28_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 181: statement_tag == ALWAYS || previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__28_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 178: if
  // 179:   &&
  // 180:     idx > 1
  // 181:     statement_tag == ALWAYS || previous_statement_tag != statement_tag
  // 182:   :
  // 183:     writeln
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__28_30;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__28_31;
}
static void entry__28_30(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 183: writeln
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__28_31(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 184: $$lines empty_list
  ((CELL *)frame->slots[4])->contents /* lines */ = get__empty_list();
  // 195: $$n length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__28_32;
}
static void cont__28_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* n */ = arguments->slots[0];
  // 196: ... : (i)
  // 197:   if str(i) == '@nl;':
  // 198:     add_line range(str i+1 n)
  // 199:     !n i-1
  frame->slots[7] /* temp__1 */ = create_closure(entry__28_33, 1);
  // 196: from_down_to n 1: (i)
  // 197:   if str(i) == '@nl;':
  // 198:     add_line range(str i+1 n)
  // 199:     !n i-1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* n */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__from_down_to();
  func = myself->type;
  frame->cont = cont__28_41;
}
static void entry__28_36(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // add_line: 0
  // str: 1
  // i: 2
  // n: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* add_line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  frame->slots[2] = myself->closure.frame->slots[0]; /* i */
  frame->slots[3] = myself->closure.frame->slots[3]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 198: ... i+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* i */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__28_37;
}
static void cont__28_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 198: ... range(str i+1 n)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = ((CELL *)frame->slots[3])->contents /* n */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__28_38;
}
static void cont__28_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 198: add_line range(str i+1 n)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = frame->slots[0] /* add_line */;
  func = myself->type;
  frame->cont = cont__28_39;
}
static void cont__28_39(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 199: !n i-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* i */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__28_40;
}
static void cont__28_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* n */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__28_33(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // i: 0
  // str: 1
  // add_line: 2
  // n: 3
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  frame->slots[2] = myself->closure.frame->slots[5]; /* add_line */
  frame->slots[3] = myself->closure.frame->slots[6]; /* n */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 197: ... str(i)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* i */;
  result_count = 1;
  myself = frame->slots[1] /* str */;
  func = myself->type;
  frame->cont = cont__28_34;
}
static void cont__28_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 197: ... str(i) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__28_35;
}
static void cont__28_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 197: ... :
  // 198:   add_line range(str i+1 n)
  // 199:   !n i-1
  frame->slots[6] /* temp__3 */ = create_closure(entry__28_36, 0);
  // 197: if str(i) == '@nl;':
  // 198:   add_line range(str i+1 n)
  // 199:   !n i-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__28_41(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 202: spaces(0)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__28_42;
}
static void cont__28_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 203: range(str 1 n)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* str */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = ((CELL *)frame->slots[6])->contents /* n */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__28_43;
}
static void cont__28_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 201: string
  // 202:   spaces(0) # add a zero indent for the first line of a tree
  // 203:   range(str 1 n)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__28_44;
}
static void cont__28_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 200: add_line
  // 201:   string
  // 202:     spaces(0) # add a zero indent for the first line of a tree
  // 203:     range(str 1 n)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = frame->slots[5] /* add_line */;
  func = myself->type;
  frame->cont = cont__28_45;
}
static void cont__28_45(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 204: for_each lines: (line) writeln line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* lines */;
  arguments->slots[1] = func__28_46;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__28_47(void) {
  myself = frame->slots[1] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__29_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // remark_lines: 0
  // indent: 1
  // buf: 2
  // indentation: 3
  frame->slots[2] /* buf */ = create_cell();
  frame->slots[3] /* indentation */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 207: $$buf "@nl;"
  ((CELL *)frame->slots[2])->contents /* buf */ = string__29_2;
  // 208: ... indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__29_3;
}
static void cont__29_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 208: $indentation spaces(indent+2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__29_4;
}
static void cont__29_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* indentation */, arguments->slots[0]);
  // 209: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__29_5;
}
static void cont__29_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 209: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__29_6;
}
static void cont__29_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 209: write_to &buf spaces(indent) '#' remark_lines(1)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = character__35;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__29_7;
}
static void cont__29_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 210: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__29_8;
}
static void cont__29_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 210: ... : (remark_line)
  // 211:   write_to &buf '@nl;' indentation remark_line
  frame->slots[5] /* temp__2 */ = create_closure(entry__29_9, 1);
  // 210: for_each_from_to remark_lines 2 -1: (remark_line)
  // 211:   write_to &buf '@nl;' indentation remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__for_each_from_to();
  func = myself->type;
  frame->cont = cont__29_11;
}
static void entry__29_9(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // remark_line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 211: write_to &buf '@nl;' indentation remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[2] /* indentation */;
  arguments->slots[3] = frame->slots[0] /* remark_line */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__29_10;
}
static void cont__29_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__29_11(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 212: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__30_48(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 253: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__30_49;
}
static void cont__30_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 253: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__30_50;
}
static void cont__30_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 253: ... string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  arguments->slots[3] = character__35;
  arguments->slots[4] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__30_51;
}
static void cont__30_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 253: -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__30_52(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // is_a_statement: 0
  // str: 1
  // remark_prefix: 2
  // remark_lines: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* is_a_statement */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  frame->slots[2] = myself->closure.frame->slots[3]; /* remark_prefix */
  frame->slots[3] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 257: -> string(str remark_prefix remark_lines(1))
  frame->slots[5] /* temp__2 */ = create_closure(entry__30_53, 0);
  // 258: ->
  // 259:   string
  // 260:     '@nl;'
  // 261:     spaces(expression_indent)
  // 262:     str
  // 263:     remark_prefix
  // 264:     remark_lines(1)
  frame->slots[6] /* temp__3 */ = create_closure(entry__30_56, 0);
  // 255: if
  // 256:   is_a_statement
  // 257:   -> string(str remark_prefix remark_lines(1))
  // 258:   ->
  // 259:     string
  // 260:       '@nl;'
  // 261:       spaces(expression_indent)
  // 262:       str
  // 263:       remark_prefix
  // 264:       remark_lines(1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* is_a_statement */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__30_60;
}
static void entry__30_53(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[3]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 257: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__30_54;
}
static void cont__30_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 257: ... string(str remark_prefix remark_lines(1))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_prefix */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__30_55;
}
static void cont__30_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 257: -> string(str remark_prefix remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__30_56(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[3]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 261: spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__30_57;
}
static void cont__30_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 264: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__30_58;
}
static void cont__30_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 259: string
  // 260:   '@nl;'
  // 261:   spaces(expression_indent)
  // 262:   str
  // 263:   remark_prefix
  // 264:   remark_lines(1)
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[0] /* str */;
  arguments->slots[3] = frame->slots[1] /* remark_prefix */;
  arguments->slots[4] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__30_59;
}
static void cont__30_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 258: ->
  // 259:   string
  // 260:     '@nl;'
  // 261:     spaces(expression_indent)
  // 262:     str
  // 263:     remark_prefix
  // 264:     remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__30_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 254: ->
  // 255:   if
  // 256:     is_a_statement
  // 257:     -> string(str remark_prefix remark_lines(1))
  // 258:     ->
  // 259:       string
  // 260:         '@nl;'
  // 261:         spaces(expression_indent)
  // 262:         str
  // 263:         remark_prefix
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__30_45(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  // is_a_statement: 2
  // remark_prefix: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[3]; /* is_a_statement */
  frame->slots[3] = myself->closure.frame->slots[1]; /* remark_prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 252: str == ":"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__30_46;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__30_47;
}
static void cont__30_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 253: -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  frame->slots[5] /* temp__2 */ = create_closure(entry__30_48, 0);
  // 254: ->
  // 255:   if
  // 256:     is_a_statement
  // 257:     -> string(str remark_prefix remark_lines(1))
  // 258:     ->
  // 259:       string
  // 260:         '@nl;'
  // 261:         spaces(expression_indent)
  // 262:         str
  // 263:         remark_prefix
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__30_52, 0);
  // 251: if
  // 252:   str == ":"
  // 253:   -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 254:   ->
  // 255:     if
  // 256:       is_a_statement
  // 257:       -> string(str remark_prefix remark_lines(1))
  // 258:       ->
  // 259:         string
  // 260:           '@nl;'
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__30_61(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 265: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__30_62;
}
static void cont__30_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 265: ... string(str remark_prefix remark_lines(1))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_prefix */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__30_63;
}
static void cont__30_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 265: -> string(str remark_prefix remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__30_20(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // str: 0
  // is_a_statement: 1
  // remark_lines: 2
  // indent: 3
  // buf: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* is_a_statement */
  frame->slots[2] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[3] /* indent */ = create_cell();
  frame->slots[4] /* buf */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 239: $$indent expression_indent
  ((CELL *)frame->slots[3])->contents /* indent */ = get__expression_indent();
  // 240: $$buf str
  ((CELL *)frame->slots[4])->contents /* buf */ = frame->slots[0] /* str */;
  // 241: ... str != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__30_21;
}
static void cont__30_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 241: ... str != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__30_22;
}
static void cont__30_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 241: ... str != ":"
  frame->slots[8] /* temp__4 */ = create_closure(entry__30_23, 0);
  // 241: ... str != "" && str != ":"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__30_27;
}
static void entry__30_23(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 241: ... str != ":"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__30_24;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__30_25;
}
static void cont__30_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 241: ... str != ":"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__30_26;
}
static void cont__30_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 241: ... str != ":"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__30_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 241: ... :
  // 242:   unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  // 243:   plus &indent 2
  frame->slots[9] /* temp__5 */ = create_closure(entry__30_28, 0);
  // 241: if str != "" && str != ":":
  // 242:   unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  // 243:   plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__30_34;
}
static void entry__30_28(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // is_a_statement: 0
  // buf: 1
  // str: 2
  // indent: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* is_a_statement */
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  frame->slots[3] = myself->closure.frame->slots[3]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 242: ... : !buf string('@nl;' spaces(expression_indent) str)
  frame->slots[4] /* temp__1 */ = create_closure(entry__30_29, 0);
  // 242: unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* is_a_statement */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__30_32;
}
static void entry__30_29(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 242: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__30_30;
}
static void cont__30_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 242: ... !buf string('@nl;' spaces(expression_indent) str)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__30_31;
}
static void cont__30_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__30_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 243: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__30_33;
}
static void cont__30_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__30_34(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 244: ... line_start_remark_to_string(remark_lines indent)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* remark_lines */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* indent */;
  result_count = 1;
  myself = var._line_start_remark_to_string;
  func = myself->type;
  frame->cont = cont__30_35;
}
static void cont__30_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 244: ... append(buf line_start_remark_to_string(remark_lines indent))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__30_36;
}
static void cont__30_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 244: -> append(buf line_start_remark_to_string(remark_lines indent))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__30_37(void) {
  allocate_initialized_frame_gc(4, 13);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  // is_a_statement: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[3]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[3] = myself->closure.frame->slots[2]; /* is_a_statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 248: length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__30_38;
}
static void cont__30_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 248: ... length_of(remark_prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__30_39;
}
static void cont__30_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__5 */ = arguments->slots[0];
  // 248: length_of(str)+length_of(remark_prefix)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__30_40;
}
static void cont__30_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 248: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__30_41;
}
static void cont__30_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__7 */ = arguments->slots[0];
  // 248: ... length_of(remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__7 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__30_42;
}
static void cont__30_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__6 */ = arguments->slots[0];
  // 248: length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = frame->slots[9] /* temp__6 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__30_43;
}
static void cont__30_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 247: >
  // 248:   length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  // 249:   line_end_expression_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__30_44;
}
static void cont__30_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 250: :
  // 251:   if
  // 252:     str == ":"
  // 253:     -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 254:     ->
  // 255:       if
  // 256:         is_a_statement
  // 257:         -> string(str remark_prefix remark_lines(1))
  // 258:         ->
  // 259:           string
  // ...
  frame->slots[11] /* temp__8 */ = create_closure(entry__30_45, 0);
  // 265: -> string(str remark_prefix remark_lines(1))
  frame->slots[12] /* temp__9 */ = create_closure(entry__30_61, 0);
  // 246: if
  // 247:   >
  // 248:     length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  // 249:     line_end_expression_width
  // 250:   :
  // 251:     if
  // 252:       str == ":"
  // 253:       -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 254:       ->
  // 255:         if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__8 */;
  arguments->slots[2] = frame->slots[12] /* temp__9 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__30_1(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  // is_a_statement: 2
  // remark_prefix: 3
  frame->slots[3] /* remark_prefix */ = create_future();
  if (argument_count < 2) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[2] /* is_a_statement */ = arguments->slots[2];
    case 2:;
  }
  switch(argument_count) {
    case 2: frame->slots[2] /* is_a_statement */ = get__false();
  }
  // 227: ... str == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__30_2;
}
static void cont__30_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 227: $remark_prefix if(str == "" (-> "#") -> " #")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = func__30_3;
  arguments->slots[2] = func__30_5;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__30_7;
}
static void entry__30_3(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 227: ... -> "#"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__30_4;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__30_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 227: ... -> " #"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__30_6;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__30_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* remark_prefix */, arguments->slots[0]);
  // 230: length_of(remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__30_8;
}
static void cont__30_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 230: length_of(remark_lines) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__30_9;
}
static void cont__30_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 231: >
  // 232:   +
  // 233:     expression_indent
  // 234:     length_of(str)
  // 235:     length_of(remark_prefix)
  // 236:     length_of(remark_lines(1))
  // 237:   line_width
  frame->slots[7] /* temp__4 */ = create_closure(entry__30_10, 0);
  // 229: ||
  // 230:   length_of(remark_lines) > 1
  // 231:   >
  // 232:     +
  // 233:       expression_indent
  // 234:       length_of(str)
  // 235:       length_of(remark_prefix)
  // 236:       length_of(remark_lines(1))
  // 237:     line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__30_19;
}
static void entry__30_10(void) {
  allocate_initialized_frame_gc(3, 11);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[3]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 234: length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__30_11;
}
static void cont__30_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__30_12;
}
static void cont__30_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 235: length_of(remark_prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__30_13;
}
static void cont__30_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__6 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  arguments->slots[1] = frame->slots[8] /* temp__6 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__30_14;
}
static void cont__30_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 236: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__30_15;
}
static void cont__30_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__8 */ = arguments->slots[0];
  // 236: length_of(remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__8 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__30_16;
}
static void cont__30_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__7 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[9] /* temp__7 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__30_17;
}
static void cont__30_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 231: >
  // 232:   +
  // 233:     expression_indent
  // 234:     length_of(str)
  // 235:     length_of(remark_prefix)
  // 236:     length_of(remark_lines(1))
  // 237:   line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__30_18;
}
static void cont__30_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 231: >
  // 232:   +
  // 233:     expression_indent
  // 234:     length_of(str)
  // 235:     length_of(remark_prefix)
  // 236:     length_of(remark_lines(1))
  // 237:   line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__30_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 238: :
  // 239:   $$indent expression_indent
  // 240:   $$buf str
  // 241:   if str != "" && str != ":":
  // 242:     unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  // 243:     plus &indent 2
  // 244:   -> append(buf line_start_remark_to_string(remark_lines indent))
  frame->slots[8] /* temp__5 */ = create_closure(entry__30_20, 0);
  // 245: : # special line-end form
  // 246:   if
  // 247:     >
  // 248:       length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  // 249:       line_end_expression_width
  // 250:     :
  // 251:       if
  // 252:         str == ":"
  // 253:         -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 254:         ->
  // ...
  frame->slots[9] /* temp__6 */ = create_closure(entry__30_37, 0);
  // 228: if
  // 229:   ||
  // 230:     length_of(remark_lines) > 1
  // 231:     >
  // 232:       +
  // 233:         expression_indent
  // 234:         length_of(str)
  // 235:         length_of(remark_prefix)
  // 236:         length_of(remark_lines(1))
  // 237:       line_width
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  arguments->slots[2] = frame->slots[9] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__31_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 269: ... -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_5(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 269: ... add_remark_lines(str remark_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__31_6;
}
static void cont__31_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 269: ... -> add_remark_lines(str remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__31_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // self: 0
  // str: 1
  // remark_lines: 2
  frame->slots[2] /* remark_lines */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 268: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__31_2;
}
static void cont__31_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* remark_lines */, arguments->slots[0]);
  // 269: ... remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__31_3;
}
static void cont__31_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 269: ... -> str
  frame->slots[4] /* temp__2 */ = create_closure(entry__31_4, 0);
  // 269: ... -> add_remark_lines(str remark_lines)
  frame->slots[5] /* temp__3 */ = create_closure(entry__31_5, 0);
  // 269: if remark_lines.is_empty (-> str) -> add_remark_lines(str remark_lines)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__32_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 273: ... -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__32_5(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 273: ... add_remark_lines(str remark_lines true)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__32_6;
}
static void cont__32_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 273: ... -> add_remark_lines(str remark_lines true)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__32_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // self: 0
  // str: 1
  // remark_lines: 2
  frame->slots[2] /* remark_lines */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 272: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__32_2;
}
static void cont__32_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* remark_lines */, arguments->slots[0]);
  // 273: ... remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__32_3;
}
static void cont__32_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 273: ... -> str
  frame->slots[4] /* temp__2 */ = create_closure(entry__32_4, 0);
  // 273: ... -> add_remark_lines(str remark_lines true)
  frame->slots[5] /* temp__3 */ = create_closure(entry__32_5, 0);
  // 273: if remark_lines.is_empty (-> str) -> add_remark_lines(str remark_lines true)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__33_2(void) {
  allocate_initialized_frame_gc(4, 4);
  // slot allocations:
  // return__1: 0
  // indent: 1
  // self: 2
  // str: 3
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[1]; /* str */
  define__expression_indent(create_future());
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 278: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__33_3;
}
static void cont__33_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 279: add_remark self str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  arguments->slots[1] = frame->slots[3] /* str */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame->cont = cont__33_4;
}
static void cont__33_4(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__33_1(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // self: 0
  // str: 1
  // indent: 2
  // _define $indent expression_indent
  frame->slots[2] /* indent */ = get__expression_indent();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 277: ... :
  // 278:   %expression_indent indent+2
  // 279:   add_remark self str
  frame->slots[3] /* temp__1 */ = create_closure(entry__33_2, 0);
  // 277: do:
  // 278:   %expression_indent indent+2
  // 279:   add_remark self str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__34_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 284: ... -> "<???>"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__34_2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__35_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 290: !statement_tag REQUIRE
  set__statement_tag(var._REQUIRE);
  // 291: ... node::filename_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filename_of();
  func = myself->type;
  frame->cont = cont__35_2;
}
static void cont__35_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 291: ... "<require @(node::filename_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__35_3;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = string__35_4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__35_5;
}
static void cont__35_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 291: ... add_statement_remark(self "<require @(node::filename_of(self))>")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._add_statement_remark;
  func = myself->type;
  frame->cont = cont__35_6;
}
static void cont__35_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 291: -> add_statement_remark(self "<require @(node::filename_of(self))>")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__36_1(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 294: !statement_tag NAMESPACE
  set__statement_tag(var._NAMESPACE);
  // 299: namespace_alias_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_alias_of();
  func = myself->type;
  frame->cont = cont__36_2;
}
static void cont__36_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 299: namespace_alias_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__36_3;
}
static void cont__36_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 300: -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  frame->slots[5] /* temp__5 */ = create_closure(entry__36_4, 0);
  // 301: -> "<namespace @(namespace_of(self))>"
  frame->slots[6] /* temp__6 */ = create_closure(entry__36_11, 0);
  // 298: if
  // 299:   namespace_alias_of(self).is_defined
  // 300:   -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  // 301:   -> "<namespace @(namespace_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  arguments->slots[2] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__36_16;
}
static void entry__36_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 300: ... namespace_alias_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_alias_of();
  func = myself->type;
  frame->cont = cont__36_5;
}
static void cont__36_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 300: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__36_6;
}
static void cont__36_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 300: ... "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__36_7;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__36_8;
  arguments->slots[3] = frame->slots[3] /* temp__3 */;
  arguments->slots[4] = string__36_9;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__36_10;
}
static void cont__36_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 300: -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__36_11(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 301: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__36_12;
}
static void cont__36_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 301: ... "<namespace @(namespace_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__36_13;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__36_14;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__36_15;
}
static void cont__36_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 301: -> "<namespace @(namespace_of(self))>"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__36_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 296: add_remark
  // 297:   self
  // 298:   if
  // 299:     namespace_alias_of(self).is_defined
  // 300:     -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  // 301:     -> "<namespace @(namespace_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._add_remark;
  func = myself->type;
  frame->cont = cont__36_17;
}
static void cont__36_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 295: ->
  // 296:   add_remark
  // 297:     self
  // 298:     if
  // 299:       namespace_alias_of(self).is_defined
  // 300:       -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  // 301:       -> "<namespace @(namespace_of(self))>"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__37_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 304: !statement_tag USING
  set__statement_tag(var._USING);
  // 305: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__37_2;
}
static void cont__37_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 305: ... "<using @(namespace_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__37_3;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = string__37_4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__37_5;
}
static void cont__37_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 305: ... add_statement_remark(self "<using @(namespace_of(self))>")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._add_statement_remark;
  func = myself->type;
  frame->cont = cont__37_6;
}
static void cont__37_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 305: -> add_statement_remark(self "<using @(namespace_of(self))>")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__38_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 308: !statement_tag INCLUDE
  set__statement_tag(var._INCLUDE);
  // 309: ... node::filename_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filename_of();
  func = myself->type;
  frame->cont = cont__38_2;
}
static void cont__38_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 309: ... "<include @(node::filename_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__38_3;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = string__38_4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__38_5;
}
static void cont__38_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 309: ... add_statement_remark(self "<include @(node::filename_of(self))>")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._add_statement_remark;
  func = myself->type;
  frame->cont = cont__38_6;
}
static void cont__38_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 309: -> add_statement_remark(self "<include @(node::filename_of(self))>")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__39_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 312: !statement_tag LINK
  set__statement_tag(var._LINK);
  // 313: ... node::filename_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filename_of();
  func = myself->type;
  frame->cont = cont__39_2;
}
static void cont__39_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 313: ... "<link @(node::filename_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__39_3;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = string__39_4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__39_5;
}
static void cont__39_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 313: ... add_statement_remark(self "<link @(node::filename_of(self))>")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._add_statement_remark;
  func = myself->type;
  frame->cont = cont__39_6;
}
static void cont__39_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 313: -> add_statement_remark(self "<link @(node::filename_of(self))>")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__40_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 316: !statement_tag DATA
  set__statement_tag(var._DATA);
  // 317: ... node::filemask_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filemask_of();
  func = myself->type;
  frame->cont = cont__40_2;
}
static void cont__40_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 317: ... "<data @(node::filemask_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__40_3;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = string__40_4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__40_5;
}
static void cont__40_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 317: ... add_statement_remark(self "<data @(node::filemask_of(self))>")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = var._add_statement_remark;
  func = myself->type;
  frame->cont = cont__40_6;
}
static void cont__40_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 317: -> add_statement_remark(self "<data @(node::filemask_of(self))>")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // remark_lines: 1
  // buf: 2
  frame->slots[1] /* remark_lines */ = create_future();
  frame->slots[2] /* buf */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 323: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__41_2;
}
static void cont__41_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* remark_lines */, arguments->slots[0]);
  // 326: -> remark_lines(1) .has_prefix. '!' -> SHEBANG
  frame->slots[3] /* temp__1 */ = create_closure(entry__41_3, 0);
  // 327: ->
  // 328:   &&
  // 329:     remark_lines(1) != ""
  // 330:     remark_lines(1)(1) != ' '
  // 331:     remark_lines(1)(1) != '#'
  // 332:   -> CODE_EXCLUSION
  frame->slots[4] /* temp__2 */ = create_closure(entry__41_7, 0);
  // 333: -> length_of(remark_lines) == 1 -> REMARK
  frame->slots[5] /* temp__3 */ = create_closure(entry__41_24, 0);
  // 324: !statement_tag
  // 325:   cond
  // 326:     -> remark_lines(1) .has_prefix. '!' -> SHEBANG
  // 327:     ->
  // 328:       &&
  // 329:         remark_lines(1) != ""
  // 330:         remark_lines(1)(1) != ' '
  // 331:         remark_lines(1)(1) != '#'
  // 332:       -> CODE_EXCLUSION
  // 333:     -> length_of(remark_lines) == 1 -> REMARK
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  arguments->slots[3] = func__41_28;
  result_count = 1;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__41_30;
}
static void entry__41_29(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 334: ... -> ALWAYS
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._ALWAYS;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_27(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 333: ... -> REMARK
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._REMARK;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_23(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 332: -> CODE_EXCLUSION
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._CODE_EXCLUSION;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_6(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 326: ... -> SHEBANG
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._SHEBANG;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 326: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__41_4;
}
static void cont__41_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 326: ... remark_lines(1) .has_prefix. '!'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__33;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__41_5;
}
static void cont__41_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 326: -> remark_lines(1) .has_prefix. '!' -> SHEBANG
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__41_6;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_7(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 329: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__41_8;
}
static void cont__41_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 329: remark_lines(1) != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__41_9;
}
static void cont__41_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 329: remark_lines(1) != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__41_10;
}
static void cont__41_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__5 */ = create_closure(entry__41_11, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__41_22;
}
static void entry__41_11(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 330: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__41_12;
}
static void cont__41_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 330: remark_lines(1)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[5] /* temp__5 */;
  func = myself->type;
  frame->cont = cont__41_13;
}
static void cont__41_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 330: remark_lines(1)(1) != ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__41_14;
}
static void cont__41_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 330: remark_lines(1)(1) != ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__41_15;
}
static void cont__41_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 331: remark_lines(1)(1) != '#'
  frame->slots[6] /* temp__6 */ = create_closure(entry__41_16, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__41_21;
}
static void entry__41_16(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 331: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__41_17;
}
static void cont__41_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 331: remark_lines(1)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__4 */;
  func = myself->type;
  frame->cont = cont__41_18;
}
static void cont__41_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 331: remark_lines(1)(1) != '#'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__35;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__41_19;
}
static void cont__41_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 331: remark_lines(1)(1) != '#'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__41_20;
}
static void cont__41_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 331: remark_lines(1)(1) != '#'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__41_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__41_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 327: ->
  // 328:   &&
  // 329:     remark_lines(1) != ""
  // 330:     remark_lines(1)(1) != ' '
  // 331:     remark_lines(1)(1) != '#'
  // 332:   -> CODE_EXCLUSION
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__41_23;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_24(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 333: ... length_of(remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__41_25;
}
static void cont__41_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 333: ... length_of(remark_lines) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__41_26;
}
static void cont__41_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 333: -> length_of(remark_lines) == 1 -> REMARK
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__41_27;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_28(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 334: -> true -> ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = func__41_29;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__41_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__statement_tag(arguments->slots[0]);
  // 335: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__41_31;
}
static void cont__41_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 335: $$buf string('#' remark_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__35;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__41_32;
}
static void cont__41_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 336: ... length_of(remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__41_33;
}
static void cont__41_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 336: ... length_of(remark_lines) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__41_34;
}
static void cont__41_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 336: ... :
  // 337:   $indent expression_indent+2
  // 338:   for_each_from_to remark_lines 2 -1: (line)
  // 339:     push &buf '@nl;'
  // 340:     if line != "": write_to &buf spaces(indent) line
  frame->slots[5] /* temp__3 */ = create_closure(entry__41_35, 0);
  // 336: if length_of(remark_lines) > 1:
  // 337:   $indent expression_indent+2
  // 338:   for_each_from_to remark_lines 2 -1: (line)
  // 339:     push &buf '@nl;'
  // 340:     if line != "": write_to &buf spaces(indent) line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__41_45;
}
static void entry__41_42(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // buf: 0
  // indent: 1
  // line: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 340: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__41_43;
}
static void cont__41_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 340: ... write_to &buf spaces(indent) line
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[2] /* line */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__41_44;
}
static void cont__41_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__41_38(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // line: 0
  // buf: 1
  // indent: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 339: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__41_39;
}
static void cont__41_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 340: ... line != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__41_40;
}
static void cont__41_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 340: ... line != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__41_41;
}
static void cont__41_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 340: ... : write_to &buf spaces(indent) line
  frame->slots[5] /* temp__3 */ = create_closure(entry__41_42, 0);
  // 340: if line != "": write_to &buf spaces(indent) line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__41_35(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // remark_lines: 0
  // buf: 1
  // indent: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[2] /* indent */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 337: $indent expression_indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__41_36;
}
static void cont__41_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* indent */, arguments->slots[0]);
  // 338: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__41_37;
}
static void cont__41_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 338: ... : (line)
  // 339:   push &buf '@nl;'
  // 340:   if line != "": write_to &buf spaces(indent) line
  frame->slots[4] /* temp__2 */ = create_closure(entry__41_38, 1);
  // 338: for_each_from_to remark_lines 2 -1: (line)
  // 339:   push &buf '@nl;'
  // 340:   if line != "": write_to &buf spaces(indent) line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  arguments->slots[3] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_from_to();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__41_45(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 341: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_24(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // indent: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 361: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__42_25;
}
static void cont__42_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 361: ... string('@nl;' spaces(indent) str)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__42_26;
}
static void cont__42_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 361: -> string('@nl;' spaces(indent) str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_27(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 362: -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_16(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // self: 0
  // indent: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] /* str */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 358: ... statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__42_17;
}
static void cont__42_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 358: ... statements_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__2 */;
  func = myself->type;
  frame->cont = cont__42_18;
}
static void cont__42_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 358: $str statements_of(self)(1).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__42_19;
}
static void cont__42_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* str */, arguments->slots[0]);
  // 360: line_end_expression_width == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_20;
}
static void cont__42_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 360: ... str .contains. '@nl;'
  frame->slots[5] /* temp__3 */ = create_closure(entry__42_21, 0);
  // 360: line_end_expression_width == 0 && str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__42_23;
}
static void entry__42_21(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 360: ... str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__42_22;
}
static void cont__42_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 360: ... str .contains. '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 361: -> string('@nl;' spaces(indent) str)
  frame->slots[6] /* temp__4 */ = create_closure(entry__42_24, 0);
  // 362: -> str
  frame->slots[7] /* temp__5 */ = create_closure(entry__42_27, 0);
  // 359: if
  // 360:   line_end_expression_width == 0 && str .contains. '@nl;'
  // 361:   -> string('@nl;' spaces(indent) str)
  // 362:   -> str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_28(void) {
  allocate_initialized_frame_gc(4, 13);
  // slot allocations:
  // indent: 0
  // parameters: 1
  // remark_lines: 2
  // self: 3
  // buf: 4
  // check_for_line_end_expression: 5
  // handle_simple_parameters: 6
  // handle_complex_parameters: 7
  // outer_line_end_expression_width: 8
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[3]; /* parameters */
  frame->slots[2] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[3] = myself->closure.frame->slots[0]; /* self */
  frame->slots[5] /* check_for_line_end_expression */ = create_future();
  frame->slots[6] /* handle_simple_parameters */ = create_future();
  frame->slots[7] /* handle_complex_parameters */ = create_future();
  frame->slots[4] /* buf */ = create_cell();
  // _define $outer_line_end_expression_width line_end_expression_width
  frame->slots[8] /* outer_line_end_expression_width */ = get__line_end_expression_width();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 366: ... :
  // 367:   if
  // 368:     line_end_expression_width > 0:
  // 369:       !buf ":"
  // 370:     :
  // 371:       !buf string("@nl;" spaces(indent) ':')
  // 372:       plus &indent 2
  frame->slots[9] /* temp__1 */ = create_closure(entry__42_29, 0);
  // 366: $check_for_line_end_expression:
  // 367:   if
  // 368:     line_end_expression_width > 0:
  // 369:       !buf ":"
  // 370:     :
  // 371:       !buf string("@nl;" spaces(indent) ':')
  // 372:       plus &indent 2
  initialize_future(frame->slots[5] /* check_for_line_end_expression */, frame->slots[9] /* temp__1 */);
  // 374: ... :
  // 375:   $$parameter_text ": ("
  // 376:   for_each
  // 377:     parameters: (parameter)
  // 378:       append &parameter_text parameter.to_string
  // 379:     :
  // 380:       push &parameter_text ' '
  // 381:   push &parameter_text ')'
  // 382:   unless remark_lines.is_empty:
  // 383:     add_remark_lines &parameter_text remark_lines true
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__42_38, 0);
  // 374: $handle_simple_parameters:
  // 375:   $$parameter_text ": ("
  // 376:   for_each
  // 377:     parameters: (parameter)
  // 378:       append &parameter_text parameter.to_string
  // 379:     :
  // 380:       push &parameter_text ' '
  // 381:   push &parameter_text ')'
  // 382:   unless remark_lines.is_empty:
  // 383:     add_remark_lines &parameter_text remark_lines true
  // ...
  initialize_future(frame->slots[6] /* handle_simple_parameters */, frame->slots[9] /* temp__1 */);
  // 396: ... :
  // 397:   check_for_line_end_expression
  // 398:   $parameter_indentation spaces(indent+2)
  // 399:   unless remark_lines.is_empty: add_remark_lines &buf remark_lines
  // 400:   push &buf '@nl;'
  // 401:   write_to &buf spaces(indent) "("
  // 402:   for_each parameters: ($parameter)
  // 403:     to_string &parameter
  // 404:     if
  // 405:       parameter(1) == '@nl;':
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__42_65, 0);
  // 396: $handle_complex_parameters:
  // 397:   check_for_line_end_expression
  // 398:   $parameter_indentation spaces(indent+2)
  // 399:   unless remark_lines.is_empty: add_remark_lines &buf remark_lines
  // 400:   push &buf '@nl;'
  // 401:   write_to &buf spaces(indent) "("
  // 402:   for_each parameters: ($parameter)
  // 403:     to_string &parameter
  // 404:     if
  // 405:       parameter(1) == '@nl;':
  // ...
  initialize_future(frame->slots[7] /* handle_complex_parameters */, frame->slots[9] /* temp__1 */);
  // 364: $$buf undefined
  ((CELL *)frame->slots[4])->contents /* buf */ = get__undefined();
  // 412: length_of(parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* parameters */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_88;
}
static void entry__42_59(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // buf: 0
  // indent: 1
  // parameter_text: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* parameter_text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 391: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__42_60;
}
static void cont__42_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 391: !buf string("@nl;" spaces(indent) parameter_text)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__42_61;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[2])->contents /* parameter_text */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__42_62;
}
static void cont__42_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 392: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__42_63;
}
static void cont__42_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_64(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // handle_complex_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* handle_complex_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 394: handle_complex_parameters
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* handle_complex_parameters */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_54(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // parameter_text: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* parameter_text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 387: !buf parameter_text
  ((CELL *)frame->slots[0])->contents /* buf */ = ((CELL *)frame->slots[1])->contents /* parameter_text */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_55(void) {
  allocate_initialized_frame_gc(5, 10);
  // slot allocations:
  // indent: 0
  // parameter_text_length: 1
  // buf: 2
  // parameter_text: 3
  // handle_complex_parameters: 4
  frame->slots[0] = myself->closure.frame->slots[3]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[6]; /* parameter_text_length */
  frame->slots[2] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[5]; /* parameter_text */
  frame->slots[4] = myself->closure.frame->slots[4]; /* handle_complex_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 390: indent+parameter_text_length
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  arguments->slots[1] = frame->slots[1] /* parameter_text_length */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__42_56;
}
static void cont__42_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 390: indent+parameter_text_length <= line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__42_57;
}
static void cont__42_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 390: indent+parameter_text_length <= line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__42_58;
}
static void cont__42_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 390: ... :
  // 391:   !buf string("@nl;" spaces(indent) parameter_text)
  // 392:   plus &indent 2
  frame->slots[8] /* temp__4 */ = create_closure(entry__42_59, 0);
  // 393: :
  // 394:   handle_complex_parameters
  frame->slots[9] /* temp__5 */ = create_closure(entry__42_64, 0);
  // 389: if
  // 390:   indent+parameter_text_length <= line_width:
  // 391:     !buf string("@nl;" spaces(indent) parameter_text)
  // 392:     plus &indent 2
  // 393:   :
  // 394:     handle_complex_parameters
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  arguments->slots[2] = frame->slots[9] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_31(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 369: !buf ":"
  ((CELL *)frame->slots[0])->contents /* buf */ = string__42_32;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_33(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 371: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__42_34;
}
static void cont__42_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 371: !buf string("@nl;" spaces(indent) ':')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__42_35;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = character__58;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__42_36;
}
static void cont__42_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 372: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__42_37;
}
static void cont__42_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_29(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // buf: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 368: line_end_expression_width > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = get__line_end_expression_width();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__42_30;
}
static void cont__42_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 368: ... :
  // 369:   !buf ":"
  frame->slots[3] /* temp__2 */ = create_closure(entry__42_31, 0);
  // 370: :
  // 371:   !buf string("@nl;" spaces(indent) ':')
  // 372:   plus &indent 2
  frame->slots[4] /* temp__3 */ = create_closure(entry__42_33, 0);
  // 367: if
  // 368:   line_end_expression_width > 0:
  // 369:     !buf ":"
  // 370:   :
  // 371:     !buf string("@nl;" spaces(indent) ':')
  // 372:     plus &indent 2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_38(void) {
  allocate_initialized_frame_gc(5, 11);
  // slot allocations:
  // parameters: 0
  // remark_lines: 1
  // buf: 2
  // indent: 3
  // handle_complex_parameters: 4
  // parameter_text: 5
  // parameter_text_length: 6
  frame->slots[0] = myself->closure.frame->slots[1]; /* parameters */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[4] = myself->closure.frame->slots[7]; /* handle_complex_parameters */
  frame->slots[5] /* parameter_text */ = create_cell();
  frame->slots[6] /* parameter_text_length */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 375: $$parameter_text ": ("
  ((CELL *)frame->slots[5])->contents /* parameter_text */ = string__42_39;
  // 377: ... : (parameter)
  // 378:   append &parameter_text parameter.to_string
  frame->slots[7] /* temp__1 */ = create_closure(entry__42_40, 1);
  // 379: :
  // 380:   push &parameter_text ' '
  frame->slots[8] /* temp__2 */ = create_closure(entry__42_43, 0);
  // 376: for_each
  // 377:   parameters: (parameter)
  // 378:     append &parameter_text parameter.to_string
  // 379:   :
  // 380:     push &parameter_text ' '
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__42_45;
}
static void entry__42_40(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // parameter: 0
  // parameter_text: 1
  frame->slots[1] = myself->closure.frame->slots[5]; /* parameter_text */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 378: ... parameter.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__42_41;
}
static void cont__42_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 378: append &parameter_text parameter.to_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* parameter_text */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__42_42;
}
static void cont__42_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* parameter_text */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_43(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // parameter_text: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* parameter_text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 380: push &parameter_text ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* parameter_text */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__42_44;
}
static void cont__42_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* parameter_text */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_45(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 381: push &parameter_text ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* parameter_text */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__42_46;
}
static void cont__42_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* parameter_text */ = arguments->slots[0];
  // 382: ... remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__42_47;
}
static void cont__42_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 382: ... :
  // 383:   add_remark_lines &parameter_text remark_lines true
  frame->slots[8] /* temp__2 */ = create_closure(entry__42_48, 0);
  // 382: unless remark_lines.is_empty:
  // 383:   add_remark_lines &parameter_text remark_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__42_50;
}
static void entry__42_48(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // parameter_text: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* parameter_text */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 383: add_remark_lines &parameter_text remark_lines true
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* parameter_text */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__42_49;
}
static void cont__42_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* parameter_text */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_50(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 384: $parameter_text_length length_of(parameter_text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* parameter_text */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_51;
}
static void cont__42_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* parameter_text_length */, arguments->slots[0]);
  // 386: parameter_text_length <= line_end_expression_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = frame->slots[6] /* parameter_text_length */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__42_52;
}
static void cont__42_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 386: parameter_text_length <= line_end_expression_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__42_53;
}
static void cont__42_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 386: ... :
  // 387:   !buf parameter_text
  frame->slots[9] /* temp__3 */ = create_closure(entry__42_54, 0);
  // 388: :
  // 389:   if
  // 390:     indent+parameter_text_length <= line_width:
  // 391:       !buf string("@nl;" spaces(indent) parameter_text)
  // 392:       plus &indent 2
  // 393:     :
  // 394:       handle_complex_parameters
  frame->slots[10] /* temp__4 */ = create_closure(entry__42_55, 0);
  // 385: if
  // 386:   parameter_text_length <= line_end_expression_width:
  // 387:     !buf parameter_text
  // 388:   :
  // 389:     if
  // 390:       indent+parameter_text_length <= line_width:
  // 391:         !buf string("@nl;" spaces(indent) parameter_text)
  // 392:         plus &indent 2
  // 393:       :
  // 394:         handle_complex_parameters
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_65(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // check_for_line_end_expression: 0
  // indent: 1
  // remark_lines: 2
  // buf: 3
  // parameters: 4
  // parameter_indentation: 5
  frame->slots[0] = myself->closure.frame->slots[5]; /* check_for_line_end_expression */
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[3] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[4] = myself->closure.frame->slots[1]; /* parameters */
  frame->slots[5] /* parameter_indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 397: check_for_line_end_expression
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* check_for_line_end_expression */;
  func = myself->type;
  frame->cont = cont__42_66;
}
static void cont__42_66(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 398: ... indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__42_67;
}
static void cont__42_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 398: $parameter_indentation spaces(indent+2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__42_68;
}
static void cont__42_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* parameter_indentation */, arguments->slots[0]);
  // 399: ... remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__42_69;
}
static void cont__42_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 399: ... : add_remark_lines &buf remark_lines
  frame->slots[7] /* temp__2 */ = create_closure(entry__42_70, 0);
  // 399: unless remark_lines.is_empty: add_remark_lines &buf remark_lines
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__42_72;
}
static void entry__42_70(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 399: ... add_remark_lines &buf remark_lines
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__42_71;
}
static void cont__42_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_72(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 400: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__42_73;
}
static void cont__42_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* buf */ = arguments->slots[0];
  // 401: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__42_74;
}
static void cont__42_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 401: write_to &buf spaces(indent) "("
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* buf */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = string__42_75;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__42_76;
}
static void cont__42_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* buf */ = arguments->slots[0];
  // 402: ... : ($parameter)
  // 403:   to_string &parameter
  // 404:   if
  // 405:     parameter(1) == '@nl;':
  // 406:       append &buf parameter
  // 407:     :
  // 408:       write_to &buf '@nl;' parameter_indentation parameter
  frame->slots[6] /* temp__1 */ = create_closure(entry__42_77, 1);
  // 402: for_each parameters: ($parameter)
  // 403:   to_string &parameter
  // 404:   if
  // 405:     parameter(1) == '@nl;':
  // 406:       append &buf parameter
  // 407:     :
  // 408:       write_to &buf '@nl;' parameter_indentation parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* parameters */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__42_85;
}
static void entry__42_81(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 406: append &buf parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* parameter */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__42_82;
}
static void cont__42_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_83(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // buf: 0
  // parameter_indentation: 1
  // parameter: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* parameter_indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 408: write_to &buf '@nl;' parameter_indentation parameter
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[1] /* parameter_indentation */;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* parameter */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__42_84;
}
static void cont__42_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_77(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // parameter: 0
  // buf: 1
  // parameter_indentation: 2
  frame->slots[1] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[5]; /* parameter_indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* parameter */ = create_cell_with_contents(arguments->slots[0]);
  // 403: to_string &parameter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* parameter */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__42_78;
}
static void cont__42_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* parameter */ = arguments->slots[0];
  // 405: parameter(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* parameter */;
  func = myself->type;
  frame->cont = cont__42_79;
}
static void cont__42_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 405: parameter(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_80;
}
static void cont__42_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 405: ... :
  // 406:   append &buf parameter
  frame->slots[5] /* temp__3 */ = create_closure(entry__42_81, 0);
  // 407: :
  // 408:   write_to &buf '@nl;' parameter_indentation parameter
  frame->slots[6] /* temp__4 */ = create_closure(entry__42_83, 0);
  // 404: if
  // 405:   parameter(1) == '@nl;':
  // 406:     append &buf parameter
  // 407:   :
  // 408:     write_to &buf '@nl;' parameter_indentation parameter
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__42_85(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 409: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__42_86;
}
static void cont__42_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 409: write_to &buf '@nl;' spaces(indent) ')'
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[6] /* temp__1 */;
  arguments->slots[3] = character__41;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__42_87;
}
static void cont__42_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 412: length_of(parameters) == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_89;
}
static void cont__42_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 412: ... :
  // 413:   check_for_line_end_expression
  // 414:   unless remark_lines.is_empty: add_remark_lines &buf remark_lines true
  frame->slots[11] /* temp__3 */ = create_closure(entry__42_90, 0);
  // 415: :
  // 416:   $has_simple_parameters
  // 417:     &&
  // 418:       ||
  // 419:         length_of(parameters) == 1
  // 420:         not
  // 421:           any_of
  // 422:             parameters: (parameter)
  // 423:               ->
  // 424:                 ||
  // ...
  frame->slots[12] /* temp__4 */ = create_closure(entry__42_95, 0);
  // 411: if
  // 412:   length_of(parameters) == 0:
  // 413:     check_for_line_end_expression
  // 414:     unless remark_lines.is_empty: add_remark_lines &buf remark_lines true
  // 415:   :
  // 416:     $has_simple_parameters
  // 417:       &&
  // 418:         ||
  // 419:           length_of(parameters) == 1
  // 420:           not
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__3 */;
  arguments->slots[2] = frame->slots[12] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__42_118;
}
static void entry__42_116(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // handle_simple_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* handle_simple_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 433: handle_simple_parameters
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* handle_simple_parameters */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_117(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // handle_complex_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* handle_complex_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 435: handle_complex_parameters
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* handle_complex_parameters */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_93(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 414: ... add_remark_lines &buf remark_lines true
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__42_94;
}
static void cont__42_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_90(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // check_for_line_end_expression: 0
  // remark_lines: 1
  // buf: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* check_for_line_end_expression */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[4]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 413: check_for_line_end_expression
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* check_for_line_end_expression */;
  func = myself->type;
  frame->cont = cont__42_91;
}
static void cont__42_91(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 414: ... remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__42_92;
}
static void cont__42_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 414: ... : add_remark_lines &buf remark_lines true
  frame->slots[4] /* temp__2 */ = create_closure(entry__42_93, 0);
  // 414: unless remark_lines.is_empty: add_remark_lines &buf remark_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__42_95(void) {
  allocate_initialized_frame_gc(3, 9);
  // slot allocations:
  // parameters: 0
  // handle_simple_parameters: 1
  // handle_complex_parameters: 2
  // has_simple_parameters: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* parameters */
  frame->slots[1] = myself->closure.frame->slots[6]; /* handle_simple_parameters */
  frame->slots[2] = myself->closure.frame->slots[7]; /* handle_complex_parameters */
  frame->slots[3] /* has_simple_parameters */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 419: length_of(parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_96;
}
static void cont__42_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 419: length_of(parameters) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_97;
}
static void cont__42_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 420: not
  // 421:   any_of
  // 422:     parameters: (parameter)
  // 423:       ->
  // 424:         ||
  // 425:           parameter_kind_of(parameter) != IN_PARAMETER
  // 426:           default_value_of(parameter).is_defined
  frame->slots[7] /* temp__4 */ = create_closure(entry__42_98, 0);
  // 418: ||
  // 419:   length_of(parameters) == 1
  // 420:   not
  // 421:     any_of
  // 422:       parameters: (parameter)
  // 423:         ->
  // 424:           ||
  // 425:             parameter_kind_of(parameter) != IN_PARAMETER
  // 426:             default_value_of(parameter).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__42_109;
}
static void entry__42_98(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // parameters: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 421: any_of
  // 422:   parameters: (parameter)
  // 423:     ->
  // 424:       ||
  // 425:         parameter_kind_of(parameter) != IN_PARAMETER
  // 426:         default_value_of(parameter).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  arguments->slots[1] = func__42_99;
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__42_107;
}
static void entry__42_99(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // parameter: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 425: parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__42_100;
}
static void cont__42_100(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 425: parameter_kind_of(parameter) != IN_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = get__IN_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_101;
}
static void cont__42_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 425: parameter_kind_of(parameter) != IN_PARAMETER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__42_102;
}
static void cont__42_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 426: default_value_of(parameter).is_defined
  frame->slots[5] /* temp__5 */ = create_closure(entry__42_103, 0);
  // 424: ||
  // 425:   parameter_kind_of(parameter) != IN_PARAMETER
  // 426:   default_value_of(parameter).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__42_106;
}
static void entry__42_103(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // parameter: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 426: default_value_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__42_104;
}
static void cont__42_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 426: default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__42_105;
}
static void cont__42_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 426: default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 423: ->
  // 424:   ||
  // 425:     parameter_kind_of(parameter) != IN_PARAMETER
  // 426:     default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 420: not
  // 421:   any_of
  // 422:     parameters: (parameter)
  // 423:       ->
  // 424:         ||
  // 425:           parameter_kind_of(parameter) != IN_PARAMETER
  // 426:           default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__42_108;
}
static void cont__42_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 420: not
  // 421:   any_of
  // 422:     parameters: (parameter)
  // 423:       ->
  // 424:         ||
  // 425:           parameter_kind_of(parameter) != IN_PARAMETER
  // 426:           default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 427: all_of
  // 428:   parameters: (parameter)
  // 429:     -> remark_lines_of(parameter).is_empty
  frame->slots[8] /* temp__5 */ = create_closure(entry__42_110, 0);
  // 416: $has_simple_parameters
  // 417:   &&
  // 418:     ||
  // 419:       length_of(parameters) == 1
  // 420:       not
  // 421:         any_of
  // 422:           parameters: (parameter)
  // 423:             ->
  // 424:               ||
  // 425:                 parameter_kind_of(parameter) != IN_PARAMETER
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__42_115;
}
static void entry__42_110(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // parameters: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 427: all_of
  // 428:   parameters: (parameter)
  // 429:     -> remark_lines_of(parameter).is_empty
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  arguments->slots[1] = func__42_111;
  result_count = 1;
  myself = get__all_of();
  func = myself->type;
  frame->cont = cont__42_114;
}
static void entry__42_111(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // parameter: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 429: ... remark_lines_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__42_112;
}
static void cont__42_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 429: ... remark_lines_of(parameter).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__42_113;
}
static void cont__42_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 429: -> remark_lines_of(parameter).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 427: all_of
  // 428:   parameters: (parameter)
  // 429:     -> remark_lines_of(parameter).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* has_simple_parameters */, arguments->slots[0]);
  // 432: ... :
  // 433:   handle_simple_parameters
  frame->slots[4] /* temp__1 */ = create_closure(entry__42_116, 0);
  // 434: :
  // 435:   handle_complex_parameters
  frame->slots[5] /* temp__2 */ = create_closure(entry__42_117, 0);
  // 431: if
  // 432:   has_simple_parameters:
  // 433:     handle_simple_parameters
  // 434:   :
  // 435:     handle_complex_parameters
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* has_simple_parameters */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__42_118(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 437: ... :
  // 438:   %expression_indent indent
  // 439:   $indentation spaces(indent)
  // 440:   if
  // 441:     hide_body_statements:
  // 442:       write_to &buf '@nl;' indentation "
  // 443:         ...
  // 444:     :
  // 445:       %line_end_expression_width 0
  // 446:       $statements statements_of(self)
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__42_119, 0);
  // 437: do:
  // 438:   %expression_indent indent
  // 439:   $indentation spaces(indent)
  // 440:   if
  // 441:     hide_body_statements:
  // 442:       write_to &buf '@nl;' indentation "
  // 443:         ...
  // 444:     :
  // 445:       %line_end_expression_width 0
  // 446:       $statements statements_of(self)
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__42_161;
}
static void entry__42_119(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // return__2: 0
  // indent: 1
  // buf: 2
  // self: 3
  // outer_line_end_expression_width: 4
  // indentation: 5
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[3]; /* self */
  frame->slots[4] = myself->closure.frame->slots[8]; /* outer_line_end_expression_width */
  // _define %expression_indent indent
  define__expression_indent(create_future());
  frame->slots[5] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 438: %expression_indent indent
  initialize_maybe_future(get__expression_indent(), ((CELL *)frame->slots[1])->contents /* indent */);
  // 439: $indentation spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__42_120;
}
static void cont__42_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* indentation */, arguments->slots[0]);
  // 441: ... :
  // 442:   write_to &buf '@nl;' indentation "
  // 443:     ...
  frame->slots[6] /* temp__1 */ = create_closure(entry__42_121, 0);
  // 444: :
  // 445:   %line_end_expression_width 0
  // 446:   $statements statements_of(self)
  // 447:   $n length_of(statements)
  // 448:   %%statement_tag undefined
  // 449:   for_each statements_of(self): (idx statement)
  // 450:     $previous_statement_tag statement_tag
  // 451:     !statement_tag undefined
  // 452:     $str statement.to_string
  // 453:     if
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__42_124, 0);
  // 440: if
  // 441:   hide_body_statements:
  // 442:     write_to &buf '@nl;' indentation "
  // 443:       ...
  // 444:   :
  // 445:     %line_end_expression_width 0
  // 446:     $statements statements_of(self)
  // 447:     $n length_of(statements)
  // 448:     %%statement_tag undefined
  // 449:     for_each statements_of(self): (idx statement)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__hide_body_statements();
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__42_160;
}
static void entry__42_121(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 442: write_to &buf '@nl;' indentation "
  // 443:   ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[1] /* indentation */;
  arguments->slots[3] = string__42_122;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__42_123;
}
static void cont__42_123(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_124(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // return__1: 0
  // self: 1
  // buf: 2
  // outer_line_end_expression_width: 3
  // indentation: 4
  // statements: 5
  // n: 6
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[3]; /* self */
  frame->slots[2] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[4]; /* outer_line_end_expression_width */
  frame->slots[4] = myself->closure.frame->slots[5]; /* indentation */
  // _define %line_end_expression_width 0
  define__line_end_expression_width(number__0);
  frame->slots[5] /* statements */ = create_future();
  frame->slots[6] /* n */ = create_future();
  define__statement_tag(undefined);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 446: $statements statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__42_125;
}
static void cont__42_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* statements */, arguments->slots[0]);
  // 447: $n length_of(statements)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* statements */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_126;
}
static void cont__42_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* n */, arguments->slots[0]);
  // 448: %%statement_tag undefined
  set__statement_tag(get__undefined());
  // 449: ... statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__42_127;
}
static void cont__42_127(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 449: ... : (idx statement)
  // 450:   $previous_statement_tag statement_tag
  // 451:   !statement_tag undefined
  // 452:   $str statement.to_string
  // 453:   if
  // 454:     &&
  // 455:       idx > 1
  // 456:       ||
  // 457:         statement_tag == ALWAYS
  // 458:         previous_statement_tag != statement_tag
  // ...
  frame->slots[8] /* temp__2 */ = create_closure(entry__42_128, 2);
  // 449: for_each statements_of(self): (idx statement)
  // 450:   $previous_statement_tag statement_tag
  // 451:   !statement_tag undefined
  // 452:   $str statement.to_string
  // 453:   if
  // 454:     &&
  // 455:       idx > 1
  // 456:       ||
  // 457:         statement_tag == ALWAYS
  // 458:         previous_statement_tag != statement_tag
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__42_159;
}
static void entry__42_155(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[7]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 470: write_to &buf '@nl;' indentation str
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[1] /* indentation */;
  arguments->slots[3] = frame->slots[2] /* str */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__42_156;
}
static void cont__42_156(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_157(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[7]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 472: write_to &buf ' ' str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__32;
  arguments->slots[2] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__42_158;
}
static void cont__42_158(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_128(void) {
  allocate_initialized_frame_gc(6, 13);
  // slot allocations:
  // idx: 0
  // statement: 1
  // buf: 2
  // n: 3
  // outer_line_end_expression_width: 4
  // indentation: 5
  // previous_statement_tag: 6
  // str: 7
  frame->slots[2] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[6]; /* n */
  frame->slots[4] = myself->closure.frame->slots[3]; /* outer_line_end_expression_width */
  frame->slots[5] = myself->closure.frame->slots[4]; /* indentation */
  frame->slots[6] /* previous_statement_tag */ = create_future();
  frame->slots[7] /* str */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 450: $previous_statement_tag statement_tag
  initialize_future(frame->slots[6] /* previous_statement_tag */, get__statement_tag());
  // 451: !statement_tag undefined
  set__statement_tag(get__undefined());
  // 452: $str statement.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__42_129;
}
static void cont__42_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* str */, arguments->slots[0]);
  // 455: idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__42_130;
}
static void cont__42_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 456: ||
  // 457:   statement_tag == ALWAYS
  // 458:   previous_statement_tag != statement_tag
  frame->slots[10] /* temp__3 */ = create_closure(entry__42_131, 0);
  // 454: &&
  // 455:   idx > 1
  // 456:   ||
  // 457:     statement_tag == ALWAYS
  // 458:     previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__42_137;
}
static void entry__42_131(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 457: statement_tag == ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__statement_tag();
  arguments->slots[1] = var._ALWAYS;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_132;
}
static void cont__42_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 458: previous_statement_tag != statement_tag
  frame->slots[3] /* temp__3 */ = create_closure(entry__42_133, 0);
  // 456: ||
  // 457:   statement_tag == ALWAYS
  // 458:   previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__42_136;
}
static void entry__42_133(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 458: previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* previous_statement_tag */;
  arguments->slots[1] = get__statement_tag();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_134;
}
static void cont__42_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 458: previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__42_135;
}
static void cont__42_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 458: previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 456: ||
  // 457:   statement_tag == ALWAYS
  // 458:   previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 459: :
  // 460:   writeln_to &buf
  frame->slots[11] /* temp__4 */ = create_closure(entry__42_138, 0);
  // 453: if
  // 454:   &&
  // 455:     idx > 1
  // 456:     ||
  // 457:       statement_tag == ALWAYS
  // 458:       previous_statement_tag != statement_tag
  // 459:   :
  // 460:     writeln_to &buf
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__42_140;
}
static void entry__42_138(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 460: writeln_to &buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__42_139;
}
static void cont__42_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_140(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 463: n > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* n */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__42_141;
}
static void cont__42_141(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  frame->slots[10] /* temp__3 */ = create_closure(entry__42_142, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__42_154;
}
static void entry__42_142(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // buf: 0
  // str: 1
  // outer_line_end_expression_width: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[7]; /* str */
  frame->slots[2] = myself->closure.frame->slots[4]; /* outer_line_end_expression_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 464: buf .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__42_143;
}
static void cont__42_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__3 */ = create_closure(entry__42_144, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__42_153;
}
static void entry__42_144(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // outer_line_end_expression_width: 1
  // buf: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* outer_line_end_expression_width */
  frame->slots[2] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 465: str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__42_145;
}
static void cont__42_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 466: >
  // 467:   length_of(buf)+1+length_of(str)
  // 468:   outer_line_end_expression_width
  frame->slots[5] /* temp__3 */ = create_closure(entry__42_146, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__42_152;
}
static void entry__42_146(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // outer_line_end_expression_width: 0
  // buf: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* outer_line_end_expression_width */
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 467: length_of(buf)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_147;
}
static void cont__42_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 467: length_of(buf)+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__42_148;
}
static void cont__42_148(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 467: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_149;
}
static void cont__42_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  // 467: length_of(buf)+1+length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__42_150;
}
static void cont__42_150(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 466: >
  // 467:   length_of(buf)+1+length_of(str)
  // 468:   outer_line_end_expression_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* outer_line_end_expression_width */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__42_151;
}
static void cont__42_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 466: >
  // 467:   length_of(buf)+1+length_of(str)
  // 468:   outer_line_end_expression_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_153(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 469: :
  // 470:   write_to &buf '@nl;' indentation str
  frame->slots[11] /* temp__4 */ = create_closure(entry__42_155, 0);
  // 471: :
  // 472:   write_to &buf ' ' str
  frame->slots[12] /* temp__5 */ = create_closure(entry__42_157, 0);
  // 461: if
  // 462:   ||
  // 463:     n > 1
  // 464:     buf .contains. '@nl;'
  // 465:     str .contains. '@nl;'
  // 466:     >
  // 467:       length_of(buf)+1+length_of(str)
  // 468:       outer_line_end_expression_width
  // 469:   :
  // 470:     write_to &buf '@nl;' indentation str
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  arguments->slots[2] = frame->slots[12] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__42_159(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__42_160(void) {
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__42_161(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 473: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__42_1(void) {
  allocate_initialized_frame_gc(1, 10);
  // slot allocations:
  // self: 0
  // indent: 1
  // remark_lines: 2
  // parameters: 3
  frame->slots[1] /* indent */ = create_cell();
  frame->slots[2] /* remark_lines */ = create_future();
  frame->slots[3] /* parameters */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 349: $$indent expression_indent
  ((CELL *)frame->slots[1])->contents /* indent */ = get__expression_indent();
  // 350: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__42_2;
}
static void cont__42_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* remark_lines */, arguments->slots[0]);
  // 351: $parameters parameters_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__parameters_of();
  func = myself->type;
  frame->cont = cont__42_3;
}
static void cont__42_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* parameters */, arguments->slots[0]);
  // 354: length_of(parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* parameters */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_4;
}
static void cont__42_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 354: length_of(parameters) == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_5;
}
static void cont__42_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__4 */ = create_closure(entry__42_6, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__42_15;
}
static void entry__42_6(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 355: ... statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__42_7;
}
static void cont__42_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 355: length_of(statements_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__42_8;
}
static void cont__42_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 355: length_of(statements_of(self)) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__42_9;
}
static void cont__42_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 356: statements_of(self)(1).is_a_return
  frame->slots[5] /* temp__5 */ = create_closure(entry__42_10, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__42_14;
}
static void entry__42_10(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 356: statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__42_11;
}
static void cont__42_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 356: statements_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[3] /* temp__3 */;
  func = myself->type;
  frame->cont = cont__42_12;
}
static void cont__42_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 356: statements_of(self)(1).is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_a_return();
  func = myself->type;
  frame->cont = cont__42_13;
}
static void cont__42_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 356: statements_of(self)(1).is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__42_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 357: :
  // 358:   $str statements_of(self)(1).to_string
  // 359:   if
  // 360:     line_end_expression_width == 0 && str .contains. '@nl;'
  // 361:     -> string('@nl;' spaces(indent) str)
  // 362:     -> str
  frame->slots[8] /* temp__5 */ = create_closure(entry__42_16, 0);
  // 363: :
  // 364:   $$buf undefined
  // 365:   
  // 366:   $check_for_line_end_expression:
  // 367:     if
  // 368:       line_end_expression_width > 0:
  // 369:         !buf ":"
  // 370:       :
  // 371:         !buf string("@nl;" spaces(indent) ':')
  // 372:         plus &indent 2
  // ...
  frame->slots[9] /* temp__6 */ = create_closure(entry__42_28, 0);
  // 352: if
  // 353:   &&
  // 354:     length_of(parameters) == 0
  // 355:     length_of(statements_of(self)) == 1
  // 356:     statements_of(self)(1).is_a_return
  // 357:   :
  // 358:     $str statements_of(self)(1).to_string
  // 359:     if
  // 360:       line_end_expression_width == 0 && str .contains. '@nl;'
  // 361:       -> string('@nl;' spaces(indent) str)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  arguments->slots[2] = frame->slots[9] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__43_1(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // self: 0
  // return: 1
  // output_arguments: 2
  // input_arguments: 3
  // all_arguments: 4
  frame->slots[1] /* return */ = create_continuation();
  frame->slots[2] /* output_arguments */ = create_cell();
  frame->slots[3] /* input_arguments */ = create_cell();
  frame->slots[4] /* all_arguments */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 483: $$output_arguments output_arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__output_arguments_of();
  func = myself->type;
  frame->cont = cont__43_2;
}
static void cont__43_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* output_arguments */ = arguments->slots[0];
  // 484: ... output_arguments.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* output_arguments */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__43_3;
}
static void cont__43_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 484: ... : return output_arguments
  frame->slots[6] /* temp__2 */ = create_closure(entry__43_4, 0);
  // 484: if output_arguments.is_undefined: return output_arguments
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__43_5;
}
static void entry__43_4(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // return: 0
  // output_arguments: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* output_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 484: ... return output_arguments
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_arguments */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__43_5(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 485: $$input_arguments arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__43_6;
}
static void cont__43_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* input_arguments */ = arguments->slots[0];
  // 486: $$all_arguments empty_list
  ((CELL *)frame->slots[4])->contents /* all_arguments */ = get__empty_list();
  // 487: ... -> length_of(output_arguments)+length_of(input_arguments) > 0: (-> continue)
  // 488:   unless output_arguments.is_empty:
  // 489:     # there is at least one more output argument
  // 490:     
  // 491:     $next_output_argument output_arguments(1)
  // 492:     $output_enumeration_no enumeration_no_of(next_output_argument)
  // 493:     if output_enumeration_no.is_undefined:
  // 494:       # undefined enumeration numbers have the highest priority
  // 495:       
  // 496:       push &all_arguments next_output_argument
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__43_7, 0);
  // 487: while -> length_of(output_arguments)+length_of(input_arguments) > 0: (-> continue)
  // 488:   unless output_arguments.is_empty:
  // 489:     # there is at least one more output argument
  // 490:     
  // 491:     $next_output_argument output_arguments(1)
  // 492:     $output_enumeration_no enumeration_no_of(next_output_argument)
  // 493:     if output_enumeration_no.is_undefined:
  // 494:       # undefined enumeration numbers have the highest priority
  // 495:       
  // 496:       push &all_arguments next_output_argument
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__43_44;
}
static void entry__43_12(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // continue: 0
  // output_arguments: 1
  // all_arguments: 2
  // input_arguments: 3
  frame->slots[0] /* continue */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* output_arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* all_arguments */
  frame->slots[3] = myself->closure.frame->slots[1]; /* input_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 488: ... output_arguments.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_arguments */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__43_13;
}
static void cont__43_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 488: ... :
  // 489:   # there is at least one more output argument
  // 490:   
  // 491:   $next_output_argument output_arguments(1)
  // 492:   $output_enumeration_no enumeration_no_of(next_output_argument)
  // 493:   if output_enumeration_no.is_undefined:
  // 494:     # undefined enumeration numbers have the highest priority
  // 495:     
  // 496:     push &all_arguments next_output_argument
  // 497:     range &output_arguments 2 -1
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__43_14, 0);
  // 488: unless output_arguments.is_empty:
  // 489:   # there is at least one more output argument
  // 490:   
  // 491:   $next_output_argument output_arguments(1)
  // 492:   $output_enumeration_no enumeration_no_of(next_output_argument)
  // 493:   if output_enumeration_no.is_undefined:
  // 494:     # undefined enumeration numbers have the highest priority
  // 495:     
  // 496:     push &all_arguments next_output_argument
  // 497:     range &output_arguments 2 -1
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__43_42;
}
static void entry__43_14(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // output_arguments: 0
  // all_arguments: 1
  // continue: 2
  // input_arguments: 3
  // next_output_argument: 4
  // output_enumeration_no: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* output_arguments */
  frame->slots[1] = myself->closure.frame->slots[2]; /* all_arguments */
  frame->slots[2] = myself->closure.frame->slots[0]; /* continue */
  frame->slots[3] = myself->closure.frame->slots[3]; /* input_arguments */
  frame->slots[4] /* next_output_argument */ = create_future();
  frame->slots[5] /* output_enumeration_no */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 491: $next_output_argument output_arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* output_arguments */;
  func = myself->type;
  frame->cont = cont__43_15;
}
static void cont__43_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* next_output_argument */, arguments->slots[0]);
  // 492: $output_enumeration_no enumeration_no_of(next_output_argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* next_output_argument */;
  result_count = 1;
  myself = get__enumeration_no_of();
  func = myself->type;
  frame->cont = cont__43_16;
}
static void cont__43_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* output_enumeration_no */, arguments->slots[0]);
  // 493: ... output_enumeration_no.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* output_enumeration_no */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__43_17;
}
static void cont__43_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 493: ... :
  // 494:   # undefined enumeration numbers have the highest priority
  // 495:   
  // 496:   push &all_arguments next_output_argument
  // 497:   range &output_arguments 2 -1
  // 498:   continue
  frame->slots[7] /* temp__2 */ = create_closure(entry__43_18, 0);
  // 493: if output_enumeration_no.is_undefined:
  // 494:   # undefined enumeration numbers have the highest priority
  // 495:   
  // 496:   push &all_arguments next_output_argument
  // 497:   range &output_arguments 2 -1
  // 498:   continue
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__43_22;
}
static void entry__43_18(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // all_arguments: 0
  // next_output_argument: 1
  // output_arguments: 2
  // continue: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* all_arguments */
  frame->slots[1] = myself->closure.frame->slots[4]; /* next_output_argument */
  frame->slots[2] = myself->closure.frame->slots[0]; /* output_arguments */
  frame->slots[3] = myself->closure.frame->slots[2]; /* continue */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 496: push &all_arguments next_output_argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* all_arguments */;
  arguments->slots[1] = frame->slots[1] /* next_output_argument */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__43_19;
}
static void cont__43_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* all_arguments */ = arguments->slots[0];
  // 497: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__43_20;
}
static void cont__43_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 497: range &output_arguments 2 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* output_arguments */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__43_21;
}
static void cont__43_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* output_arguments */ = arguments->slots[0];
  // 498: continue
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[3] /* continue */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__43_22(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 499: ... input_arguments.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* input_arguments */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__43_23;
}
static void cont__43_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 499: ... :
  // 500:   $next_input_argument input_arguments(1)
  // 501:   $input_enumeration_no enumeration_no_of(next_input_argument)
  // 502:   if input_enumeration_no.is_undefined:
  // 503:     # undefined enumeration numbers have the highest priority
  // 504:     
  // 505:     push &all_arguments next_input_argument
  // 506:     range &input_arguments 2 -1
  // 507:     continue
  // 508:   
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__43_24, 0);
  // 499: unless input_arguments.is_empty:
  // 500:   $next_input_argument input_arguments(1)
  // 501:   $input_enumeration_no enumeration_no_of(next_input_argument)
  // 502:   if input_enumeration_no.is_undefined:
  // 503:     # undefined enumeration numbers have the highest priority
  // 504:     
  // 505:     push &all_arguments next_input_argument
  // 506:     range &input_arguments 2 -1
  // 507:     continue
  // 508:   
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__43_38;
}
static void entry__43_34(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // all_arguments: 0
  // next_input_argument: 1
  // input_arguments: 2
  // continue: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* all_arguments */
  frame->slots[1] = myself->closure.frame->slots[4]; /* next_input_argument */
  frame->slots[2] = myself->closure.frame->slots[0]; /* input_arguments */
  frame->slots[3] = myself->closure.frame->slots[2]; /* continue */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 514: push &all_arguments next_input_argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* all_arguments */;
  arguments->slots[1] = frame->slots[1] /* next_input_argument */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__43_35;
}
static void cont__43_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* all_arguments */ = arguments->slots[0];
  // 515: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__43_36;
}
static void cont__43_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 515: range &input_arguments 2 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* input_arguments */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__43_37;
}
static void cont__43_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* input_arguments */ = arguments->slots[0];
  // 516: continue
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[3] /* continue */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__43_24(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // input_arguments: 0
  // all_arguments: 1
  // continue: 2
  // output_enumeration_no: 3
  // next_input_argument: 4
  // input_enumeration_no: 5
  frame->slots[0] = myself->closure.frame->slots[3]; /* input_arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* all_arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* continue */
  frame->slots[3] = myself->closure.frame->slots[5]; /* output_enumeration_no */
  frame->slots[4] /* next_input_argument */ = create_future();
  frame->slots[5] /* input_enumeration_no */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 500: $next_input_argument input_arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* input_arguments */;
  func = myself->type;
  frame->cont = cont__43_25;
}
static void cont__43_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* next_input_argument */, arguments->slots[0]);
  // 501: $input_enumeration_no enumeration_no_of(next_input_argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* next_input_argument */;
  result_count = 1;
  myself = get__enumeration_no_of();
  func = myself->type;
  frame->cont = cont__43_26;
}
static void cont__43_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* input_enumeration_no */, arguments->slots[0]);
  // 502: ... input_enumeration_no.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* input_enumeration_no */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__43_27;
}
static void cont__43_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 502: ... :
  // 503:   # undefined enumeration numbers have the highest priority
  // 504:   
  // 505:   push &all_arguments next_input_argument
  // 506:   range &input_arguments 2 -1
  // 507:   continue
  frame->slots[7] /* temp__2 */ = create_closure(entry__43_28, 0);
  // 502: if input_enumeration_no.is_undefined:
  // 503:   # undefined enumeration numbers have the highest priority
  // 504:   
  // 505:   push &all_arguments next_input_argument
  // 506:   range &input_arguments 2 -1
  // 507:   continue
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__43_32;
}
static void entry__43_28(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // all_arguments: 0
  // next_input_argument: 1
  // input_arguments: 2
  // continue: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* all_arguments */
  frame->slots[1] = myself->closure.frame->slots[4]; /* next_input_argument */
  frame->slots[2] = myself->closure.frame->slots[0]; /* input_arguments */
  frame->slots[3] = myself->closure.frame->slots[2]; /* continue */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 505: push &all_arguments next_input_argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* all_arguments */;
  arguments->slots[1] = frame->slots[1] /* next_input_argument */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__43_29;
}
static void cont__43_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* all_arguments */ = arguments->slots[0];
  // 506: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__43_30;
}
static void cont__43_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 506: range &input_arguments 2 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* input_arguments */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__43_31;
}
static void cont__43_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* input_arguments */ = arguments->slots[0];
  // 507: continue
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[3] /* continue */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__43_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 513: ... input_enumeration_no < output_enumeration_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* input_enumeration_no */;
  arguments->slots[1] = frame->slots[3] /* output_enumeration_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__43_33;
}
static void cont__43_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 513: ... :
  // 514:   push &all_arguments next_input_argument
  // 515:   range &input_arguments 2 -1
  // 516:   continue
  frame->slots[7] /* temp__2 */ = create_closure(entry__43_34, 0);
  // 513: if input_enumeration_no < output_enumeration_no:
  // 514:   push &all_arguments next_input_argument
  // 515:   range &input_arguments 2 -1
  // 516:   continue
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__43_38(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 520: push &all_arguments next_output_argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* all_arguments */;
  arguments->slots[1] = frame->slots[4] /* next_output_argument */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__43_39;
}
static void cont__43_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* all_arguments */ = arguments->slots[0];
  // 521: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__43_40;
}
static void cont__43_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 521: range &output_arguments 2 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_arguments */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__43_41;
}
static void cont__43_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* output_arguments */ = arguments->slots[0];
  // 522: continue
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[2] /* continue */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__43_42(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 526: append &all_arguments input_arguments
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* all_arguments */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* input_arguments */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__43_43;
}
static void cont__43_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* all_arguments */ = arguments->slots[0];
  // 527: !input_arguments empty_list
  ((CELL *)frame->slots[3])->contents /* input_arguments */ = get__empty_list();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__43_7(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // output_arguments: 0
  // input_arguments: 1
  // all_arguments: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* output_arguments */
  frame->slots[1] = myself->closure.frame->slots[3]; /* input_arguments */
  frame->slots[2] = myself->closure.frame->slots[4]; /* all_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 487: ... length_of(output_arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__43_8;
}
static void cont__43_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 487: ... length_of(input_arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* input_arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__43_9;
}
static void cont__43_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 487: ... length_of(output_arguments)+length_of(input_arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__43_10;
}
static void cont__43_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 487: ... length_of(output_arguments)+length_of(input_arguments) > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__43_11;
}
static void cont__43_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 487: ... : (-> continue)
  // 488:   unless output_arguments.is_empty:
  // 489:     # there is at least one more output argument
  // 490:     
  // 491:     $next_output_argument output_arguments(1)
  // 492:     $output_enumeration_no enumeration_no_of(next_output_argument)
  // 493:     if output_enumeration_no.is_undefined:
  // 494:       # undefined enumeration numbers have the highest priority
  // 495:       
  // 496:       push &all_arguments next_output_argument
  // ...
  frame->slots[7] /* temp__5 */ = create_closure(entry__43_12, 0);
  // 487: ... -> length_of(output_arguments)+length_of(input_arguments) > 0: (-> continue)
  // 488:   unless output_arguments.is_empty:
  // 489:     # there is at least one more output argument
  // 490:     
  // 491:     $next_output_argument output_arguments(1)
  // 492:     $output_enumeration_no enumeration_no_of(next_output_argument)
  // 493:     if output_enumeration_no.is_undefined:
  // 494:       # undefined enumeration numbers have the highest priority
  // 495:       
  // 496:       push &all_arguments next_output_argument
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__43_44(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 528: -> all_arguments
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* all_arguments */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__44_2(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // return__1: 0
  // argument: 1
  // width: 2
  // str: 3
  // first_chr: 4
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[2] = myself->closure.frame->slots[1]; /* width */
  define__line_width(create_future());
  frame->slots[3] /* str */ = create_cell();
  frame->slots[4] /* first_chr */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 536: argument.is_a_destination
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__is_a_destination();
  func = myself->type;
  frame->cont = cont__44_3;
}
static void cont__44_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__3 */ = create_closure(entry__44_4, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__44_9;
}
static void entry__44_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 537: argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__44_5;
}
static void cont__44_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 538: argument.is_an_optional_item
  frame->slots[3] /* temp__3 */ = create_closure(entry__44_6, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__44_8;
}
static void entry__44_6(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 538: argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__44_7;
}
static void cont__44_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 538: argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 540: -> width
  frame->slots[8] /* temp__4 */ = create_closure(entry__44_10, 0);
  // 533: %line_width
  // 534:   if
  // 535:     ||
  // 536:       argument.is_a_destination
  // 537:       argument.is_an_expanded_item
  // 538:       argument.is_an_optional_item
  // 539:     -> UNLIMITED
  // 540:     -> width
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = func__44_11;
  arguments->slots[2] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__44_12;
}
static void entry__44_10(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // width: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 540: -> width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* width */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_11(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 539: -> UNLIMITED
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._UNLIMITED;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_width(), arguments->slots[0]);
  // 542: $$str argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__44_13;
}
static void cont__44_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* str */ = arguments->slots[0];
  // 544: -> argument.is_an_expanded_item:
  // 545:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 546:     !str string('(' str ')')
  // 547:   push &str '*'
  frame->slots[5] /* temp__1 */ = create_closure(entry__44_14, 0);
  // 548: -> argument.is_an_optional_item:
  // 549:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 550:     !str string('(' str ')')
  // 551:   push &str '?'
  frame->slots[6] /* temp__2 */ = create_closure(entry__44_23, 0);
  // 543: cond
  // 544:   -> argument.is_an_expanded_item:
  // 545:     if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 546:       !str string('(' str ')')
  // 547:     push &str '*'
  // 548:   -> argument.is_an_optional_item:
  // 549:     if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 550:       !str string('(' str ')')
  // 551:     push &str '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__44_32;
}
static void entry__44_25(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 549: ... precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__44_26;
}
static void cont__44_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 549: ... precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__44_27;
}
static void cont__44_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 549: ... :
  // 550:   !str string('(' str ')')
  frame->slots[4] /* temp__3 */ = create_closure(entry__44_28, 0);
  // 549: if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 550:   !str string('(' str ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__44_30;
}
static void entry__44_28(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 550: !str string('(' str ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* str */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__44_29;
}
static void cont__44_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_30(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 551: push &str '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* str */;
  arguments->slots[1] = character__63;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__44_31;
}
static void cont__44_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_16(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 545: ... precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__44_17;
}
static void cont__44_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 545: ... precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__44_18;
}
static void cont__44_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 545: ... :
  // 546:   !str string('(' str ')')
  frame->slots[4] /* temp__3 */ = create_closure(entry__44_19, 0);
  // 545: if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 546:   !str string('(' str ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__44_21;
}
static void entry__44_19(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 546: !str string('(' str ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* str */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__44_20;
}
static void cont__44_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_21(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 547: push &str '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* str */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__44_22;
}
static void cont__44_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_14(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 544: ... argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__44_15;
}
static void cont__44_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 544: ... :
  // 545:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 546:     !str string('(' str ')')
  // 547:   push &str '*'
  frame->slots[3] /* temp__2 */ = create_closure(entry__44_16, 0);
  // 544: -> argument.is_an_expanded_item:
  // 545:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 546:     !str string('(' str ')')
  // 547:   push &str '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_23(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 548: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__44_24;
}
static void cont__44_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 548: ... :
  // 549:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 550:     !str string('(' str ')')
  // 551:   push &str '?'
  frame->slots[3] /* temp__2 */ = create_closure(entry__44_25, 0);
  // 548: -> argument.is_an_optional_item:
  // 549:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 550:     !str string('(' str ')')
  // 551:   push &str '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 552: $first_chr str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* str */;
  func = myself->type;
  frame->cont = cont__44_33;
}
static void cont__44_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* first_chr */, arguments->slots[0]);
  // 554: argument.is_a_destination
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__is_a_destination();
  func = myself->type;
  frame->cont = cont__44_34;
}
static void cont__44_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 554: ... first_chr != '$' && first_chr != '%'
  frame->slots[7] /* temp__3 */ = create_closure(entry__44_35, 0);
  // 554: argument.is_a_destination && first_chr != '$' && first_chr != '%'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__44_42;
}
static void entry__44_35(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // first_chr: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* first_chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 554: ... first_chr != '$'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* first_chr */;
  arguments->slots[1] = character__36;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__44_36;
}
static void cont__44_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 554: ... first_chr != '$'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__44_37;
}
static void cont__44_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 554: ... first_chr != '%'
  frame->slots[4] /* temp__4 */ = create_closure(entry__44_38, 0);
  // 554: ... first_chr != '$' && first_chr != '%'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__44_41;
}
static void entry__44_38(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // first_chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* first_chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 554: ... first_chr != '%'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* first_chr */;
  arguments->slots[1] = character__37;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__44_39;
}
static void cont__44_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 554: ... first_chr != '%'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__44_40;
}
static void cont__44_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 554: ... first_chr != '%'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 554: ... first_chr != '$' && first_chr != '%'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 555: -> string('!' str)
  frame->slots[8] /* temp__4 */ = create_closure(entry__44_43, 0);
  // 556: -> str
  frame->slots[9] /* temp__5 */ = create_closure(entry__44_45, 0);
  // 553: if
  // 554:   argument.is_a_destination && first_chr != '$' && first_chr != '%'
  // 555:   -> string('!' str)
  // 556:   -> str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  arguments->slots[2] = frame->slots[9] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__44_46;
}
static void entry__44_43(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 555: ... string('!' str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__33;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* str */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__44_44;
}
static void cont__44_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 555: -> string('!' str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__44_45(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 556: -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__44_46(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__44_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // argument: 0
  // width: 1
  // _define $width line_width
  frame->slots[1] /* width */ = get__line_width();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 531: $width line_width
  initialize_maybe_future(frame->slots[1] /* width */, get__line_width());
  // 532: ... :
  // 533:   %line_width
  // 534:     if
  // 535:       ||
  // 536:         argument.is_a_destination
  // 537:         argument.is_an_expanded_item
  // 538:         argument.is_an_optional_item
  // 539:       -> UNLIMITED
  // 540:       -> width
  // 541:   
  // ...
  frame->slots[2] /* temp__1 */ = create_closure(entry__44_2, 0);
  // 532: do:
  // 533:   %line_width
  // 534:     if
  // 535:       ||
  // 536:         argument.is_a_destination
  // 537:         argument.is_an_expanded_item
  // 538:         argument.is_an_optional_item
  // 539:       -> UNLIMITED
  // 540:       -> width
  // 541:   
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_1(void) {
  allocate_initialized_frame_gc(4, 18);
  // slot allocations:
  // self: 0
  // mode: 1
  // available_width: 2
  // return: 3
  // line_end_width: 4
  // arguments: 5
  // len: 6
  // do_use_multiple_lines: 7
  // total_length: 8
  // strings: 9
  // do_skip_next: 10
  // buf: 11
  frame->slots[3] /* return */ = create_continuation();
  // _define $line_end_width line_end_expression_width
  frame->slots[4] /* line_end_width */ = get__line_end_expression_width();
  frame->slots[5] /* arguments */ = create_future();
  frame->slots[6] /* len */ = create_future();
  frame->slots[7] /* do_use_multiple_lines */ = create_cell();
  frame->slots[8] /* total_length */ = create_cell();
  frame->slots[9] /* strings */ = create_cell();
  frame->slots[10] /* do_skip_next */ = create_cell();
  frame->slots[11] /* buf */ = create_cell();
  if (argument_count != 3) {
    invalid_arguments_error();
    return;
  }
  frame->slots[2] /* available_width */ = create_cell_with_contents(arguments->slots[2]);
  // 566: $arguments all_arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._all_arguments_of;
  func = myself->type;
  frame->cont = cont__45_2;
}
static void cont__45_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* arguments */, arguments->slots[0]);
  // 567: ... arguments.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* arguments */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__45_3;
}
static void cont__45_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__1 */ = arguments->slots[0];
  // 567: ... : return ""
  frame->slots[13] /* temp__2 */ = create_closure(entry__45_4, 0);
  // 567: if arguments.is_empty: return ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__1 */;
  arguments->slots[1] = frame->slots[13] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_5;
}
static void entry__45_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 567: ... return ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__45_5(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 568: $len length_of(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_6;
}
static void cont__45_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* len */, arguments->slots[0]);
  // 569: $$do_use_multiple_lines false
  ((CELL *)frame->slots[7])->contents /* do_use_multiple_lines */ = get__false();
  // 570: $$total_length 0
  ((CELL *)frame->slots[8])->contents /* total_length */ = number__0;
  // 571: $$strings empty_list
  ((CELL *)frame->slots[9])->contents /* strings */ = get__empty_list();
  // 572: $$do_skip_next false
  ((CELL *)frame->slots[10])->contents /* do_skip_next */ = get__false();
  // 573: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_7;
}
static void cont__45_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__2 */ = arguments->slots[0];
  // 573: ... arguments(1).is_an_attribute_value_pair
  frame->slots[14] /* temp__3 */ = create_closure(entry__45_8, 0);
  // 573: ... mode == PROC && arguments(1).is_an_attribute_value_pair
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__2 */;
  arguments->slots[1] = frame->slots[14] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_11;
}
static void entry__45_8(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 573: ... arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__45_9;
}
static void cont__45_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 573: ... arguments(1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_attribute_value_pair();
  func = myself->type;
  frame->cont = cont__45_10;
}
static void cont__45_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 573: ... arguments(1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__1 */ = arguments->slots[0];
  // 573: ... :
  // 574:   !do_use_multiple_lines true
  frame->slots[15] /* temp__4 */ = create_closure(entry__45_12, 0);
  // 573: if mode == PROC && arguments(1).is_an_attribute_value_pair:
  // 574:   !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__1 */;
  arguments->slots[1] = frame->slots[15] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_13;
}
static void entry__45_12(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 574: !do_use_multiple_lines true
  ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 575: ... : (idx argument)
  // 576:   if
  // 577:     do_skip_next:
  // 578:       !do_skip_next false
  // 579:     :
  // 580:       $remark_lines_behind remark_lines_behind_of(argument)
  // 581:       
  // 582:       %line_end_expression_width
  // 583:         if
  // 584:           &&
  // ...
  frame->slots[12] /* temp__1 */ = create_closure(entry__45_14, 2);
  // 575: for_each arguments: (idx argument)
  // 576:   if
  // 577:     do_skip_next:
  // 578:       !do_skip_next false
  // 579:     :
  // 580:       $remark_lines_behind remark_lines_behind_of(argument)
  // 581:       
  // 582:       %line_end_expression_width
  // 583:         if
  // 584:           &&
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* arguments */;
  arguments->slots[1] = frame->slots[12] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__45_117;
}
static void entry__45_15(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_skip_next: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* do_skip_next */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 578: !do_skip_next false
  ((CELL *)frame->slots[0])->contents /* do_skip_next */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_16(void) {
  allocate_initialized_frame_gc(13, 20);
  // slot allocations:
  // return__1: 0
  // argument: 1
  // mode: 2
  // idx: 3
  // len: 4
  // total_length: 5
  // line_end_width: 6
  // do_use_multiple_lines: 7
  // self: 8
  // arguments: 9
  // do_skip_next: 10
  // available_width: 11
  // strings: 12
  // remark_lines_behind: 13
  // str: 14
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[2] = myself->closure.frame->slots[3]; /* mode */
  frame->slots[3] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[4] = myself->closure.frame->slots[4]; /* len */
  frame->slots[5] = myself->closure.frame->slots[5]; /* total_length */
  frame->slots[6] = myself->closure.frame->slots[6]; /* line_end_width */
  frame->slots[7] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  frame->slots[8] = myself->closure.frame->slots[8]; /* self */
  frame->slots[9] = myself->closure.frame->slots[9]; /* arguments */
  frame->slots[10] = myself->closure.frame->slots[2]; /* do_skip_next */
  frame->slots[11] = myself->closure.frame->slots[10]; /* available_width */
  frame->slots[12] = myself->closure.frame->slots[11]; /* strings */
  frame->slots[13] /* remark_lines_behind */ = create_future();
  define__line_end_expression_width(create_future());
  frame->slots[14] /* str */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 580: $remark_lines_behind remark_lines_behind_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__remark_lines_behind_of();
  func = myself->type;
  frame->cont = cont__45_17;
}
static void cont__45_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[13] /* remark_lines_behind */, arguments->slots[0]);
  // 585: mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_18;
}
static void cont__45_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[16] /* temp__2 */ = arguments->slots[0];
  frame->slots[17] /* temp__3 */ = create_closure(entry__45_19, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* temp__2 */;
  arguments->slots[1] = frame->slots[17] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_35;
}
static void entry__45_19(void) {
  allocate_initialized_frame_gc(6, 9);
  // slot allocations:
  // idx: 0
  // len: 1
  // total_length: 2
  // line_end_width: 3
  // do_use_multiple_lines: 4
  // self: 5
  frame->slots[0] = myself->closure.frame->slots[3]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[4]; /* len */
  frame->slots[2] = myself->closure.frame->slots[5]; /* total_length */
  frame->slots[3] = myself->closure.frame->slots[6]; /* line_end_width */
  frame->slots[4] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  frame->slots[5] = myself->closure.frame->slots[8]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 586: idx == len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[1] /* len */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_20;
}
static void cont__45_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  frame->slots[8] /* temp__3 */ = create_closure(entry__45_21, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_34;
}
static void entry__45_21(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // total_length: 0
  // line_end_width: 1
  // do_use_multiple_lines: 2
  // self: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_length */
  frame->slots[1] = myself->closure.frame->slots[3]; /* line_end_width */
  frame->slots[2] = myself->closure.frame->slots[4]; /* do_use_multiple_lines */
  frame->slots[3] = myself->closure.frame->slots[5]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 587: total_length < line_end_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  arguments->slots[1] = frame->slots[1] /* line_end_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_22;
}
static void cont__45_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  frame->slots[6] /* temp__3 */ = create_closure(entry__45_23, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_33;
}
static void entry__45_23(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // do_use_multiple_lines: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* do_use_multiple_lines */
  frame->slots[1] = myself->closure.frame->slots[3]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 588: not(do_use_multiple_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__45_24;
}
static void cont__45_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__3 */ = create_closure(entry__45_25, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_32;
}
static void entry__45_25(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 589: remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__45_26;
}
static void cont__45_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 589: remark_lines_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__45_27;
}
static void cont__45_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 590: remark_lines_behind_of(self).is_empty
  frame->slots[4] /* temp__4 */ = create_closure(entry__45_28, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_31;
}
static void entry__45_28(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 590: remark_lines_behind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_behind_of();
  func = myself->type;
  frame->cont = cont__45_29;
}
static void cont__45_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 590: remark_lines_behind_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__45_30;
}
static void cont__45_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 590: remark_lines_behind_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  // 591: -> line_end_width-total_length
  frame->slots[18] /* temp__4 */ = create_closure(entry__45_36, 0);
  // 582: %line_end_expression_width
  // 583:   if
  // 584:     &&
  // 585:       mode == PROC
  // 586:       idx == len
  // 587:       total_length < line_end_width
  // 588:       not(do_use_multiple_lines)
  // 589:       remark_lines_of(self).is_empty
  // 590:       remark_lines_behind_of(self).is_empty
  // 591:     -> line_end_width-total_length
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[18] /* temp__4 */;
  arguments->slots[2] = func__45_38;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_39;
}
static void entry__45_36(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // line_end_width: 0
  // total_length: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* line_end_width */
  frame->slots[1] = myself->closure.frame->slots[5]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 591: ... line_end_width-total_length
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line_end_width */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* total_length */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__45_37;
}
static void cont__45_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 591: -> line_end_width-total_length
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_38(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 592: -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 594: $$str argument_to_string(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = var._argument_to_string;
  func = myself->type;
  frame->cont = cont__45_40;
}
static void cont__45_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[14])->contents /* str */ = arguments->slots[0];
  // 597: str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[14])->contents /* str */;
  func = myself->type;
  frame->cont = cont__45_41;
}
static void cont__45_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__3 */ = arguments->slots[0];
  // 597: str(1) == '!'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__3 */;
  arguments->slots[1] = character__33;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_42;
}
static void cont__45_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[16] /* temp__2 */ = arguments->slots[0];
  frame->slots[18] /* temp__4 */ = create_closure(entry__45_43, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* temp__2 */;
  arguments->slots[1] = frame->slots[18] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_52;
}
static void entry__45_43(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // idx: 0
  // len: 1
  // arguments: 2
  // argument: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[4]; /* len */
  frame->slots[2] = myself->closure.frame->slots[9]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[1]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 598: idx < len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[1] /* len */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_44;
}
static void cont__45_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 599: enumeration_no_of(arguments(idx+1)) == enumeration_no_of(argument)
  frame->slots[6] /* temp__3 */ = create_closure(entry__45_45, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_51;
}
static void entry__45_45(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // arguments: 0
  // idx: 1
  // argument: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[3]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 599: ... idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__45_46;
}
static void cont__45_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 599: ... arguments(idx+1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__45_47;
}
static void cont__45_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 599: enumeration_no_of(arguments(idx+1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__enumeration_no_of();
  func = myself->type;
  frame->cont = cont__45_48;
}
static void cont__45_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 599: ... enumeration_no_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* argument */;
  result_count = 1;
  myself = get__enumeration_no_of();
  func = myself->type;
  frame->cont = cont__45_49;
}
static void cont__45_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  // 599: enumeration_no_of(arguments(idx+1)) == enumeration_no_of(argument)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_50;
}
static void cont__45_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 599: enumeration_no_of(arguments(idx+1)) == enumeration_no_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  // 600: :
  // 601:   !str(1) '&'
  // 602:   !do_skip_next true
  frame->slots[19] /* temp__5 */ = create_closure(entry__45_53, 0);
  // 595: if
  // 596:   &&
  // 597:     str(1) == '!'
  // 598:     idx < len
  // 599:     enumeration_no_of(arguments(idx+1)) == enumeration_no_of(argument)
  // 600:   :
  // 601:     !str(1) '&'
  // 602:     !do_skip_next true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[19] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_55;
}
static void entry__45_53(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // str: 0
  // do_skip_next: 1
  frame->slots[0] = myself->closure.frame->slots[14]; /* str */
  frame->slots[1] = myself->closure.frame->slots[10]; /* do_skip_next */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 601: !str(1) '&'
  frame->slots[2] /* temp__1 */ = character__38;
  // 601: !str(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* str */;
  func = myself->type;
  frame->cont = cont__45_54;
}
static void cont__45_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* str */ = arguments->slots[0];
  // 602: !do_skip_next true
  ((CELL *)frame->slots[1])->contents /* do_skip_next */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_55(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 604: str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[14])->contents /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__45_56;
}
static void cont__45_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  // 604: ... :
  // 605:   if str(1) == '@nl;': !do_use_multiple_lines true
  frame->slots[16] /* temp__2 */ = create_closure(entry__45_57, 0);
  // 606: :
  // 607:   if
  // 608:     idx < len: # not the last argument
  // 609:       if mode == PROC || idx > 1: inc &total_length # separating space
  // 610:       plus &total_length length_of(str)
  // 611:       if str .has_prefix. "->":
  // 612:         plus &total_length 2 # needs parentheses
  // 613:       if total_length > available_width: !do_use_multiple_lines true
  // 614:     : # last argument
  // 615:       if (mode == PROC || idx > 1) && str(1) != ':':
  // ...
  frame->slots[17] /* temp__3 */ = create_closure(entry__45_61, 0);
  // 603: if
  // 604:   str .contains. '@nl;':
  // 605:     if str(1) == '@nl;': !do_use_multiple_lines true
  // 606:   :
  // 607:     if
  // 608:       idx < len: # not the last argument
  // 609:         if mode == PROC || idx > 1: inc &total_length # separating space
  // 610:         plus &total_length length_of(str)
  // 611:         if str .has_prefix. "->":
  // 612:           plus &total_length 2 # needs parentheses
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[16] /* temp__2 */;
  arguments->slots[2] = frame->slots[17] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_97;
}
static void entry__45_96(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 618: ... !do_use_multiple_lines true
  ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_79(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 613: ... !do_use_multiple_lines true
  ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_63(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // mode: 0
  // idx: 1
  // total_length: 2
  // str: 3
  // available_width: 4
  // do_use_multiple_lines: 5
  frame->slots[0] = myself->closure.frame->slots[2]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[3]; /* total_length */
  frame->slots[3] = myself->closure.frame->slots[4]; /* str */
  frame->slots[4] = myself->closure.frame->slots[5]; /* available_width */
  frame->slots[5] = myself->closure.frame->slots[6]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 609: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_64;
}
static void cont__45_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 609: ... idx > 1
  frame->slots[8] /* temp__3 */ = create_closure(entry__45_65, 0);
  // 609: ... mode == PROC || idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__45_67;
}
static void entry__45_65(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // idx: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 609: ... idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_66;
}
static void cont__45_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 609: ... idx > 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 609: ... : inc &total_length # separating space
  frame->slots[9] /* temp__4 */ = create_closure(entry__45_68, 0);
  // 609: if mode == PROC || idx > 1: inc &total_length # separating space
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_70;
}
static void entry__45_68(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_length: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 609: ... inc &total_length # separating space
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__45_69;
}
static void cont__45_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_length */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_70(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 610: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_71;
}
static void cont__45_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 610: plus &total_length length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_length */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__45_72;
}
static void cont__45_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* total_length */ = arguments->slots[0];
  // 611: ... str .has_prefix. "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* str */;
  arguments->slots[1] = string__45_73;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__45_74;
}
static void cont__45_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 611: ... :
  // 612:   plus &total_length 2 # needs parentheses
  frame->slots[7] /* temp__2 */ = create_closure(entry__45_75, 0);
  // 611: if str .has_prefix. "->":
  // 612:   plus &total_length 2 # needs parentheses
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_77;
}
static void entry__45_75(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_length: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 612: plus &total_length 2 # needs parentheses
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__45_76;
}
static void cont__45_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_length */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_77(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 613: ... total_length > available_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* available_width */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_length */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_78;
}
static void cont__45_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 613: ... : !do_use_multiple_lines true
  frame->slots[7] /* temp__2 */ = create_closure(entry__45_79, 0);
  // 613: if total_length > available_width: !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_80(void) {
  allocate_initialized_frame_gc(6, 12);
  // slot allocations:
  // mode: 0
  // idx: 1
  // str: 2
  // total_length: 3
  // available_width: 4
  // do_use_multiple_lines: 5
  frame->slots[0] = myself->closure.frame->slots[2]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[4]; /* str */
  frame->slots[3] = myself->closure.frame->slots[3]; /* total_length */
  frame->slots[4] = myself->closure.frame->slots[5]; /* available_width */
  frame->slots[5] = myself->closure.frame->slots[6]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 615: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_81;
}
static void cont__45_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 615: ... idx > 1
  frame->slots[9] /* temp__4 */ = create_closure(entry__45_82, 0);
  // 615: ... mode == PROC || idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__3 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__45_84;
}
static void entry__45_82(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // idx: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 615: ... idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_83;
}
static void cont__45_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 615: ... idx > 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 615: ... str(1) != ':'
  frame->slots[10] /* temp__5 */ = create_closure(entry__45_85, 0);
  // 615: ... mode == PROC || idx > 1) && str(1) != ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[10] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_89;
}
static void entry__45_85(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 615: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* str */;
  func = myself->type;
  frame->cont = cont__45_86;
}
static void cont__45_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 615: ... str(1) != ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_87;
}
static void cont__45_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 615: ... str(1) != ':'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__45_88;
}
static void cont__45_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 615: ... str(1) != ':'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 615: ... :
  // 616:   inc &total_length # separating space
  frame->slots[11] /* temp__6 */ = create_closure(entry__45_90, 0);
  // 615: if (mode == PROC || idx > 1) && str(1) != ':':
  // 616:   inc &total_length # separating space
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__6 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_92;
}
static void entry__45_90(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_length: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 616: inc &total_length # separating space
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__45_91;
}
static void cont__45_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_length */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_92(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 617: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_93;
}
static void cont__45_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 617: plus &total_length length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* total_length */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__45_94;
}
static void cont__45_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* total_length */ = arguments->slots[0];
  // 618: ... total_length > available_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* available_width */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* total_length */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_95;
}
static void cont__45_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 618: ... : !do_use_multiple_lines true
  frame->slots[7] /* temp__2 */ = create_closure(entry__45_96, 0);
  // 618: if total_length > available_width: !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_60(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 605: ... !do_use_multiple_lines true
  ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_57(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // str: 0
  // do_use_multiple_lines: 1
  frame->slots[0] = myself->closure.frame->slots[14]; /* str */
  frame->slots[1] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 605: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* str */;
  func = myself->type;
  frame->cont = cont__45_58;
}
static void cont__45_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 605: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_59;
}
static void cont__45_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 605: ... : !do_use_multiple_lines true
  frame->slots[4] /* temp__3 */ = create_closure(entry__45_60, 0);
  // 605: if str(1) == '@nl;': !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_61(void) {
  allocate_initialized_frame_gc(7, 10);
  // slot allocations:
  // idx: 0
  // len: 1
  // mode: 2
  // total_length: 3
  // str: 4
  // available_width: 5
  // do_use_multiple_lines: 6
  frame->slots[0] = myself->closure.frame->slots[3]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[4]; /* len */
  frame->slots[2] = myself->closure.frame->slots[2]; /* mode */
  frame->slots[3] = myself->closure.frame->slots[5]; /* total_length */
  frame->slots[4] = myself->closure.frame->slots[14]; /* str */
  frame->slots[5] = myself->closure.frame->slots[11]; /* available_width */
  frame->slots[6] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 608: idx < len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[1] /* len */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_62;
}
static void cont__45_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 608: ... : # not the last argument
  // 609:   if mode == PROC || idx > 1: inc &total_length # separating space
  // 610:   plus &total_length length_of(str)
  // 611:   if str .has_prefix. "->":
  // 612:     plus &total_length 2 # needs parentheses
  // 613:   if total_length > available_width: !do_use_multiple_lines true
  frame->slots[8] /* temp__2 */ = create_closure(entry__45_63, 0);
  // 614: : # last argument
  // 615:   if (mode == PROC || idx > 1) && str(1) != ':':
  // 616:     inc &total_length # separating space
  // 617:   plus &total_length length_of(str)
  // 618:   if total_length > available_width: !do_use_multiple_lines true
  frame->slots[9] /* temp__3 */ = create_closure(entry__45_80, 0);
  // 607: if
  // 608:   idx < len: # not the last argument
  // 609:     if mode == PROC || idx > 1: inc &total_length # separating space
  // 610:     plus &total_length length_of(str)
  // 611:     if str .has_prefix. "->":
  // 612:       plus &total_length 2 # needs parentheses
  // 613:     if total_length > available_width: !do_use_multiple_lines true
  // 614:   : # last argument
  // 615:     if (mode == PROC || idx > 1) && str(1) != ':':
  // 616:       inc &total_length # separating space
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__45_97(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 619: push &strings str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* strings */;
  arguments->slots[1] = ((CELL *)frame->slots[14])->contents /* str */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_98;
}
static void cont__45_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[12])->contents /* strings */ = arguments->slots[0];
  // 620: ... remark_lines_behind.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* remark_lines_behind */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__45_99;
}
static void cont__45_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  // 620: ... :
  // 621:   $$remark add_remark_lines("" remark_lines_behind)
  // 622:   if remark(1) != '@nl;':
  // 623:     !remark string('@nl;' spaces(expression_indent) remark)
  // 624:   push &strings string('@nl;' remark)
  // 625:   if idx < len: push &strings "@nl;" # empty line behind
  // 626:   !do_use_multiple_lines true
  frame->slots[16] /* temp__2 */ = create_closure(entry__45_100, 0);
  // 620: unless remark_lines_behind.is_empty:
  // 621:   $$remark add_remark_lines("" remark_lines_behind)
  // 622:   if remark(1) != '@nl;':
  // 623:     !remark string('@nl;' spaces(expression_indent) remark)
  // 624:   push &strings string('@nl;' remark)
  // 625:   if idx < len: push &strings "@nl;" # empty line behind
  // 626:   !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[16] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__45_116;
}
static void entry__45_100(void) {
  allocate_initialized_frame_gc(5, 10);
  // slot allocations:
  // remark_lines_behind: 0
  // strings: 1
  // idx: 2
  // len: 3
  // do_use_multiple_lines: 4
  // remark: 5
  frame->slots[0] = myself->closure.frame->slots[13]; /* remark_lines_behind */
  frame->slots[1] = myself->closure.frame->slots[12]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[3]; /* idx */
  frame->slots[3] = myself->closure.frame->slots[4]; /* len */
  frame->slots[4] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  frame->slots[5] /* remark */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 621: $$remark add_remark_lines("" remark_lines_behind)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  arguments->slots[1] = frame->slots[0] /* remark_lines_behind */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__45_101;
}
static void cont__45_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* remark */ = arguments->slots[0];
  // 622: ... remark(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[5])->contents /* remark */;
  func = myself->type;
  frame->cont = cont__45_102;
}
static void cont__45_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 622: ... remark(1) != '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__3 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_103;
}
static void cont__45_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 622: ... remark(1) != '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__45_104;
}
static void cont__45_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 622: ... :
  // 623:   !remark string('@nl;' spaces(expression_indent) remark)
  frame->slots[9] /* temp__4 */ = create_closure(entry__45_105, 0);
  // 622: if remark(1) != '@nl;':
  // 623:   !remark string('@nl;' spaces(expression_indent) remark)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_108;
}
static void entry__45_105(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // remark: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* remark */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 623: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__45_106;
}
static void cont__45_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 623: !remark string('@nl;' spaces(expression_indent) remark)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* remark */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__45_107;
}
static void cont__45_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* remark */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_108(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 624: ... string('@nl;' remark)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = ((CELL *)frame->slots[5])->contents /* remark */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__45_109;
}
static void cont__45_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 624: push &strings string('@nl;' remark)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_110;
}
static void cont__45_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* strings */ = arguments->slots[0];
  // 625: ... idx < len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* idx */;
  arguments->slots[1] = frame->slots[3] /* len */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_111;
}
static void cont__45_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 625: ... : push &strings "@nl;" # empty line behind
  frame->slots[7] /* temp__2 */ = create_closure(entry__45_112, 0);
  // 625: if idx < len: push &strings "@nl;" # empty line behind
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_115;
}
static void entry__45_112(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // strings: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* strings */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 625: ... push &strings "@nl;" # empty line behind
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = string__45_113;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_114;
}
static void cont__45_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_115(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 626: !do_use_multiple_lines true
  ((CELL *)frame->slots[4])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_116(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__45_14(void) {
  allocate_initialized_frame_gc(12, 14);
  // slot allocations:
  // idx: 0
  // argument: 1
  // do_skip_next: 2
  // mode: 3
  // len: 4
  // total_length: 5
  // line_end_width: 6
  // do_use_multiple_lines: 7
  // self: 8
  // arguments: 9
  // available_width: 10
  // strings: 11
  frame->slots[2] = myself->closure.frame->slots[10]; /* do_skip_next */
  frame->slots[3] = myself->closure.frame->slots[1]; /* mode */
  frame->slots[4] = myself->closure.frame->slots[6]; /* len */
  frame->slots[5] = myself->closure.frame->slots[8]; /* total_length */
  frame->slots[6] = myself->closure.frame->slots[4]; /* line_end_width */
  frame->slots[7] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  frame->slots[8] = myself->closure.frame->slots[0]; /* self */
  frame->slots[9] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[10] = myself->closure.frame->slots[2]; /* available_width */
  frame->slots[11] = myself->closure.frame->slots[9]; /* strings */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 577: ... :
  // 578:   !do_skip_next false
  frame->slots[12] /* temp__1 */ = create_closure(entry__45_15, 0);
  // 579: :
  // 580:   $remark_lines_behind remark_lines_behind_of(argument)
  // 581:   
  // 582:   %line_end_expression_width
  // 583:     if
  // 584:       &&
  // 585:         mode == PROC
  // 586:         idx == len
  // 587:         total_length < line_end_width
  // 588:         not(do_use_multiple_lines)
  // ...
  frame->slots[13] /* temp__2 */ = create_closure(entry__45_16, 0);
  // 576: if
  // 577:   do_skip_next:
  // 578:     !do_skip_next false
  // 579:   :
  // 580:     $remark_lines_behind remark_lines_behind_of(argument)
  // 581:     
  // 582:     %line_end_expression_width
  // 583:       if
  // 584:         &&
  // 585:           mode == PROC
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* do_skip_next */;
  arguments->slots[1] = frame->slots[12] /* temp__1 */;
  arguments->slots[2] = frame->slots[13] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__45_117(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 630: mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_118;
}
static void cont__45_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__3 */ = arguments->slots[0];
  // 631: remark_lines_of(self).is_empty || not(do_use_multiple_lines)
  frame->slots[15] /* temp__4 */ = create_closure(entry__45_119, 0);
  // 629: &&
  // 630:   mode == PROC
  // 631:   remark_lines_of(self).is_empty || not(do_use_multiple_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[14] /* temp__3 */;
  arguments->slots[1] = frame->slots[15] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_125;
}
static void entry__45_119(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // self: 0
  // do_use_multiple_lines: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 631: remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__45_120;
}
static void cont__45_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 631: remark_lines_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__45_121;
}
static void cont__45_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 631: ... not(do_use_multiple_lines)
  frame->slots[5] /* temp__4 */ = create_closure(entry__45_122, 0);
  // 631: remark_lines_of(self).is_empty || not(do_use_multiple_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__45_124;
}
static void entry__45_122(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 631: ... not(do_use_multiple_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__45_123;
}
static void cont__45_123(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 631: ... not(do_use_multiple_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 631: remark_lines_of(self).is_empty || not(do_use_multiple_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__2 */ = arguments->slots[0];
  // 632: mode == FUNC && remark_lines_behind_of(functor_of(self)).is_empty
  frame->slots[16] /* temp__5 */ = create_closure(entry__45_126, 0);
  // 628: ||
  // 629:   &&
  // 630:     mode == PROC
  // 631:     remark_lines_of(self).is_empty || not(do_use_multiple_lines)
  // 632:   mode == FUNC && remark_lines_behind_of(functor_of(self)).is_empty
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__2 */;
  arguments->slots[1] = frame->slots[16] /* temp__5 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__45_133;
}
static void entry__45_126(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // mode: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 632: mode == FUNC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._FUNC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_127;
}
static void cont__45_127(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 632: ... remark_lines_behind_of(functor_of(self)).is_empty
  frame->slots[4] /* temp__3 */ = create_closure(entry__45_128, 0);
  // 632: mode == FUNC && remark_lines_behind_of(functor_of(self)).is_empty
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_132;
}
static void entry__45_128(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 632: ... functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__45_129;
}
static void cont__45_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 632: ... remark_lines_behind_of(functor_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__remark_lines_behind_of();
  func = myself->type;
  frame->cont = cont__45_130;
}
static void cont__45_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 632: ... remark_lines_behind_of(functor_of(self)).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__45_131;
}
static void cont__45_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 632: ... remark_lines_behind_of(functor_of(self)).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 632: mode == FUNC && remark_lines_behind_of(functor_of(self)).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__1 */ = arguments->slots[0];
  // 633: :
  // 634:   put &strings "@nl;" # prepend an empty line
  // 635:   !do_use_multiple_lines true
  frame->slots[17] /* temp__6 */ = create_closure(entry__45_134, 0);
  // 627: unless
  // 628:   ||
  // 629:     &&
  // 630:       mode == PROC
  // 631:       remark_lines_of(self).is_empty || not(do_use_multiple_lines)
  // 632:     mode == FUNC && remark_lines_behind_of(functor_of(self)).is_empty
  // 633:   :
  // 634:     put &strings "@nl;" # prepend an empty line
  // 635:     !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__1 */;
  arguments->slots[1] = frame->slots[17] /* temp__6 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__45_137;
}
static void entry__45_134(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // strings: 0
  // do_use_multiple_lines: 1
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 634: put &strings "@nl;" # prepend an empty line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = string__45_135;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__45_136;
}
static void cont__45_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  // 635: !do_use_multiple_lines true
  ((CELL *)frame->slots[1])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_137(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 636: $$buf ""
  ((CELL *)frame->slots[11])->contents /* buf */ = empty_string;
  // 638: ... :
  // 639:   # spread arguments over multiple lines
  // 640:   
  // 641:   $indentation spaces(expression_indent)
  // 642:   if mode == PROC:
  // 643:     while
  // 644:       # append output parameters to the starting line
  // 645:       
  // 646:       ->
  // 647:         &&
  // ...
  frame->slots[12] /* temp__1 */ = create_closure(entry__45_138, 0);
  // 683: :
  // 684:   # all arguments on a single line (and maybe a line-end-expression)
  // 685:   
  // 686:   $n length_of(strings)
  // 687:   for_each strings: (idx str)
  // 688:     unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  // 689:     if
  // 690:       idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 691:         push &buf '('
  // 692:         append &buf str
  // ...
  frame->slots[13] /* temp__2 */ = create_closure(entry__45_219, 0);
  // 637: if
  // 638:   do_use_multiple_lines:
  // 639:     # spread arguments over multiple lines
  // 640:     
  // 641:     $indentation spaces(expression_indent)
  // 642:     if mode == PROC:
  // 643:       while
  // 644:         # append output parameters to the starting line
  // 645:         
  // 646:         ->
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[7])->contents /* do_use_multiple_lines */;
  arguments->slots[1] = frame->slots[12] /* temp__1 */;
  arguments->slots[2] = frame->slots[13] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_249;
}
static void entry__45_243(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 691: push &buf '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_244;
}
static void cont__45_244(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 692: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__45_245;
}
static void cont__45_245(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 693: push &buf ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_246;
}
static void cont__45_246(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_247(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 695: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__45_248;
}
static void cont__45_248(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_221(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // idx: 0
  // str: 1
  // buf: 2
  // n: 3
  frame->slots[2] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[2]; /* n */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 688: ... buf.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__45_222;
}
static void cont__45_222(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 688: ... str(1) == ':' || str(1) == '@nl;'
  frame->slots[6] /* temp__3 */ = create_closure(entry__45_223, 0);
  // 688: ... buf.is_empty || str(1) == ':' || str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__45_230;
}
static void entry__45_223(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 688: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__45_224;
}
static void cont__45_224(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 688: ... str(1) == ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_225;
}
static void cont__45_225(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 688: ... str(1) == '@nl;'
  frame->slots[4] /* temp__4 */ = create_closure(entry__45_226, 0);
  // 688: ... str(1) == ':' || str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__45_229;
}
static void entry__45_226(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 688: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__45_227;
}
static void cont__45_227(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 688: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_228;
}
static void cont__45_228(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 688: ... str(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_229(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 688: ... str(1) == ':' || str(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_230(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 688: ... : push &buf ' '
  frame->slots[7] /* temp__4 */ = create_closure(entry__45_231, 0);
  // 688: unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__45_233;
}
static void entry__45_231(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 688: ... push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_232;
}
static void cont__45_232(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_233(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 690: idx < n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[3] /* n */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_234;
}
static void cont__45_234(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 690: ... str .has_prefix. "->" && not(str .contains. '@nl;')
  frame->slots[6] /* temp__3 */ = create_closure(entry__45_235, 0);
  // 690: idx < n && str .has_prefix. "->" && not(str .contains. '@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_242;
}
static void entry__45_235(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 690: ... str .has_prefix. "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__45_236;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__45_237;
}
static void cont__45_237(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 690: ... not(str .contains. '@nl;')
  frame->slots[3] /* temp__3 */ = create_closure(entry__45_238, 0);
  // 690: ... str .has_prefix. "->" && not(str .contains. '@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_241;
}
static void entry__45_238(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 690: ... str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__45_239;
}
static void cont__45_239(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 690: ... not(str .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__45_240;
}
static void cont__45_240(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 690: ... not(str .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_241(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 690: ... str .has_prefix. "->" && not(str .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 690: ... :
  // 691:   push &buf '('
  // 692:   append &buf str
  // 693:   push &buf ')'
  frame->slots[7] /* temp__4 */ = create_closure(entry__45_243, 0);
  // 694: :
  // 695:   append &buf str
  frame->slots[8] /* temp__5 */ = create_closure(entry__45_247, 0);
  // 689: if
  // 690:   idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 691:     push &buf '('
  // 692:     append &buf str
  // 693:     push &buf ')'
  // 694:   :
  // 695:     append &buf str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_198(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 673: ... str .from. ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__from();
  func = myself->type;
  frame->cont = cont__45_199;
}
static void cont__45_199(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 673: append &buf str .from. ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__45_200;
}
static void cont__45_200(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_201(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 675: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__45_202;
}
static void cont__45_202(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_174(void) {
  allocate_initialized_frame_gc(4, 10);
  // slot allocations:
  // str: 0
  // idx: 1
  // strings: 2
  // buf: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[3]; /* strings */
  frame->slots[3] = myself->closure.frame->slots[4]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 664: ... '@nl;', INDENTATION, ':'
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = var._INDENTATION;
  arguments->slots[2] = character__58;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__45_175;
}
static void cont__45_175(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 664: str .has_prefix. ('@nl;', INDENTATION, ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__45_176;
}
static void cont__45_176(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__4 */ = create_closure(entry__45_177, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_197;
}
static void entry__45_177(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // idx: 0
  // strings: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[2]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 665: idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_178;
}
static void cont__45_178(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 665: ... not(strings(idx-1) .contains. '@nl;')
  frame->slots[6] /* temp__4 */ = create_closure(entry__45_179, 0);
  // 665: idx > 1 && not(strings(idx-1) .contains. '@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_184;
}
static void entry__45_179(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // strings: 0
  // idx: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 665: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__45_180;
}
static void cont__45_180(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 665: ... strings(idx-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__45_181;
}
static void cont__45_181(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 665: ... strings(idx-1) .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__45_182;
}
static void cont__45_182(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 665: ... not(strings(idx-1) .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__45_183;
}
static void cont__45_183(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 665: ... not(strings(idx-1) .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_184(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 666: <=
  // 667:   +
  // 668:     expression_indent
  // 669:     length_of(strings(idx-1))
  // 670:     length_of(str .from. ':' .truncate_from. '@nl;')
  // 671:   line_width
  frame->slots[7] /* temp__5 */ = create_closure(entry__45_185, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_196;
}
static void entry__45_185(void) {
  allocate_initialized_frame_gc(3, 13);
  // slot allocations:
  // strings: 0
  // idx: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 669: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__45_186;
}
static void cont__45_186(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__7 */ = arguments->slots[0];
  // 669: ... strings(idx-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__7 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__45_187;
}
static void cont__45_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__6 */ = arguments->slots[0];
  // 669: length_of(strings(idx-1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__6 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_188;
}
static void cont__45_188(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__45_189;
}
static void cont__45_189(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 670: ... str .from. ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__from();
  func = myself->type;
  frame->cont = cont__45_190;
}
static void cont__45_190(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__10 */ = arguments->slots[0];
  // 670: ... str .from. ':' .truncate_from. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__10 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__truncate_from();
  func = myself->type;
  frame->cont = cont__45_191;
}
static void cont__45_191(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__9 */ = arguments->slots[0];
  // 670: length_of(str .from. ':' .truncate_from. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__9 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_192;
}
static void cont__45_192(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__8 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  arguments->slots[1] = frame->slots[10] /* temp__8 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__45_193;
}
static void cont__45_193(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 666: <=
  // 667:   +
  // 668:     expression_indent
  // 669:     length_of(strings(idx-1))
  // 670:     length_of(str .from. ':' .truncate_from. '@nl;')
  // 671:   line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_194;
}
static void cont__45_194(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 666: <=
  // 667:   +
  // 668:     expression_indent
  // 669:     length_of(strings(idx-1))
  // 670:     length_of(str .from. ':' .truncate_from. '@nl;')
  // 671:   line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__45_195;
}
static void cont__45_195(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 666: <=
  // 667:   +
  // 668:     expression_indent
  // 669:     length_of(strings(idx-1))
  // 670:     length_of(str .from. ':' .truncate_from. '@nl;')
  // 671:   line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_196(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_197(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 672: :
  // 673:   append &buf str .from. ':'
  frame->slots[8] /* temp__5 */ = create_closure(entry__45_198, 0);
  // 674: :
  // 675:   append &buf str
  frame->slots[9] /* temp__6 */ = create_closure(entry__45_201, 0);
  // 662: if
  // 663:   &&
  // 664:     str .has_prefix. ('@nl;', INDENTATION, ':')
  // 665:     idx > 1 && not(strings(idx-1) .contains. '@nl;')
  // 666:     <=
  // 667:       +
  // 668:         expression_indent
  // 669:         length_of(strings(idx-1))
  // 670:         length_of(str .from. ':' .truncate_from. '@nl;')
  // 671:       line_width
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  arguments->slots[2] = frame->slots[9] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_203(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // str: 0
  // buf: 1
  // indentation: 2
  // line_end_conversion_is_allowed: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[5]; /* indentation */
  frame->slots[3] = myself->closure.frame->slots[2]; /* line_end_conversion_is_allowed */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 677: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__45_204;
}
static void cont__45_204(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 677: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_205;
}
static void cont__45_205(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 677: ... :
  // 678:   push &buf '@nl;'
  // 679:   append &buf indentation
  frame->slots[6] /* temp__3 */ = create_closure(entry__45_206, 0);
  // 677: unless str(1) == '@nl;':
  // 678:   push &buf '@nl;'
  // 679:   append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__45_209;
}
static void entry__45_206(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 678: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_207;
}
static void cont__45_207(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 679: append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__45_208;
}
static void cont__45_208(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_209(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 680: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__45_210;
}
static void cont__45_210(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 682: str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__45_211;
}
static void cont__45_211(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 682: str(1) != ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_212;
}
static void cont__45_212(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 682: str(1) != ':'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__45_213;
}
static void cont__45_213(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 682: ... not(str .has_prefix. "->")
  frame->slots[7] /* temp__4 */ = create_closure(entry__45_214, 0);
  // 681: !line_end_conversion_is_allowed
  // 682:   str(1) != ':' && not(str .has_prefix. "->")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_218;
}
static void entry__45_214(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 682: ... str .has_prefix. "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__45_215;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__45_216;
}
static void cont__45_216(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 682: ... not(str .has_prefix. "->")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__45_217;
}
static void cont__45_217(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 682: ... not(str .has_prefix. "->")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_218(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* line_end_conversion_is_allowed */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_170(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // idx: 0
  // str: 1
  // line_end_conversion_is_allowed: 2
  // strings: 3
  // buf: 4
  // indentation: 5
  frame->slots[2] = myself->closure.frame->slots[5]; /* line_end_conversion_is_allowed */
  frame->slots[3] = myself->closure.frame->slots[1]; /* strings */
  frame->slots[4] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[5] = myself->closure.frame->slots[4]; /* indentation */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 659: ... str .contains. '@nl;'
  frame->slots[7] /* temp__2 */ = create_closure(entry__45_171, 0);
  // 659: line_end_conversion_is_allowed && str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* line_end_conversion_is_allowed */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_173;
}
static void entry__45_171(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 659: ... str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__45_172;
}
static void cont__45_172(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 659: ... str .contains. '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_173(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 659: ... :
  // 660:   # check for possible "line-end-form conversion"
  // 661:   
  // 662:   if
  // 663:     &&
  // 664:       str .has_prefix. ('@nl;', INDENTATION, ':')
  // 665:       idx > 1 && not(strings(idx-1) .contains. '@nl;')
  // 666:       <=
  // 667:         +
  // 668:           expression_indent
  // ...
  frame->slots[8] /* temp__3 */ = create_closure(entry__45_174, 0);
  // 676: :
  // 677:   unless str(1) == '@nl;':
  // 678:     push &buf '@nl;'
  // 679:     append &buf indentation
  // 680:   append &buf str
  // 681:   !line_end_conversion_is_allowed
  // 682:     str(1) != ':' && not(str .has_prefix. "->")
  frame->slots[9] /* temp__4 */ = create_closure(entry__45_203, 0);
  // 658: if
  // 659:   line_end_conversion_is_allowed && str .contains. '@nl;':
  // 660:     # check for possible "line-end-form conversion"
  // 661:     
  // 662:     if
  // 663:       &&
  // 664:         str .has_prefix. ('@nl;', INDENTATION, ':')
  // 665:         idx > 1 && not(strings(idx-1) .contains. '@nl;')
  // 666:         <=
  // 667:           +
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_138(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // mode: 0
  // strings: 1
  // available_width: 2
  // buf: 3
  // indentation: 4
  // line_end_conversion_is_allowed: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[2]; /* available_width */
  frame->slots[3] = myself->closure.frame->slots[11]; /* buf */
  frame->slots[4] /* indentation */ = create_future();
  frame->slots[5] /* line_end_conversion_is_allowed */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 641: $indentation spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__45_139;
}
static void cont__45_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* indentation */, arguments->slots[0]);
  // 642: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_140;
}
static void cont__45_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 642: ... :
  // 643:   while
  // 644:     # append output parameters to the starting line
  // 645:     
  // 646:     ->
  // 647:       &&
  // 648:         length_of(strings) > 0
  // 649:         strings(1) .has_prefix. alt('$' '!')
  // 650:         length_of(strings(1)) < available_width
  // 651:       :
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__45_141, 0);
  // 642: if mode == PROC:
  // 643:   while
  // 644:     # append output parameters to the starting line
  // 645:     
  // 646:     ->
  // 647:       &&
  // 648:         length_of(strings) > 0
  // 649:         strings(1) .has_prefix. alt('$' '!')
  // 650:         length_of(strings(1)) < available_width
  // 651:       :
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_169;
}
static void entry__45_155(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // buf: 0
  // strings: 1
  // available_width: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[1]; /* available_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 652: ... buf != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__45_156;
}
static void cont__45_156(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 652: ... buf != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__45_157;
}
static void cont__45_157(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 652: ... : push &buf ' '
  frame->slots[5] /* temp__3 */ = create_closure(entry__45_158, 0);
  // 652: if buf != "": push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__45_160;
}
static void entry__45_158(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 652: ... push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__45_159;
}
static void cont__45_159(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_160(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 653: ... strings(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__45_161;
}
static void cont__45_161(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 653: append &buf strings(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__45_162;
}
static void cont__45_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 654: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__45_163;
}
static void cont__45_163(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 654: range &strings 2 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__45_164;
}
static void cont__45_164(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* strings */ = arguments->slots[0];
  // 655: ... strings(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__45_165;
}
static void cont__45_165(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 655: ... length_of(strings(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_166;
}
static void cont__45_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 655: ... length_of(strings(1))+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__45_167;
}
static void cont__45_167(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 655: minus &available_width length_of(strings(1))+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* available_width */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__minus();
  func = myself->type;
  frame->cont = cont__45_168;
}
static void cont__45_168(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* available_width */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_142(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // strings: 0
  // available_width: 1
  // buf: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[1]; /* available_width */
  frame->slots[2] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 648: length_of(strings)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_143;
}
static void cont__45_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 648: length_of(strings) > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_144;
}
static void cont__45_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[6] /* temp__4 */ = create_closure(entry__45_145, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_154;
}
static void entry__45_145(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // strings: 0
  // available_width: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[1]; /* available_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 649: strings(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__45_146;
}
static void cont__45_146(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 649: ... alt('$' '!')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__36;
  arguments->slots[1] = character__33;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__45_147;
}
static void cont__45_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 649: strings(1) .has_prefix. alt('$' '!')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__45_148;
}
static void cont__45_148(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 650: length_of(strings(1)) < available_width
  frame->slots[6] /* temp__5 */ = create_closure(entry__45_149, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__45_153;
}
static void entry__45_149(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // strings: 0
  // available_width: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[1]; /* available_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 650: ... strings(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__45_150;
}
static void cont__45_150(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 650: length_of(strings(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_151;
}
static void cont__45_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 650: length_of(strings(1)) < available_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* available_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__45_152;
}
static void cont__45_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 650: length_of(strings(1)) < available_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_153(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__45_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 651: :
  // 652:   if buf != "": push &buf ' '
  // 653:   append &buf strings(1)
  // 654:   range &strings 2 -1
  // 655:   minus &available_width length_of(strings(1))+1
  frame->slots[7] /* temp__5 */ = create_closure(entry__45_155, 0);
  // 646: ->
  // 647:   &&
  // 648:     length_of(strings) > 0
  // 649:     strings(1) .has_prefix. alt('$' '!')
  // 650:     length_of(strings(1)) < available_width
  // 651:   :
  // 652:     if buf != "": push &buf ' '
  // 653:     append &buf strings(1)
  // 654:     range &strings 2 -1
  // 655:     minus &available_width length_of(strings(1))+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__45_141(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // strings: 0
  // available_width: 1
  // buf: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[2]; /* available_width */
  frame->slots[2] = myself->closure.frame->slots[3]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 646: ->
  // 647:   &&
  // 648:     length_of(strings) > 0
  // 649:     strings(1) .has_prefix. alt('$' '!')
  // 650:     length_of(strings(1)) < available_width
  // 651:   :
  // 652:     if buf != "": push &buf ' '
  // 653:     append &buf strings(1)
  // 654:     range &strings 2 -1
  // 655:     minus &available_width length_of(strings(1))+1
  frame->slots[3] /* temp__1 */ = create_closure(entry__45_142, 0);
  // 643: while
  // 644:   # append output parameters to the starting line
  // 645:   
  // 646:   ->
  // 647:     &&
  // 648:       length_of(strings) > 0
  // 649:       strings(1) .has_prefix. alt('$' '!')
  // 650:       length_of(strings(1)) < available_width
  // 651:     :
  // 652:       if buf != "": push &buf ' '
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__while();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__45_169(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 656: $$line_end_conversion_is_allowed true
  ((CELL *)frame->slots[5])->contents /* line_end_conversion_is_allowed */ = get__true();
  // 657: ... : (idx str)
  // 658:   if
  // 659:     line_end_conversion_is_allowed && str .contains. '@nl;':
  // 660:       # check for possible "line-end-form conversion"
  // 661:       
  // 662:       if
  // 663:         &&
  // 664:           str .has_prefix. ('@nl;', INDENTATION, ':')
  // 665:           idx > 1 && not(strings(idx-1) .contains. '@nl;')
  // 666:           <=
  // ...
  frame->slots[6] /* temp__1 */ = create_closure(entry__45_170, 2);
  // 657: for_each strings: (idx str)
  // 658:   if
  // 659:     line_end_conversion_is_allowed && str .contains. '@nl;':
  // 660:       # check for possible "line-end-form conversion"
  // 661:       
  // 662:       if
  // 663:         &&
  // 664:           str .has_prefix. ('@nl;', INDENTATION, ':')
  // 665:           idx > 1 && not(strings(idx-1) .contains. '@nl;')
  // 666:           <=
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__45_219(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // strings: 0
  // buf: 1
  // n: 2
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[11]; /* buf */
  frame->slots[2] /* n */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 686: $n length_of(strings)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__45_220;
}
static void cont__45_220(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* n */, arguments->slots[0]);
  // 687: ... : (idx str)
  // 688:   unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  // 689:   if
  // 690:     idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 691:       push &buf '('
  // 692:       append &buf str
  // 693:       push &buf ')'
  // 694:     :
  // 695:       append &buf str
  frame->slots[3] /* temp__1 */ = create_closure(entry__45_221, 2);
  // 687: for_each strings: (idx str)
  // 688:   unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  // 689:   if
  // 690:     idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 691:       push &buf '('
  // 692:       append &buf str
  // 693:       push &buf ')'
  // 694:     :
  // 695:       append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__45_249(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 696: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* buf */;
  myself = frame->slots[3] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__46_1(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // functor: 0
  // arguments: 1
  // remark_lines: 2
  // remark: 3
  frame->slots[3] /* remark */ = create_cell();
  if (argument_count != 3) {
    invalid_arguments_error();
    return;
  }
  frame->slots[1] /* arguments */ = create_cell_with_contents(arguments->slots[1]);
  // 699: $$remark add_remark_lines("" remark_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  arguments->slots[1] = frame->slots[2] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__46_2;
}
static void cont__46_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* remark */ = arguments->slots[0];
  // 700: ... remark(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* remark */;
  func = myself->type;
  frame->cont = cont__46_3;
}
static void cont__46_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 700: ... remark(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__46_4;
}
static void cont__46_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 700: ... :
  // 701:   !remark string('@nl;' spaces(expression_indent) remark)
  frame->slots[6] /* temp__3 */ = create_closure(entry__46_5, 0);
  // 700: unless remark(1) == '@nl;':
  // 701:   !remark string('@nl;' spaces(expression_indent) remark)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__46_8;
}
static void entry__46_5(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // remark: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* remark */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 701: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__46_6;
}
static void cont__46_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 701: !remark string('@nl;' spaces(expression_indent) remark)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* remark */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__46_7;
}
static void cont__46_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* remark */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__46_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 702: ... arguments .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__46_9;
}
static void cont__46_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 702: ... :
  // 703:   !arguments string('@nl;' spaces(expression_indent) arguments)
  frame->slots[5] /* temp__2 */ = create_closure(entry__46_10, 0);
  // 702: unless arguments .contains. '@nl;':
  // 703:   !arguments string('@nl;' spaces(expression_indent) arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__46_13;
}
static void entry__46_10(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 703: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__46_11;
}
static void cont__46_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 703: !arguments string('@nl;' spaces(expression_indent) arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__46_12;
}
static void cont__46_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__46_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 704: ... string(functor remark arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* remark */;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__46_14;
}
static void cont__46_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 704: -> string(functor remark arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_3(void) {
  allocate_initialized_frame_gc(4, 11);
  // slot allocations:
  // return__2: 0
  // self: 1
  // outer_line_end_expression_width: 2
  // indent: 3
  // has_no_remarks: 4
  // arguments: 5
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[2]; /* outer_line_end_expression_width */
  frame->slots[3] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[4] /* has_no_remarks */ = create_future();
  define__expression_indent(create_future());
  define__line_end_expression_width(create_future());
  frame->slots[5] /* arguments */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 712: remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__47_4;
}
static void cont__47_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 712: remark_lines_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__47_5;
}
static void cont__47_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 712: ... remark_lines_behind_of(self).is_empty
  frame->slots[8] /* temp__3 */ = create_closure(entry__47_6, 0);
  // 711: $has_no_remarks
  // 712:   remark_lines_of(self).is_empty && remark_lines_behind_of(self).is_empty
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__47_9;
}
static void entry__47_6(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 712: ... remark_lines_behind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* self */;
  result_count = 1;
  myself = get__remark_lines_behind_of();
  func = myself->type;
  frame->cont = cont__47_7;
}
static void cont__47_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 712: ... remark_lines_behind_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__47_8;
}
static void cont__47_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 712: ... remark_lines_behind_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* has_no_remarks */, arguments->slots[0]);
  // 716: outer_line_end_expression_width > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = frame->slots[2] /* outer_line_end_expression_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__47_10;
}
static void cont__47_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 716: ... has_no_remarks
  frame->slots[8] /* temp__3 */ = create_closure(entry__47_11, 0);
  // 716: outer_line_end_expression_width > 0 && has_no_remarks
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__47_12;
}
static void entry__47_11(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_no_remarks: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* has_no_remarks */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 716: ... has_no_remarks
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* has_no_remarks */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 717: -> indent
  frame->slots[9] /* temp__4 */ = create_closure(entry__47_13, 0);
  // 718: -> indent+2
  frame->slots[10] /* temp__5 */ = create_closure(entry__47_14, 0);
  // 714: %expression_indent
  // 715:   if
  // 716:     outer_line_end_expression_width > 0 && has_no_remarks
  // 717:     -> indent
  // 718:     -> indent+2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  arguments->slots[2] = frame->slots[10] /* temp__5 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_16;
}
static void entry__47_13(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 717: -> indent
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_14(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 718: ... indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__47_15;
}
static void cont__47_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 718: -> indent+2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 720: ... line_width-indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[3] /* indent */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__47_17;
}
static void cont__47_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 720: %line_end_expression_width line_width-indent-2 # "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__47_18;
}
static void cont__47_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 721: $$arguments arguments_to_string(self PROC line_end_expression_width)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  arguments->slots[1] = var._PROC;
  arguments->slots[2] = get__line_end_expression_width();
  result_count = 1;
  myself = var._arguments_to_string;
  func = myself->type;
  frame->cont = cont__47_19;
}
static void cont__47_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* arguments */ = arguments->slots[0];
  // 723: ... :
  // 724:   if
  // 725:     arguments(1) == '@nl;'
  // 726:     -> string("->" arguments)
  // 727:     -> string("-> " arguments)
  frame->slots[6] /* temp__1 */ = create_closure(entry__47_20, 0);
  // 728: :
  // 729:   $remark_lines
  // 730:     append(remark_lines_of(self) remark_lines_behind_of(self))
  // 731:   
  // 732:   %expression_indent indent
  // 733:   if
  // 734:     arguments .contains. '@nl;':
  // 735:       $$functor add_remark_lines("->" remark_lines)
  // 736:       
  // 737:       # ATTENTION: some weird fixes!
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__47_29, 0);
  // 722: if
  // 723:   has_no_remarks:
  // 724:     if
  // 725:       arguments(1) == '@nl;'
  // 726:       -> string("->" arguments)
  // 727:       -> string("-> " arguments)
  // 728:   :
  // 729:     $remark_lines
  // 730:       append(remark_lines_of(self) remark_lines_behind_of(self))
  // 731:     
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* has_no_remarks */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_70;
}
static void entry__47_23(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 726: ... string("->" arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__47_24;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_25;
}
static void cont__47_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 726: -> string("->" arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_26(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 727: ... string("-> " arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__47_27;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_28;
}
static void cont__47_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 727: -> string("-> " arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_20(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 725: arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* arguments */;
  func = myself->type;
  frame->cont = cont__47_21;
}
static void cont__47_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 725: arguments(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_22;
}
static void cont__47_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 726: -> string("->" arguments)
  frame->slots[3] /* temp__3 */ = create_closure(entry__47_23, 0);
  // 727: -> string("-> " arguments)
  frame->slots[4] /* temp__4 */ = create_closure(entry__47_26, 0);
  // 724: if
  // 725:   arguments(1) == '@nl;'
  // 726:   -> string("->" arguments)
  // 727:   -> string("-> " arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__47_29(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // return__1: 0
  // self: 1
  // indent: 2
  // arguments: 3
  // remark_lines: 4
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[4] /* remark_lines */ = create_future();
  // _define %expression_indent indent
  define__expression_indent(frame->slots[2] /* indent */);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 730: ... remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__47_30;
}
static void cont__47_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 730: ... remark_lines_behind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__remark_lines_behind_of();
  func = myself->type;
  frame->cont = cont__47_31;
}
static void cont__47_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 729: $remark_lines
  // 730:   append(remark_lines_of(self) remark_lines_behind_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__47_32;
}
static void cont__47_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* remark_lines */, arguments->slots[0]);
  // 732: %expression_indent indent
  initialize_maybe_future(get__expression_indent(), frame->slots[2] /* indent */);
  // 734: arguments .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* arguments */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__47_33;
}
static void cont__47_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 734: ... :
  // 735:   $$functor add_remark_lines("->" remark_lines)
  // 736:   
  // 737:   # ATTENTION: some weird fixes!
  // 738:   
  // 739:   unless functor(1) == '@nl;':
  // 740:     !functor string('@nl;' spaces(expression_indent) functor)
  // 741:     if arguments .has_prefix. "@nl;@nl;": range &arguments 2 -1
  // 742:   unless arguments(1) == '@nl;':
  // 743:     !arguments string('@nl;' spaces(expression_indent) arguments)
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__47_34, 0);
  // 745: :
  // 746:   if
  // 747:     3+length_of(arguments) <= line_end_expression_width
  // 748:     ->
  // 749:       string
  // 750:         "-> "
  // 751:         arguments
  // 752:         line_start_remark_to_string(remark_lines indent+2)
  // 753:     -> add_remark_lines(string("-> " arguments) remark_lines true)
  frame->slots[7] /* temp__3 */ = create_closure(entry__47_55, 0);
  // 733: if
  // 734:   arguments .contains. '@nl;':
  // 735:     $$functor add_remark_lines("->" remark_lines)
  // 736:     
  // 737:     # ATTENTION: some weird fixes!
  // 738:     
  // 739:     unless functor(1) == '@nl;':
  // 740:       !functor string('@nl;' spaces(expression_indent) functor)
  // 741:       if arguments .has_prefix. "@nl;@nl;": range &arguments 2 -1
  // 742:     unless arguments(1) == '@nl;':
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_69;
}
static void entry__47_60(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // arguments: 0
  // remark_lines: 1
  // indent: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 752: ... indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__47_61;
}
static void cont__47_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 752: line_start_remark_to_string(remark_lines indent+2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = var._line_start_remark_to_string;
  func = myself->type;
  frame->cont = cont__47_62;
}
static void cont__47_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 749: string
  // 750:   "-> "
  // 751:   arguments
  // 752:   line_start_remark_to_string(remark_lines indent+2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47_63;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_64;
}
static void cont__47_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 748: ->
  // 749:   string
  // 750:     "-> "
  // 751:     arguments
  // 752:     line_start_remark_to_string(remark_lines indent+2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_65(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // arguments: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 753: ... string("-> " arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__47_66;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_67;
}
static void cont__47_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 753: ... add_remark_lines(string("-> " arguments) remark_lines true)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__47_68;
}
static void cont__47_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 753: -> add_remark_lines(string("-> " arguments) remark_lines true)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_34(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // remark_lines: 0
  // arguments: 1
  // functor: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* remark_lines */
  frame->slots[1] = myself->closure.frame->slots[3]; /* arguments */
  frame->slots[2] /* functor */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 735: $$functor add_remark_lines("->" remark_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__47_35;
  arguments->slots[1] = frame->slots[0] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__47_36;
}
static void cont__47_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* functor */ = arguments->slots[0];
  // 739: ... functor(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[2])->contents /* functor */;
  func = myself->type;
  frame->cont = cont__47_37;
}
static void cont__47_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 739: ... functor(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_38;
}
static void cont__47_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 739: ... :
  // 740:   !functor string('@nl;' spaces(expression_indent) functor)
  // 741:   if arguments .has_prefix. "@nl;@nl;": range &arguments 2 -1
  frame->slots[5] /* temp__3 */ = create_closure(entry__47_39, 0);
  // 739: unless functor(1) == '@nl;':
  // 740:   !functor string('@nl;' spaces(expression_indent) functor)
  // 741:   if arguments .has_prefix. "@nl;@nl;": range &arguments 2 -1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__47_47;
}
static void entry__47_44(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 741: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__47_45;
}
static void cont__47_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 741: ... range &arguments 2 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[1] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__47_46;
}
static void cont__47_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_39(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 740: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__47_40;
}
static void cont__47_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 740: !functor string('@nl;' spaces(expression_indent) functor)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* functor */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_41;
}
static void cont__47_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* functor */ = arguments->slots[0];
  // 741: ... arguments .has_prefix. "@nl;@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = string__47_42;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__47_43;
}
static void cont__47_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 741: ... : range &arguments 2 -1
  frame->slots[3] /* temp__2 */ = create_closure(entry__47_44, 0);
  // 741: if arguments .has_prefix. "@nl;@nl;": range &arguments 2 -1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__47_47(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 742: ... arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* arguments */;
  func = myself->type;
  frame->cont = cont__47_48;
}
static void cont__47_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 742: ... arguments(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_49;
}
static void cont__47_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 742: ... :
  // 743:   !arguments string('@nl;' spaces(expression_indent) arguments)
  frame->slots[5] /* temp__3 */ = create_closure(entry__47_50, 0);
  // 742: unless arguments(1) == '@nl;':
  // 743:   !arguments string('@nl;' spaces(expression_indent) arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__47_53;
}
static void entry__47_50(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 743: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__47_51;
}
static void cont__47_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 743: !arguments string('@nl;' spaces(expression_indent) arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_52;
}
static void cont__47_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_53(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 744: ... append(functor arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* functor */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* arguments */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__47_54;
}
static void cont__47_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 744: -> append(functor arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_55(void) {
  allocate_initialized_frame_gc(3, 9);
  // slot allocations:
  // arguments: 0
  // remark_lines: 1
  // indent: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[4]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 747: ... length_of(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__47_56;
}
static void cont__47_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 747: 3+length_of(arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__3;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__47_57;
}
static void cont__47_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 747: 3+length_of(arguments) <= line_end_expression_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__47_58;
}
static void cont__47_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 747: 3+length_of(arguments) <= line_end_expression_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__47_59;
}
static void cont__47_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 748: ->
  // 749:   string
  // 750:     "-> "
  // 751:     arguments
  // 752:     line_start_remark_to_string(remark_lines indent+2)
  frame->slots[7] /* temp__5 */ = create_closure(entry__47_60, 0);
  // 753: -> add_remark_lines(string("-> " arguments) remark_lines true)
  frame->slots[8] /* temp__6 */ = create_closure(entry__47_65, 0);
  // 746: if
  // 747:   3+length_of(arguments) <= line_end_expression_width
  // 748:   ->
  // 749:     string
  // 750:       "-> "
  // 751:       arguments
  // 752:       line_start_remark_to_string(remark_lines indent+2)
  // 753:   -> add_remark_lines(string("-> " arguments) remark_lines true)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  arguments->slots[2] = frame->slots[8] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__47_69(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__47_70(void) {
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__47_71(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // return__5: 0
  // indent: 1
  // self: 2
  // functor: 3
  // this_is_a_definition: 4
  // arguments: 5
  // remark_lines: 6
  frame->slots[0] /* return__5 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  define__expression_indent(create_future());
  frame->slots[3] /* functor */ = create_cell();
  frame->slots[4] /* this_is_a_definition */ = create_cell();
  define__line_end_expression_width(create_future());
  frame->slots[5] /* arguments */ = create_future();
  frame->slots[6] /* remark_lines */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 755: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__47_72;
}
static void cont__47_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 756: $$functor undefined
  ((CELL *)frame->slots[3])->contents /* functor */ = get__undefined();
  // 757: $$this_is_a_definition false
  ((CELL *)frame->slots[4])->contents /* this_is_a_definition */ = get__false();
  // 758: ... :
  // 759:   %line_width UNLIMITED # force inline output
  // 760:   if
  // 761:     self.is_an_assignment:
  // 762:       !functor output_arguments_of(self)(1)
  // 763:       !this_is_a_definition functor.is_a_definition
  // 764:       argument_to_string &functor
  // 765:       !self.output_arguments_of empty_list
  // 766:       $source arguments_of(self)(1)
  // 767:       cond
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__47_73, 0);
  // 758: do:
  // 759:   %line_width UNLIMITED # force inline output
  // 760:   if
  // 761:     self.is_an_assignment:
  // 762:       !functor output_arguments_of(self)(1)
  // 763:       !this_is_a_definition functor.is_a_definition
  // 764:       argument_to_string &functor
  // 765:       !self.output_arguments_of empty_list
  // 766:       $source arguments_of(self)(1)
  // 767:       cond
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__47_95;
}
static void entry__47_73(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // return__3: 0
  // self: 1
  // functor: 2
  // this_is_a_definition: 3
  frame->slots[0] /* return__3 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor */
  frame->slots[3] = myself->closure.frame->slots[4]; /* this_is_a_definition */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 761: self.is_an_assignment
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__is_an_assignment();
  func = myself->type;
  frame->cont = cont__47_74;
}
static void cont__47_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 761: ... :
  // 762:   !functor output_arguments_of(self)(1)
  // 763:   !this_is_a_definition functor.is_a_definition
  // 764:   argument_to_string &functor
  // 765:   !self.output_arguments_of empty_list
  // 766:   $source arguments_of(self)(1)
  // 767:   cond
  // 768:     -> source.is_a_body: !statement_tag ALWAYS
  // 769:     -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  // 770:     -> source.is_a_polymorphic_function_constant:
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__47_75, 0);
  // 772: :
  // 773:   !functor functor_of(self).to_string
  frame->slots[6] /* temp__3 */ = create_closure(entry__47_91, 0);
  // 760: if
  // 761:   self.is_an_assignment:
  // 762:     !functor output_arguments_of(self)(1)
  // 763:     !this_is_a_definition functor.is_a_definition
  // 764:     argument_to_string &functor
  // 765:     !self.output_arguments_of empty_list
  // 766:     $source arguments_of(self)(1)
  // 767:     cond
  // 768:       -> source.is_a_body: !statement_tag ALWAYS
  // 769:       -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_94;
}
static void entry__47_90(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 771: !statement_tag POLYMORPHIC_FUNCTION
  set__statement_tag(var._POLYMORPHIC_FUNCTION);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_87(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 769: ... !statement_tag UNIQUE
  set__statement_tag(var._UNIQUE);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_84(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 768: ... !statement_tag ALWAYS
  set__statement_tag(var._ALWAYS);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_82(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 768: ... source.is_a_body
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_body();
  func = myself->type;
  frame->cont = cont__47_83;
}
static void cont__47_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 768: -> source.is_a_body: !statement_tag ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__47_84;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_85(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 769: ... source.is_a_unique_item_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_unique_item_constant();
  func = myself->type;
  frame->cont = cont__47_86;
}
static void cont__47_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 769: -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__47_87;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_88(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 770: ... source.is_a_polymorphic_function_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_polymorphic_function_constant();
  func = myself->type;
  frame->cont = cont__47_89;
}
static void cont__47_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 770: -> source.is_a_polymorphic_function_constant:
  // 771:   !statement_tag POLYMORPHIC_FUNCTION
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__47_90;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_75(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // functor: 0
  // self: 1
  // this_is_a_definition: 2
  // source: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* this_is_a_definition */
  frame->slots[3] /* source */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 762: ... output_arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__output_arguments_of();
  func = myself->type;
  frame->cont = cont__47_76;
}
static void cont__47_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 762: !functor output_arguments_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__1 */;
  func = myself->type;
  frame->cont = cont__47_77;
}
static void cont__47_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* functor */ = arguments->slots[0];
  // 763: !this_is_a_definition functor.is_a_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  result_count = 1;
  myself = get__is_a_definition();
  func = myself->type;
  frame->cont = cont__47_78;
}
static void cont__47_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* this_is_a_definition */ = arguments->slots[0];
  // 764: argument_to_string &functor
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  result_count = 1;
  myself = var._argument_to_string;
  func = myself->type;
  frame->cont = cont__47_79;
}
static void cont__47_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* functor */ = arguments->slots[0];
  // 765: !self.output_arguments_of empty_list
  frame->slots[4] /* temp__1 */ = get__empty_list();
  // 765: !self.output_arguments_of
  {
    NODE *temp = clone_object_and_attributes(((CELL *)frame->slots[1])->contents /* self */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__output_arguments_of, frame->slots[4] /* temp__1 */);
    ((CELL *)frame->slots[1])->contents /* self */ = temp;

  }
  // 766: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__47_80;
}
static void cont__47_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 766: $source arguments_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__1 */;
  func = myself->type;
  frame->cont = cont__47_81;
}
static void cont__47_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* source */, arguments->slots[0]);
  // 768: -> source.is_a_body: !statement_tag ALWAYS
  frame->slots[4] /* temp__1 */ = create_closure(entry__47_82, 0);
  // 769: -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  frame->slots[5] /* temp__2 */ = create_closure(entry__47_85, 0);
  // 770: -> source.is_a_polymorphic_function_constant:
  // 771:   !statement_tag POLYMORPHIC_FUNCTION
  frame->slots[6] /* temp__3 */ = create_closure(entry__47_88, 0);
  // 767: cond
  // 768:   -> source.is_a_body: !statement_tag ALWAYS
  // 769:   -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  // 770:   -> source.is_a_polymorphic_function_constant:
  // 771:     !statement_tag POLYMORPHIC_FUNCTION
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__47_91(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 773: ... functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__47_92;
}
static void cont__47_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 773: !functor functor_of(self).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__47_93;
}
static void cont__47_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* functor */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_94(void) {
  myself = frame->slots[0] /* return__3 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__47_95(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 774: ... line_width-indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__47_96;
}
static void cont__47_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 774: ... length_of(functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* functor */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__47_97;
}
static void cont__47_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 774: %line_end_expression_width line_width-indent-length_of(functor)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__47_98;
}
static void cont__47_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 775: $arguments arguments_to_string(self PROC line_end_expression_width)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* self */;
  arguments->slots[1] = var._PROC;
  arguments->slots[2] = get__line_end_expression_width();
  result_count = 1;
  myself = var._arguments_to_string;
  func = myself->type;
  frame->cont = cont__47_99;
}
static void cont__47_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* arguments */, arguments->slots[0]);
  // 776: ... arguments .contains. '@nl;'
  frame->slots[8] /* temp__2 */ = create_closure(entry__47_100, 0);
  // 776: ... this_is_a_definition && arguments .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* this_is_a_definition */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__47_102;
}
static void entry__47_100(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 776: ... arguments .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__47_101;
}
static void cont__47_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 776: ... arguments .contains. '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 776: if this_is_a_definition && arguments .contains. '@nl;':
  // 777:   !statement_tag ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__47_103;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_104;
}
static void entry__47_103(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 777: !statement_tag ALWAYS
  set__statement_tag(var._ALWAYS);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_104(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 778: ... remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__47_105;
}
static void cont__47_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 778: ... remark_lines_behind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* self */;
  result_count = 1;
  myself = get__remark_lines_behind_of();
  func = myself->type;
  frame->cont = cont__47_106;
}
static void cont__47_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 778: $remark_lines append(remark_lines_of(self) remark_lines_behind_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__47_107;
}
static void cont__47_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* remark_lines */, arguments->slots[0]);
  // 780: remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__47_108;
}
static void cont__47_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 781: ->
  // 782:   if
  // 783:     arguments == "" || arguments(1) == ':' || arguments(1) == '@nl;'
  // 784:     -> string(functor arguments)
  // 785:     -> string(functor ' ' arguments)
  frame->slots[8] /* temp__2 */ = create_closure(entry__47_109, 0);
  // 786: :
  // 787:   cond
  // 788:     ->
  // 789:       arguments == ""
  // 790:       -> string(add_remark_lines(functor remark_lines true) arguments)
  // 791:     ->
  // 792:       ||
  // 793:         arguments .contains. '@nl;'
  // 794:         any_of
  // 795:           arguments_of(self): (argument)
  // ...
  frame->slots[9] /* temp__3 */ = create_closure(entry__47_124, 0);
  // 779: if
  // 780:   remark_lines.is_empty
  // 781:   ->
  // 782:     if
  // 783:       arguments == "" || arguments(1) == ':' || arguments(1) == '@nl;'
  // 784:       -> string(functor arguments)
  // 785:       -> string(functor ' ' arguments)
  // 786:   :
  // 787:     cond
  // 788:       ->
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_144;
}
static void entry__47_141(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // return__4: 0
  // indent: 1
  // functor: 2
  // arguments: 3
  // remark_lines: 4
  frame->slots[0] /* return__4 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[3] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[4] = myself->closure.frame->slots[3]; /* remark_lines */
  // _define %expression_indent indent
  define__expression_indent(frame->slots[1] /* indent */);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 799: %expression_indent indent
  initialize_maybe_future(get__expression_indent(), frame->slots[1] /* indent */);
  // 802: string(functor ' ' arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* functor */;
  arguments->slots[1] = character__32;
  arguments->slots[2] = frame->slots[3] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_142;
}
static void cont__47_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 801: add_remark_lines
  // 802:   string(functor ' ' arguments)
  // 803:   remark_lines
  // 804:   true
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* remark_lines */;
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__47_143;
}
static void cont__47_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 800: ->
  // 801:   add_remark_lines
  // 802:     string(functor ' ' arguments)
  // 803:     remark_lines
  // 804:     true
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  myself = frame->slots[0] /* return__4 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__47_138(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // functor: 0
  // arguments: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[0]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[3]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 797: ... call_with_remark_to_string(functor arguments remark_lines)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  arguments->slots[1] = frame->slots[1] /* arguments */;
  arguments->slots[2] = frame->slots[2] /* remark_lines */;
  result_count = 1;
  myself = var._call_with_remark_to_string;
  func = myself->type;
  frame->cont = cont__47_139;
}
static void cont__47_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 797: -> call_with_remark_to_string(functor arguments remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_127(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // functor: 0
  // remark_lines: 1
  // arguments: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 790: ... add_remark_lines(functor remark_lines true)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__47_128;
}
static void cont__47_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 790: ... string(add_remark_lines(functor remark_lines true) arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[2] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_129;
}
static void cont__47_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 790: -> string(add_remark_lines(functor remark_lines true) arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_125(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // arguments: 0
  // functor: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[2] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 789: arguments == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_126;
}
static void cont__47_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 790: -> string(add_remark_lines(functor remark_lines true) arguments)
  frame->slots[4] /* temp__2 */ = create_closure(entry__47_127, 0);
  // 788: ->
  // 789:   arguments == ""
  // 790:   -> string(add_remark_lines(functor remark_lines true) arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_130(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // arguments: 0
  // self: 1
  // functor: 2
  // remark_lines: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[3]; /* self */
  frame->slots[2] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[3] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 793: arguments .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__47_131;
}
static void cont__47_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 794: any_of
  // 795:   arguments_of(self): (argument)
  // 796:     -> argument.is_a_body
  frame->slots[6] /* temp__3 */ = create_closure(entry__47_132, 0);
  // 792: ||
  // 793:   arguments .contains. '@nl;'
  // 794:   any_of
  // 795:     arguments_of(self): (argument)
  // 796:       -> argument.is_a_body
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__47_137;
}
static void entry__47_132(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 795: arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__47_133;
}
static void cont__47_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 794: any_of
  // 795:   arguments_of(self): (argument)
  // 796:     -> argument.is_a_body
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = func__47_134;
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__47_136;
}
static void entry__47_134(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 796: ... argument.is_a_body
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_a_body();
  func = myself->type;
  frame->cont = cont__47_135;
}
static void cont__47_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 796: -> argument.is_a_body
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 794: any_of
  // 795:   arguments_of(self): (argument)
  // 796:     -> argument.is_a_body
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 797: -> call_with_remark_to_string(functor arguments remark_lines)
  frame->slots[7] /* temp__4 */ = create_closure(entry__47_138, 0);
  // 791: ->
  // 792:   ||
  // 793:     arguments .contains. '@nl;'
  // 794:     any_of
  // 795:       arguments_of(self): (argument)
  // 796:         -> argument.is_a_body
  // 797:   -> call_with_remark_to_string(functor arguments remark_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_140(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // indent: 0
  // functor: 1
  // arguments: 2
  // remark_lines: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[2] = myself->closure.frame->slots[0]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 798: ... :
  // 799:   %expression_indent indent
  // 800:   ->
  // 801:     add_remark_lines
  // 802:       string(functor ' ' arguments)
  // 803:       remark_lines
  // 804:       true
  frame->slots[4] /* temp__1 */ = create_closure(entry__47_141, 0);
  // 798: -> true:
  // 799:   %expression_indent indent
  // 800:   ->
  // 801:     add_remark_lines
  // 802:       string(functor ' ' arguments)
  // 803:       remark_lines
  // 804:       true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_109(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // arguments: 0
  // functor: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[3]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 783: arguments == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_110;
}
static void cont__47_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 783: ... arguments(1) == ':' || arguments(1) == '@nl;'
  frame->slots[5] /* temp__4 */ = create_closure(entry__47_111, 0);
  // 783: arguments == "" || arguments(1) == ':' || arguments(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__47_118;
}
static void entry__47_111(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 783: ... arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__47_112;
}
static void cont__47_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 783: ... arguments(1) == ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_113;
}
static void cont__47_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 783: ... arguments(1) == '@nl;'
  frame->slots[4] /* temp__4 */ = create_closure(entry__47_114, 0);
  // 783: ... arguments(1) == ':' || arguments(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__47_117;
}
static void entry__47_114(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 783: ... arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__47_115;
}
static void cont__47_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 783: ... arguments(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__47_116;
}
static void cont__47_116(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 783: ... arguments(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 783: ... arguments(1) == ':' || arguments(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 784: -> string(functor arguments)
  frame->slots[6] /* temp__5 */ = create_closure(entry__47_119, 0);
  // 785: -> string(functor ' ' arguments)
  frame->slots[7] /* temp__6 */ = create_closure(entry__47_121, 0);
  // 782: if
  // 783:   arguments == "" || arguments(1) == ':' || arguments(1) == '@nl;'
  // 784:   -> string(functor arguments)
  // 785:   -> string(functor ' ' arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  arguments->slots[2] = frame->slots[7] /* temp__6 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__47_123;
}
static void entry__47_119(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 784: ... string(functor arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  arguments->slots[1] = frame->slots[1] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_120;
}
static void cont__47_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 784: -> string(functor arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_121(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 785: ... string(functor ' ' arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  arguments->slots[1] = character__32;
  arguments->slots[2] = frame->slots[1] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__47_122;
}
static void cont__47_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 785: -> string(functor ' ' arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__47_123(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 781: ->
  // 782:   if
  // 783:     arguments == "" || arguments(1) == ':' || arguments(1) == '@nl;'
  // 784:     -> string(functor arguments)
  // 785:     -> string(functor ' ' arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__47_124(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // arguments: 0
  // functor: 1
  // remark_lines: 2
  // self: 3
  // indent: 4
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[3]; /* functor */
  frame->slots[2] = myself->closure.frame->slots[6]; /* remark_lines */
  frame->slots[3] = myself->closure.frame->slots[2]; /* self */
  frame->slots[4] = myself->closure.frame->slots[1]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 788: ->
  // 789:   arguments == ""
  // 790:   -> string(add_remark_lines(functor remark_lines true) arguments)
  frame->slots[5] /* temp__1 */ = create_closure(entry__47_125, 0);
  // 791: ->
  // 792:   ||
  // 793:     arguments .contains. '@nl;'
  // 794:     any_of
  // 795:       arguments_of(self): (argument)
  // 796:         -> argument.is_a_body
  // 797:   -> call_with_remark_to_string(functor arguments remark_lines)
  frame->slots[6] /* temp__2 */ = create_closure(entry__47_130, 0);
  // 798: -> true:
  // 799:   %expression_indent indent
  // 800:   ->
  // 801:     add_remark_lines
  // 802:       string(functor ' ' arguments)
  // 803:       remark_lines
  // 804:       true
  frame->slots[7] /* temp__3 */ = create_closure(entry__47_140, 0);
  // 787: cond
  // 788:   ->
  // 789:     arguments == ""
  // 790:     -> string(add_remark_lines(functor remark_lines true) arguments)
  // 791:   ->
  // 792:     ||
  // 793:       arguments .contains. '@nl;'
  // 794:       any_of
  // 795:         arguments_of(self): (argument)
  // 796:           -> argument.is_a_body
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__47_144(void) {
  myself = frame->slots[0] /* return__5 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__47_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // indent: 1
  // outer_line_end_expression_width: 2
  // _define $indent expression_indent
  frame->slots[1] /* indent */ = get__expression_indent();
  // _define $outer_line_end_expression_width line_end_expression_width
  frame->slots[2] /* outer_line_end_expression_width */ = get__line_end_expression_width();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* self */ = create_cell_with_contents(arguments->slots[0]);
  // 710: self.is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* self */;
  result_count = 1;
  myself = get__is_a_return();
  func = myself->type;
  frame->cont = cont__47_2;
}
static void cont__47_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 710: ... :
  // 711:   $has_no_remarks
  // 712:     remark_lines_of(self).is_empty && remark_lines_behind_of(self).is_empty
  // 713:   
  // 714:   %expression_indent
  // 715:     if
  // 716:       outer_line_end_expression_width > 0 && has_no_remarks
  // 717:       -> indent
  // 718:       -> indent+2
  // 719:   
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__47_3, 0);
  // 754: :
  // 755:   %expression_indent indent+2
  // 756:   $$functor undefined
  // 757:   $$this_is_a_definition false
  // 758:   do:
  // 759:     %line_width UNLIMITED # force inline output
  // 760:     if
  // 761:       self.is_an_assignment:
  // 762:         !functor output_arguments_of(self)(1)
  // 763:         !this_is_a_definition functor.is_a_definition
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__47_71, 0);
  // 709: if
  // 710:   self.is_a_return:
  // 711:     $has_no_remarks
  // 712:       remark_lines_of(self).is_empty && remark_lines_behind_of(self).is_empty
  // 713:     
  // 714:     %expression_indent
  // 715:       if
  // 716:         outer_line_end_expression_width > 0 && has_no_remarks
  // 717:         -> indent
  // 718:         -> indent+2
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__48_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // prefix: 0
  // definition: 1
  // buf: 2
  frame->slots[2] /* buf */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 807: $$buf ""
  ((CELL *)frame->slots[2])->contents /* buf */ = empty_string;
  // 808: ... parameter_kind_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__48_2;
}
static void cont__48_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 808: ... parameter_kind_of(definition) == CONTINUATION_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__48_3;
}
static void cont__48_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 808: ... : append &buf "-> "
  frame->slots[5] /* temp__3 */ = create_closure(entry__48_4, 0);
  // 808: if parameter_kind_of(definition) == CONTINUATION_PARAMETER: append &buf "-> "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__48_7;
}
static void entry__48_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 808: ... append &buf "-> "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = string__48_5;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__48_6;
}
static void cont__48_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__48_7(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 809: append &buf prefix
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  arguments->slots[1] = frame->slots[0] /* prefix */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__48_8;
}
static void cont__48_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 810: ... identifier_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__48_9;
}
static void cont__48_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 810: ... identifier_of(definition).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__48_10;
}
static void cont__48_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 810: append &buf identifier_of(definition).to_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__48_11;
}
static void cont__48_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 811: ... definition.is_a_parameter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__is_a_parameter();
  func = myself->type;
  frame->cont = cont__48_12;
}
static void cont__48_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 811: ... :
  // 812:   if parameter_kind_of(definition) == MYSELF_PARAMETER: push &buf '^'
  // 813:   cond
  // 814:     -> definition.is_an_optional_item:
  // 815:       if
  // 816:         default_value_of(definition).is_defined:
  // 817:           write_to &buf " = " default_value_of(definition)
  // 818:         :
  // 819:           push &buf '?'
  // 820:     -> definition.is_an_expanded_item: push &buf '*'
  frame->slots[4] /* temp__2 */ = create_closure(entry__48_13, 0);
  // 811: if definition.is_a_parameter:
  // 812:   if parameter_kind_of(definition) == MYSELF_PARAMETER: push &buf '^'
  // 813:   cond
  // 814:     -> definition.is_an_optional_item:
  // 815:       if
  // 816:         default_value_of(definition).is_defined:
  // 817:           write_to &buf " = " default_value_of(definition)
  // 818:         :
  // 819:           push &buf '?'
  // 820:     -> definition.is_an_expanded_item: push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__48_34;
}
static void entry__48_32(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 820: ... push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__48_33;
}
static void cont__48_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__48_24(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // definition: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 817: ... default_value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__48_25;
}
static void cont__48_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 817: write_to &buf " = " default_value_of(definition)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = string__48_26;
  arguments->slots[2] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__48_27;
}
static void cont__48_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__48_28(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 819: push &buf '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__63;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__48_29;
}
static void cont__48_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__48_21(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 816: default_value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__48_22;
}
static void cont__48_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 816: default_value_of(definition).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__48_23;
}
static void cont__48_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 816: ... :
  // 817:   write_to &buf " = " default_value_of(definition)
  frame->slots[4] /* temp__3 */ = create_closure(entry__48_24, 0);
  // 818: :
  // 819:   push &buf '?'
  frame->slots[5] /* temp__4 */ = create_closure(entry__48_28, 0);
  // 815: if
  // 816:   default_value_of(definition).is_defined:
  // 817:     write_to &buf " = " default_value_of(definition)
  // 818:   :
  // 819:     push &buf '?'
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__48_19(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 814: ... definition.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__48_20;
}
static void cont__48_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 814: ... :
  // 815:   if
  // 816:     default_value_of(definition).is_defined:
  // 817:       write_to &buf " = " default_value_of(definition)
  // 818:     :
  // 819:       push &buf '?'
  frame->slots[3] /* temp__2 */ = create_closure(entry__48_21, 0);
  // 814: -> definition.is_an_optional_item:
  // 815:   if
  // 816:     default_value_of(definition).is_defined:
  // 817:       write_to &buf " = " default_value_of(definition)
  // 818:     :
  // 819:       push &buf '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__48_30(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 820: ... definition.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__48_31;
}
static void cont__48_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 820: ... : push &buf '*'
  frame->slots[3] /* temp__2 */ = create_closure(entry__48_32, 0);
  // 820: -> definition.is_an_expanded_item: push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__48_13(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 812: ... parameter_kind_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__48_14;
}
static void cont__48_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 812: ... parameter_kind_of(definition) == MYSELF_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__MYSELF_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__48_15;
}
static void cont__48_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 812: ... : push &buf '^'
  frame->slots[4] /* temp__3 */ = create_closure(entry__48_16, 0);
  // 812: if parameter_kind_of(definition) == MYSELF_PARAMETER: push &buf '^'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__48_18;
}
static void entry__48_16(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 812: ... push &buf '^'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__94;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__48_17;
}
static void cont__48_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__48_18(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 814: -> definition.is_an_optional_item:
  // 815:   if
  // 816:     default_value_of(definition).is_defined:
  // 817:       write_to &buf " = " default_value_of(definition)
  // 818:     :
  // 819:       push &buf '?'
  frame->slots[2] /* temp__1 */ = create_closure(entry__48_19, 0);
  // 820: -> definition.is_an_expanded_item: push &buf '*'
  frame->slots[3] /* temp__2 */ = create_closure(entry__48_30, 0);
  // 813: cond
  // 814:   -> definition.is_an_optional_item:
  // 815:     if
  // 816:       default_value_of(definition).is_defined:
  // 817:         write_to &buf " = " default_value_of(definition)
  // 818:       :
  // 819:         push &buf '?'
  // 820:   -> definition.is_an_expanded_item: push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__48_34(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 821: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__49_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // prefix: 1
  // buf: 2
  frame->slots[1] /* prefix */ = create_future();
  frame->slots[2] /* buf */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 829: parameter_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__49_2;
}
static void cont__49_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 830: IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__IN_PARAMETER();
  arguments->slots[1] = get__MYSELF_PARAMETER();
  arguments->slots[2] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__49_3;
}
static void cont__49_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 827: $prefix
  // 828:   case
  // 829:     parameter_kind_of(self)
  // 830:     IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  // 831:     -> ""
  // 832:     -> "$"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = func__49_4;
  arguments->slots[3] = func__49_5;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__49_7;
}
static void entry__49_4(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 831: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__49_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 832: -> "$"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__49_6;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__49_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* prefix */, arguments->slots[0]);
  // 834: definition_to_string $$buf prefix self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._definition_to_string;
  func = myself->type;
  frame->cont = cont__49_8;
}
static void cont__49_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 836: attribute_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__49_9;
}
static void cont__49_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 837: ... :
  // 838:   write_to &buf '.' attribute_of(self)
  frame->slots[4] /* temp__2 */ = create_closure(entry__49_10, 0);
  // 839: ... :
  // 840:   push &buf '/'
  // 841:   if attribute_of(self).is_defined: write_to &buf attribute_of(self)
  frame->slots[5] /* temp__3 */ = create_closure(entry__49_13, 0);
  // 835: case
  // 836:   attribute_kind_of(self)
  // 837:   ATTRIBUTE_KIND:
  // 838:     write_to &buf '.' attribute_of(self)
  // 839:   METHOD_KIND:
  // 840:     push &buf '/'
  // 841:     if attribute_of(self).is_defined: write_to &buf attribute_of(self)
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = get__ATTRIBUTE_KIND();
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  arguments->slots[3] = get__METHOD_KIND();
  arguments->slots[4] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__49_20;
}
static void entry__49_17(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 841: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__49_18;
}
static void cont__49_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 841: ... write_to &buf attribute_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__49_19;
}
static void cont__49_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__49_10(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 838: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__49_11;
}
static void cont__49_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 838: write_to &buf '.' attribute_of(self)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__46;
  arguments->slots[2] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__49_12;
}
static void cont__49_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__49_13(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // buf: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 840: push &buf '/'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__47;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__49_14;
}
static void cont__49_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 841: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__49_15;
}
static void cont__49_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 841: ... attribute_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__49_16;
}
static void cont__49_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 841: ... : write_to &buf attribute_of(self)
  frame->slots[4] /* temp__3 */ = create_closure(entry__49_17, 0);
  // 841: if attribute_of(self).is_defined: write_to &buf attribute_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__49_20(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 842: add_indented_remark self buf
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* buf */;
  result_count = frame->caller_result_count;
  myself = var._add_indented_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__50_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  // prefix: 1
  frame->slots[1] /* prefix */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 850: parameter_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__50_2;
}
static void cont__50_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 851: IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__IN_PARAMETER();
  arguments->slots[1] = get__MYSELF_PARAMETER();
  arguments->slots[2] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__50_3;
}
static void cont__50_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 848: $prefix
  // 849:   case
  // 850:     parameter_kind_of(self)
  // 851:     IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  // 852:     -> "$"
  // 853:     OUT_PARAMETER
  // 854:     -> "!"
  // 855:     IN_OUT_PARAMETER
  // 856:     -> "&"
  // 857:     -> "$$"
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = func__50_4;
  arguments->slots[3] = get__OUT_PARAMETER();
  arguments->slots[4] = func__50_6;
  arguments->slots[5] = get__IN_OUT_PARAMETER();
  arguments->slots[6] = func__50_8;
  arguments->slots[7] = func__50_10;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__50_12;
}
static void entry__50_4(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 852: -> "$"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__50_5;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__50_6(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 854: -> "!"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__50_7;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__50_8(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 856: -> "&"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__50_9;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__50_10(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 857: -> "$$"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__50_11;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__50_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* prefix */, arguments->slots[0]);
  // 859: ... definition_to_string(prefix self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._definition_to_string;
  func = myself->type;
  frame->cont = cont__50_13;
}
static void cont__50_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 859: add_indented_remark self definition_to_string(prefix self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_indented_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__51_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 865: ... definition_to_string("%" self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__51_2;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._definition_to_string;
  func = myself->type;
  frame->cont = cont__51_3;
}
static void cont__51_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 865: add_indented_remark self definition_to_string("%" self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_indented_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__52_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 871: ... definition_to_string("%%" self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__52_2;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._definition_to_string;
  func = myself->type;
  frame->cont = cont__52_3;
}
static void cont__52_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 871: add_indented_remark self definition_to_string("%%" self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_indented_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__53_17(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 885: -> INFIX_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__INFIX_PRECEDENCE();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 886: -> HIGHEST_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__HIGHEST_PRECEDENCE();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_11(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 881: ... functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__53_12;
}
static void cont__53_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 881: ... name_of(functor_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__53_13;
}
static void cont__53_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 881: ... precedence(name_of(functor_of(expr)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__precedence();
  func = myself->type;
  frame->cont = cont__53_14;
}
static void cont__53_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 881: -> precedence(name_of(functor_of(expr)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_15(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 884: expr.is_in_infix_notation
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_in_infix_notation();
  func = myself->type;
  frame->cont = cont__53_16;
}
static void cont__53_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 883: if
  // 884:   expr.is_in_infix_notation
  // 885:   -> INFIX_PRECEDENCE
  // 886:   -> HIGHEST_PRECEDENCE
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__53_17;
  arguments->slots[2] = func__53_18;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__53_8(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 880: functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__53_9;
}
static void cont__53_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 880: functor_of(expr).is_an_operator_symbol
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_operator_symbol();
  func = myself->type;
  frame->cont = cont__53_10;
}
static void cont__53_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 881: -> precedence(name_of(functor_of(expr)))
  frame->slots[3] /* temp__3 */ = create_closure(entry__53_11, 0);
  // 882: :
  // 883:   if
  // 884:     expr.is_in_infix_notation
  // 885:     -> INFIX_PRECEDENCE
  // 886:     -> HIGHEST_PRECEDENCE
  frame->slots[4] /* temp__4 */ = create_closure(entry__53_15, 0);
  // 879: if
  // 880:   functor_of(expr).is_an_operator_symbol
  // 881:   -> precedence(name_of(functor_of(expr)))
  // 882:   :
  // 883:     if
  // 884:       expr.is_in_infix_notation
  // 885:       -> INFIX_PRECEDENCE
  // 886:       -> HIGHEST_PRECEDENCE
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__53_19(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 887: -> HIGHEST_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__HIGHEST_PRECEDENCE();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__53_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 878: expr.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__53_2;
}
static void cont__53_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 878: ... length_of(arguments_of(expr)) == 2
  frame->slots[3] /* temp__3 */ = create_closure(entry__53_3, 0);
  // 878: expr.is_a_function_call && length_of(arguments_of(expr)) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__53_7;
}
static void entry__53_3(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 878: ... arguments_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__53_4;
}
static void cont__53_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 878: ... length_of(arguments_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__53_5;
}
static void cont__53_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 878: ... length_of(arguments_of(expr)) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__53_6;
}
static void cont__53_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 878: ... length_of(arguments_of(expr)) == 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__53_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 878: ... :
  // 879:   if
  // 880:     functor_of(expr).is_an_operator_symbol
  // 881:     -> precedence(name_of(functor_of(expr)))
  // 882:     :
  // 883:       if
  // 884:         expr.is_in_infix_notation
  // 885:         -> INFIX_PRECEDENCE
  // 886:         -> HIGHEST_PRECEDENCE
  frame->slots[4] /* temp__4 */ = create_closure(entry__53_8, 0);
  // 877: if
  // 878:   expr.is_a_function_call && length_of(arguments_of(expr)) == 2:
  // 879:     if
  // 880:       functor_of(expr).is_an_operator_symbol
  // 881:       -> precedence(name_of(functor_of(expr)))
  // 882:       :
  // 883:         if
  // 884:           expr.is_in_infix_notation
  // 885:           -> INFIX_PRECEDENCE
  // 886:           -> HIGHEST_PRECEDENCE
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  arguments->slots[2] = func__53_19;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__54_12(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 895: ... functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__54_13;
}
static void cont__54_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 895: ... functor_of(expr).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__54_14;
}
static void cont__54_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 895: -> functor_of(expr).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__54_15(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 896: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__54_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 892: expr.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__54_2;
}
static void cont__54_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[3] /* temp__3 */ = create_closure(entry__54_3, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__54_11;
}
static void entry__54_3(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 893: ... arguments_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__54_4;
}
static void cont__54_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 893: length_of(arguments_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__54_5;
}
static void cont__54_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 893: length_of(arguments_of(expr)) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__54_6;
}
static void cont__54_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 894: functor_of(expr).is_an_operator_symbol
  frame->slots[5] /* temp__5 */ = create_closure(entry__54_7, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__54_10;
}
static void entry__54_7(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 894: functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__54_8;
}
static void cont__54_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 894: functor_of(expr).is_an_operator_symbol
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_operator_symbol();
  func = myself->type;
  frame->cont = cont__54_9;
}
static void cont__54_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 894: functor_of(expr).is_an_operator_symbol
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__54_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__54_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 895: -> functor_of(expr).to_string
  frame->slots[4] /* temp__4 */ = create_closure(entry__54_12, 0);
  // 890: if
  // 891:   &&
  // 892:     expr.is_a_function_call
  // 893:     length_of(arguments_of(expr)) == 2
  // 894:     functor_of(expr).is_an_operator_symbol
  // 895:   -> functor_of(expr).to_string
  // 896:   -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  arguments->slots[2] = func__54_15;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_152(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // return__7: 0
  // indent: 1
  // arguments: 2
  // functor_string: 3
  frame->slots[0] /* return__7 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[2]; /* functor_string */
  define__expression_indent(create_future());
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1000: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__55_153;
}
static void cont__55_153(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 1002: length_of(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_154;
}
static void cont__55_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1002: length_of(arguments) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_155;
}
static void cont__55_155(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1002: ... :
  // 1003:   $argument arguments(1)
  // 1004:   if
  // 1005:     precedence_of(argument) < HIGHEST_PRECEDENCE
  // 1006:     -> string(functor_string '(' argument ')')
  // 1007:     -> string(functor_string argument)
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_156, 0);
  // 1008: :
  // 1009:   %line_end_expression_width 0
  // 1010:   $prec precedence(functor_string)
  // 1011:   $$left arguments(1)
  // 1012:   $$right arguments(2)
  // 1013:   
  // 1014:   $stringify_le: (expr)
  // 1015:     $str expr.to_string
  // 1016:     if
  // 1017:       precedence_of(expr) <= prec
  // ...
  frame->slots[7] /* temp__4 */ = create_closure(entry__55_164, 0);
  // 1001: if
  // 1002:   length_of(arguments) == 1:
  // 1003:     $argument arguments(1)
  // 1004:     if
  // 1005:       precedence_of(argument) < HIGHEST_PRECEDENCE
  // 1006:       -> string(functor_string '(' argument ')')
  // 1007:       -> string(functor_string argument)
  // 1008:   :
  // 1009:     %line_end_expression_width 0
  // 1010:     $prec precedence(functor_string)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_279;
}
static void entry__55_160(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor_string: 0
  // argument: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[2]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1006: ... string(functor_string '(' argument ')')
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = character__40;
  arguments->slots[2] = frame->slots[1] /* argument */;
  arguments->slots[3] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_161;
}
static void cont__55_161(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1006: -> string(functor_string '(' argument ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_162(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor_string: 0
  // argument: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[2]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1007: ... string(functor_string argument)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_163;
}
static void cont__55_163(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1007: -> string(functor_string argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_156(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // arguments: 0
  // functor_string: 1
  // argument: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[2] /* argument */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1003: $argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_157;
}
static void cont__55_157(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* argument */, arguments->slots[0]);
  // 1005: precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__55_158;
}
static void cont__55_158(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1005: precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_159;
}
static void cont__55_159(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1006: -> string(functor_string '(' argument ')')
  frame->slots[5] /* temp__3 */ = create_closure(entry__55_160, 0);
  // 1007: -> string(functor_string argument)
  frame->slots[6] /* temp__4 */ = create_closure(entry__55_162, 0);
  // 1004: if
  // 1005:   precedence_of(argument) < HIGHEST_PRECEDENCE
  // 1006:   -> string(functor_string '(' argument ')')
  // 1007:   -> string(functor_string argument)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_164(void) {
  allocate_initialized_frame_gc(4, 16);
  // slot allocations:
  // return__6: 0
  // functor_string: 1
  // arguments: 2
  // indent: 3
  // prec: 4
  // left: 5
  // right: 6
  // stringify_le: 7
  // stringify_lt: 8
  // strings: 9
  // inline_functor: 10
  // total_width: 11
  // buf: 12
  frame->slots[0] /* return__6 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[7] /* stringify_le */ = create_future();
  frame->slots[8] /* stringify_lt */ = create_future();
  // _define %line_end_expression_width 0
  define__line_end_expression_width(number__0);
  frame->slots[4] /* prec */ = create_future();
  frame->slots[5] /* left */ = create_cell();
  frame->slots[6] /* right */ = create_cell();
  frame->slots[9] /* strings */ = create_cell();
  frame->slots[10] /* inline_functor */ = create_cell();
  frame->slots[11] /* total_width */ = create_cell();
  frame->slots[12] /* buf */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1014: ... : (expr)
  // 1015:   $str expr.to_string
  // 1016:   if
  // 1017:     precedence_of(expr) <= prec
  // 1018:     -> str(.needs_parenthesis true)
  // 1019:     -> str(.needs_parenthesis false)
  frame->slots[13] /* temp__1 */ = create_closure(entry__55_165, 1);
  // 1014: $stringify_le: (expr)
  // 1015:   $str expr.to_string
  // 1016:   if
  // 1017:     precedence_of(expr) <= prec
  // 1018:     -> str(.needs_parenthesis true)
  // 1019:     -> str(.needs_parenthesis false)
  initialize_future(frame->slots[7] /* stringify_le */, frame->slots[13] /* temp__1 */);
  // 1021: ... : (expr)
  // 1022:   $str expr.to_string
  // 1023:   if
  // 1024:     precedence_of(expr) < prec
  // 1025:     -> str(.needs_parenthesis true)
  // 1026:     -> str(.needs_parenthesis false)
  frame->slots[13] /* temp__1 */ = create_closure(entry__55_172, 1);
  // 1021: $stringify_lt: (expr)
  // 1022:   $str expr.to_string
  // 1023:   if
  // 1024:     precedence_of(expr) < prec
  // 1025:     -> str(.needs_parenthesis true)
  // 1026:     -> str(.needs_parenthesis false)
  initialize_future(frame->slots[8] /* stringify_lt */, frame->slots[13] /* temp__1 */);
  // 1010: $prec precedence(functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__precedence();
  func = myself->type;
  frame->cont = cont__55_178;
}
static void entry__55_176(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1025: ... str(.needs_parenthesis true)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__true());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 1025: -> str(.needs_parenthesis true)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_177(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1026: ... str(.needs_parenthesis false)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__false());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 1026: -> str(.needs_parenthesis false)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_170(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1018: ... str(.needs_parenthesis true)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__true());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 1018: -> str(.needs_parenthesis true)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_171(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1019: ... str(.needs_parenthesis false)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__false());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 1019: -> str(.needs_parenthesis false)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_165(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // expr: 0
  // prec: 1
  // str: 2
  frame->slots[1] = myself->closure.frame->slots[4]; /* prec */
  frame->slots[2] /* str */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1015: $str expr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__55_166;
}
static void cont__55_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* str */, arguments->slots[0]);
  // 1017: precedence_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__55_167;
}
static void cont__55_167(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1017: precedence_of(expr) <= prec
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prec */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_168;
}
static void cont__55_168(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1017: precedence_of(expr) <= prec
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__55_169;
}
static void cont__55_169(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1018: -> str(.needs_parenthesis true)
  frame->slots[6] /* temp__4 */ = create_closure(entry__55_170, 0);
  // 1019: -> str(.needs_parenthesis false)
  frame->slots[7] /* temp__5 */ = create_closure(entry__55_171, 0);
  // 1016: if
  // 1017:   precedence_of(expr) <= prec
  // 1018:   -> str(.needs_parenthesis true)
  // 1019:   -> str(.needs_parenthesis false)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_172(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // expr: 0
  // prec: 1
  // str: 2
  frame->slots[1] = myself->closure.frame->slots[4]; /* prec */
  frame->slots[2] /* str */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1022: $str expr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__55_173;
}
static void cont__55_173(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* str */, arguments->slots[0]);
  // 1024: precedence_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__55_174;
}
static void cont__55_174(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1024: precedence_of(expr) < prec
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[1] /* prec */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_175;
}
static void cont__55_175(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1025: -> str(.needs_parenthesis true)
  frame->slots[5] /* temp__3 */ = create_closure(entry__55_176, 0);
  // 1026: -> str(.needs_parenthesis false)
  frame->slots[6] /* temp__4 */ = create_closure(entry__55_177, 0);
  // 1023: if
  // 1024:   precedence_of(expr) < prec
  // 1025:   -> str(.needs_parenthesis true)
  // 1026:   -> str(.needs_parenthesis false)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__55_178(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* prec */, arguments->slots[0]);
  // 1011: $$left arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_179;
}
static void cont__55_179(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* left */ = arguments->slots[0];
  // 1012: $$right arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[2] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_180;
}
static void cont__55_180(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* right */ = arguments->slots[0];
  // 1028: $$strings empty_list
  ((CELL *)frame->slots[9])->contents /* strings */ = get__empty_list();
  // 1030: prec.is_left_associative
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* prec */;
  result_count = 1;
  myself = get__is_left_associative();
  func = myself->type;
  frame->cont = cont__55_181;
}
static void cont__55_181(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1030: ... :
  // 1031:   put &strings stringify_le(right)
  // 1032:   while -> operator_of(left) == functor_string:
  // 1033:     $left_operands arguments_of(left)
  // 1034:     put &strings stringify_le(left_operands(2))
  // 1035:     !left left_operands(1)
  // 1036:   put &strings stringify_lt(left)
  frame->slots[14] /* temp__2 */ = create_closure(entry__55_182, 0);
  // 1037: : # no two right associative operatores have the same precedence
  // 1038:   push &strings stringify_le(left)
  // 1039:   while -> operator_of(right) == functor_string:
  // 1040:     $right_operands arguments_of(right)
  // 1041:     push &strings stringify_le(right_operands(1))
  // 1042:     !right right_operands(2)
  // 1043:   push &strings stringify_lt(right)
  frame->slots[15] /* temp__3 */ = create_closure(entry__55_197, 0);
  // 1029: if
  // 1030:   prec.is_left_associative:
  // 1031:     put &strings stringify_le(right)
  // 1032:     while -> operator_of(left) == functor_string:
  // 1033:       $left_operands arguments_of(left)
  // 1034:       put &strings stringify_le(left_operands(2))
  // 1035:       !left left_operands(1)
  // 1036:     put &strings stringify_lt(left)
  // 1037:   : # no two right associative operatores have the same precedence
  // 1038:     push &strings stringify_le(left)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_212;
}
static void entry__55_182(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // strings: 0
  // stringify_le: 1
  // right: 2
  // left: 3
  // functor_string: 4
  // stringify_lt: 5
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[7]; /* stringify_le */
  frame->slots[2] = myself->closure.frame->slots[6]; /* right */
  frame->slots[3] = myself->closure.frame->slots[5]; /* left */
  frame->slots[4] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[5] = myself->closure.frame->slots[8]; /* stringify_lt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1031: ... stringify_le(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* right */;
  result_count = 1;
  myself = frame->slots[1] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__55_183;
}
static void cont__55_183(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1031: put &strings stringify_le(right)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__55_184;
}
static void cont__55_184(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  // 1032: ... -> operator_of(left) == functor_string:
  // 1033:   $left_operands arguments_of(left)
  // 1034:   put &strings stringify_le(left_operands(2))
  // 1035:   !left left_operands(1)
  frame->slots[6] /* temp__1 */ = create_closure(entry__55_185, 0);
  // 1032: while -> operator_of(left) == functor_string:
  // 1033:   $left_operands arguments_of(left)
  // 1034:   put &strings stringify_le(left_operands(2))
  // 1035:   !left left_operands(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__55_194;
}
static void entry__55_188(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // left: 0
  // strings: 1
  // stringify_le: 2
  // left_operands: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* left */
  frame->slots[1] = myself->closure.frame->slots[2]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[3]; /* stringify_le */
  frame->slots[3] /* left_operands */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1033: $left_operands arguments_of(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* left */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__55_189;
}
static void cont__55_189(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* left_operands */, arguments->slots[0]);
  // 1034: ... left_operands(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[3] /* left_operands */;
  func = myself->type;
  frame->cont = cont__55_190;
}
static void cont__55_190(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1034: ... stringify_le(left_operands(2))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[2] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__55_191;
}
static void cont__55_191(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1034: put &strings stringify_le(left_operands(2))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__55_192;
}
static void cont__55_192(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* strings */ = arguments->slots[0];
  // 1035: !left left_operands(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[3] /* left_operands */;
  func = myself->type;
  frame->cont = cont__55_193;
}
static void cont__55_193(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* left */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_185(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // left: 0
  // functor_string: 1
  // strings: 2
  // stringify_le: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* left */
  frame->slots[1] = myself->closure.frame->slots[4]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[3] = myself->closure.frame->slots[1]; /* stringify_le */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1032: ... operator_of(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* left */;
  result_count = 1;
  myself = var._operator_of;
  func = myself->type;
  frame->cont = cont__55_186;
}
static void cont__55_186(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1032: ... operator_of(left) == functor_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_187;
}
static void cont__55_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1032: ... :
  // 1033:   $left_operands arguments_of(left)
  // 1034:   put &strings stringify_le(left_operands(2))
  // 1035:   !left left_operands(1)
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_188, 0);
  // 1032: ... -> operator_of(left) == functor_string:
  // 1033:   $left_operands arguments_of(left)
  // 1034:   put &strings stringify_le(left_operands(2))
  // 1035:   !left left_operands(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_194(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1036: ... stringify_lt(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* left */;
  result_count = 1;
  myself = frame->slots[5] /* stringify_lt */;
  func = myself->type;
  frame->cont = cont__55_195;
}
static void cont__55_195(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1036: put &strings stringify_lt(left)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__55_196;
}
static void cont__55_196(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_197(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // strings: 0
  // stringify_le: 1
  // left: 2
  // right: 3
  // functor_string: 4
  // stringify_lt: 5
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[7]; /* stringify_le */
  frame->slots[2] = myself->closure.frame->slots[5]; /* left */
  frame->slots[3] = myself->closure.frame->slots[6]; /* right */
  frame->slots[4] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[5] = myself->closure.frame->slots[8]; /* stringify_lt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1038: ... stringify_le(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* left */;
  result_count = 1;
  myself = frame->slots[1] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__55_198;
}
static void cont__55_198(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1038: push &strings stringify_le(left)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__55_199;
}
static void cont__55_199(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  // 1039: ... -> operator_of(right) == functor_string:
  // 1040:   $right_operands arguments_of(right)
  // 1041:   push &strings stringify_le(right_operands(1))
  // 1042:   !right right_operands(2)
  frame->slots[6] /* temp__1 */ = create_closure(entry__55_200, 0);
  // 1039: while -> operator_of(right) == functor_string:
  // 1040:   $right_operands arguments_of(right)
  // 1041:   push &strings stringify_le(right_operands(1))
  // 1042:   !right right_operands(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__55_209;
}
static void entry__55_203(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // right: 0
  // strings: 1
  // stringify_le: 2
  // right_operands: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* right */
  frame->slots[1] = myself->closure.frame->slots[2]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[3]; /* stringify_le */
  frame->slots[3] /* right_operands */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1040: $right_operands arguments_of(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__55_204;
}
static void cont__55_204(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* right_operands */, arguments->slots[0]);
  // 1041: ... right_operands(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[3] /* right_operands */;
  func = myself->type;
  frame->cont = cont__55_205;
}
static void cont__55_205(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1041: ... stringify_le(right_operands(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[2] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__55_206;
}
static void cont__55_206(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1041: push &strings stringify_le(right_operands(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__55_207;
}
static void cont__55_207(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* strings */ = arguments->slots[0];
  // 1042: !right right_operands(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[3] /* right_operands */;
  func = myself->type;
  frame->cont = cont__55_208;
}
static void cont__55_208(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_200(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // right: 0
  // functor_string: 1
  // strings: 2
  // stringify_le: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* right */
  frame->slots[1] = myself->closure.frame->slots[4]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[3] = myself->closure.frame->slots[1]; /* stringify_le */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1039: ... operator_of(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right */;
  result_count = 1;
  myself = var._operator_of;
  func = myself->type;
  frame->cont = cont__55_201;
}
static void cont__55_201(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1039: ... operator_of(right) == functor_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_202;
}
static void cont__55_202(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1039: ... :
  // 1040:   $right_operands arguments_of(right)
  // 1041:   push &strings stringify_le(right_operands(1))
  // 1042:   !right right_operands(2)
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_203, 0);
  // 1039: ... -> operator_of(right) == functor_string:
  // 1040:   $right_operands arguments_of(right)
  // 1041:   push &strings stringify_le(right_operands(1))
  // 1042:   !right right_operands(2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_209(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1043: ... stringify_lt(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* right */;
  result_count = 1;
  myself = frame->slots[5] /* stringify_lt */;
  func = myself->type;
  frame->cont = cont__55_210;
}
static void cont__55_210(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1043: push &strings stringify_lt(right)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__55_211;
}
static void cont__55_211(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_212(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1044: $$inline_functor undefined
  ((CELL *)frame->slots[10])->contents /* inline_functor */ = get__undefined();
  // 1045: $$total_width 0
  ((CELL *)frame->slots[11])->contents /* total_width */ = number__0;
  // 1046: ... : (-> break)
  // 1047:   for_each strings: (str)
  // 1048:     if str(1) == '@nl;':
  // 1049:       !total_width undefined
  // 1050:       break
  // 1051:     plus &total_width length_of(str)
  // 1052:     if str.needs_parenthesis: plus &total_width 2
  frame->slots[13] /* temp__1 */ = create_closure(entry__55_213, 0);
  // 1046: do: (-> break)
  // 1047:   for_each strings: (str)
  // 1048:     if str(1) == '@nl;':
  // 1049:       !total_width undefined
  // 1050:       break
  // 1051:     plus &total_width length_of(str)
  // 1052:     if str.needs_parenthesis: plus &total_width 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__55_225;
}
static void entry__55_213(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // break: 0
  // strings: 1
  // total_width: 2
  frame->slots[0] /* break */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[11]; /* total_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1047: ... : (str)
  // 1048:   if str(1) == '@nl;':
  // 1049:     !total_width undefined
  // 1050:     break
  // 1051:   plus &total_width length_of(str)
  // 1052:   if str.needs_parenthesis: plus &total_width 2
  frame->slots[3] /* temp__1 */ = create_closure(entry__55_214, 1);
  // 1047: for_each strings: (str)
  // 1048:   if str(1) == '@nl;':
  // 1049:     !total_width undefined
  // 1050:     break
  // 1051:   plus &total_width length_of(str)
  // 1052:   if str.needs_parenthesis: plus &total_width 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__55_224;
}
static void entry__55_222(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_width: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* total_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1052: ... plus &total_width 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_width */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__55_223;
}
static void cont__55_223(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_width */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_214(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // total_width: 1
  // break: 2
  frame->slots[1] = myself->closure.frame->slots[2]; /* total_width */
  frame->slots[2] = myself->closure.frame->slots[0]; /* break */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1048: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__55_215;
}
static void cont__55_215(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1048: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_216;
}
static void cont__55_216(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1048: ... :
  // 1049:   !total_width undefined
  // 1050:   break
  frame->slots[5] /* temp__3 */ = create_closure(entry__55_217, 0);
  // 1048: if str(1) == '@nl;':
  // 1049:   !total_width undefined
  // 1050:   break
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_218;
}
static void entry__55_217(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // total_width: 0
  // break: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* total_width */
  frame->slots[1] = myself->closure.frame->slots[2]; /* break */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1049: !total_width undefined
  ((CELL *)frame->slots[0])->contents /* total_width */ = get__undefined();
  // 1050: break
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* break */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__55_218(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1051: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_219;
}
static void cont__55_219(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1051: plus &total_width length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* total_width */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__55_220;
}
static void cont__55_220(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* total_width */ = arguments->slots[0];
  // 1052: ... str.needs_parenthesis
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = var._needs_parenthesis;
  func = myself->type;
  frame->cont = cont__55_221;
}
static void cont__55_221(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1052: ... : plus &total_width 2
  frame->slots[4] /* temp__2 */ = create_closure(entry__55_222, 0);
  // 1052: if str.needs_parenthesis: plus &total_width 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__55_224(void) {
  myself = frame->slots[0] /* break */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__55_225(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1053: ... total_width.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* total_width */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_226;
}
static void cont__55_226(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1053: ... :
  // 1054:   !inline_functor
  // 1055:     case
  // 1056:       functor_string
  // 1057:       "+", "-", "*", "/"
  // 1058:       -> functor_string
  // 1059:       ","
  // 1060:       -> string(functor_string ' ')
  // 1061:       -> string(' ' functor_string ' ')
  // 1062:   plus &total_width (length_of(strings)-1)*length_of(inline_functor)
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__55_227, 0);
  // 1053: if total_width.is_defined:
  // 1054:   !inline_functor
  // 1055:     case
  // 1056:       functor_string
  // 1057:       "+", "-", "*", "/"
  // 1058:       -> functor_string
  // 1059:       ","
  // 1060:       -> string(functor_string ' ')
  // 1061:       -> string(' ' functor_string ' ')
  // 1062:   plus &total_width (length_of(strings)-1)*length_of(inline_functor)
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_248;
}
static void entry__55_247(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_width: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1063: ... !total_width undefined
  ((CELL *)frame->slots[0])->contents /* total_width */ = get__undefined();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_227(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // inline_functor: 0
  // functor_string: 1
  // total_width: 2
  // strings: 3
  // indent: 4
  frame->slots[0] = myself->closure.frame->slots[10]; /* inline_functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[11]; /* total_width */
  frame->slots[3] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[4] = myself->closure.frame->slots[3]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1057: "+", "-", "*", "/"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__55_228;
  arguments->slots[1] = string__55_229;
  arguments->slots[2] = string__55_230;
  arguments->slots[3] = string__55_231;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__55_232;
}
static void cont__55_232(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1058: -> functor_string
  frame->slots[6] /* temp__2 */ = create_closure(entry__55_233, 0);
  // 1060: -> string(functor_string ' ')
  frame->slots[7] /* temp__3 */ = create_closure(entry__55_234, 0);
  // 1061: -> string(' ' functor_string ' ')
  frame->slots[8] /* temp__4 */ = create_closure(entry__55_236, 0);
  // 1054: !inline_functor
  // 1055:   case
  // 1056:     functor_string
  // 1057:     "+", "-", "*", "/"
  // 1058:     -> functor_string
  // 1059:     ","
  // 1060:     -> string(functor_string ' ')
  // 1061:     -> string(' ' functor_string ' ')
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  arguments->slots[3] = string__55_238;
  arguments->slots[4] = frame->slots[7] /* temp__3 */;
  arguments->slots[5] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__55_239;
}
static void entry__55_233(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1058: -> functor_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_234(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1060: ... string(functor_string ' ')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_235;
}
static void cont__55_235(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1060: -> string(functor_string ' ')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_236(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1061: ... string(' ' functor_string ' ')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[2] = character__32;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_237;
}
static void cont__55_237(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1061: -> string(' ' functor_string ' ')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_239(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* inline_functor */ = arguments->slots[0];
  // 1062: ... length_of(strings)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* strings */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_240;
}
static void cont__55_240(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 1062: ... length_of(strings)-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__55_241;
}
static void cont__55_241(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1062: ... length_of(inline_functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* inline_functor */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_242;
}
static void cont__55_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__4 */ = arguments->slots[0];
  // 1062: ... length_of(strings)-1)*length_of(inline_functor)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__std__times();
  func = myself->type;
  frame->cont = cont__55_243;
}
static void cont__55_243(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1062: plus &total_width (length_of(strings)-1)*length_of(inline_functor)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_width */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__55_244;
}
static void cont__55_244(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* total_width */ = arguments->slots[0];
  // 1063: ... indent+total_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* indent */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_width */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__55_245;
}
static void cont__55_245(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1063: ... indent+total_width > line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_246;
}
static void cont__55_246(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1063: ... : !total_width undefined
  frame->slots[7] /* temp__3 */ = create_closure(entry__55_247, 0);
  // 1063: if indent+total_width > line_width: !total_width undefined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__55_248(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1064: $$buf ""
  ((CELL *)frame->slots[12])->contents /* buf */ = empty_string;
  // 1066: total_width.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* total_width */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_249;
}
static void cont__55_249(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1066: ... : # inline
  // 1067:   for_each
  // 1068:     strings: (str)
  // 1069:       if str.needs_parenthesis: push &buf '('
  // 1070:       append &buf str
  // 1071:       if str.needs_parenthesis: push &buf ')'
  // 1072:     :
  // 1073:       append &buf inline_functor
  frame->slots[14] /* temp__2 */ = create_closure(entry__55_250, 0);
  // 1074: : # multi-line
  // 1075:   case functor_string ",": !functor_string "sequence"
  // 1076:   $indentation spaces(expression_indent)
  // 1077:   !buf string('@nl;' spaces(indent) functor_string)
  // 1078:   for_each strings: (str)
  // 1079:     unless str(1) == '@nl;':
  // 1080:       push &buf '@nl;'
  // 1081:       append &buf indentation
  // 1082:     append &buf str
  frame->slots[15] /* temp__3 */ = create_closure(entry__55_262, 0);
  // 1065: if
  // 1066:   total_width.is_defined: # inline
  // 1067:     for_each
  // 1068:       strings: (str)
  // 1069:         if str.needs_parenthesis: push &buf '('
  // 1070:         append &buf str
  // 1071:         if str.needs_parenthesis: push &buf ')'
  // 1072:       :
  // 1073:         append &buf inline_functor
  // 1074:   : # multi-line
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_278;
}
static void entry__55_270(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[4]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1079: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__55_271;
}
static void cont__55_271(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1079: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_272;
}
static void cont__55_272(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1079: ... :
  // 1080:   push &buf '@nl;'
  // 1081:   append &buf indentation
  frame->slots[5] /* temp__3 */ = create_closure(entry__55_273, 0);
  // 1079: unless str(1) == '@nl;':
  // 1080:   push &buf '@nl;'
  // 1081:   append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__55_276;
}
static void entry__55_273(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1080: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__55_274;
}
static void cont__55_274(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1081: append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__55_275;
}
static void cont__55_275(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_276(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1082: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__55_277;
}
static void cont__55_277(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_258(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1071: ... push &buf ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__55_259;
}
static void cont__55_259(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_251(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // str: 0
  // buf: 1
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1069: ... str.needs_parenthesis
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = var._needs_parenthesis;
  func = myself->type;
  frame->cont = cont__55_252;
}
static void cont__55_252(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1069: ... : push &buf '('
  frame->slots[3] /* temp__2 */ = create_closure(entry__55_253, 0);
  // 1069: if str.needs_parenthesis: push &buf '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_255;
}
static void entry__55_253(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1069: ... push &buf '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__55_254;
}
static void cont__55_254(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_255(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1070: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__55_256;
}
static void cont__55_256(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1071: ... str.needs_parenthesis
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = var._needs_parenthesis;
  func = myself->type;
  frame->cont = cont__55_257;
}
static void cont__55_257(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1071: ... : push &buf ')'
  frame->slots[3] /* temp__2 */ = create_closure(entry__55_258, 0);
  // 1071: if str.needs_parenthesis: push &buf ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_260(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // inline_functor: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* inline_functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1073: append &buf inline_functor
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* inline_functor */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__55_261;
}
static void cont__55_261(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_250(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // strings: 0
  // buf: 1
  // inline_functor: 2
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[12]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[10]; /* inline_functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1068: ... : (str)
  // 1069:   if str.needs_parenthesis: push &buf '('
  // 1070:   append &buf str
  // 1071:   if str.needs_parenthesis: push &buf ')'
  frame->slots[3] /* temp__1 */ = create_closure(entry__55_251, 1);
  // 1072: :
  // 1073:   append &buf inline_functor
  frame->slots[4] /* temp__2 */ = create_closure(entry__55_260, 0);
  // 1067: for_each
  // 1068:   strings: (str)
  // 1069:     if str.needs_parenthesis: push &buf '('
  // 1070:     append &buf str
  // 1071:     if str.needs_parenthesis: push &buf ')'
  // 1072:   :
  // 1073:     append &buf inline_functor
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_262(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // functor_string: 0
  // buf: 1
  // indent: 2
  // strings: 3
  // indentation: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[12]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[4] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1075: ... : !functor_string "sequence"
  frame->slots[5] /* temp__1 */ = create_closure(entry__55_263, 0);
  // 1075: case functor_string ",": !functor_string "sequence"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = string__55_265;
  arguments->slots[2] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__55_266;
}
static void entry__55_263(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1075: ... !functor_string "sequence"
  ((CELL *)frame->slots[0])->contents /* functor_string */ = string__55_264;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_266(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1076: $indentation spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__55_267;
}
static void cont__55_267(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* indentation */, arguments->slots[0]);
  // 1077: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__55_268;
}
static void cont__55_268(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1077: !buf string('@nl;' spaces(indent) functor_string)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_269;
}
static void cont__55_269(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1078: ... : (str)
  // 1079:   unless str(1) == '@nl;':
  // 1080:     push &buf '@nl;'
  // 1081:     append &buf indentation
  // 1082:   append &buf str
  frame->slots[5] /* temp__1 */ = create_closure(entry__55_270, 1);
  // 1078: for_each strings: (str)
  // 1079:   unless str(1) == '@nl;':
  // 1080:     push &buf '@nl;'
  // 1081:     append &buf indentation
  // 1082:   append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* strings */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__55_278(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1083: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* buf */;
  myself = frame->slots[0] /* return__6 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__55_279(void) {
  myself = frame->slots[0] /* return__7 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__55_146(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 997: ... arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_147;
}
static void cont__55_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 997: ... "--@(arguments(1))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__55_148;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__55_149;
}
static void cont__55_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 997: -> "--@(arguments(1))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_105(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 983: ... string_template_to_string(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._string_template_to_string;
  func = myself->type;
  frame->cont = cont__55_106;
}
static void cont__55_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 983: -> string_template_to_string(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_107(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // return__5: 0
  // self: 1
  frame->slots[0] /* return__5 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 986: ... string_template_to_string(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = var._string_template_to_string;
  func = myself->type;
  frame->cont = cont__55_108;
}
static void cont__55_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 986: add_remark self string_template_to_string(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame->cont = cont__55_109;
}
static void cont__55_109(void) {
  myself = frame->slots[0] /* return__5 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__55_102(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 982: remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__55_103;
}
static void cont__55_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 982: remark_lines_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__55_104;
}
static void cont__55_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 983: -> string_template_to_string(self)
  frame->slots[3] /* temp__3 */ = create_closure(entry__55_105, 0);
  // 984: :
  // 985:   %line_width UNLIMITED # force inline output
  // 986:   add_remark self string_template_to_string(self)
  frame->slots[4] /* temp__4 */ = create_closure(entry__55_107, 0);
  // 981: if
  // 982:   remark_lines_of(self).is_empty
  // 983:   -> string_template_to_string(self)
  // 984:   :
  // 985:     %line_width UNLIMITED # force inline output
  // 986:     add_remark self string_template_to_string(self)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_95(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // self: 0
  // left: 1
  // functor_string: 2
  // right: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* self */
  frame->slots[1] = myself->closure.frame->slots[6]; /* left */
  frame->slots[2] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[3] = myself->closure.frame->slots[7]; /* right */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 978: ... string(left " ." functor_string ". " right)
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* left */;
  arguments->slots[1] = string__55_96;
  arguments->slots[2] = ((CELL *)frame->slots[2])->contents /* functor_string */;
  arguments->slots[3] = string__55_97;
  arguments->slots[4] = ((CELL *)frame->slots[3])->contents /* right */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_98;
}
static void cont__55_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 978: ... add_remark(self string(left " ." functor_string ". " right))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = var._add_remark;
  func = myself->type;
  frame->cont = cont__55_99;
}
static void cont__55_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 978: -> add_remark(self string(left " ." functor_string ". " right))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_70(void) {
  allocate_initialized_frame_gc(4, 14);
  // slot allocations:
  // arguments: 0
  // functor_string: 1
  // self: 2
  // default_call: 3
  // left_argument: 4
  // right_argument: 5
  // left: 6
  // right: 7
  // length: 8
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[3]; /* default_call */
  frame->slots[4] /* left_argument */ = create_future();
  frame->slots[5] /* right_argument */ = create_future();
  frame->slots[6] /* left */ = create_cell();
  frame->slots[7] /* right */ = create_cell();
  frame->slots[8] /* length */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 967: $left_argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_71;
}
static void cont__55_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* left_argument */, arguments->slots[0]);
  // 968: $right_argument arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_72;
}
static void cont__55_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* right_argument */, arguments->slots[0]);
  // 969: $$left left_argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* left_argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__55_73;
}
static void cont__55_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* left */ = arguments->slots[0];
  // 970: $$right right_argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* right_argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__55_74;
}
static void cont__55_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[7])->contents /* right */ = arguments->slots[0];
  // 971: ... precedence_of(left_argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* left_argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__55_75;
}
static void cont__55_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 971: ... precedence_of(left_argument) < INFIX_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  arguments->slots[1] = get__INFIX_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_76;
}
static void cont__55_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 971: ... :
  // 972:   !left string('(' left ')')
  frame->slots[11] /* temp__3 */ = create_closure(entry__55_77, 0);
  // 971: if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:   !left string('(' left ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_79;
}
static void entry__55_77(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // left: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* left */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 972: !left string('(' left ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* left */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_78;
}
static void cont__55_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* left */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_79(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 973: ... precedence_of(right_argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* right_argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__55_80;
}
static void cont__55_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__3 */ = arguments->slots[0];
  // 973: ... precedence_of(right_argument) <= INFIX_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__INFIX_PRECEDENCE();
  arguments->slots[1] = frame->slots[11] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_81;
}
static void cont__55_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 973: ... precedence_of(right_argument) <= INFIX_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__55_82;
}
static void cont__55_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 973: ... :
  // 974:   !right string('(' right ')')
  frame->slots[12] /* temp__4 */ = create_closure(entry__55_83, 0);
  // 973: if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 974:   !right string('(' right ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_85;
}
static void entry__55_83(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // right: 0
  frame->slots[0] = myself->closure.frame->slots[7]; /* right */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 974: !right string('(' right ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* right */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_84;
}
static void cont__55_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_85(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 975: ... length_of(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* left */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_86;
}
static void cont__55_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__3 */ = arguments->slots[0];
  // 975: ... length_of(functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_87;
}
static void cont__55_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__4 */ = arguments->slots[0];
  // 975: ... length_of(left)+length_of(functor_string)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__3 */;
  arguments->slots[1] = frame->slots[12] /* temp__4 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__55_88;
}
static void cont__55_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 975: ... length_of(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[7])->contents /* right */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_89;
}
static void cont__55_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__5 */ = arguments->slots[0];
  // 975: ... length_of(left)+length_of(functor_string)+length_of(right)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  arguments->slots[1] = frame->slots[13] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__55_90;
}
static void cont__55_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 975: $length length_of(left)+length_of(functor_string)+length_of(right)+4
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = number__4;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__55_91;
}
static void cont__55_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* length */, arguments->slots[0]);
  // 977: expression_indent+length
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = frame->slots[8] /* length */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__55_92;
}
static void cont__55_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__3 */ = arguments->slots[0];
  // 977: expression_indent+length <= line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[11] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_93;
}
static void cont__55_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 977: expression_indent+length <= line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__55_94;
}
static void cont__55_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 978: -> add_remark(self string(left " ." functor_string ". " right))
  frame->slots[12] /* temp__4 */ = create_closure(entry__55_95, 0);
  // 976: if
  // 977:   expression_indent+length <= line_width
  // 978:   -> add_remark(self string(left " ." functor_string ". " right))
  // 979:   default_call
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__4 */;
  arguments->slots[2] = frame->slots[3] /* default_call */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_68(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  // default_call: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[3] = myself->closure.frame->slots[3]; /* default_call */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 966: ... self.is_in_infix_notation
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_in_infix_notation();
  func = myself->type;
  frame->cont = cont__55_69;
}
static void cont__55_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 966: ... :
  // 967:   $left_argument arguments(1)
  // 968:   $right_argument arguments(2)
  // 969:   $$left left_argument.to_string
  // 970:   $$right right_argument.to_string
  // 971:   if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:     !left string('(' left ')')
  // 973:   if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 974:     !right string('(' right ')')
  // 975:   $length length_of(left)+length_of(functor_string)+length_of(right)+4
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__55_70, 0);
  // 966: -> self.is_in_infix_notation:
  // 967:   $left_argument arguments(1)
  // 968:   $right_argument arguments(2)
  // 969:   $$left left_argument.to_string
  // 970:   $$right right_argument.to_string
  // 971:   if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:     !left string('(' left ')')
  // 973:   if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 974:     !right string('(' right ')')
  // 975:   $length length_of(left)+length_of(functor_string)+length_of(right)+4
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_100(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 980: ... self.is_a_string_template
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_string_template();
  func = myself->type;
  frame->cont = cont__55_101;
}
static void cont__55_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 980: ... :
  // 981:   if
  // 982:     remark_lines_of(self).is_empty
  // 983:     -> string_template_to_string(self)
  // 984:     :
  // 985:       %line_width UNLIMITED # force inline output
  // 986:       add_remark self string_template_to_string(self)
  frame->slots[2] /* temp__2 */ = create_closure(entry__55_102, 0);
  // 980: -> self.is_a_string_template:
  // 981:   if
  // 982:     remark_lines_of(self).is_empty
  // 983:     -> string_template_to_string(self)
  // 984:     :
  // 985:       %line_width UNLIMITED # force inline output
  // 986:       add_remark self string_template_to_string(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_110(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 989: functor.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__55_111;
}
static void cont__55_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__3 */ = create_closure(entry__55_112, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_145;
}
static void entry__55_112(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 990: namespace_of(functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__55_113;
}
static void cont__55_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 990: namespace_of(functor) == "std"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = string__55_114;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_115;
}
static void cont__55_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__4 */ = create_closure(entry__55_116, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_144;
}
static void entry__55_116(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 991: name_of(functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__55_117;
}
static void cont__55_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 991: name_of(functor) == "key_value_pair"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = string__55_118;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_119;
}
static void cont__55_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__4 */ = create_closure(entry__55_120, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_143;
}
static void entry__55_120(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 992: length_of(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_121;
}
static void cont__55_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 992: length_of(arguments) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_122;
}
static void cont__55_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__55_123, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_142;
}
static void entry__55_123(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 993: arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_124;
}
static void cont__55_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 993: arguments(1).is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__55_125;
}
static void cont__55_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__55_126, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_141;
}
static void entry__55_126(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 994: arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_127;
}
static void cont__55_127(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 994: arguments(2).is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__55_128;
}
static void cont__55_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__55_129, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_140;
}
static void entry__55_129(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 995: ... arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_130;
}
static void cont__55_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 995: namespace_of(arguments(2))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__55_131;
}
static void cont__55_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 995: namespace_of(arguments(2)) == "std"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = string__55_132;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_133;
}
static void cont__55_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 996: name_of(arguments(2)) == "true"
  frame->slots[5] /* temp__5 */ = create_closure(entry__55_134, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__55_139;
}
static void entry__55_134(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 996: ... arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_135;
}
static void cont__55_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 996: name_of(arguments(2))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__55_136;
}
static void cont__55_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 996: name_of(arguments(2)) == "true"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = string__55_137;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_138;
}
static void cont__55_138(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 996: name_of(arguments(2)) == "true"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_141(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 997: -> "--@(arguments(1))"
  frame->slots[5] /* temp__4 */ = create_closure(entry__55_146, 0);
  // 987: ->
  // 988:   &&
  // 989:     functor.is_an_identifier
  // 990:     namespace_of(functor) == "std"
  // 991:     name_of(functor) == "key_value_pair"
  // 992:     length_of(arguments) == 2
  // 993:     arguments(1).is_an_identifier
  // 994:     arguments(2).is_an_identifier
  // 995:     namespace_of(arguments(2)) == "std"
  // 996:     name_of(arguments(2)) == "true"
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_150(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // default_call: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* default_call */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 998: -> true default_call
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[0] /* default_call */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_67(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  // default_call: 3
  // functor: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* self */
  frame->slots[1] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[0]; /* functor_string */
  frame->slots[3] = myself->closure.frame->slots[3]; /* default_call */
  frame->slots[4] = myself->closure.frame->slots[4]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 966: -> self.is_in_infix_notation:
  // 967:   $left_argument arguments(1)
  // 968:   $right_argument arguments(2)
  // 969:   $$left left_argument.to_string
  // 970:   $$right right_argument.to_string
  // 971:   if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:     !left string('(' left ')')
  // 973:   if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 974:     !right string('(' right ')')
  // 975:   $length length_of(left)+length_of(functor_string)+length_of(right)+4
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__55_68, 0);
  // 980: -> self.is_a_string_template:
  // 981:   if
  // 982:     remark_lines_of(self).is_empty
  // 983:     -> string_template_to_string(self)
  // 984:     :
  // 985:       %line_width UNLIMITED # force inline output
  // 986:       add_remark self string_template_to_string(self)
  frame->slots[6] /* temp__2 */ = create_closure(entry__55_100, 0);
  // 987: ->
  // 988:   &&
  // 989:     functor.is_an_identifier
  // 990:     namespace_of(functor) == "std"
  // 991:     name_of(functor) == "key_value_pair"
  // 992:     length_of(arguments) == 2
  // 993:     arguments(1).is_an_identifier
  // 994:     arguments(2).is_an_identifier
  // 995:     namespace_of(arguments(2)) == "std"
  // 996:     name_of(arguments(2)) == "true"
  // ...
  frame->slots[7] /* temp__3 */ = create_closure(entry__55_110, 0);
  // 998: -> true default_call
  frame->slots[8] /* temp__4 */ = create_closure(entry__55_150, 0);
  // 965: cond
  // 966:   -> self.is_in_infix_notation:
  // 967:     $left_argument arguments(1)
  // 968:     $right_argument arguments(2)
  // 969:     $$left left_argument.to_string
  // 970:     $$right right_argument.to_string
  // 971:     if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:       !left string('(' left ')')
  // 973:     if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 974:       !right string('(' right ')')
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  arguments->slots[3] = frame->slots[8] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_57(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // arguments: 0
  // functor_string: 1
  // argument: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[2] /* argument */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 960: $$argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_58;
}
static void cont__55_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* argument */ = arguments->slots[0];
  // 961: ... precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__55_59;
}
static void cont__55_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 961: ... precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__55_60;
}
static void cont__55_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 961: ... :
  // 962:   !argument string('(' argument ')')
  frame->slots[5] /* temp__3 */ = create_closure(entry__55_61, 0);
  // 961: if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 962:   !argument string('(' argument ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_63;
}
static void entry__55_61(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 962: !argument string('(' argument ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* argument */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_62;
}
static void cont__55_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* argument */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_63(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 963: ... string(argument '.' functor_string)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* argument */;
  arguments->slots[1] = character__46;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_64;
}
static void cont__55_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 963: -> string(argument '.' functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_47(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // return__4: 0
  // arguments: 1
  // functor_string: 2
  // argument: 3
  frame->slots[0] /* return__4 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* functor_string */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  frame->slots[3] /* argument */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 954: $argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* arguments */;
  func = myself->type;
  frame->cont = cont__55_48;
}
static void cont__55_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* argument */, arguments->slots[0]);
  // 956: functor_string.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* functor_string */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_49;
}
static void cont__55_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 957: -> string(argument '/' functor_string)
  frame->slots[5] /* temp__2 */ = create_closure(entry__55_50, 0);
  // 958: -> string(argument '/')
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_52, 0);
  // 955: if
  // 956:   functor_string.is_defined
  // 957:   -> string(argument '/' functor_string)
  // 958:   -> string(argument '/')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_54;
}
static void entry__55_50(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // argument: 0
  // functor_string: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 957: ... string(argument '/' functor_string)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  arguments->slots[1] = character__47;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_51;
}
static void cont__55_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 957: -> string(argument '/' functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_52(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 958: ... string(argument '/')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  arguments->slots[1] = character__47;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_53;
}
static void cont__55_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 958: -> string(argument '/')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_54(void) {
  myself = frame->slots[0] /* return__4 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__55_45(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 952: ... self.is_a_method_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_method_definition();
  func = myself->type;
  frame->cont = cont__55_46;
}
static void cont__55_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 952: ... :
  // 953:   %line_width UNLIMITED # force inline output
  // 954:   $argument arguments(1)
  // 955:   if
  // 956:     functor_string.is_defined
  // 957:     -> string(argument '/' functor_string)
  // 958:     -> string(argument '/')
  frame->slots[4] /* temp__2 */ = create_closure(entry__55_47, 0);
  // 952: -> self.is_a_method_definition:
  // 953:   %line_width UNLIMITED # force inline output
  // 954:   $argument arguments(1)
  // 955:   if
  // 956:     functor_string.is_defined
  // 957:     -> string(argument '/' functor_string)
  // 958:     -> string(argument '/')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_55(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 959: ... self.is_an_attribute_access
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_an_attribute_access();
  func = myself->type;
  frame->cont = cont__55_56;
}
static void cont__55_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 959: ... :
  // 960:   $$argument arguments(1)
  // 961:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 962:     !argument string('(' argument ')')
  // 963:   -> string(argument '.' functor_string)
  frame->slots[4] /* temp__2 */ = create_closure(entry__55_57, 0);
  // 959: -> self.is_an_attribute_access:
  // 960:   $$argument arguments(1)
  // 961:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 962:     !argument string('(' argument ')')
  // 963:   -> string(argument '.' functor_string)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_65(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // functor_string: 0
  // self: 1
  // arguments: 2
  // default_call: 3
  // functor: 4
  frame->slots[0] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[4]; /* default_call */
  frame->slots[4] = myself->closure.frame->slots[2]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 964: ... any_of(functor_string is_a_letter)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = get__is_a_letter();
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__55_66;
}
static void cont__55_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 964: ... :
  // 965:   cond
  // 966:     -> self.is_in_infix_notation:
  // 967:       $left_argument arguments(1)
  // 968:       $right_argument arguments(2)
  // 969:       $$left left_argument.to_string
  // 970:       $$right right_argument.to_string
  // 971:       if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:         !left string('(' left ')')
  // 973:       if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__55_67, 0);
  // 964: -> any_of(functor_string is_a_letter):
  // 965:   cond
  // 966:     -> self.is_in_infix_notation:
  // 967:       $left_argument arguments(1)
  // 968:       $right_argument arguments(2)
  // 969:       $$left left_argument.to_string
  // 970:       $$right right_argument.to_string
  // 971:       if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:         !left string('(' left ')')
  // 973:       if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_151(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // indent: 0
  // arguments: 1
  // functor_string: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  //  999: ... : # operator symbols
  // 1000:   %expression_indent indent+2
  // 1001:   if
  // 1002:     length_of(arguments) == 1:
  // 1003:       $argument arguments(1)
  // 1004:       if
  // 1005:         precedence_of(argument) < HIGHEST_PRECEDENCE
  // 1006:         -> string(functor_string '(' argument ')')
  // 1007:         -> string(functor_string argument)
  // 1008:     :
  // ...
  frame->slots[3] /* temp__1 */ = create_closure(entry__55_152, 0);
  //  999: -> true: # operator symbols
  // 1000:   %expression_indent indent+2
  // 1001:   if
  // 1002:     length_of(arguments) == 1:
  // 1003:       $argument arguments(1)
  // 1004:       if
  // 1005:         precedence_of(argument) < HIGHEST_PRECEDENCE
  // 1006:         -> string(functor_string '(' argument ')')
  // 1007:         -> string(functor_string argument)
  // 1008:     :
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_1(void) {
  allocate_initialized_frame_gc(1, 10);
  // slot allocations:
  // self: 0
  // indent: 1
  // functor: 2
  // functor_string: 3
  // default_call: 4
  // arguments: 5
  frame->slots[4] /* default_call */ = create_future();
  // _define $indent expression_indent
  frame->slots[1] /* indent */ = get__expression_indent();
  frame->slots[2] /* functor */ = create_future();
  frame->slots[3] /* functor_string */ = create_cell();
  frame->slots[5] /* arguments */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 912: ... :
  // 913:   %expression_indent indent+2
  // 914:   
  // 915:   $arguments_string
  // 916:     arguments_to_string
  // 917:       self
  // 918:       FUNC
  // 919:       line_width-indent-length_of(functor_string)-2
  // 920:   
  // 921:   $remark_lines
  // ...
  frame->slots[6] /* temp__1 */ = create_closure(entry__55_2, 0);
  // 912: $default_call:
  // 913:   %expression_indent indent+2
  // 914:   
  // 915:   $arguments_string
  // 916:     arguments_to_string
  // 917:       self
  // 918:       FUNC
  // 919:       line_width-indent-length_of(functor_string)-2
  // 920:   
  // 921:   $remark_lines
  // ...
  initialize_future(frame->slots[4] /* default_call */, frame->slots[6] /* temp__1 */);
  // 903: $functor functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__55_37;
}
static void entry__55_2(void) {
  allocate_initialized_frame_gc(4, 10);
  // slot allocations:
  // return__3: 0
  // indent: 1
  // self: 2
  // functor_string: 3
  // arguments_string: 4
  // remark_lines: 5
  frame->slots[0] /* return__3 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[3]; /* functor_string */
  define__expression_indent(create_future());
  frame->slots[4] /* arguments_string */ = create_future();
  frame->slots[5] /* remark_lines */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 913: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__55_3;
}
static void cont__55_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 919: line_width-indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__55_4;
}
static void cont__55_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 919: ... length_of(functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* functor_string */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__55_5;
}
static void cont__55_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__4 */ = arguments->slots[0];
  // 919: line_width-indent-length_of(functor_string)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__3 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__55_6;
}
static void cont__55_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 919: line_width-indent-length_of(functor_string)-2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__55_7;
}
static void cont__55_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 915: $arguments_string
  // 916:   arguments_to_string
  // 917:     self
  // 918:     FUNC
  // 919:     line_width-indent-length_of(functor_string)-2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  arguments->slots[1] = var._FUNC;
  arguments->slots[2] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = var._arguments_to_string;
  func = myself->type;
  frame->cont = cont__55_8;
}
static void cont__55_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* arguments_string */, arguments->slots[0]);
  // 922: ... remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__55_9;
}
static void cont__55_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 922: ... functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__55_10;
}
static void cont__55_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 922: ... remark_lines_behind_of(functor_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__remark_lines_behind_of();
  func = myself->type;
  frame->cont = cont__55_11;
}
static void cont__55_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 921: $remark_lines
  // 922:   append(remark_lines_of(self) remark_lines_behind_of(functor_of(self)))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__55_12;
}
static void cont__55_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* remark_lines */, arguments->slots[0]);
  // 925: remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__55_13;
}
static void cont__55_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 925: ... :
  // 926:   if
  // 927:     arguments_string .contains. '@nl;'
  // 928:     -> string('@nl;' spaces(indent) functor_string arguments_string)
  // 929:     -> string(functor_string '(' arguments_string ')')
  frame->slots[7] /* temp__2 */ = create_closure(entry__55_14, 0);
  // 930: :
  // 931:   if
  // 932:     arguments_string .contains. '@nl;':
  // 933:       $$remark add_remark_lines("" remark_lines)
  // 934:       unless remark(1) == '@nl;':
  // 935:         !remark string('@nl;' spaces(expression_indent) remark)
  // 936:       ->
  // 937:         string
  // 938:           '@nl;'
  // 939:           spaces(indent)
  // ...
  frame->slots[8] /* temp__3 */ = create_closure(entry__55_21, 0);
  // 924: if
  // 925:   remark_lines.is_empty:
  // 926:     if
  // 927:       arguments_string .contains. '@nl;'
  // 928:       -> string('@nl;' spaces(indent) functor_string arguments_string)
  // 929:       -> string(functor_string '(' arguments_string ')')
  // 930:   :
  // 931:     if
  // 932:       arguments_string .contains. '@nl;':
  // 933:         $$remark add_remark_lines("" remark_lines)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_36;
}
static void entry__55_23(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // remark_lines: 0
  // indent: 1
  // functor_string: 2
  // arguments_string: 3
  // remark: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[3] = myself->closure.frame->slots[0]; /* arguments_string */
  frame->slots[4] /* remark */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 933: $$remark add_remark_lines("" remark_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  arguments->slots[1] = frame->slots[0] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__55_24;
}
static void cont__55_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* remark */ = arguments->slots[0];
  // 934: ... remark(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[4])->contents /* remark */;
  func = myself->type;
  frame->cont = cont__55_25;
}
static void cont__55_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 934: ... remark(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__55_26;
}
static void cont__55_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 934: ... :
  // 935:   !remark string('@nl;' spaces(expression_indent) remark)
  frame->slots[7] /* temp__3 */ = create_closure(entry__55_27, 0);
  // 934: unless remark(1) == '@nl;':
  // 935:   !remark string('@nl;' spaces(expression_indent) remark)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__55_30;
}
static void entry__55_27(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // remark: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* remark */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 935: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__55_28;
}
static void cont__55_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 935: !remark string('@nl;' spaces(expression_indent) remark)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* remark */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_29;
}
static void cont__55_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* remark */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_30(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 939: spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__55_31;
}
static void cont__55_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 937: string
  // 938:   '@nl;'
  // 939:   spaces(indent)
  // 940:   functor_string
  // 941:   remark
  // 942:   arguments_string
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = ((CELL *)frame->slots[2])->contents /* functor_string */;
  arguments->slots[3] = ((CELL *)frame->slots[4])->contents /* remark */;
  arguments->slots[4] = frame->slots[3] /* arguments_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_32;
}
static void cont__55_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 936: ->
  // 937:   string
  // 938:     '@nl;'
  // 939:     spaces(indent)
  // 940:     functor_string
  // 941:     remark
  // 942:     arguments_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_33(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // return__2: 0
  // indent: 1
  // functor_string: 2
  // arguments_string: 3
  // remark_lines: 4
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[3] = myself->closure.frame->slots[0]; /* arguments_string */
  frame->slots[4] = myself->closure.frame->slots[1]; /* remark_lines */
  // _define %expression_indent indent
  define__expression_indent(frame->slots[1] /* indent */);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 944: %expression_indent indent
  initialize_maybe_future(get__expression_indent(), frame->slots[1] /* indent */);
  // 947: string(functor_string '(' arguments_string ')')
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* functor_string */;
  arguments->slots[1] = character__40;
  arguments->slots[2] = frame->slots[3] /* arguments_string */;
  arguments->slots[3] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_34;
}
static void cont__55_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 946: add_remark_lines
  // 947:   string(functor_string '(' arguments_string ')')
  // 948:   remark_lines
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__55_35;
}
static void cont__55_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 945: ->
  // 946:   add_remark_lines
  // 947:     string(functor_string '(' arguments_string ')')
  // 948:     remark_lines
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__55_16(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // indent: 0
  // functor_string: 1
  // arguments_string: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[0]; /* arguments_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 928: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__55_17;
}
static void cont__55_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 928: ... string('@nl;' spaces(indent) functor_string arguments_string)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  arguments->slots[3] = frame->slots[2] /* arguments_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_18;
}
static void cont__55_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 928: -> string('@nl;' spaces(indent) functor_string arguments_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_19(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor_string: 0
  // arguments_string: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[0]; /* arguments_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 929: ... string(functor_string '(' arguments_string ')')
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = character__40;
  arguments->slots[2] = frame->slots[1] /* arguments_string */;
  arguments->slots[3] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__55_20;
}
static void cont__55_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 929: -> string(functor_string '(' arguments_string ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__55_14(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // arguments_string: 0
  // indent: 1
  // functor_string: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* arguments_string */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 927: arguments_string .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments_string */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__55_15;
}
static void cont__55_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 928: -> string('@nl;' spaces(indent) functor_string arguments_string)
  frame->slots[4] /* temp__2 */ = create_closure(entry__55_16, 0);
  // 929: -> string(functor_string '(' arguments_string ')')
  frame->slots[5] /* temp__3 */ = create_closure(entry__55_19, 0);
  // 926: if
  // 927:   arguments_string .contains. '@nl;'
  // 928:   -> string('@nl;' spaces(indent) functor_string arguments_string)
  // 929:   -> string(functor_string '(' arguments_string ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__55_21(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // arguments_string: 0
  // remark_lines: 1
  // indent: 2
  // functor_string: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* arguments_string */
  frame->slots[1] = myself->closure.frame->slots[5]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 932: arguments_string .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments_string */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__55_22;
}
static void cont__55_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 932: ... :
  // 933:   $$remark add_remark_lines("" remark_lines)
  // 934:   unless remark(1) == '@nl;':
  // 935:     !remark string('@nl;' spaces(expression_indent) remark)
  // 936:   ->
  // 937:     string
  // 938:       '@nl;'
  // 939:       spaces(indent)
  // 940:       functor_string
  // 941:       remark
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__55_23, 0);
  // 943: :
  // 944:   %expression_indent indent
  // 945:   ->
  // 946:     add_remark_lines
  // 947:       string(functor_string '(' arguments_string ')')
  // 948:       remark_lines
  frame->slots[6] /* temp__3 */ = create_closure(entry__55_33, 0);
  // 931: if
  // 932:   arguments_string .contains. '@nl;':
  // 933:     $$remark add_remark_lines("" remark_lines)
  // 934:     unless remark(1) == '@nl;':
  // 935:       !remark string('@nl;' spaces(expression_indent) remark)
  // 936:     ->
  // 937:       string
  // 938:         '@nl;'
  // 939:         spaces(indent)
  // 940:         functor_string
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__55_36(void) {
  myself = frame->slots[0] /* return__3 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__55_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* functor */, arguments->slots[0]);
  // 907: functor.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* functor */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__55_38;
}
static void cont__55_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 907: ... :
  // 908:   %line_width UNLIMITED # force inline output
  // 909:   to_string functor_of(self)
  frame->slots[7] /* temp__2 */ = create_closure(entry__55_39, 0);
  // 905: $$functor_string
  // 906:   if
  // 907:     functor.is_defined:
  // 908:       %line_width UNLIMITED # force inline output
  // 909:       to_string functor_of(self)
  // 910:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = func__55_42;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__55_43;
}
static void entry__55_39(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // return__1: 0
  // self: 1
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 909: ... functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__55_40;
}
static void cont__55_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 909: to_string functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__55_41;
}
static void cont__55_41(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__55_42(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 910: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__55_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* functor_string */ = arguments->slots[0];
  // 950: $arguments arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__55_44;
}
static void cont__55_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* arguments */, arguments->slots[0]);
  // 952: -> self.is_a_method_definition:
  // 953:   %line_width UNLIMITED # force inline output
  // 954:   $argument arguments(1)
  // 955:   if
  // 956:     functor_string.is_defined
  // 957:     -> string(argument '/' functor_string)
  // 958:     -> string(argument '/')
  frame->slots[6] /* temp__1 */ = create_closure(entry__55_45, 0);
  // 959: -> self.is_an_attribute_access:
  // 960:   $$argument arguments(1)
  // 961:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 962:     !argument string('(' argument ')')
  // 963:   -> string(argument '.' functor_string)
  frame->slots[7] /* temp__2 */ = create_closure(entry__55_55, 0);
  // 964: -> any_of(functor_string is_a_letter):
  // 965:   cond
  // 966:     -> self.is_in_infix_notation:
  // 967:       $left_argument arguments(1)
  // 968:       $right_argument arguments(2)
  // 969:       $$left left_argument.to_string
  // 970:       $$right right_argument.to_string
  // 971:       if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 972:         !left string('(' left ')')
  // 973:       if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // ...
  frame->slots[8] /* temp__3 */ = create_closure(entry__55_65, 0);
  //  999: -> true: # operator symbols
  // 1000:   %expression_indent indent+2
  // 1001:   if
  // 1002:     length_of(arguments) == 1:
  // 1003:       $argument arguments(1)
  // 1004:       if
  // 1005:         precedence_of(argument) < HIGHEST_PRECEDENCE
  // 1006:         -> string(functor_string '(' argument ')')
  // 1007:         -> string(functor_string argument)
  // 1008:     :
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__55_151, 0);
  // 951: cond
  // 952:   -> self.is_a_method_definition:
  // 953:     %line_width UNLIMITED # force inline output
  // 954:     $argument arguments(1)
  // 955:     if
  // 956:       functor_string.is_defined
  // 957:       -> string(argument '/' functor_string)
  // 958:       -> string(argument '/')
  // 959:   -> self.is_an_attribute_access:
  // 960:     $$argument arguments(1)
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  arguments->slots[3] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__56_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1088: ... node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__56_2;
}
static void cont__56_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1088: ... string('`' node::text_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__96;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__56_3;
}
static void cont__56_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1088: ... -> string('`' node::text_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_2(void) {
  allocate_initialized_frame_gc(4, 11);
  // slot allocations:
  // return__1: 0
  // indent: 1
  // self: 2
  // symbol: 3
  // identifier: 4
  // value: 5
  // separator: 6
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[1]; /* symbol */
  define__expression_indent(create_future());
  frame->slots[4] /* identifier */ = create_cell();
  define__line_end_expression_width(create_future());
  frame->slots[5] /* value */ = create_future();
  frame->slots[6] /* separator */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1096: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__57_3;
}
static void cont__57_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 1097: $$identifier identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__57_4;
}
static void cont__57_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* identifier */ = arguments->slots[0];
  // 1099: identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__57_5;
}
static void cont__57_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1099: ... :
  // 1100:   to_string &identifier
  frame->slots[8] /* temp__2 */ = create_closure(entry__57_6, 0);
  // 1101: :
  // 1102:   !identifier ""
  frame->slots[9] /* temp__3 */ = create_closure(entry__57_8, 0);
  // 1098: if
  // 1099:   identifier.is_defined:
  // 1100:     to_string &identifier
  // 1101:   :
  // 1102:     !identifier ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__57_9;
}
static void entry__57_6(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // identifier: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* identifier */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1100: to_string &identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* identifier */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__57_7;
}
static void cont__57_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* identifier */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_8(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // identifier: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* identifier */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1102: !identifier ""
  ((CELL *)frame->slots[0])->contents /* identifier */ = empty_string;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__57_9(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1103: ... length_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* identifier */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__57_10;
}
static void cont__57_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1103: ... indent+length_of(identifier)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__57_11;
}
static void cont__57_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1103: ... indent+length_of(identifier)+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__57_12;
}
static void cont__57_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1103: %line_end_expression_width line_width-(indent+length_of(identifier)+1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__57_13;
}
static void cont__57_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 1104: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__57_14;
}
static void cont__57_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1104: ... arguments_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[8] /* temp__2 */;
  func = myself->type;
  frame->cont = cont__57_15;
}
static void cont__57_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1104: $value arguments_of(self)(1).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__57_16;
}
static void cont__57_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* value */, arguments->slots[0]);
  // 1105: ... value(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[5] /* value */;
  func = myself->type;
  frame->cont = cont__57_17;
}
static void cont__57_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1105: ... value(1) == ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__57_18;
}
static void cont__57_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1105: $separator if(value(1) == ':' (-> "") -> " ")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__57_19;
  arguments->slots[2] = func__57_20;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__57_22;
}
static void entry__57_19(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1105: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_20(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1105: ... -> " "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__57_21;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__57_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* separator */, arguments->slots[0]);
  // 1107: ->
  // 1108:   value(1) == '@nl;'
  // 1109:   -> string('@nl;' spaces(indent) symbol identifier value)
  frame->slots[7] /* temp__1 */ = create_closure(entry__57_23, 0);
  // 1111: -> # line-end expression
  // 1112:   value .contains. '@nl;'
  // 1113:   -> string('@nl;' spaces(indent) symbol identifier separator value)
  frame->slots[8] /* temp__2 */ = create_closure(entry__57_29, 0);
  // 1114: -> indent+1+length_of(identifier)+1+length_of(value) > line_width ->
  // 1115:   string
  // 1116:     '@nl;'
  // 1117:     spaces(indent)
  // 1118:     symbol
  // 1119:     identifier
  // 1120:     '@nl;'
  // 1121:     spaces(expression_indent)
  // 1122:     value
  frame->slots[9] /* temp__3 */ = create_closure(entry__57_34, 0);
  // 1123: -> true -> string(symbol identifier separator value)
  frame->slots[10] /* temp__4 */ = create_closure(entry__57_46, 0);
  // 1106: cond
  // 1107:   ->
  // 1108:     value(1) == '@nl;'
  // 1109:     -> string('@nl;' spaces(indent) symbol identifier value)
  // 1110:   
  // 1111:   -> # line-end expression
  // 1112:     value .contains. '@nl;'
  // 1113:     -> string('@nl;' spaces(indent) symbol identifier separator value)
  // 1114:   -> indent+1+length_of(identifier)+1+length_of(value) > line_width ->
  // 1115:     string
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  arguments->slots[3] = frame->slots[10] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__57_49;
}
static void entry__57_47(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // symbol: 0
  // identifier: 1
  // separator: 2
  // value: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* symbol */
  frame->slots[1] = myself->closure.frame->slots[1]; /* identifier */
  frame->slots[2] = myself->closure.frame->slots[2]; /* separator */
  frame->slots[3] = myself->closure.frame->slots[3]; /* value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1123: ... string(symbol identifier separator value)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* symbol */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* identifier */;
  arguments->slots[2] = frame->slots[2] /* separator */;
  arguments->slots[3] = frame->slots[3] /* value */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__57_48;
}
static void cont__57_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1123: ... -> string(symbol identifier separator value)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_42(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // indent: 0
  // symbol: 1
  // identifier: 2
  // value: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[3]; /* symbol */
  frame->slots[2] = myself->closure.frame->slots[1]; /* identifier */
  frame->slots[3] = myself->closure.frame->slots[2]; /* value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1117: spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__57_43;
}
static void cont__57_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1121: spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__57_44;
}
static void cont__57_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1115: string
  // 1116:   '@nl;'
  // 1117:   spaces(indent)
  // 1118:   symbol
  // 1119:   identifier
  // 1120:   '@nl;'
  // 1121:   spaces(expression_indent)
  // 1122:   value
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[1] /* symbol */;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* identifier */;
  arguments->slots[4] = character__10;
  arguments->slots[5] = frame->slots[6] /* temp__3 */;
  arguments->slots[6] = frame->slots[3] /* value */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__57_45;
}
static void cont__57_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1114: ... ->
  // 1115:   string
  // 1116:     '@nl;'
  // 1117:     spaces(indent)
  // 1118:     symbol
  // 1119:     identifier
  // 1120:     '@nl;'
  // 1121:     spaces(expression_indent)
  // 1122:     value
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_31(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // indent: 0
  // symbol: 1
  // identifier: 2
  // separator: 3
  // value: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[2]; /* symbol */
  frame->slots[2] = myself->closure.frame->slots[3]; /* identifier */
  frame->slots[3] = myself->closure.frame->slots[4]; /* separator */
  frame->slots[4] = myself->closure.frame->slots[0]; /* value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1113: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__57_32;
}
static void cont__57_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1113: ... string('@nl;' spaces(indent) symbol identifier separator value)
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[1] /* symbol */;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* identifier */;
  arguments->slots[4] = frame->slots[3] /* separator */;
  arguments->slots[5] = frame->slots[4] /* value */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__57_33;
}
static void cont__57_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1113: -> string('@nl;' spaces(indent) symbol identifier separator value)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_26(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // indent: 0
  // symbol: 1
  // identifier: 2
  // value: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[2]; /* symbol */
  frame->slots[2] = myself->closure.frame->slots[3]; /* identifier */
  frame->slots[3] = myself->closure.frame->slots[0]; /* value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1109: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__57_27;
}
static void cont__57_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1109: ... string('@nl;' spaces(indent) symbol identifier value)
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[1] /* symbol */;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* identifier */;
  arguments->slots[4] = frame->slots[3] /* value */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__57_28;
}
static void cont__57_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1109: -> string('@nl;' spaces(indent) symbol identifier value)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_23(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // value: 0
  // indent: 1
  // symbol: 2
  // identifier: 3
  frame->slots[0] = myself->closure.frame->slots[5]; /* value */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* symbol */
  frame->slots[3] = myself->closure.frame->slots[4]; /* identifier */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1108: value(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* value */;
  func = myself->type;
  frame->cont = cont__57_24;
}
static void cont__57_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1108: value(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__57_25;
}
static void cont__57_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1109: -> string('@nl;' spaces(indent) symbol identifier value)
  frame->slots[6] /* temp__3 */ = create_closure(entry__57_26, 0);
  // 1107: ->
  // 1108:   value(1) == '@nl;'
  // 1109:   -> string('@nl;' spaces(indent) symbol identifier value)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_29(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // value: 0
  // indent: 1
  // symbol: 2
  // identifier: 3
  // separator: 4
  frame->slots[0] = myself->closure.frame->slots[5]; /* value */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* symbol */
  frame->slots[3] = myself->closure.frame->slots[4]; /* identifier */
  frame->slots[4] = myself->closure.frame->slots[6]; /* separator */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1112: value .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* value */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__57_30;
}
static void cont__57_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1113: -> string('@nl;' spaces(indent) symbol identifier separator value)
  frame->slots[6] /* temp__2 */ = create_closure(entry__57_31, 0);
  // 1111: -> # line-end expression
  // 1112:   value .contains. '@nl;'
  // 1113:   -> string('@nl;' spaces(indent) symbol identifier separator value)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_34(void) {
  allocate_initialized_frame_gc(4, 12);
  // slot allocations:
  // indent: 0
  // identifier: 1
  // value: 2
  // symbol: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[4]; /* identifier */
  frame->slots[2] = myself->closure.frame->slots[5]; /* value */
  frame->slots[3] = myself->closure.frame->slots[3]; /* symbol */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1114: ... indent+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__57_35;
}
static void cont__57_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__5 */ = arguments->slots[0];
  // 1114: ... length_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* identifier */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__57_36;
}
static void cont__57_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__6 */ = arguments->slots[0];
  // 1114: ... indent+1+length_of(identifier)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__5 */;
  arguments->slots[1] = frame->slots[9] /* temp__6 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__57_37;
}
static void cont__57_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1114: ... indent+1+length_of(identifier)+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__57_38;
}
static void cont__57_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1114: ... length_of(value)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* value */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__57_39;
}
static void cont__57_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__7 */ = arguments->slots[0];
  // 1114: ... indent+1+length_of(identifier)+1+length_of(value)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = frame->slots[10] /* temp__7 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__57_40;
}
static void cont__57_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1114: ... indent+1+length_of(identifier)+1+length_of(value) > line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__57_41;
}
static void cont__57_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1114: ... ->
  // 1115:   string
  // 1116:     '@nl;'
  // 1117:     spaces(indent)
  // 1118:     symbol
  // 1119:     identifier
  // 1120:     '@nl;'
  // 1121:     spaces(expression_indent)
  // 1122:     value
  frame->slots[11] /* temp__8 */ = create_closure(entry__57_42, 0);
  // 1114: -> indent+1+length_of(identifier)+1+length_of(value) > line_width ->
  // 1115:   string
  // 1116:     '@nl;'
  // 1117:     spaces(indent)
  // 1118:     symbol
  // 1119:     identifier
  // 1120:     '@nl;'
  // 1121:     spaces(expression_indent)
  // 1122:     value
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__8 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__57_46(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // symbol: 0
  // identifier: 1
  // separator: 2
  // value: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* symbol */
  frame->slots[1] = myself->closure.frame->slots[4]; /* identifier */
  frame->slots[2] = myself->closure.frame->slots[6]; /* separator */
  frame->slots[3] = myself->closure.frame->slots[5]; /* value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1123: ... -> string(symbol identifier separator value)
  frame->slots[4] /* temp__1 */ = create_closure(entry__57_47, 0);
  // 1123: -> true -> string(symbol identifier separator value)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__57_49(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__57_1(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // self: 0
  // symbol: 1
  // indent: 2
  // _define $indent expression_indent
  frame->slots[2] /* indent */ = get__expression_indent();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1095: ... :
  // 1096:   %expression_indent indent+2
  // 1097:   $$identifier identifier_of(self)
  // 1098:   if
  // 1099:     identifier.is_defined:
  // 1100:       to_string &identifier
  // 1101:     :
  // 1102:       !identifier ""
  // 1103:   %line_end_expression_width line_width-(indent+length_of(identifier)+1)
  // 1104:   $value arguments_of(self)(1).to_string
  // ...
  frame->slots[3] /* temp__1 */ = create_closure(entry__57_2, 0);
  // 1095: do:
  // 1096:   %expression_indent indent+2
  // 1097:   $$identifier identifier_of(self)
  // 1098:   if
  // 1099:     identifier.is_defined:
  // 1100:       to_string &identifier
  // 1101:     :
  // 1102:       !identifier ""
  // 1103:   %line_end_expression_width line_width-(indent+length_of(identifier)+1)
  // 1104:   $value arguments_of(self)(1).to_string
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__58_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1125: ... pair_to_string self '.'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = character__46;
  result_count = frame->caller_result_count;
  myself = var._pair_to_string;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__59_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1127: ... pair_to_string self '/'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = character__47;
  result_count = frame->caller_result_count;
  myself = var._pair_to_string;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__60_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1132: ... node::value_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__value_of();
  func = myself->type;
  frame->cont = cont__60_2;
}
static void cont__60_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1132: ... add_remark self node::value_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__62_1(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1140: !character_to_name empty_table
  var._character_to_name = get__empty_table();
  // 1141: for_each character_names: (name chr)
  // 1142:   if chr < '@0x80;' || chr == '@nbsp;': !character_to_name(chr) name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__character_names();
  arguments->slots[1] = func__62_2;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__62_9;
}
static void entry__62_7(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // chr: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1142: ... !character_to_name(chr) name
  frame->slots[2] /* temp__1 */ = frame->slots[1] /* name */;
  // 1142: ... !character_to_name(chr)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = var._character_to_name;
  func = myself->type;
  frame->cont = cont__62_8;
}
static void cont__62_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  var._character_to_name = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__62_2(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // name: 0
  // chr: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1142: ... chr < '@0x80;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = character__128;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__62_3;
}
static void cont__62_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1142: ... chr == '@nbsp;'
  frame->slots[4] /* temp__3 */ = create_closure(entry__62_4, 0);
  // 1142: ... chr < '@0x80;' || chr == '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__62_6;
}
static void entry__62_4(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1142: ... chr == '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__160;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__62_5;
}
static void cont__62_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1142: ... chr == '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__62_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1142: ... : !character_to_name(chr) name
  frame->slots[5] /* temp__4 */ = create_closure(entry__62_7, 0);
  // 1142: if chr < '@0x80;' || chr == '@nbsp;': !character_to_name(chr) name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__62_9(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1146: !character_to_name(' ') undefined
  frame->slots[0] /* temp__1 */ = get__undefined();
  // 1146: !character_to_name(' ')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = frame->slots[0] /* temp__1 */;
  result_count = 1;
  myself = var._character_to_name;
  func = myself->type;
  frame->cont = cont__62_10;
}
static void cont__62_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  var._character_to_name = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__63_26(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1161: ... chr.to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__63_27;
}
static void cont__63_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1161: ... hex(chr.to_integer)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__hex();
  func = myself->type;
  frame->cont = cont__63_28;
}
static void cont__63_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1161: ... string("@@0x" hex(chr.to_integer) ';')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__63_29;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = character__59;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__63_30;
}
static void cont__63_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1161: -> string("@@0x" hex(chr.to_integer) ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__63_31(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1162: ... chr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__63_32;
}
static void cont__63_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1162: -> chr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__63_7(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1157: ... string('@@' name ';')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__64;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = character__59;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__63_8;
}
static void cont__63_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1157: ... -> string('@@' name ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__63_10(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1157: ... -> "@@@@"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__63_11;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__63_13(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1157: ... -> "&"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__63_14;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__63_6(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1157: ... -> string('@@' name ';')
  frame->slots[1] /* temp__1 */ = create_closure(entry__63_7, 0);
  // 1157: case name "at" (-> "@@@@") "amp" (-> "&") -> string('@@' name ';')
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__63_9;
  arguments->slots[2] = func__63_10;
  arguments->slots[3] = string__63_12;
  arguments->slots[4] = func__63_13;
  arguments->slots[5] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__63_15(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1160: chr >= '@0x2b0;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__688;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__63_16;
}
static void cont__63_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1160: chr >= '@0x2b0;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__63_17;
}
static void cont__63_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1160: ... chr >= '@0x80;' && chr <= '@nbsp;'
  frame->slots[4] /* temp__4 */ = create_closure(entry__63_18, 0);
  // 1160: chr >= '@0x2b0;' || chr >= '@0x80;' && chr <= '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__63_25;
}
static void entry__63_18(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1160: ... chr >= '@0x80;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__128;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__63_19;
}
static void cont__63_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1160: ... chr >= '@0x80;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__63_20;
}
static void cont__63_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1160: ... chr <= '@nbsp;'
  frame->slots[4] /* temp__4 */ = create_closure(entry__63_21, 0);
  // 1160: ... chr >= '@0x80;' && chr <= '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__63_24;
}
static void entry__63_21(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1160: ... chr <= '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__160;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__63_22;
}
static void cont__63_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1160: ... chr <= '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__63_23;
}
static void cont__63_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1160: ... chr <= '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__63_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1160: ... chr >= '@0x80;' && chr <= '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__63_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1161: -> string("@@0x" hex(chr.to_integer) ';')
  frame->slots[5] /* temp__5 */ = create_closure(entry__63_26, 0);
  // 1162: -> chr.to_string
  frame->slots[6] /* temp__6 */ = create_closure(entry__63_31, 0);
  // 1159: if
  // 1160:   chr >= '@0x2b0;' || chr >= '@0x80;' && chr <= '@nbsp;'
  // 1161:   -> string("@@0x" hex(chr.to_integer) ';')
  // 1162:   -> chr.to_string
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  arguments->slots[2] = frame->slots[6] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__63_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  // name: 1
  frame->slots[1] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1153: ... character_to_name.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._character_to_name;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__63_2;
}
static void cont__63_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1153: unless character_to_name.is_defined create_character_table
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = var._create_character_table;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__63_3;
}
static void cont__63_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1154: $name character_to_name(chr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = var._character_to_name;
  func = myself->type;
  frame->cont = cont__63_4;
}
static void cont__63_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1156: name.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__63_5;
}
static void cont__63_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1156: ... :
  // 1157:   case name "at" (-> "@@@@") "amp" (-> "&") -> string('@@' name ';')
  frame->slots[3] /* temp__2 */ = create_closure(entry__63_6, 0);
  // 1158: :
  // 1159:   if
  // 1160:     chr >= '@0x2b0;' || chr >= '@0x80;' && chr <= '@nbsp;'
  // 1161:     -> string("@@0x" hex(chr.to_integer) ';')
  // 1162:     -> chr.to_string
  frame->slots[4] /* temp__3 */ = create_closure(entry__63_15, 0);
  // 1155: if
  // 1156:   name.is_defined:
  // 1157:     case name "at" (-> "@@@@") "amp" (-> "&") -> string('@@' name ';')
  // 1158:   :
  // 1159:     if
  // 1160:       chr >= '@0x2b0;' || chr >= '@0x80;' && chr <= '@nbsp;'
  // 1161:       -> string("@@0x" hex(chr.to_integer) ';')
  // 1162:       -> chr.to_string
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__64_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1167: ... node::value_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__value_of();
  func = myself->type;
  frame->cont = cont__64_2;
}
static void cont__64_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1167: ... escaped_character(node::value_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = var._escaped_character;
  func = myself->type;
  frame->cont = cont__64_3;
}
static void cont__64_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1167: string('@apos;' escaped_character(node::value_of(self)) '@apos;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__39;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = character__39;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__64_4;
}
static void cont__64_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1165: add_remark
  // 1166:   self
  // 1167:   string('@apos;' escaped_character(node::value_of(self)) '@apos;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__65_1(void) {
  allocate_initialized_frame_gc(2, 10);
  // slot allocations:
  // text: 0
  // return: 1
  // lines: 2
  // is_inline: 3
  // use_single_line_form: 4
  // part: 5
  // s: 6
  frame->slots[1] /* return */ = create_continuation_with_exit(exit__65_1);
  frame->slots[4] /* use_single_line_form */ = create_future();
  frame->slots[5] /* part */ = create_cell();
  frame->slots[6] /* s */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[2] /* lines */ = create_cell();
  frame->slots[3] /* is_inline */ = create_cell();
  // 1179: !is_inline true
  ((CELL *)frame->slots[3])->contents /* is_inline */ = get__true();
  // 1180: ... text == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__65_2;
}
static void cont__65_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1180: ... :
  // 1181:   !lines list("")
  // 1182:   return
  frame->slots[8] /* temp__2 */ = create_closure(entry__65_3, 0);
  // 1180: if text == "":
  // 1181:   !lines list("")
  // 1182:   return
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__65_5;
}
static void entry__65_3(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1181: !lines list("")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__65_4;
}
static void cont__65_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1182: return
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__65_5(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1183: ... some('@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__10;
  result_count = 1;
  myself = get__some();
  func = myself->type;
  frame->cont = cont__65_6;
}
static void cont__65_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1183: ... text .matches. some('@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__matches();
  func = myself->type;
  frame->cont = cont__65_7;
}
static void cont__65_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1183: ... :
  // 1184:   # strings containing *only* newlines are always printed in inline form
  // 1185:   
  // 1186:   !lines list(dup("@@nl;" length_of(text)))
  // 1187:   return
  frame->slots[9] /* temp__3 */ = create_closure(entry__65_8, 0);
  // 1183: if text .matches. some('@nl;'):
  // 1184:   # strings containing *only* newlines are always printed in inline form
  // 1185:   
  // 1186:   !lines list(dup("@@nl;" length_of(text)))
  // 1187:   return
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__65_13;
}
static void entry__65_8(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // lines: 0
  // text: 1
  // return: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* text */
  frame->slots[2] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1186: ... length_of(text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__65_9;
}
static void cont__65_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1186: ... dup("@@nl;" length_of(text))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__65_10;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__dup();
  func = myself->type;
  frame->cont = cont__65_11;
}
static void cont__65_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1186: !lines list(dup("@@nl;" length_of(text)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__65_12;
}
static void cont__65_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1187: return
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[2] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__65_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1188: !lines empty_list
  ((CELL *)frame->slots[2])->contents /* lines */ = get__empty_list();
  // 1189: ... line_width == UNLIMITED
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = var._UNLIMITED;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__65_14;
}
static void cont__65_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1189: ... length_of(text) <= 3
  frame->slots[8] /* temp__2 */ = create_closure(entry__65_15, 0);
  // 1189: $use_single_line_form line_width == UNLIMITED || length_of(text) <= 3
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__65_19;
}
static void entry__65_15(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // text: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1189: ... length_of(text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__65_16;
}
static void cont__65_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1189: ... length_of(text) <= 3
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__3;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__65_17;
}
static void cont__65_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1189: ... length_of(text) <= 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__65_18;
}
static void cont__65_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1189: ... length_of(text) <= 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__65_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* use_single_line_form */, arguments->slots[0]);
  // 1190: $$part ""
  ((CELL *)frame->slots[5])->contents /* part */ = empty_string;
  // 1191: $$s 1
  ((CELL *)frame->slots[6])->contents /* s */ = number__1;
  // 1192: ... : (idx chr)
  // 1193:   case
  // 1194:     chr
  // 1195:     '@nl;':
  // 1196:       append &part range(text s idx-1)
  // 1197:       if
  // 1198:         use_single_line_form:
  // 1199:           # force single line string literal
  // 1200:           
  // 1201:           append &part "@@nl;"
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__65_20, 2);
  // 1192: for_each text: (idx chr)
  // 1193:   case
  // 1194:     chr
  // 1195:     '@nl;':
  // 1196:       append &part range(text s idx-1)
  // 1197:       if
  // 1198:         use_single_line_form:
  // 1199:           # force single line string literal
  // 1200:           
  // 1201:           append &part "@@nl;"
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__65_58;
}
static void entry__65_52(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  // escaped: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* part */
  frame->slots[1] = myself->closure.frame->slots[2]; /* text */
  frame->slots[2] = myself->closure.frame->slots[3]; /* s */
  frame->slots[3] = myself->closure.frame->slots[4]; /* idx */
  frame->slots[4] = myself->closure.frame->slots[5]; /* escaped */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1225: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__65_53;
}
static void cont__65_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1225: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__65_54;
}
static void cont__65_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1225: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_55;
}
static void cont__65_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1226: append &part escaped
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[4] /* escaped */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_56;
}
static void cont__65_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1227: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__65_57;
}
static void cont__65_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_33(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* part */
  frame->slots[1] = myself->closure.frame->slots[2]; /* text */
  frame->slots[2] = myself->closure.frame->slots[3]; /* s */
  frame->slots[3] = myself->closure.frame->slots[4]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1209: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__65_34;
}
static void cont__65_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1209: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__65_35;
}
static void cont__65_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1209: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_36;
}
static void cont__65_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1213: append &part "@@quot;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = string__65_37;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_38;
}
static void cont__65_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1214: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__65_39;
}
static void cont__65_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_40(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_inline: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1216: !is_inline false
  ((CELL *)frame->slots[0])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_21(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  // use_single_line_form: 4
  // lines: 5
  frame->slots[0] = myself->closure.frame->slots[2]; /* part */
  frame->slots[1] = myself->closure.frame->slots[3]; /* text */
  frame->slots[2] = myself->closure.frame->slots[4]; /* s */
  frame->slots[3] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[4] = myself->closure.frame->slots[5]; /* use_single_line_form */
  frame->slots[5] = myself->closure.frame->slots[6]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1196: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__65_22;
}
static void cont__65_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1196: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__65_23;
}
static void cont__65_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1196: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_24;
}
static void cont__65_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1198: ... :
  // 1199:   # force single line string literal
  // 1200:   
  // 1201:   append &part "@@nl;"
  frame->slots[6] /* temp__1 */ = create_closure(entry__65_25, 0);
  // 1202: :
  // 1203:   push &lines part
  // 1204:   !part ""
  frame->slots[7] /* temp__2 */ = create_closure(entry__65_28, 0);
  // 1197: if
  // 1198:   use_single_line_form:
  // 1199:     # force single line string literal
  // 1200:     
  // 1201:     append &part "@@nl;"
  // 1202:   :
  // 1203:     push &lines part
  // 1204:     !part ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* use_single_line_form */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__65_30;
}
static void entry__65_25(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // part: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1201: append &part "@@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = string__65_26;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_27;
}
static void cont__65_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_28(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1203: push &lines part
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__65_29;
}
static void cont__65_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1204: !part ""
  ((CELL *)frame->slots[1])->contents /* part */ = empty_string;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__65_30(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1205: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__65_31;
}
static void cont__65_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_32(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // use_single_line_form: 0
  // part: 1
  // text: 2
  // s: 3
  // idx: 4
  // is_inline: 5
  frame->slots[0] = myself->closure.frame->slots[5]; /* use_single_line_form */
  frame->slots[1] = myself->closure.frame->slots[2]; /* part */
  frame->slots[2] = myself->closure.frame->slots[3]; /* text */
  frame->slots[3] = myself->closure.frame->slots[4]; /* s */
  frame->slots[4] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[5] = myself->closure.frame->slots[7]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1208: ... :
  // 1209:   append &part range(text s idx-1)
  // 1210:   
  // 1211:   # force single line string literal
  // 1212:   
  // 1213:   append &part "@@quot;"
  // 1214:   !s idx+1
  frame->slots[6] /* temp__1 */ = create_closure(entry__65_33, 0);
  // 1215: :
  // 1216:   !is_inline false
  frame->slots[7] /* temp__2 */ = create_closure(entry__65_40, 0);
  // 1207: if
  // 1208:   use_single_line_form:
  // 1209:     append &part range(text s idx-1)
  // 1210:     
  // 1211:     # force single line string literal
  // 1212:     
  // 1213:     append &part "@@quot;"
  // 1214:     !s idx+1
  // 1215:   :
  // 1216:     !is_inline false
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* use_single_line_form */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__65_41(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* part */
  frame->slots[1] = myself->closure.frame->slots[3]; /* text */
  frame->slots[2] = myself->closure.frame->slots[4]; /* s */
  frame->slots[3] = myself->closure.frame->slots[0]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1218: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__65_42;
}
static void cont__65_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1218: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__65_43;
}
static void cont__65_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1218: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_44;
}
static void cont__65_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1219: append &part "@@@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = string__65_45;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_46;
}
static void cont__65_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1220: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__65_47;
}
static void cont__65_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_48(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // chr: 0
  // part: 1
  // text: 2
  // s: 3
  // idx: 4
  // escaped: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[2]; /* part */
  frame->slots[2] = myself->closure.frame->slots[3]; /* text */
  frame->slots[3] = myself->closure.frame->slots[4]; /* s */
  frame->slots[4] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[5] /* escaped */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1223: $escaped escaped_character(chr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = var._escaped_character;
  func = myself->type;
  frame->cont = cont__65_49;
}
static void cont__65_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* escaped */, arguments->slots[0]);
  // 1224: ... length_of(escaped)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* escaped */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__65_50;
}
static void cont__65_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1224: ... length_of(escaped) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__65_51;
}
static void cont__65_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1224: ... :
  // 1225:   append &part range(text s idx-1)
  // 1226:   append &part escaped
  // 1227:   !s idx+1
  frame->slots[8] /* temp__3 */ = create_closure(entry__65_52, 0);
  // 1224: if length_of(escaped) > 1:
  // 1225:   append &part range(text s idx-1)
  // 1226:   append &part escaped
  // 1227:   !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__65_20(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // idx: 0
  // chr: 1
  // part: 2
  // text: 3
  // s: 4
  // use_single_line_form: 5
  // lines: 6
  // is_inline: 7
  frame->slots[2] = myself->closure.frame->slots[5]; /* part */
  frame->slots[3] = myself->closure.frame->slots[0]; /* text */
  frame->slots[4] = myself->closure.frame->slots[6]; /* s */
  frame->slots[5] = myself->closure.frame->slots[4]; /* use_single_line_form */
  frame->slots[6] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[7] = myself->closure.frame->slots[3]; /* is_inline */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1195: ... :
  // 1196:   append &part range(text s idx-1)
  // 1197:   if
  // 1198:     use_single_line_form:
  // 1199:       # force single line string literal
  // 1200:       
  // 1201:       append &part "@@nl;"
  // 1202:     :
  // 1203:       push &lines part
  // 1204:       !part ""
  // ...
  frame->slots[8] /* temp__1 */ = create_closure(entry__65_21, 0);
  // 1206: ... : # strings containing quotes are never printed in inline form
  // 1207:   if
  // 1208:     use_single_line_form:
  // 1209:       append &part range(text s idx-1)
  // 1210:       
  // 1211:       # force single line string literal
  // 1212:       
  // 1213:       append &part "@@quot;"
  // 1214:       !s idx+1
  // 1215:     :
  // ...
  frame->slots[9] /* temp__2 */ = create_closure(entry__65_32, 0);
  // 1217: ... :
  // 1218:   append &part range(text s idx-1)
  // 1219:   append &part "@@@@"
  // 1220:   !s idx+1
  frame->slots[10] /* temp__3 */ = create_closure(entry__65_41, 0);
  // 1222: ... :
  // 1223:   $escaped escaped_character(chr)
  // 1224:   if length_of(escaped) > 1:
  // 1225:     append &part range(text s idx-1)
  // 1226:     append &part escaped
  // 1227:     !s idx+1
  frame->slots[11] /* temp__4 */ = create_closure(entry__65_48, 0);
  // 1193: case
  // 1194:   chr
  // 1195:   '@nl;':
  // 1196:     append &part range(text s idx-1)
  // 1197:     if
  // 1198:       use_single_line_form:
  // 1199:         # force single line string literal
  // 1200:         
  // 1201:         append &part "@@nl;"
  // 1202:       :
  // ...
  argument_count = 10;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[8] /* temp__1 */;
  arguments->slots[3] = character__34;
  arguments->slots[4] = frame->slots[9] /* temp__2 */;
  arguments->slots[5] = character__64;
  arguments->slots[6] = frame->slots[10] /* temp__3 */;
  arguments->slots[7] = character__39;
  arguments->slots[8] = get__pass();
  arguments->slots[9] = frame->slots[11] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__65_58(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1228: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__65_59;
}
static void cont__65_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1228: ... range(text s -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[6])->contents /* s */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__65_60;
}
static void cont__65_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1228: append &part range(text s -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* part */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__65_61;
}
static void cont__65_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* part */ = arguments->slots[0];
  // 1230: part == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* part */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__65_62;
}
static void cont__65_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1230: ... :
  // 1231:   # there must be a newline somewhere
  // 1232:   
  // 1233:   !is_inline false
  frame->slots[8] /* temp__2 */ = create_closure(entry__65_63, 0);
  // 1234: :
  // 1235:   # if the current part is not empty there was no trainling newline
  // 1236:   
  // 1237:   $max_width
  // 1238:     # the maximum width is computed for multi-line-strings
  // 1239:     
  // 1240:     -
  // 1241:       max(line_width-expression_indent 20)
  // 1242:       if(line_end_expression_width >= 2 (-> 0) -> 2)
  // 1243:   
  // ...
  frame->slots[9] /* temp__3 */ = create_closure(entry__65_64, 0);
  // 1229: if
  // 1230:   part == "":
  // 1231:     # there must be a newline somewhere
  // 1232:     
  // 1233:     !is_inline false
  // 1234:   :
  // 1235:     # if the current part is not empty there was no trainling newline
  // 1236:     
  // 1237:     $max_width
  // 1238:       # the maximum width is computed for multi-line-strings
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count =
    frame->caller_result_count >= 2 ?
    frame->caller_result_count-2 : -1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__65_87;
}
static void entry__65_82(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1247: push &lines part
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__65_83;
}
static void cont__65_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_84(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1249: ... string(part '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* part */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__65_85;
}
static void cont__65_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1249: push &lines string(part '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__65_86;
}
static void cont__65_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_63(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_inline: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1233: !is_inline false
  ((CELL *)frame->slots[0])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_64(void) {
  allocate_initialized_frame_gc(3, 9);
  // slot allocations:
  // lines: 0
  // part: 1
  // is_inline: 2
  // max_width: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[5]; /* part */
  frame->slots[2] = myself->closure.frame->slots[3]; /* is_inline */
  frame->slots[3] /* max_width */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1241: ... line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__65_65;
}
static void cont__65_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1241: max(line_width-expression_indent 20)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = number__20;
  result_count = 1;
  myself = get__max();
  func = myself->type;
  frame->cont = cont__65_66;
}
static void cont__65_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1242: ... line_end_expression_width >= 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__65_67;
}
static void cont__65_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__5 */ = arguments->slots[0];
  // 1242: ... line_end_expression_width >= 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__5 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__65_68;
}
static void cont__65_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1242: if(line_end_expression_width >= 2 (-> 0) -> 2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  arguments->slots[1] = func__65_69;
  arguments->slots[2] = func__65_70;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__65_71;
}
static void entry__65_69(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1242: ... -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__65_70(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1242: ... -> 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__65_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1237: $max_width
  // 1238:   # the maximum width is computed for multi-line-strings
  // 1239:   
  // 1240:   -
  // 1241:     max(line_width-expression_indent 20)
  // 1242:     if(line_end_expression_width >= 2 (-> 0) -> 2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__65_72;
}
static void cont__65_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* max_width */, arguments->slots[0]);
  // 1244: ... lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__65_73;
}
static void cont__65_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1244: ... length_of(part)+2 <= max_width
  frame->slots[6] /* temp__3 */ = create_closure(entry__65_74, 0);
  // 1244: ... lines.is_empty && length_of(part)+2 <= max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__65_79;
}
static void entry__65_74(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // max_width: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* max_width */
  frame->slots[1] = myself->closure.frame->slots[1]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1244: ... length_of(part)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__65_75;
}
static void cont__65_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1244: ... length_of(part)+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__65_76;
}
static void cont__65_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1244: ... length_of(part)+2 <= max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* max_width */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__65_77;
}
static void cont__65_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1244: ... length_of(part)+2 <= max_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__65_78;
}
static void cont__65_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1244: ... length_of(part)+2 <= max_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__65_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1244: ... : !is_inline false
  frame->slots[7] /* temp__4 */ = create_closure(entry__65_80, 0);
  // 1244: unless lines.is_empty && length_of(part)+2 <= max_width: !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__65_81;
}
static void entry__65_80(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_inline: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1244: ... !is_inline false
  ((CELL *)frame->slots[0])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__65_81(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1246: ... :
  // 1247:   push &lines part
  frame->slots[4] /* temp__1 */ = create_closure(entry__65_82, 0);
  // 1248: :
  // 1249:   push &lines string(part '@@')
  frame->slots[5] /* temp__2 */ = create_closure(entry__65_84, 0);
  // 1245: if
  // 1246:   is_inline:
  // 1247:     push &lines part
  // 1248:   :
  // 1249:     push &lines string(part '@@')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* is_inline */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__65_87(void) {
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void exit__65_1(void) {
  frame = ((CONTINUATION *)myself)->exit_frame;
  int i = argument_count;
  while (--i >= 0) {
    arguments->slots[i+2] = arguments->slots[i];
  }
  argument_count += 2;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* is_inline */;
  func = continuation_type_function;
}
static void entry__66_15(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1257: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__66_16;
}
static void cont__66_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1257: ... string('@quot;' lines(1) '@quot;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__34;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = character__34;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__66_17;
}
static void cont__66_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1257: ... -> string('@quot;' lines(1) '@quot;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_18(void) {
  allocate_initialized_frame_gc(1, 12);
  // slot allocations:
  // lines: 0
  // max_width: 1
  // has_leading_spaces: 2
  // split_lines: 3
  // buf: 4
  // indent: 5
  // indentation: 6
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] /* max_width */ = create_future();
  frame->slots[2] /* has_leading_spaces */ = create_cell();
  frame->slots[3] /* split_lines */ = create_cell();
  frame->slots[4] /* buf */ = create_cell();
  frame->slots[5] /* indent */ = create_cell();
  frame->slots[6] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1262: ... line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__66_19;
}
static void cont__66_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1262: max(line_width-expression_indent 20)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = number__20;
  result_count = 1;
  myself = get__max();
  func = myself->type;
  frame->cont = cont__66_20;
}
static void cont__66_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1263: ... line_end_expression_width >= 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__66_21;
}
static void cont__66_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__5 */ = arguments->slots[0];
  // 1263: ... line_end_expression_width >= 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__5 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_22;
}
static void cont__66_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__4 */ = arguments->slots[0];
  // 1263: if(line_end_expression_width >= 2 (-> 0) -> 2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__4 */;
  arguments->slots[1] = func__66_23;
  arguments->slots[2] = func__66_24;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_25;
}
static void entry__66_23(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1263: ... -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_24(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1263: ... -> 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1258: $max_width
  // 1259:   # the maximum width is computed for multi-line-strings
  // 1260:   
  // 1261:   -
  // 1262:     max(line_width-expression_indent 20)
  // 1263:     if(line_end_expression_width >= 2 (-> 0) -> 2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__66_26;
}
static void cont__66_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* max_width */, arguments->slots[0]);
  // 1265: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__66_27;
}
static void cont__66_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1265: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__66_28;
}
static void cont__66_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1265: ... lines(-1) != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_29;
}
static void cont__66_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1265: $$has_leading_spaces lines(-1) != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_30;
}
static void cont__66_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* has_leading_spaces */ = arguments->slots[0];
  // 1269: $$split_lines empty_list
  ((CELL *)frame->slots[3])->contents /* split_lines */ = get__empty_list();
  // 1270: ... : ($line)
  // 1271:   if line != "" && line(1) != ' ': !has_leading_spaces false
  // 1272:   while -> length_of(line) > max_width:
  // 1273:     # split long lines (if possible after a space)
  // 1274:     
  // 1275:     $skip_till_end_of_string:
  // 1276:       do_while:
  // 1277:         inc &pos
  // 1278:         if line(pos) == '@@':
  // 1279:           skip_special
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__66_31, 1);
  // 1270: for_each lines: ($line)
  // 1271:   if line != "" && line(1) != ' ': !has_leading_spaces false
  // 1272:   while -> length_of(line) > max_width:
  // 1273:     # split long lines (if possible after a space)
  // 1274:     
  // 1275:     $skip_till_end_of_string:
  // 1276:       do_while:
  // 1277:         inc &pos
  // 1278:         if line(pos) == '@@':
  // 1279:           skip_special
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__66_125;
}
static void entry__66_31(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // line: 0
  // has_leading_spaces: 1
  // max_width: 2
  // split_lines: 3
  frame->slots[1] = myself->closure.frame->slots[2]; /* has_leading_spaces */
  frame->slots[2] = myself->closure.frame->slots[1]; /* max_width */
  frame->slots[3] = myself->closure.frame->slots[3]; /* split_lines */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* line */ = create_cell_with_contents(arguments->slots[0]);
  // 1271: ... line != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_32;
}
static void cont__66_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1271: ... line != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_33;
}
static void cont__66_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1271: ... line(1) != ' '
  frame->slots[7] /* temp__4 */ = create_closure(entry__66_34, 0);
  // 1271: ... line != "" && line(1) != ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__66_38;
}
static void entry__66_34(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // line: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1271: ... line(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_35;
}
static void cont__66_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1271: ... line(1) != ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_36;
}
static void cont__66_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1271: ... line(1) != ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_37;
}
static void cont__66_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1271: ... line(1) != ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1271: ... : !has_leading_spaces false
  frame->slots[8] /* temp__5 */ = create_closure(entry__66_39, 0);
  // 1271: if line != "" && line(1) != ' ': !has_leading_spaces false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_40;
}
static void entry__66_39(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_leading_spaces: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_leading_spaces */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1271: ... !has_leading_spaces false
  ((CELL *)frame->slots[0])->contents /* has_leading_spaces */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_40(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1272: ... -> length_of(line) > max_width:
  // 1273:   # split long lines (if possible after a space)
  // 1274:   
  // 1275:   $skip_till_end_of_string:
  // 1276:     do_while:
  // 1277:       inc &pos
  // 1278:       if line(pos) == '@@':
  // 1279:         skip_special
  // 1280:         inc &pos
  // 1281:       -> line(pos) != '@quot;'
  // ...
  frame->slots[4] /* temp__1 */ = create_closure(entry__66_41, 0);
  // 1272: while -> length_of(line) > max_width:
  // 1273:   # split long lines (if possible after a space)
  // 1274:   
  // 1275:   $skip_till_end_of_string:
  // 1276:     do_while:
  // 1277:       inc &pos
  // 1278:       if line(pos) == '@@':
  // 1279:         skip_special
  // 1280:         inc &pos
  // 1281:       -> line(pos) != '@quot;'
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__66_123;
}
static void entry__66_44(void) {
  allocate_initialized_frame_gc(3, 11);
  // slot allocations:
  // line: 0
  // max_width: 1
  // split_lines: 2
  // skip_till_end_of_string: 3
  // skip_till_close: 4
  // skip_special: 5
  // best_split_pos: 6
  // last_valid_pos: 7
  // pos: 8
  frame->slots[0] = myself->closure.frame->slots[1]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* max_width */
  frame->slots[2] = myself->closure.frame->slots[2]; /* split_lines */
  frame->slots[3] /* skip_till_end_of_string */ = create_future();
  frame->slots[4] /* skip_till_close */ = create_future();
  frame->slots[5] /* skip_special */ = create_future();
  frame->slots[6] /* best_split_pos */ = create_cell();
  frame->slots[7] /* last_valid_pos */ = create_cell();
  frame->slots[8] /* pos */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1275: ... :
  // 1276:   do_while:
  // 1277:     inc &pos
  // 1278:     if line(pos) == '@@':
  // 1279:       skip_special
  // 1280:       inc &pos
  // 1281:     -> line(pos) != '@quot;'
  frame->slots[9] /* temp__1 */ = create_closure(entry__66_45, 0);
  // 1275: $skip_till_end_of_string:
  // 1276:   do_while:
  // 1277:     inc &pos
  // 1278:     if line(pos) == '@@':
  // 1279:       skip_special
  // 1280:       inc &pos
  // 1281:     -> line(pos) != '@quot;'
  initialize_future(frame->slots[3] /* skip_till_end_of_string */, frame->slots[9] /* temp__1 */);
  // 1283: ... :
  // 1284:   do_while:
  // 1285:     inc &pos
  // 1286:     if line(pos) == '(':
  // 1287:       skip_till_close
  // 1288:       inc &pos
  // 1289:     if line(pos) == '@quot;':
  // 1290:       skip_till_end_of_string
  // 1291:       inc &pos
  // 1292:     -> line(pos) != ')'
  frame->slots[9] /* temp__1 */ = create_closure(entry__66_57, 0);
  // 1283: $skip_till_close:
  // 1284:   do_while:
  // 1285:     inc &pos
  // 1286:     if line(pos) == '(':
  // 1287:       skip_till_close
  // 1288:       inc &pos
  // 1289:     if line(pos) == '@quot;':
  // 1290:       skip_till_end_of_string
  // 1291:       inc &pos
  // 1292:     -> line(pos) != ')'
  initialize_future(frame->slots[4] /* skip_till_close */, frame->slots[9] /* temp__1 */);
  // 1294: ... :
  // 1295:   inc &pos
  // 1296:   unless line(pos) == '@@':
  // 1297:     if
  // 1298:       line(pos) == '(':
  // 1299:         skip_till_close
  // 1300:       : # it's a special character
  // 1301:         while -> line(pos) != ';': inc &pos
  frame->slots[9] /* temp__1 */ = create_closure(entry__66_75, 0);
  // 1294: $skip_special:
  // 1295:   inc &pos
  // 1296:   unless line(pos) == '@@':
  // 1297:     if
  // 1298:       line(pos) == '(':
  // 1299:         skip_till_close
  // 1300:       : # it's a special character
  // 1301:         while -> line(pos) != ';': inc &pos
  initialize_future(frame->slots[5] /* skip_special */, frame->slots[9] /* temp__1 */);
  // 1303: $$best_split_pos undefined
  ((CELL *)frame->slots[6])->contents /* best_split_pos */ = get__undefined();
  // 1304: $$last_valid_pos undefined
  ((CELL *)frame->slots[7])->contents /* last_valid_pos */ = get__undefined();
  // 1305: $$pos 1
  ((CELL *)frame->slots[8])->contents /* pos */ = number__1;
  // 1306: ... -> pos < max_width:
  // 1307:   $chr line(pos)
  // 1308:   if
  // 1309:     chr == ' ':
  // 1310:       !best_split_pos pos
  // 1311:     :
  // 1312:       if
  // 1313:         chr == '@@':
  // 1314:           skip_special
  // 1315:           cond
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__66_90, 0);
  // 1306: while -> pos < max_width:
  // 1307:   $chr line(pos)
  // 1308:   if
  // 1309:     chr == ' ':
  // 1310:       !best_split_pos pos
  // 1311:     :
  // 1312:       if
  // 1313:         chr == '@@':
  // 1314:           skip_special
  // 1315:           cond
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__66_113;
}
static void entry__66_92(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // line: 0
  // pos: 1
  // best_split_pos: 2
  // skip_special: 3
  // max_width: 4
  // last_valid_pos: 5
  // chr: 6
  frame->slots[0] = myself->closure.frame->slots[2]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[2] = myself->closure.frame->slots[3]; /* best_split_pos */
  frame->slots[3] = myself->closure.frame->slots[4]; /* skip_special */
  frame->slots[4] = myself->closure.frame->slots[1]; /* max_width */
  frame->slots[5] = myself->closure.frame->slots[5]; /* last_valid_pos */
  frame->slots[6] /* chr */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1307: $chr line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_93;
}
static void cont__66_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* chr */, arguments->slots[0]);
  // 1309: chr == ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* chr */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_94;
}
static void cont__66_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1309: ... :
  // 1310:   !best_split_pos pos
  frame->slots[8] /* temp__2 */ = create_closure(entry__66_95, 0);
  // 1311: :
  // 1312:   if
  // 1313:     chr == '@@':
  // 1314:       skip_special
  // 1315:       cond
  // 1316:         -> pos < max_width && line(pos) == ')': !best_split_pos pos
  // 1317:         -> last_valid_pos.is_undefined: !last_valid_pos pos
  // 1318:     :
  // 1319:       !last_valid_pos pos
  frame->slots[9] /* temp__3 */ = create_closure(entry__66_96, 0);
  // 1308: if
  // 1309:   chr == ' ':
  // 1310:     !best_split_pos pos
  // 1311:   :
  // 1312:     if
  // 1313:       chr == '@@':
  // 1314:         skip_special
  // 1315:         cond
  // 1316:           -> pos < max_width && line(pos) == ')': !best_split_pos pos
  // 1317:           -> last_valid_pos.is_undefined: !last_valid_pos pos
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_111;
}
static void entry__66_109(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // last_valid_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* last_valid_pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1317: ... !last_valid_pos pos
  ((CELL *)frame->slots[0])->contents /* last_valid_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_106(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // best_split_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* best_split_pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1316: ... !best_split_pos pos
  ((CELL *)frame->slots[0])->contents /* best_split_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_100(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // pos: 0
  // max_width: 1
  // line: 2
  // best_split_pos: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[2]; /* max_width */
  frame->slots[2] = myself->closure.frame->slots[3]; /* line */
  frame->slots[3] = myself->closure.frame->slots[4]; /* best_split_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1316: ... pos < max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  arguments->slots[1] = frame->slots[1] /* max_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__66_101;
}
static void cont__66_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1316: ... line(pos) == ')'
  frame->slots[6] /* temp__3 */ = create_closure(entry__66_102, 0);
  // 1316: ... pos < max_width && line(pos) == ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__66_105;
}
static void entry__66_102(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // line: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1316: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_103;
}
static void cont__66_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1316: ... line(pos) == ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_104;
}
static void cont__66_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1316: ... line(pos) == ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1316: ... : !best_split_pos pos
  frame->slots[7] /* temp__4 */ = create_closure(entry__66_106, 0);
  // 1316: -> pos < max_width && line(pos) == ')': !best_split_pos pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_107(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // last_valid_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* last_valid_pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1317: ... last_valid_pos.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* last_valid_pos */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__66_108;
}
static void cont__66_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1317: ... : !last_valid_pos pos
  frame->slots[3] /* temp__2 */ = create_closure(entry__66_109, 0);
  // 1317: -> last_valid_pos.is_undefined: !last_valid_pos pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_98(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // skip_special: 0
  // pos: 1
  // max_width: 2
  // line: 3
  // best_split_pos: 4
  // last_valid_pos: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* skip_special */
  frame->slots[1] = myself->closure.frame->slots[2]; /* pos */
  frame->slots[2] = myself->closure.frame->slots[3]; /* max_width */
  frame->slots[3] = myself->closure.frame->slots[4]; /* line */
  frame->slots[4] = myself->closure.frame->slots[5]; /* best_split_pos */
  frame->slots[5] = myself->closure.frame->slots[6]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1314: skip_special
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_special */;
  func = myself->type;
  frame->cont = cont__66_99;
}
static void cont__66_99(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1316: -> pos < max_width && line(pos) == ')': !best_split_pos pos
  frame->slots[6] /* temp__1 */ = create_closure(entry__66_100, 0);
  // 1317: -> last_valid_pos.is_undefined: !last_valid_pos pos
  frame->slots[7] /* temp__2 */ = create_closure(entry__66_107, 0);
  // 1315: cond
  // 1316:   -> pos < max_width && line(pos) == ')': !best_split_pos pos
  // 1317:   -> last_valid_pos.is_undefined: !last_valid_pos pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_110(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // last_valid_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* last_valid_pos */
  frame->slots[1] = myself->closure.frame->slots[2]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1319: !last_valid_pos pos
  ((CELL *)frame->slots[0])->contents /* last_valid_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_95(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // best_split_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* best_split_pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1310: !best_split_pos pos
  ((CELL *)frame->slots[0])->contents /* best_split_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_96(void) {
  allocate_initialized_frame_gc(7, 10);
  // slot allocations:
  // chr: 0
  // skip_special: 1
  // pos: 2
  // max_width: 3
  // line: 4
  // best_split_pos: 5
  // last_valid_pos: 6
  frame->slots[0] = myself->closure.frame->slots[6]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[3]; /* skip_special */
  frame->slots[2] = myself->closure.frame->slots[1]; /* pos */
  frame->slots[3] = myself->closure.frame->slots[4]; /* max_width */
  frame->slots[4] = myself->closure.frame->slots[0]; /* line */
  frame->slots[5] = myself->closure.frame->slots[2]; /* best_split_pos */
  frame->slots[6] = myself->closure.frame->slots[5]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1313: chr == '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_97;
}
static void cont__66_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1313: ... :
  // 1314:   skip_special
  // 1315:   cond
  // 1316:     -> pos < max_width && line(pos) == ')': !best_split_pos pos
  // 1317:     -> last_valid_pos.is_undefined: !last_valid_pos pos
  frame->slots[8] /* temp__2 */ = create_closure(entry__66_98, 0);
  // 1318: :
  // 1319:   !last_valid_pos pos
  frame->slots[9] /* temp__3 */ = create_closure(entry__66_110, 0);
  // 1312: if
  // 1313:   chr == '@@':
  // 1314:     skip_special
  // 1315:     cond
  // 1316:       -> pos < max_width && line(pos) == ')': !best_split_pos pos
  // 1317:       -> last_valid_pos.is_undefined: !last_valid_pos pos
  // 1318:   :
  // 1319:     !last_valid_pos pos
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__66_111(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1320: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_112;
}
static void cont__66_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_88(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // pos: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1301: ... inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_89;
}
static void cont__66_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_84(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1301: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_85;
}
static void cont__66_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1301: ... line(pos) != ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_86;
}
static void cont__66_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1301: ... line(pos) != ';'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_87;
}
static void cont__66_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1301: ... : inc &pos
  frame->slots[5] /* temp__4 */ = create_closure(entry__66_88, 0);
  // 1301: ... -> line(pos) != ';': inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_82(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // skip_till_close: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* skip_till_close */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1299: skip_till_close
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* skip_till_close */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_83(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // line: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1301: ... -> line(pos) != ';': inc &pos
  frame->slots[2] /* temp__1 */ = create_closure(entry__66_84, 0);
  // 1301: while -> line(pos) != ';': inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__while();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_79(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // line: 0
  // pos: 1
  // skip_till_close: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[2] = myself->closure.frame->slots[2]; /* skip_till_close */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1298: line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_80;
}
static void cont__66_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1298: line(pos) == '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_81;
}
static void cont__66_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1298: ... :
  // 1299:   skip_till_close
  frame->slots[5] /* temp__3 */ = create_closure(entry__66_82, 0);
  // 1300: : # it's a special character
  // 1301:   while -> line(pos) != ';': inc &pos
  frame->slots[6] /* temp__4 */ = create_closure(entry__66_83, 0);
  // 1297: if
  // 1298:   line(pos) == '(':
  // 1299:     skip_till_close
  // 1300:   : # it's a special character
  // 1301:     while -> line(pos) != ';': inc &pos
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_58(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_till_close: 2
  // skip_till_end_of_string: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* line */
  frame->slots[2] = myself->closure.frame->slots[2]; /* skip_till_close */
  frame->slots[3] = myself->closure.frame->slots[3]; /* skip_till_end_of_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1285: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_59;
}
static void cont__66_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  // 1286: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_60;
}
static void cont__66_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1286: ... line(pos) == '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_61;
}
static void cont__66_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1286: ... :
  // 1287:   skip_till_close
  // 1288:   inc &pos
  frame->slots[6] /* temp__3 */ = create_closure(entry__66_62, 0);
  // 1286: if line(pos) == '(':
  // 1287:   skip_till_close
  // 1288:   inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_65;
}
static void entry__66_62(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // skip_till_close: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* skip_till_close */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1287: skip_till_close
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_till_close */;
  func = myself->type;
  frame->cont = cont__66_63;
}
static void cont__66_63(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1288: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_64;
}
static void cont__66_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_65(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1289: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_66;
}
static void cont__66_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1289: ... line(pos) == '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_67;
}
static void cont__66_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1289: ... :
  // 1290:   skip_till_end_of_string
  // 1291:   inc &pos
  frame->slots[6] /* temp__3 */ = create_closure(entry__66_68, 0);
  // 1289: if line(pos) == '@quot;':
  // 1290:   skip_till_end_of_string
  // 1291:   inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_71;
}
static void entry__66_68(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // skip_till_end_of_string: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* skip_till_end_of_string */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1290: skip_till_end_of_string
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_till_end_of_string */;
  func = myself->type;
  frame->cont = cont__66_69;
}
static void cont__66_69(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1291: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_70;
}
static void cont__66_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_71(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1292: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_72;
}
static void cont__66_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1292: ... line(pos) != ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_73;
}
static void cont__66_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1292: ... line(pos) != ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_74;
}
static void cont__66_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1292: -> line(pos) != ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_46(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_special: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* line */
  frame->slots[2] = myself->closure.frame->slots[2]; /* skip_special */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1277: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_47;
}
static void cont__66_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  // 1278: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_48;
}
static void cont__66_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1278: ... line(pos) == '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_49;
}
static void cont__66_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1278: ... :
  // 1279:   skip_special
  // 1280:   inc &pos
  frame->slots[5] /* temp__3 */ = create_closure(entry__66_50, 0);
  // 1278: if line(pos) == '@@':
  // 1279:   skip_special
  // 1280:   inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_53;
}
static void entry__66_50(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // skip_special: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* skip_special */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1279: skip_special
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_special */;
  func = myself->type;
  frame->cont = cont__66_51;
}
static void cont__66_51(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1280: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_52;
}
static void cont__66_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_53(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1281: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_54;
}
static void cont__66_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1281: ... line(pos) != '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_55;
}
static void cont__66_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1281: ... line(pos) != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_56;
}
static void cont__66_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1281: -> line(pos) != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_45(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_special: 2
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[5]; /* skip_special */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1276: ... :
  // 1277:   inc &pos
  // 1278:   if line(pos) == '@@':
  // 1279:     skip_special
  // 1280:     inc &pos
  // 1281:   -> line(pos) != '@quot;'
  frame->slots[3] /* temp__1 */ = create_closure(entry__66_46, 0);
  // 1276: do_while:
  // 1277:   inc &pos
  // 1278:   if line(pos) == '@@':
  // 1279:     skip_special
  // 1280:     inc &pos
  // 1281:   -> line(pos) != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do_while();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_57(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_till_close: 2
  // skip_till_end_of_string: 3
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[4]; /* skip_till_close */
  frame->slots[3] = myself->closure.frame->slots[3]; /* skip_till_end_of_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1284: ... :
  // 1285:   inc &pos
  // 1286:   if line(pos) == '(':
  // 1287:     skip_till_close
  // 1288:     inc &pos
  // 1289:   if line(pos) == '@quot;':
  // 1290:     skip_till_end_of_string
  // 1291:     inc &pos
  // 1292:   -> line(pos) != ')'
  frame->slots[4] /* temp__1 */ = create_closure(entry__66_58, 0);
  // 1284: do_while:
  // 1285:   inc &pos
  // 1286:   if line(pos) == '(':
  // 1287:     skip_till_close
  // 1288:     inc &pos
  // 1289:   if line(pos) == '@quot;':
  // 1290:     skip_till_end_of_string
  // 1291:     inc &pos
  // 1292:   -> line(pos) != ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do_while();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_75(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_till_close: 2
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[4]; /* skip_till_close */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1295: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__66_76;
}
static void cont__66_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  // 1296: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__66_77;
}
static void cont__66_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1296: ... line(pos) == '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_78;
}
static void cont__66_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1296: ... :
  // 1297:   if
  // 1298:     line(pos) == '(':
  // 1299:       skip_till_close
  // 1300:     : # it's a special character
  // 1301:       while -> line(pos) != ';': inc &pos
  frame->slots[5] /* temp__3 */ = create_closure(entry__66_79, 0);
  // 1296: unless line(pos) == '@@':
  // 1297:   if
  // 1298:     line(pos) == '(':
  // 1299:       skip_till_close
  // 1300:     : # it's a special character
  // 1301:       while -> line(pos) != ';': inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_90(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // pos: 0
  // max_width: 1
  // line: 2
  // best_split_pos: 3
  // skip_special: 4
  // last_valid_pos: 5
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* max_width */
  frame->slots[2] = myself->closure.frame->slots[0]; /* line */
  frame->slots[3] = myself->closure.frame->slots[6]; /* best_split_pos */
  frame->slots[4] = myself->closure.frame->slots[5]; /* skip_special */
  frame->slots[5] = myself->closure.frame->slots[7]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1306: ... pos < max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  arguments->slots[1] = frame->slots[1] /* max_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__66_91;
}
static void cont__66_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1306: ... :
  // 1307:   $chr line(pos)
  // 1308:   if
  // 1309:     chr == ' ':
  // 1310:       !best_split_pos pos
  // 1311:     :
  // 1312:       if
  // 1313:         chr == '@@':
  // 1314:           skip_special
  // 1315:           cond
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__66_92, 0);
  // 1306: ... -> pos < max_width:
  // 1307:   $chr line(pos)
  // 1308:   if
  // 1309:     chr == ' ':
  // 1310:       !best_split_pos pos
  // 1311:     :
  // 1312:       if
  // 1313:         chr == '@@':
  // 1314:           skip_special
  // 1315:           cond
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_113(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1321: ... best_split_pos.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* best_split_pos */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__66_114;
}
static void cont__66_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 1321: ... : !best_split_pos last_valid_pos
  frame->slots[10] /* temp__2 */ = create_closure(entry__66_115, 0);
  // 1321: if best_split_pos.is_undefined: !best_split_pos last_valid_pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_116;
}
static void entry__66_115(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // best_split_pos: 0
  // last_valid_pos: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* best_split_pos */
  frame->slots[1] = myself->closure.frame->slots[7]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1321: ... !best_split_pos last_valid_pos
  ((CELL *)frame->slots[0])->contents /* best_split_pos */ = ((CELL *)frame->slots[1])->contents /* last_valid_pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_116(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1322: ... range(line 1 best_split_pos)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = ((CELL *)frame->slots[6])->contents /* best_split_pos */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__66_117;
}
static void cont__66_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 1322: ... push(range(line 1 best_split_pos) '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__66_118;
}
static void cont__66_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 1322: push &split_lines push(range(line 1 best_split_pos) '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* split_lines */;
  arguments->slots[1] = frame->slots[9] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__66_119;
}
static void cont__66_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* split_lines */ = arguments->slots[0];
  // 1323: ... best_split_pos+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* best_split_pos */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__66_120;
}
static void cont__66_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 1323: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__66_121;
}
static void cont__66_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 1323: range &line best_split_pos+1 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[9] /* temp__1 */;
  arguments->slots[2] = frame->slots[10] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__66_122;
}
static void cont__66_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_41(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // max_width: 0
  // line: 1
  // split_lines: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* max_width */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[3]; /* split_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1272: ... length_of(line)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* line */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__66_42;
}
static void cont__66_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1272: ... length_of(line) > max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* max_width */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__66_43;
}
static void cont__66_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1272: ... :
  // 1273:   # split long lines (if possible after a space)
  // 1274:   
  // 1275:   $skip_till_end_of_string:
  // 1276:     do_while:
  // 1277:       inc &pos
  // 1278:       if line(pos) == '@@':
  // 1279:         skip_special
  // 1280:         inc &pos
  // 1281:       -> line(pos) != '@quot;'
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__66_44, 0);
  // 1272: ... -> length_of(line) > max_width:
  // 1273:   # split long lines (if possible after a space)
  // 1274:   
  // 1275:   $skip_till_end_of_string:
  // 1276:     do_while:
  // 1277:       inc &pos
  // 1278:       if line(pos) == '@@':
  // 1279:         skip_special
  // 1280:         inc &pos
  // 1281:       -> line(pos) != '@quot;'
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_123(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1324: push &split_lines line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* split_lines */;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* line */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__66_124;
}
static void cont__66_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* split_lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_125(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1325: !lines split_lines
  ((CELL *)frame->slots[0])->contents /* lines */ = ((CELL *)frame->slots[3])->contents /* split_lines */;
  // 1326: ... :
  // 1327:   #
  // 1328:     no single line starts at the indent position;
  // 1329:     so we have to add a line at the start that contains no characters
  // 1330:   
  // 1331:   put &lines "@@"
  frame->slots[7] /* temp__1 */ = create_closure(entry__66_126, 0);
  // 1326: if has_leading_spaces:
  // 1327:   #
  // 1328:     no single line starts at the indent position;
  // 1329:     so we have to add a line at the start that contains no characters
  // 1330:   
  // 1331:   put &lines "@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* has_leading_spaces */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_129;
}
static void entry__66_126(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1331: put &lines "@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = string__66_127;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__66_128;
}
static void cont__66_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_129(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1332: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__66_130;
}
static void cont__66_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1332: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__66_131;
}
static void cont__66_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1332: ... lines(-1) == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_132;
}
static void cont__66_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1332: ... :
  // 1333:   #
  // 1334:     the last line is empty;
  // 1335:     so we replace it with an empty special sequence
  // 1336:   
  // 1337:   !lines(-1) "@@;"
  frame->slots[10] /* temp__4 */ = create_closure(entry__66_133, 0);
  // 1332: if lines(-1) == "":
  // 1333:   #
  // 1334:     the last line is empty;
  // 1335:     so we replace it with an empty special sequence
  // 1336:   
  // 1337:   !lines(-1) "@@;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_137;
}
static void entry__66_133(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1337: !lines(-1) "@@;"
  frame->slots[1] /* temp__1 */ = string__66_134;
  // 1337: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__66_135;
}
static void cont__66_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1337: !lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__66_136;
}
static void cont__66_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_137(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1338: $$buf undefined
  ((CELL *)frame->slots[4])->contents /* buf */ = get__undefined();
  // 1339: $$indent expression_indent
  ((CELL *)frame->slots[5])->contents /* indent */ = get__expression_indent();
  // 1341: line_end_expression_width >= 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__66_138;
}
static void cont__66_138(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1341: line_end_expression_width >= 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__66_139;
}
static void cont__66_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1341: ... :
  // 1342:   !buf "@quot;"
  frame->slots[9] /* temp__3 */ = create_closure(entry__66_140, 0);
  // 1343: :
  // 1344:   !buf string('@nl;' spaces(indent) '@quot;')
  // 1345:   plus &indent 2
  frame->slots[10] /* temp__4 */ = create_closure(entry__66_142, 0);
  // 1340: if
  // 1341:   line_end_expression_width >= 2:
  // 1342:     !buf "@quot;"
  // 1343:   :
  // 1344:     !buf string('@nl;' spaces(indent) '@quot;')
  // 1345:     plus &indent 2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_146;
}
static void entry__66_140(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1342: !buf "@quot;"
  ((CELL *)frame->slots[0])->contents /* buf */ = string__66_141;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_142(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1344: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__66_143;
}
static void cont__66_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1344: !buf string('@nl;' spaces(indent) '@quot;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = character__34;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__66_144;
}
static void cont__66_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1345: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__66_145;
}
static void cont__66_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__66_146(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1346: $indentation spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__66_147;
}
static void cont__66_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* indentation */, arguments->slots[0]);
  // 1347: ... : (line)
  // 1348:   push &buf '@nl;'
  // 1349:   unless line == "":
  // 1350:     append &buf indentation
  // 1351:     append &buf line
  frame->slots[7] /* temp__1 */ = create_closure(entry__66_148, 1);
  // 1347: for_each lines: (line)
  // 1348:   push &buf '@nl;'
  // 1349:   unless line == "":
  // 1350:     append &buf indentation
  // 1351:     append &buf line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__66_154;
}
static void entry__66_151(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // line: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1350: append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__66_152;
}
static void cont__66_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1351: append &buf line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* line */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__66_153;
}
static void cont__66_153(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_148(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[6]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1348: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__66_149;
}
static void cont__66_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1349: ... line == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_150;
}
static void cont__66_150(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1349: ... :
  // 1350:   append &buf indentation
  // 1351:   append &buf line
  frame->slots[4] /* temp__2 */ = create_closure(entry__66_151, 0);
  // 1349: unless line == "":
  // 1350:   append &buf indentation
  // 1351:   append &buf line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__66_154(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1352: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_1(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* lines */ = create_cell_with_contents(arguments->slots[0]);
  frame->slots[1] /* is_inline */ = create_cell_with_contents(arguments->slots[1]);
  // 1252: ... :
  // 1253:   unless line_width == UNLIMITED:
  // 1254:     if length_of(lines(1))+2 > line_width-expression_indent:
  // 1255:       push &lines(1) '@@'
  // 1256:       !is_inline false
  frame->slots[2] /* temp__1 */ = create_closure(entry__66_2, 0);
  // 1252: if is_inline:
  // 1253:   unless line_width == UNLIMITED:
  // 1254:     if length_of(lines(1))+2 > line_width-expression_indent:
  // 1255:       push &lines(1) '@@'
  // 1256:       !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* is_inline */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__66_14;
}
static void entry__66_10(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1255: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__66_11;
}
static void cont__66_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1255: push &lines(1) '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__66_12;
}
static void cont__66_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1255: ... &lines(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__66_13;
}
static void cont__66_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1256: !is_inline false
  ((CELL *)frame->slots[1])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__66_4(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1254: ... line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__66_5;
}
static void cont__66_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1254: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__66_6;
}
static void cont__66_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 1254: ... length_of(lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__66_7;
}
static void cont__66_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1254: ... length_of(lines(1))+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__66_8;
}
static void cont__66_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1254: ... length_of(lines(1))+2 > line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__66_9;
}
static void cont__66_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1254: ... :
  // 1255:   push &lines(1) '@@'
  // 1256:   !is_inline false
  frame->slots[7] /* temp__6 */ = create_closure(entry__66_10, 0);
  // 1254: if length_of(lines(1))+2 > line_width-expression_indent:
  // 1255:   push &lines(1) '@@'
  // 1256:   !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__66_2(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1253: ... line_width == UNLIMITED
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = var._UNLIMITED;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__66_3;
}
static void cont__66_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1253: ... :
  // 1254:   if length_of(lines(1))+2 > line_width-expression_indent:
  // 1255:     push &lines(1) '@@'
  // 1256:     !is_inline false
  frame->slots[3] /* temp__2 */ = create_closure(entry__66_4, 0);
  // 1253: unless line_width == UNLIMITED:
  // 1254:   if length_of(lines(1))+2 > line_width-expression_indent:
  // 1255:     push &lines(1) '@@'
  // 1256:     !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__66_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1257: ... -> string('@quot;' lines(1) '@quot;')
  frame->slots[2] /* temp__1 */ = create_closure(entry__66_15, 0);
  // 1257: ... :
  // 1258:   $max_width
  // 1259:     # the maximum width is computed for multi-line-strings
  // 1260:     
  // 1261:     -
  // 1262:       max(line_width-expression_indent 20)
  // 1263:       if(line_end_expression_width >= 2 (-> 0) -> 2)
  // 1264:   
  // 1265:   $$has_leading_spaces lines(-1) != ""
  // 1266:     #
  // ...
  frame->slots[3] /* temp__2 */ = create_closure(entry__66_18, 0);
  // 1257: if is_inline (-> string('@quot;' lines(1) '@quot;')):
  // 1258:   $max_width
  // 1259:     # the maximum width is computed for multi-line-strings
  // 1260:     
  // 1261:     -
  // 1262:       max(line_width-expression_indent 20)
  // 1263:       if(line_end_expression_width >= 2 (-> 0) -> 2)
  // 1264:   
  // 1265:   $$has_leading_spaces lines(-1) != ""
  // 1266:     #
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* is_inline */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__67_1(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // self: 0
  // lines: 1
  // template_is_inline: 2
  // add_part: 3
  // add_lines: 4
  frame->slots[3] /* add_part */ = create_future();
  frame->slots[4] /* add_lines */ = create_future();
  frame->slots[1] /* lines */ = create_cell();
  frame->slots[2] /* template_is_inline */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1358: ... : ($part)
  // 1359:   if
  // 1360:     lines.is_empty:
  // 1361:       push &lines part # that's the first part of the string template
  // 1362:     :
  // 1363:       if
  // 1364:         template_is_inline:
  // 1365:           append &lines(1) part # there is only a single line
  // 1366:         :
  // 1367:           push &part '@@' # append the part with a line-continuation suffix
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__67_2, 1);
  // 1358: $add_part: ($part)
  // 1359:   if
  // 1360:     lines.is_empty:
  // 1361:       push &lines part # that's the first part of the string template
  // 1362:     :
  // 1363:       if
  // 1364:         template_is_inline:
  // 1365:           append &lines(1) part # there is only a single line
  // 1366:         :
  // 1367:           push &part '@@' # append the part with a line-continuation suffix
  // ...
  initialize_future(frame->slots[3] /* add_part */, frame->slots[5] /* temp__1 */);
  // 1380: ... : ($more_lines)
  // 1381:   if
  // 1382:     lines.is_empty:
  // 1383:       !lines more_lines
  // 1384:     :
  // 1385:       if
  // 1386:         template_is_inline:
  // 1387:           # append the new lines at the end of the existing text
  // 1388:           
  // 1389:           !more_lines(1) string(lines(1) more_lines(1))
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__67_26, 1);
  // 1380: $add_lines: ($more_lines)
  // 1381:   if
  // 1382:     lines.is_empty:
  // 1383:       !lines more_lines
  // 1384:     :
  // 1385:       if
  // 1386:         template_is_inline:
  // 1387:           # append the new lines at the end of the existing text
  // 1388:           
  // 1389:           !more_lines(1) string(lines(1) more_lines(1))
  // ...
  initialize_future(frame->slots[4] /* add_lines */, frame->slots[5] /* temp__1 */);
  // 1355: $$lines empty_list
  ((CELL *)frame->slots[1])->contents /* lines */ = get__empty_list();
  // 1356: $$template_is_inline true
  ((CELL *)frame->slots[2])->contents /* template_is_inline */ = get__true();
  // 1407: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__67_48;
}
static void entry__67_16(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1374: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_17;
}
static void cont__67_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1374: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_18;
}
static void cont__67_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1374: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_19;
}
static void cont__67_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1374: ... range(lines(-1) 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__67_20;
}
static void cont__67_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1374: !lines(-1) string(range(lines(-1) 1 -2) part)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__67_21;
}
static void cont__67_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 1374: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_22;
}
static void cont__67_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__6 */ = arguments->slots[0];
  // 1374: !lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__6 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_23;
}
static void cont__67_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__67_24(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1378: push &lines part
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__67_25;
}
static void cont__67_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__67_7(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[2]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1365: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_8;
}
static void cont__67_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1365: append &lines(1) part # there is only a single line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__67_9;
}
static void cont__67_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1365: ... &lines(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_10;
}
static void cont__67_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__67_11(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // part: 0
  // lines: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* part */
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1367: push &part '@@' # append the part with a line-continuation suffix
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__67_12;
}
static void cont__67_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1369: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_13;
}
static void cont__67_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1369: lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_14;
}
static void cont__67_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1369: lines(-1) .has_suffix. '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__67_15;
}
static void cont__67_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1369: ... :
  // 1370:   #
  // 1371:     replace the current line's continuation suffix with
  // 1372:     the new part
  // 1373:   
  // 1374:   !lines(-1) string(range(lines(-1) 1 -2) part)
  frame->slots[5] /* temp__4 */ = create_closure(entry__67_16, 0);
  // 1375: :
  // 1376:   # append the new part as a new line
  // 1377:   
  // 1378:   push &lines part
  frame->slots[6] /* temp__5 */ = create_closure(entry__67_24, 0);
  // 1368: if
  // 1369:   lines(-1) .has_suffix. '@@':
  // 1370:     #
  // 1371:       replace the current line's continuation suffix with
  // 1372:       the new part
  // 1373:     
  // 1374:     !lines(-1) string(range(lines(-1) 1 -2) part)
  // 1375:   :
  // 1376:     # append the new part as a new line
  // 1377:     
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  arguments->slots[2] = frame->slots[6] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__67_4(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1361: push &lines part # that's the first part of the string template
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__67_5;
}
static void cont__67_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__67_6(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // template_is_inline: 0
  // lines: 1
  // part: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* template_is_inline */
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1364: ... :
  // 1365:   append &lines(1) part # there is only a single line
  frame->slots[3] /* temp__1 */ = create_closure(entry__67_7, 0);
  // 1366: :
  // 1367:   push &part '@@' # append the part with a line-continuation suffix
  // 1368:   if
  // 1369:     lines(-1) .has_suffix. '@@':
  // 1370:       #
  // 1371:         replace the current line's continuation suffix with
  // 1372:         the new part
  // 1373:       
  // 1374:       !lines(-1) string(range(lines(-1) 1 -2) part)
  // 1375:     :
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__67_11, 0);
  // 1363: if
  // 1364:   template_is_inline:
  // 1365:     append &lines(1) part # there is only a single line
  // 1366:   :
  // 1367:     push &part '@@' # append the part with a line-continuation suffix
  // 1368:     if
  // 1369:       lines(-1) .has_suffix. '@@':
  // 1370:         #
  // 1371:           replace the current line's continuation suffix with
  // 1372:           the new part
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* template_is_inline */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__67_2(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // part: 0
  // lines: 1
  // template_is_inline: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] = myself->closure.frame->slots[2]; /* template_is_inline */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* part */ = create_cell_with_contents(arguments->slots[0]);
  // 1360: lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__67_3;
}
static void cont__67_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1360: ... :
  // 1361:   push &lines part # that's the first part of the string template
  frame->slots[4] /* temp__2 */ = create_closure(entry__67_4, 0);
  // 1362: :
  // 1363:   if
  // 1364:     template_is_inline:
  // 1365:       append &lines(1) part # there is only a single line
  // 1366:     :
  // 1367:       push &part '@@' # append the part with a line-continuation suffix
  // 1368:       if
  // 1369:         lines(-1) .has_suffix. '@@':
  // 1370:           #
  // 1371:             replace the current line's continuation suffix with
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__67_6, 0);
  // 1359: if
  // 1360:   lines.is_empty:
  // 1361:     push &lines part # that's the first part of the string template
  // 1362:   :
  // 1363:     if
  // 1364:       template_is_inline:
  // 1365:         append &lines(1) part # there is only a single line
  // 1366:       :
  // 1367:         push &part '@@' # append the part with a line-continuation suffix
  // 1368:         if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__67_26(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // more_lines: 0
  // lines: 1
  // template_is_inline: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] = myself->closure.frame->slots[2]; /* template_is_inline */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* more_lines */ = create_cell_with_contents(arguments->slots[0]);
  // 1382: lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__67_27;
}
static void cont__67_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1382: ... :
  // 1383:   !lines more_lines
  frame->slots[4] /* temp__2 */ = create_closure(entry__67_28, 0);
  // 1384: :
  // 1385:   if
  // 1386:     template_is_inline:
  // 1387:       # append the new lines at the end of the existing text
  // 1388:       
  // 1389:       !more_lines(1) string(lines(1) more_lines(1))
  // 1390:       !lines more_lines
  // 1391:     :
  // 1392:       #
  // 1393:         the last modification of <lines> *must* have been done by a call
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__67_29, 0);
  // 1381: if
  // 1382:   lines.is_empty:
  // 1383:     !lines more_lines
  // 1384:   :
  // 1385:     if
  // 1386:       template_is_inline:
  // 1387:         # append the new lines at the end of the existing text
  // 1388:         
  // 1389:         !more_lines(1) string(lines(1) more_lines(1))
  // 1390:         !lines more_lines
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__67_47;
}
static void entry__67_30(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // more_lines: 0
  // lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* more_lines */
  frame->slots[1] = myself->closure.frame->slots[2]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1389: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_31;
}
static void cont__67_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1389: ... more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* more_lines */;
  func = myself->type;
  frame->cont = cont__67_32;
}
static void cont__67_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1389: !more_lines(1) string(lines(1) more_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__67_33;
}
static void cont__67_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1389: !more_lines(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* more_lines */;
  func = myself->type;
  frame->cont = cont__67_34;
}
static void cont__67_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* more_lines */ = arguments->slots[0];
  // 1390: !lines more_lines
  ((CELL *)frame->slots[1])->contents /* lines */ = ((CELL *)frame->slots[0])->contents /* more_lines */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__67_35(void) {
  allocate_initialized_frame_gc(2, 9);
  // slot allocations:
  // lines: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1401: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_36;
}
static void cont__67_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1401: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_37;
}
static void cont__67_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1401: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_38;
}
static void cont__67_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1401: ... range(lines(-1) 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__67_39;
}
static void cont__67_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1401: ... more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* more_lines */;
  func = myself->type;
  frame->cont = cont__67_40;
}
static void cont__67_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 1401: !lines(-1) string(range(lines(-1) 1 -2) more_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__67_41;
}
static void cont__67_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__6 */ = arguments->slots[0];
  // 1401: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_42;
}
static void cont__67_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__7 */ = arguments->slots[0];
  // 1401: !lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__7 */;
  arguments->slots[1] = frame->slots[7] /* temp__6 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_43;
}
static void cont__67_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1402: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_44;
}
static void cont__67_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1402: ... range(more_lines 2 -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* more_lines */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__67_45;
}
static void cont__67_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1402: append &lines range(more_lines 2 -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__67_46;
}
static void cont__67_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__67_28(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1383: !lines more_lines
  ((CELL *)frame->slots[0])->contents /* lines */ = ((CELL *)frame->slots[1])->contents /* more_lines */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__67_29(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // template_is_inline: 0
  // more_lines: 1
  // lines: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* template_is_inline */
  frame->slots[1] = myself->closure.frame->slots[0]; /* more_lines */
  frame->slots[2] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1386: ... :
  // 1387:   # append the new lines at the end of the existing text
  // 1388:   
  // 1389:   !more_lines(1) string(lines(1) more_lines(1))
  // 1390:   !lines more_lines
  frame->slots[3] /* temp__1 */ = create_closure(entry__67_30, 0);
  // 1391: :
  // 1392:   #
  // 1393:     the last modification of <lines> *must* have been done by a call
  // 1394:     to <add_part> because there cannot be two adjacent string literals
  // 1395:     in a string template so the last line *must* end with a
  // 1396:     line-continuation suffix
  // 1397:     
  // 1398:     this suffix is replaced with the contents of the first of
  // 1399:     the new lines
  // 1400:   
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__67_35, 0);
  // 1385: if
  // 1386:   template_is_inline:
  // 1387:     # append the new lines at the end of the existing text
  // 1388:     
  // 1389:     !more_lines(1) string(lines(1) more_lines(1))
  // 1390:     !lines more_lines
  // 1391:   :
  // 1392:     #
  // 1393:       the last modification of <lines> *must* have been done by a call
  // 1394:       to <add_part> because there cannot be two adjacent string literals
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* template_is_inline */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__67_47(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1403: !template_is_inline false
  ((CELL *)frame->slots[2])->contents /* template_is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__67_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1407: ... : (argument)
  // 1408:   if
  // 1409:     argument.is_a_string_literal:
  // 1410:       analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1411:       if
  // 1412:         is_inline:
  // 1413:           add_part more_lines(1)
  // 1414:         :
  // 1415:           add_lines more_lines
  // 1416:     :
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__67_49, 1);
  // 1407: for_each arguments_of(self): (argument)
  // 1408:   if
  // 1409:     argument.is_a_string_literal:
  // 1410:       analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1411:       if
  // 1412:         is_inline:
  // 1413:           add_part more_lines(1)
  // 1414:         :
  // 1415:           add_lines more_lines
  // 1416:     :
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__67_62;
}
static void entry__67_54(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // add_part: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* add_part */
  frame->slots[1] = myself->closure.frame->slots[3]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1413: ... more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* more_lines */;
  func = myself->type;
  frame->cont = cont__67_55;
}
static void cont__67_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1413: add_part more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* add_part */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__67_56(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // add_lines: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* add_lines */
  frame->slots[1] = myself->closure.frame->slots[3]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1415: add_lines more_lines
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* more_lines */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* add_lines */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__67_51(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // argument: 0
  // add_part: 1
  // add_lines: 2
  // more_lines: 3
  // is_inline: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[1]; /* add_part */
  frame->slots[2] = myself->closure.frame->slots[2]; /* add_lines */
  frame->slots[3] /* more_lines */ = create_future();
  frame->slots[4] /* is_inline */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1410: ... node::text_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__67_52;
}
static void cont__67_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1410: analyze_string_literal $more_lines $is_inline node::text_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 2;
  myself = var._analyze_string_literal;
  func = myself->type;
  frame->cont = cont__67_53;
}
static void cont__67_53(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__3 */ = arguments->slots[1];
  // 1410: ... more_lines
  initialize_future(frame->slots[3] /* more_lines */, frame->slots[6] /* temp__2 */);
  // 1410: ... is_inline
  initialize_future(frame->slots[4] /* is_inline */, frame->slots[7] /* temp__3 */);
  // 1412: ... :
  // 1413:   add_part more_lines(1)
  frame->slots[5] /* temp__1 */ = create_closure(entry__67_54, 0);
  // 1414: :
  // 1415:   add_lines more_lines
  frame->slots[6] /* temp__2 */ = create_closure(entry__67_56, 0);
  // 1411: if
  // 1412:   is_inline:
  // 1413:     add_part more_lines(1)
  // 1414:   :
  // 1415:     add_lines more_lines
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* is_inline */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__67_57(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // return__1: 0
  // add_part: 1
  // argument: 2
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* add_part */
  frame->slots[2] = myself->closure.frame->slots[0]; /* argument */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1418: ... argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__67_58;
}
static void cont__67_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1418: ... string("@@(" argument.to_string ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__67_59;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__67_60;
}
static void cont__67_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1418: add_part string("@@(" argument.to_string ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* add_part */;
  func = myself->type;
  frame->cont = cont__67_61;
}
static void cont__67_61(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__67_49(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // argument: 0
  // add_part: 1
  // add_lines: 2
  frame->slots[1] = myself->closure.frame->slots[3]; /* add_part */
  frame->slots[2] = myself->closure.frame->slots[4]; /* add_lines */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1409: argument.is_a_string_literal
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_a_string_literal();
  func = myself->type;
  frame->cont = cont__67_50;
}
static void cont__67_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1409: ... :
  // 1410:   analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1411:   if
  // 1412:     is_inline:
  // 1413:       add_part more_lines(1)
  // 1414:     :
  // 1415:       add_lines more_lines
  frame->slots[4] /* temp__2 */ = create_closure(entry__67_51, 0);
  // 1416: :
  // 1417:   %line_width UNLIMITED # force inline output
  // 1418:   add_part string("@@(" argument.to_string ')')
  frame->slots[5] /* temp__3 */ = create_closure(entry__67_57, 0);
  // 1408: if
  // 1409:   argument.is_a_string_literal:
  // 1410:     analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1411:     if
  // 1412:       is_inline:
  // 1413:         add_part more_lines(1)
  // 1414:       :
  // 1415:         add_lines more_lines
  // 1416:   :
  // 1417:     %line_width UNLIMITED # force inline output
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__67_62(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1419: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_63;
}
static void cont__67_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 1419: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_64;
}
static void cont__67_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1419: ... lines(-1) .has_suffix. "@@nl;@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = string__67_65;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__67_66;
}
static void cont__67_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1419: ... : range &lines(-1) 1 -6 # remove nonsense
  frame->slots[8] /* temp__4 */ = create_closure(entry__67_67, 0);
  // 1419: if lines(-1) .has_suffix. "@@nl;@@": range &lines(-1) 1 -6 # remove nonsense
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__67_74;
}
static void entry__67_67(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1419: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_68;
}
static void cont__67_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1419: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_69;
}
static void cont__67_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1419: ... 6
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__6;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_70;
}
static void cont__67_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1419: ... range &lines(-1) 1 -6 # remove nonsense
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__67_71;
}
static void cont__67_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 1419: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__67_72;
}
static void cont__67_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 1419: ... &lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__67_73;
}
static void cont__67_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__67_74(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1420: print_string_literal lines template_is_inline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* template_is_inline */;
  result_count = frame->caller_result_count;
  myself = var._print_string_literal;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__68_4(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // lines: 1
  // is_inline: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] /* lines */ = create_future();
  frame->slots[2] /* is_inline */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1425: ... node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__68_5;
}
static void cont__68_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1425: analyze_string_literal $lines $is_inline node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 2;
  myself = var._analyze_string_literal;
  func = myself->type;
  frame->cont = cont__68_6;
}
static void cont__68_6(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__3 */ = arguments->slots[1];
  // 1425: ... lines
  initialize_future(frame->slots[1] /* lines */, frame->slots[4] /* temp__2 */);
  // 1425: ... is_inline
  initialize_future(frame->slots[2] /* is_inline */, frame->slots[5] /* temp__3 */);
  // 1426: print_string_literal lines is_inline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* lines */;
  arguments->slots[1] = frame->slots[2] /* is_inline */;
  result_count = frame->caller_result_count;
  myself = var._print_string_literal;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__68_7(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // return__1: 0
  // self: 1
  // lines: 2
  // is_inline: 3
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  frame->slots[2] /* lines */ = create_future();
  frame->slots[3] /* is_inline */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1429: ... node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__68_8;
}
static void cont__68_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1429: analyze_string_literal $lines $is_inline node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 2;
  myself = var._analyze_string_literal;
  func = myself->type;
  frame->cont = cont__68_9;
}
static void cont__68_9(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  frame->slots[6] /* temp__3 */ = arguments->slots[1];
  // 1429: ... lines
  initialize_future(frame->slots[2] /* lines */, frame->slots[5] /* temp__2 */);
  // 1429: ... is_inline
  initialize_future(frame->slots[3] /* is_inline */, frame->slots[6] /* temp__3 */);
  // 1430: ... print_string_literal(lines is_inline)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* lines */;
  arguments->slots[1] = frame->slots[3] /* is_inline */;
  result_count = 1;
  myself = var._print_string_literal;
  func = myself->type;
  frame->cont = cont__68_10;
}
static void cont__68_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1430: add_remark self print_string_literal(lines is_inline)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame->cont = cont__68_11;
}
static void cont__68_11(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__68_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1424: remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__68_2;
}
static void cont__68_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1424: remark_lines_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__68_3;
}
static void cont__68_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1424: ... :
  // 1425:   analyze_string_literal $lines $is_inline node::text_of(self)
  // 1426:   print_string_literal lines is_inline
  frame->slots[3] /* temp__3 */ = create_closure(entry__68_4, 0);
  // 1427: :
  // 1428:   %line_width UNLIMITED # force inline output
  // 1429:   analyze_string_literal $lines $is_inline node::text_of(self)
  // 1430:   add_remark self print_string_literal(lines is_inline)
  frame->slots[4] /* temp__4 */ = create_closure(entry__68_7, 0);
  // 1423: if
  // 1424:   remark_lines_of(self).is_empty:
  // 1425:     analyze_string_literal $lines $is_inline node::text_of(self)
  // 1426:     print_string_literal lines is_inline
  // 1427:   :
  // 1428:     %line_width UNLIMITED # force inline output
  // 1429:     analyze_string_literal $lines $is_inline node::text_of(self)
  // 1430:     add_remark self print_string_literal(lines is_inline)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__69_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1435: ... add_remark self "."
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = string__69_2;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__70_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1441: ... self.is_a_setter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_setter();
  func = myself->type;
  frame->cont = cont__70_2;
}
static void cont__70_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1441: ... if(self.is_a_setter (-> "(!)") -> "()")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = func__70_3;
  arguments->slots[2] = func__70_5;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__70_7;
}
static void entry__70_3(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1441: ... -> "(!)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__70_4;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__70_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1441: ... -> "()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__70_6;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__70_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1441: add_remark self if(self.is_a_setter (-> "(!)") -> "()")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__71_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1450: ->
  // 1451:   namespace_of(self).is_defined
  // 1452:   -> string(namespace_of(self) "::" name_of(self))
  frame->slots[2] /* temp__2 */ = create_closure(entry__71_2, 0);
  // 1453: -> self.is_not_used -> string('_' name_of(self))
  frame->slots[3] /* temp__3 */ = create_closure(entry__71_10, 0);
  // 1454: -> true -> name_of(self)
  frame->slots[4] /* temp__4 */ = create_closure(entry__71_15, 0);
  // 1449: cond
  // 1450:   ->
  // 1451:     namespace_of(self).is_defined
  // 1452:     -> string(namespace_of(self) "::" name_of(self))
  // 1453:   -> self.is_not_used -> string('_' name_of(self))
  // 1454:   -> true -> name_of(self)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__71_18;
}
static void entry__71_16(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1454: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__71_17;
}
static void cont__71_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1454: ... -> name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__71_12(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1453: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__71_13;
}
static void cont__71_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1453: ... string('_' name_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__95;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__71_14;
}
static void cont__71_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1453: ... -> string('_' name_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__71_5(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1452: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__71_6;
}
static void cont__71_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1452: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__71_7;
}
static void cont__71_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1452: ... string(namespace_of(self) "::" name_of(self))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = string__71_8;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__71_9;
}
static void cont__71_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1452: -> string(namespace_of(self) "::" name_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__71_2(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1451: namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__71_3;
}
static void cont__71_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1451: namespace_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__71_4;
}
static void cont__71_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1452: -> string(namespace_of(self) "::" name_of(self))
  frame->slots[3] /* temp__3 */ = create_closure(entry__71_5, 0);
  // 1450: ->
  // 1451:   namespace_of(self).is_defined
  // 1452:   -> string(namespace_of(self) "::" name_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__71_10(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1453: ... self.is_not_used
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_not_used();
  func = myself->type;
  frame->cont = cont__71_11;
}
static void cont__71_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1453: ... -> string('_' name_of(self))
  frame->slots[2] /* temp__2 */ = create_closure(entry__71_12, 0);
  // 1453: -> self.is_not_used -> string('_' name_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__71_15(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1454: ... -> name_of(self)
  frame->slots[1] /* temp__1 */ = create_closure(entry__71_16, 0);
  // 1454: -> true -> name_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__71_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1447: add_remark
  // 1448:   self
  // 1449:   cond
  // 1450:     ->
  // 1451:       namespace_of(self).is_defined
  // 1452:       -> string(namespace_of(self) "::" name_of(self))
  // 1453:     -> self.is_not_used -> string('_' name_of(self))
  // 1454:     -> true -> name_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__72_2(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // self: 0
  // buf: 1
  // indent: 2
  // indentation: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] /* buf */ = create_cell();
  frame->slots[2] /* indent */ = create_future();
  frame->slots[3] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1464: expression_indent > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__72_3;
}
static void cont__72_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1462: $$buf
  // 1463:   if
  // 1464:     expression_indent > 0
  // 1465:     -> string('@nl;' spaces(expression_indent) "{@nl;")
  // 1466:     -> "{@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = func__72_4;
  arguments->slots[2] = func__72_8;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_10;
}
static void entry__72_4(void) {
  allocate_initialized_frame_gc(0, 2);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1465: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__72_5;
}
static void cont__72_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__2 */ = arguments->slots[0];
  // 1465: ... string('@nl;' spaces(expression_indent) "{@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__2 */;
  arguments->slots[2] = string__72_6;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__72_7;
}
static void cont__72_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 1465: -> string('@nl;' spaces(expression_indent) "{@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__72_8(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1466: -> "{@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__72_9;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1468: $indent expression_indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__72_11;
}
static void cont__72_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* indent */, arguments->slots[0]);
  // 1469: $indentation spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__72_12;
}
static void cont__72_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* indentation */, arguments->slots[0]);
  // 1470: ... kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__kind_of();
  func = myself->type;
  frame->cont = cont__72_13;
}
static void cont__72_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1470: ... kind_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__72_14;
}
static void cont__72_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1470: ... :
  // 1471:   writeln_to &buf indentation "<kind @(kind_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__72_15, 0);
  // 1470: if kind_of(self).is_defined:
  // 1471:   writeln_to &buf indentation "<kind @(kind_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_21;
}
static void entry__72_15(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1471: ... kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__kind_of();
  func = myself->type;
  frame->cont = cont__72_16;
}
static void cont__72_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1471: ... "<kind @(kind_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__72_17;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__72_18;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__72_19;
}
static void cont__72_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1471: writeln_to &buf indentation "<kind @(kind_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_20;
}
static void cont__72_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_21(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1472: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__72_22;
}
static void cont__72_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1472: ... identifier_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__72_23;
}
static void cont__72_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1472: ... :
  // 1473:   writeln_to &buf indentation "<name @(identifier_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__72_24, 0);
  // 1472: if identifier_of(self).is_defined:
  // 1473:   writeln_to &buf indentation "<name @(identifier_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_30;
}
static void entry__72_24(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1473: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__72_25;
}
static void cont__72_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1473: ... "<name @(identifier_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__72_26;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__72_27;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__72_28;
}
static void cont__72_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1473: writeln_to &buf indentation "<name @(identifier_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_29;
}
static void cont__72_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_30(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1474: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__72_31;
}
static void cont__72_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1474: ... node_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__72_32;
}
static void cont__72_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1474: ... :
  // 1475:   writeln_to &buf indentation "<node @(node_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__72_33, 0);
  // 1474: if node_of(self).is_defined:
  // 1475:   writeln_to &buf indentation "<node @(node_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_39;
}
static void entry__72_33(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1475: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__72_34;
}
static void cont__72_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1475: ... "<node @(node_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__72_35;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__72_36;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__72_37;
}
static void cont__72_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1475: writeln_to &buf indentation "<node @(node_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_38;
}
static void cont__72_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_39(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1476: ... node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__72_40;
}
static void cont__72_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1476: ... node::type_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__72_41;
}
static void cont__72_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1476: ... :
  // 1477:   writeln_to &buf indentation "<type @(node::type_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__72_42, 0);
  // 1476: if node::type_of(self).is_defined:
  // 1477:   writeln_to &buf indentation "<type @(node::type_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_48;
}
static void entry__72_42(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1477: ... node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__72_43;
}
static void cont__72_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1477: ... "<type @(node::type_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__72_44;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__72_45;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__72_46;
}
static void cont__72_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1477: writeln_to &buf indentation "<type @(node::type_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_47;
}
static void cont__72_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_48(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1478: ... base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__72_49;
}
static void cont__72_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1478: ... base_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__72_50;
}
static void cont__72_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1478: ... :
  // 1479:   writeln_to &buf indentation "<base @(base_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__72_51, 0);
  // 1478: if base_of(self).is_defined:
  // 1479:   writeln_to &buf indentation "<base @(base_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_57;
}
static void entry__72_51(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1479: ... base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__72_52;
}
static void cont__72_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1479: ... "<base @(base_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__72_53;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__72_54;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__72_55;
}
static void cont__72_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1479: writeln_to &buf indentation "<base @(base_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_56;
}
static void cont__72_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_57(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1480: ... scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__72_58;
}
static void cont__72_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1480: ... scope_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__72_59;
}
static void cont__72_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1480: ... scope_of(self) != "local"
  frame->slots[7] /* temp__4 */ = create_closure(entry__72_60, 0);
  // 1480: ... scope_of(self).is_defined && scope_of(self) != "local"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__72_65;
}
static void entry__72_60(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1480: ... scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__72_61;
}
static void cont__72_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1480: ... scope_of(self) != "local"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = string__72_62;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__72_63;
}
static void cont__72_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1480: ... scope_of(self) != "local"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__72_64;
}
static void cont__72_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1480: ... scope_of(self) != "local"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1480: ... :
  // 1481:   writeln_to &buf indentation "<scope @(scope_of(self))>"
  frame->slots[8] /* temp__5 */ = create_closure(entry__72_66, 0);
  // 1480: if scope_of(self).is_defined && scope_of(self) != "local":
  // 1481:   writeln_to &buf indentation "<scope @(scope_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_72;
}
static void entry__72_66(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1481: ... scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__72_67;
}
static void cont__72_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1481: ... "<scope @(scope_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__72_68;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__72_69;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__72_70;
}
static void cont__72_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1481: writeln_to &buf indentation "<scope @(scope_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_71;
}
static void cont__72_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_72(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1482: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__72_73;
}
static void cont__72_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1482: ... : (argument)
  // 1483:   writeln_to &buf indentation "<argument @(argument)>"
  frame->slots[5] /* temp__2 */ = create_closure(entry__72_74, 1);
  // 1482: for_each arguments_of(self): (argument)
  // 1483:   writeln_to &buf indentation "<argument @(argument)>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__72_79;
}
static void entry__72_74(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // argument: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1483: ... "<argument @(argument)>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__72_75;
  arguments->slots[1] = frame->slots[0] /* argument */;
  arguments->slots[2] = string__72_76;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__72_77;
}
static void cont__72_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1483: writeln_to &buf indentation "<argument @(argument)>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_78;
}
static void cont__72_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_79(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1484: ... remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__72_80;
}
static void cont__72_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1484: ... remark_lines_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__72_81;
}
static void cont__72_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1484: ... :
  // 1485:   push &buf '@nl;'
  // 1486:   for_each remark_lines_of(self): (remark_line)
  // 1487:     writeln_to &buf indentation "//" remark_line
  frame->slots[6] /* temp__3 */ = create_closure(entry__72_82, 0);
  // 1484: unless remark_lines_of(self).is_empty:
  // 1485:   push &buf '@nl;'
  // 1486:   for_each remark_lines_of(self): (remark_line)
  // 1487:     writeln_to &buf indentation "//" remark_line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__72_88;
}
static void entry__72_85(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // remark_line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1487: writeln_to &buf indentation "//" remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* indentation */;
  arguments->slots[2] = string__72_86;
  arguments->slots[3] = frame->slots[0] /* remark_line */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_87;
}
static void cont__72_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__72_82(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // self: 1
  // indentation: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1485: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__72_83;
}
static void cont__72_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1486: ... remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__72_84;
}
static void cont__72_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1486: ... : (remark_line)
  // 1487:   writeln_to &buf indentation "//" remark_line
  frame->slots[4] /* temp__2 */ = create_closure(entry__72_85, 1);
  // 1486: for_each remark_lines_of(self): (remark_line)
  // 1487:   writeln_to &buf indentation "//" remark_line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__72_88(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1488: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__72_89;
}
static void cont__72_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1488: ... source_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__72_90;
}
static void cont__72_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1488: ... :
  // 1489:   if length_of(buf) > 4: writeln_to &buf
  // 1490:   for_each_line source_of(self): (line) writeln_to &buf indentation line
  frame->slots[6] /* temp__3 */ = create_closure(entry__72_91, 0);
  // 1488: if source_of(self).is_defined:
  // 1489:   if length_of(buf) > 4: writeln_to &buf
  // 1490:   for_each_line source_of(self): (line) writeln_to &buf indentation line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_100;
}
static void entry__72_98(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1490: ... writeln_to &buf indentation line
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* indentation */;
  arguments->slots[2] = frame->slots[0] /* line */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_99;
}
static void cont__72_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__72_91(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // buf: 0
  // self: 1
  // indentation: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1489: ... length_of(buf)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__72_92;
}
static void cont__72_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1489: ... length_of(buf) > 4
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__4;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__72_93;
}
static void cont__72_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1489: ... : writeln_to &buf
  frame->slots[5] /* temp__3 */ = create_closure(entry__72_94, 0);
  // 1489: if length_of(buf) > 4: writeln_to &buf
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__72_96;
}
static void entry__72_94(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1489: ... writeln_to &buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__72_95;
}
static void cont__72_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__72_96(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1490: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__72_97;
}
static void cont__72_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1490: ... : (line) writeln_to &buf indentation line
  frame->slots[4] /* temp__2 */ = create_closure(entry__72_98, 1);
  // 1490: for_each_line source_of(self): (line) writeln_to &buf indentation line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_line();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__72_100(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1491: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__72_101;
}
static void cont__72_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1491: ... string(spaces(expression_indent) '}')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__125;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__72_102;
}
static void cont__72_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1491: append &buf string(spaces(expression_indent) '}')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__72_103;
}
static void cont__72_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1492: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__72_104(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1461: ... -> "{...}"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__72_105;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__72_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1460: !statement_tag ALWAYS
  set__statement_tag(var._ALWAYS);
  // 1461: ... :
  // 1462:   $$buf
  // 1463:     if
  // 1464:       expression_indent > 0
  // 1465:       -> string('@nl;' spaces(expression_indent) "{@nl;")
  // 1466:       -> "{@nl;"
  // 1467:   
  // 1468:   $indent expression_indent+2
  // 1469:   $indentation spaces(indent)
  // 1470:   if kind_of(self).is_defined:
  // ...
  frame->slots[1] /* temp__1 */ = create_closure(entry__72_2, 0);
  // 1461: if hide_body_statements (-> "{...}"):
  // 1462:   $$buf
  // 1463:     if
  // 1464:       expression_indent > 0
  // 1465:       -> string('@nl;' spaces(expression_indent) "{@nl;")
  // 1466:       -> "{@nl;"
  // 1467:   
  // 1468:   $indent expression_indent+2
  // 1469:   $indentation spaces(indent)
  // 1470:   if kind_of(self).is_defined:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__hide_body_statements();
  arguments->slots[1] = func__72_104;
  arguments->slots[2] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
EXPORT void collect__pretty_printer(void) {
  var._needs_parenthesis = collect_node(var._needs_parenthesis);
  var._ALWAYS = collect_node(var._ALWAYS);
  unique__2_1 = collect_node(unique__2_1);
  var._SHEBANG = collect_node(var._SHEBANG);
  unique__3_1 = collect_node(unique__3_1);
  var._REMARK = collect_node(var._REMARK);
  unique__4_1 = collect_node(unique__4_1);
  var._CODE_EXCLUSION = collect_node(var._CODE_EXCLUSION);
  unique__5_1 = collect_node(unique__5_1);
  var._REQUIRE = collect_node(var._REQUIRE);
  unique__6_1 = collect_node(unique__6_1);
  var._NAMESPACE = collect_node(var._NAMESPACE);
  unique__7_1 = collect_node(unique__7_1);
  var._USING = collect_node(var._USING);
  unique__8_1 = collect_node(unique__8_1);
  var._INCLUDE = collect_node(var._INCLUDE);
  unique__9_1 = collect_node(unique__9_1);
  var._LINK = collect_node(var._LINK);
  unique__10_1 = collect_node(unique__10_1);
  var._DATA = collect_node(var._DATA);
  unique__11_1 = collect_node(unique__11_1);
  var._POLYMORPHIC_FUNCTION = collect_node(var._POLYMORPHIC_FUNCTION);
  unique__12_1 = collect_node(unique__12_1);
  var._UNIQUE = collect_node(var._UNIQUE);
  unique__13_1 = collect_node(unique__13_1);
  var._PROC = collect_node(var._PROC);
  unique__14_1 = collect_node(unique__14_1);
  var._FUNC = collect_node(var._FUNC);
  unique__15_1 = collect_node(unique__15_1);
  var._UNLIMITED = collect_node(var._UNLIMITED);
  var._INDENTATION_MARKER = collect_node(var._INDENTATION_MARKER);
  var._INDENTATION_MARKER_HIGH = collect_node(var._INDENTATION_MARKER_HIGH);
  var._INDENTATION = collect_node(var._INDENTATION);
  func__24_13 = collect_node(func__24_13);
  func__24_14 = collect_node(func__24_14);
  func__24_1 = collect_node(func__24_1);
  var._indentation_string = collect_node(var._indentation_string);
  func__27_1 = collect_node(func__27_1);
  var.sim2c__print_trees = collect_node(var.sim2c__print_trees);
  func__28_2 = collect_node(func__28_2);
  func__28_30 = collect_node(func__28_30);
  func__28_46 = collect_node(func__28_46);
  func__28_6 = collect_node(func__28_6);
  func__28_1 = collect_node(func__28_1);
  var._line_start_remark_to_string = collect_node(var._line_start_remark_to_string);
  string__29_2 = collect_node(string__29_2);
  func__29_1 = collect_node(func__29_1);
  var._add_remark_lines = collect_node(var._add_remark_lines);
  string__30_4 = collect_node(string__30_4);
  func__30_3 = collect_node(func__30_3);
  string__30_6 = collect_node(string__30_6);
  func__30_5 = collect_node(func__30_5);
  string__30_24 = collect_node(string__30_24);
  string__30_46 = collect_node(string__30_46);
  func__30_1 = collect_node(func__30_1);
  var._add_remark = collect_node(var._add_remark);
  func__31_1 = collect_node(func__31_1);
  var._add_statement_remark = collect_node(var._add_statement_remark);
  func__32_1 = collect_node(func__32_1);
  var._add_indented_remark = collect_node(var._add_indented_remark);
  func__33_1 = collect_node(func__33_1);
  string__34_2 = collect_node(string__34_2);
  func__34_1 = collect_node(func__34_1);
  string__35_3 = collect_node(string__35_3);
  string__35_4 = collect_node(string__35_4);
  func__35_1 = collect_node(func__35_1);
  string__36_7 = collect_node(string__36_7);
  string__36_8 = collect_node(string__36_8);
  string__36_9 = collect_node(string__36_9);
  string__36_13 = collect_node(string__36_13);
  string__36_14 = collect_node(string__36_14);
  func__36_1 = collect_node(func__36_1);
  string__37_3 = collect_node(string__37_3);
  string__37_4 = collect_node(string__37_4);
  func__37_1 = collect_node(func__37_1);
  string__38_3 = collect_node(string__38_3);
  string__38_4 = collect_node(string__38_4);
  func__38_1 = collect_node(func__38_1);
  string__39_3 = collect_node(string__39_3);
  string__39_4 = collect_node(string__39_4);
  func__39_1 = collect_node(func__39_1);
  string__40_3 = collect_node(string__40_3);
  string__40_4 = collect_node(string__40_4);
  func__40_1 = collect_node(func__40_1);
  func__41_6 = collect_node(func__41_6);
  func__41_23 = collect_node(func__41_23);
  func__41_27 = collect_node(func__41_27);
  func__41_29 = collect_node(func__41_29);
  func__41_28 = collect_node(func__41_28);
  func__41_1 = collect_node(func__41_1);
  string__42_32 = collect_node(string__42_32);
  string__42_35 = collect_node(string__42_35);
  string__42_39 = collect_node(string__42_39);
  string__42_61 = collect_node(string__42_61);
  string__42_75 = collect_node(string__42_75);
  func__42_99 = collect_node(func__42_99);
  func__42_111 = collect_node(func__42_111);
  string__42_122 = collect_node(string__42_122);
  func__42_1 = collect_node(func__42_1);
  var._all_arguments_of = collect_node(var._all_arguments_of);
  func__43_1 = collect_node(func__43_1);
  var._argument_to_string = collect_node(var._argument_to_string);
  func__44_11 = collect_node(func__44_11);
  func__44_1 = collect_node(func__44_1);
  var._arguments_to_string = collect_node(var._arguments_to_string);
  func__45_38 = collect_node(func__45_38);
  string__45_73 = collect_node(string__45_73);
  string__45_113 = collect_node(string__45_113);
  string__45_135 = collect_node(string__45_135);
  string__45_215 = collect_node(string__45_215);
  string__45_236 = collect_node(string__45_236);
  func__45_1 = collect_node(func__45_1);
  var._call_with_remark_to_string = collect_node(var._call_with_remark_to_string);
  func__46_1 = collect_node(func__46_1);
  string__47_24 = collect_node(string__47_24);
  string__47_27 = collect_node(string__47_27);
  string__47_35 = collect_node(string__47_35);
  string__47_42 = collect_node(string__47_42);
  string__47_63 = collect_node(string__47_63);
  string__47_66 = collect_node(string__47_66);
  func__47_84 = collect_node(func__47_84);
  func__47_87 = collect_node(func__47_87);
  func__47_90 = collect_node(func__47_90);
  func__47_103 = collect_node(func__47_103);
  func__47_134 = collect_node(func__47_134);
  func__47_1 = collect_node(func__47_1);
  var._definition_to_string = collect_node(var._definition_to_string);
  string__48_5 = collect_node(string__48_5);
  string__48_26 = collect_node(string__48_26);
  func__48_1 = collect_node(func__48_1);
  func__49_4 = collect_node(func__49_4);
  string__49_6 = collect_node(string__49_6);
  func__49_5 = collect_node(func__49_5);
  func__49_1 = collect_node(func__49_1);
  string__50_5 = collect_node(string__50_5);
  func__50_4 = collect_node(func__50_4);
  string__50_7 = collect_node(string__50_7);
  func__50_6 = collect_node(func__50_6);
  string__50_9 = collect_node(string__50_9);
  func__50_8 = collect_node(func__50_8);
  string__50_11 = collect_node(string__50_11);
  func__50_10 = collect_node(func__50_10);
  func__50_1 = collect_node(func__50_1);
  string__51_2 = collect_node(string__51_2);
  func__51_1 = collect_node(func__51_1);
  string__52_2 = collect_node(string__52_2);
  func__52_1 = collect_node(func__52_1);
  var._precedence_of = collect_node(var._precedence_of);
  func__53_17 = collect_node(func__53_17);
  func__53_18 = collect_node(func__53_18);
  func__53_19 = collect_node(func__53_19);
  func__53_1 = collect_node(func__53_1);
  var._operator_of = collect_node(var._operator_of);
  func__54_15 = collect_node(func__54_15);
  func__54_1 = collect_node(func__54_1);
  func__55_42 = collect_node(func__55_42);
  string__55_96 = collect_node(string__55_96);
  string__55_97 = collect_node(string__55_97);
  string__55_114 = collect_node(string__55_114);
  string__55_118 = collect_node(string__55_118);
  string__55_132 = collect_node(string__55_132);
  string__55_137 = collect_node(string__55_137);
  string__55_148 = collect_node(string__55_148);
  string__55_228 = collect_node(string__55_228);
  string__55_229 = collect_node(string__55_229);
  string__55_230 = collect_node(string__55_230);
  string__55_231 = collect_node(string__55_231);
  string__55_238 = collect_node(string__55_238);
  string__55_264 = collect_node(string__55_264);
  string__55_265 = collect_node(string__55_265);
  func__55_1 = collect_node(func__55_1);
  func__56_1 = collect_node(func__56_1);
  var._pair_to_string = collect_node(var._pair_to_string);
  func__57_19 = collect_node(func__57_19);
  string__57_21 = collect_node(string__57_21);
  func__57_20 = collect_node(func__57_20);
  func__57_1 = collect_node(func__57_1);
  func__58_1 = collect_node(func__58_1);
  func__59_1 = collect_node(func__59_1);
  func__60_1 = collect_node(func__60_1);
  var._character_to_name = collect_node(var._character_to_name);
  var._create_character_table = collect_node(var._create_character_table);
  func__62_2 = collect_node(func__62_2);
  func__62_1 = collect_node(func__62_1);
  var._escaped_character = collect_node(var._escaped_character);
  string__63_9 = collect_node(string__63_9);
  string__63_11 = collect_node(string__63_11);
  func__63_10 = collect_node(func__63_10);
  string__63_12 = collect_node(string__63_12);
  string__63_14 = collect_node(string__63_14);
  func__63_13 = collect_node(func__63_13);
  string__63_29 = collect_node(string__63_29);
  func__63_1 = collect_node(func__63_1);
  func__64_1 = collect_node(func__64_1);
  var._analyze_string_literal = collect_node(var._analyze_string_literal);
  string__65_10 = collect_node(string__65_10);
  string__65_26 = collect_node(string__65_26);
  string__65_37 = collect_node(string__65_37);
  string__65_45 = collect_node(string__65_45);
  func__65_69 = collect_node(func__65_69);
  func__65_70 = collect_node(func__65_70);
  func__65_1 = collect_node(func__65_1);
  var._print_string_literal = collect_node(var._print_string_literal);
  func__66_23 = collect_node(func__66_23);
  func__66_24 = collect_node(func__66_24);
  string__66_127 = collect_node(string__66_127);
  string__66_134 = collect_node(string__66_134);
  string__66_141 = collect_node(string__66_141);
  func__66_1 = collect_node(func__66_1);
  var._string_template_to_string = collect_node(var._string_template_to_string);
  string__67_59 = collect_node(string__67_59);
  string__67_65 = collect_node(string__67_65);
  func__67_1 = collect_node(func__67_1);
  func__68_1 = collect_node(func__68_1);
  string__69_2 = collect_node(string__69_2);
  func__69_1 = collect_node(func__69_1);
  string__70_4 = collect_node(string__70_4);
  func__70_3 = collect_node(func__70_3);
  string__70_6 = collect_node(string__70_6);
  func__70_5 = collect_node(func__70_5);
  func__70_1 = collect_node(func__70_1);
  string__71_8 = collect_node(string__71_8);
  func__71_1 = collect_node(func__71_1);
  string__72_6 = collect_node(string__72_6);
  func__72_4 = collect_node(func__72_4);
  string__72_9 = collect_node(string__72_9);
  func__72_8 = collect_node(func__72_8);
  string__72_17 = collect_node(string__72_17);
  string__72_18 = collect_node(string__72_18);
  string__72_26 = collect_node(string__72_26);
  string__72_27 = collect_node(string__72_27);
  string__72_35 = collect_node(string__72_35);
  string__72_36 = collect_node(string__72_36);
  string__72_44 = collect_node(string__72_44);
  string__72_45 = collect_node(string__72_45);
  string__72_53 = collect_node(string__72_53);
  string__72_54 = collect_node(string__72_54);
  string__72_62 = collect_node(string__72_62);
  string__72_68 = collect_node(string__72_68);
  string__72_69 = collect_node(string__72_69);
  string__72_75 = collect_node(string__72_75);
  string__72_76 = collect_node(string__72_76);
  string__72_86 = collect_node(string__72_86);
  string__72_105 = collect_node(string__72_105);
  func__72_104 = collect_node(func__72_104);
  func__72_1 = collect_node(func__72_1);
  character__9 = collect_node(character__9);
  number__6 = collect_node(number__6);
  character__35 = collect_node(character__35);
  character__38 = collect_node(character__38);
  character__47 = collect_node(character__47);
  character__94 = collect_node(character__94);
  number__80 = collect_node(number__80);
  character__160 = collect_node(character__160);
  character__96 = collect_node(character__96);
  character__688 = collect_node(character__688);
  character__63 = collect_node(character__63);
  character__10 = collect_node(character__10);
  number__999999 = collect_node(number__999999);
  character__58 = collect_node(character__58);
  number__0 = collect_node(number__0);
  number__3 = collect_node(number__3);
  number__4 = collect_node(number__4);
  character__37 = collect_node(character__37);
  character__95 = collect_node(character__95);
  number__0x80 = collect_node(number__0x80);
  character__33 = collect_node(character__33);
  number__8 = collect_node(number__8);
  character__64 = collect_node(character__64);
  character__40 = collect_node(character__40);
  character__34 = collect_node(character__34);
  character__36 = collect_node(character__36);
  character__39 = collect_node(character__39);
  character__32 = collect_node(character__32);
  character__125 = collect_node(character__125);
  character__41 = collect_node(character__41);
  character__59 = collect_node(character__59);
  number__1 = collect_node(number__1);
  number__0x9f = collect_node(number__0x9f);
  character__46 = collect_node(character__46);
  number__2 = collect_node(number__2);
  number__20 = collect_node(number__20);
  character__42 = collect_node(character__42);
  character__128 = collect_node(character__128);
}

static int already_run_phase_1 = false;

EXPORT void phase_1__pretty_printer(void) {
  if (already_run_phase_1) return;
  already_run_phase_1 = true;
  register_module_info(&module_info);
  register_polymorphic_function("_pretty_printer::needs_parenthesis", &poly_idx__needs_parenthesis);
}

static int already_run_phase_2 = false;

EXPORT void phase_2__pretty_printer(void) {
  if (already_run_phase_2) return;
  already_run_phase_2 = true;
  character__9 = from_uchar32(9);
  number__6 = from_uint32(6U);
  character__35 = from_uchar32(35);
  character__38 = from_uchar32(38);
  character__47 = from_uchar32(47);
  character__94 = from_uchar32(94);
  number__80 = from_uint32(80U);
  character__160 = from_uchar32(160);
  character__96 = from_uchar32(96);
  character__688 = from_uchar32(688);
  character__63 = from_uchar32(63);
  character__10 = from_uchar32(10);
  number__999999 = from_uint32(999999U);
  character__58 = from_uchar32(58);
  number__0 = from_uint32(0U);
  number__3 = from_uint32(3U);
  number__4 = from_uint32(4U);
  character__37 = from_uchar32(37);
  character__95 = from_uchar32(95);
  number__0x80 = from_uint32(128U);
  character__33 = from_uchar32(33);
  number__8 = from_uint32(8U);
  character__64 = from_uchar32(64);
  character__40 = from_uchar32(40);
  character__34 = from_uchar32(34);
  character__36 = from_uchar32(36);
  character__39 = from_uchar32(39);
  character__32 = from_uchar32(32);
  character__125 = from_uchar32(125);
  character__41 = from_uchar32(41);
  character__59 = from_uchar32(59);
  number__1 = from_uint32(1U);
  number__0x9f = from_uint32(159U);
  character__46 = from_uchar32(46);
  number__2 = from_uint32(2U);
  number__20 = from_uint32(20U);
  character__42 = from_uchar32(42);
  character__128 = from_uchar32(128);
  string__29_2 = from_latin_1_string("\012", 1);
  string__30_4 = from_latin_1_string("#", 1);
  string__30_6 = from_latin_1_string(" #", 2);
  string__30_24 = from_latin_1_string(":", 1);
  string__30_46 = from_latin_1_string(":", 1);
  string__34_2 = from_latin_1_string("<???>", 5);
  string__35_3 = from_latin_1_string("<require ", 9);
  string__35_4 = from_latin_1_string(">", 1);
  string__36_7 = from_latin_1_string("<namespace ", 11);
  string__36_8 = from_latin_1_string(" = ", 3);
  string__36_9 = from_latin_1_string(">", 1);
  string__36_13 = from_latin_1_string("<namespace ", 11);
  string__36_14 = from_latin_1_string(">", 1);
  string__37_3 = from_latin_1_string("<using ", 7);
  string__37_4 = from_latin_1_string(">", 1);
  string__38_3 = from_latin_1_string("<include ", 9);
  string__38_4 = from_latin_1_string(">", 1);
  string__39_3 = from_latin_1_string("<link ", 6);
  string__39_4 = from_latin_1_string(">", 1);
  string__40_3 = from_latin_1_string("<data ", 6);
  string__40_4 = from_latin_1_string(">", 1);
  string__42_32 = from_latin_1_string(":", 1);
  string__42_35 = from_latin_1_string("\012", 1);
  string__42_39 = from_latin_1_string(": (", 3);
  string__42_61 = from_latin_1_string("\012", 1);
  string__42_75 = from_latin_1_string("(", 1);
  string__42_122 = from_latin_1_string("...\012", 4);
  string__45_73 = from_latin_1_string("->", 2);
  string__45_113 = from_latin_1_string("\012", 1);
  string__45_135 = from_latin_1_string("\012", 1);
  string__45_215 = from_latin_1_string("->", 2);
  string__45_236 = from_latin_1_string("->", 2);
  string__47_24 = from_latin_1_string("->", 2);
  string__47_27 = from_latin_1_string("-> ", 3);
  string__47_35 = from_latin_1_string("->", 2);
  string__47_42 = from_latin_1_string("\012\012", 2);
  string__47_63 = from_latin_1_string("-> ", 3);
  string__47_66 = from_latin_1_string("-> ", 3);
  string__48_5 = from_latin_1_string("-> ", 3);
  string__48_26 = from_latin_1_string(" = ", 3);
  string__49_6 = from_latin_1_string("$", 1);
  string__50_5 = from_latin_1_string("$", 1);
  string__50_7 = from_latin_1_string("!", 1);
  string__50_9 = from_latin_1_string("&", 1);
  string__50_11 = from_latin_1_string("$$", 2);
  string__51_2 = from_latin_1_string("%", 1);
  string__52_2 = from_latin_1_string("%%", 2);
  string__55_96 = from_latin_1_string(" .", 2);
  string__55_97 = from_latin_1_string(". ", 2);
  string__55_114 = from_latin_1_string("std", 3);
  string__55_118 = from_latin_1_string("key_value_pair", 14);
  string__55_132 = from_latin_1_string("std", 3);
  string__55_137 = from_latin_1_string("true", 4);
  string__55_148 = from_latin_1_string("--", 2);
  string__55_228 = from_latin_1_string("+", 1);
  string__55_229 = from_latin_1_string("-", 1);
  string__55_230 = from_latin_1_string("*", 1);
  string__55_231 = from_latin_1_string("/", 1);
  string__55_238 = from_latin_1_string(",", 1);
  string__55_264 = from_latin_1_string("sequence", 8);
  string__55_265 = from_latin_1_string(",", 1);
  string__57_21 = from_latin_1_string(" ", 1);
  string__63_9 = from_latin_1_string("at", 2);
  string__63_11 = from_latin_1_string("@@", 2);
  string__63_12 = from_latin_1_string("amp", 3);
  string__63_14 = from_latin_1_string("&", 1);
  string__63_29 = from_latin_1_string("@0x", 3);
  string__65_10 = from_latin_1_string("@nl;", 4);
  string__65_26 = from_latin_1_string("@nl;", 4);
  string__65_37 = from_latin_1_string("@quot;", 6);
  string__65_45 = from_latin_1_string("@@", 2);
  string__66_127 = from_latin_1_string("@", 1);
  string__66_134 = from_latin_1_string("@;", 2);
  string__66_141 = from_latin_1_string("\042", 1);
  string__67_59 = from_latin_1_string("@(", 2);
  string__67_65 = from_latin_1_string("@nl;@", 5);
  string__69_2 = from_latin_1_string(".", 1);
  string__70_4 = from_latin_1_string("(!)", 3);
  string__70_6 = from_latin_1_string("()", 2);
  string__71_8 = from_latin_1_string("::", 2);
  string__72_6 = from_latin_1_string("{\012", 2);
  string__72_9 = from_latin_1_string("{\012", 2);
  string__72_17 = from_latin_1_string("<kind ", 6);
  string__72_18 = from_latin_1_string(">", 1);
  string__72_26 = from_latin_1_string("<name ", 6);
  string__72_27 = from_latin_1_string(">", 1);
  string__72_35 = from_latin_1_string("<node ", 6);
  string__72_36 = from_latin_1_string(">", 1);
  string__72_44 = from_latin_1_string("<type ", 6);
  string__72_45 = from_latin_1_string(">", 1);
  string__72_53 = from_latin_1_string("<base ", 6);
  string__72_54 = from_latin_1_string(">", 1);
  string__72_62 = from_latin_1_string("local", 5);
  string__72_68 = from_latin_1_string("<scope ", 7);
  string__72_69 = from_latin_1_string(">", 1);
  string__72_75 = from_latin_1_string("<argument ", 10);
  string__72_76 = from_latin_1_string(">", 1);
  string__72_86 = from_latin_1_string("//", 2);
  string__72_105 = from_latin_1_string("{...}", 5);
}

static int already_run_phase_3 = false;

EXPORT void phase_3__pretty_printer(void) {
  if (already_run_phase_3) return;
  already_run_phase_3 = true;
  set_module("pretty_printer");
  set_used_namespaces(used_namespaces);
  unique__2_1 = register_unique_item("ALWAYS");
  assign_value(&var._ALWAYS, unique__2_1);
  unique__3_1 = register_unique_item("SHEBANG");
  assign_value(&var._SHEBANG, unique__3_1);
  unique__4_1 = register_unique_item("REMARK");
  assign_value(&var._REMARK, unique__4_1);
  unique__5_1 = register_unique_item("CODE_EXCLUSION");
  assign_value(&var._CODE_EXCLUSION, unique__5_1);
  unique__6_1 = register_unique_item("REQUIRE");
  assign_value(&var._REQUIRE, unique__6_1);
  unique__7_1 = register_unique_item("NAMESPACE");
  assign_value(&var._NAMESPACE, unique__7_1);
  unique__8_1 = register_unique_item("USING");
  assign_value(&var._USING, unique__8_1);
  unique__9_1 = register_unique_item("INCLUDE");
  assign_value(&var._INCLUDE, unique__9_1);
  unique__10_1 = register_unique_item("LINK");
  assign_value(&var._LINK, unique__10_1);
  unique__11_1 = register_unique_item("DATA");
  assign_value(&var._DATA, unique__11_1);
  unique__12_1 = register_unique_item("POLYMORPHIC_FUNCTION");
  assign_value(&var._POLYMORPHIC_FUNCTION, unique__12_1);
  unique__13_1 = register_unique_item("UNIQUE");
  assign_value(&var._UNIQUE, unique__13_1);
  unique__14_1 = register_unique_item("PROC");
  assign_value(&var._PROC, unique__14_1);
  unique__15_1 = register_unique_item("FUNC");
  assign_value(&var._FUNC, unique__15_1);
  define_single_assign_dynamic("sim2c", "hide_body_statements", get__sim2c__hide_body_statements, define__sim2c__hide_body_statements, &dyna_idx__sim2c__hide_body_statements);
  define__sim2c__hide_body_statements(create_future());
  define_single_assign_dynamic("sim2c", "line_width", get__sim2c__line_width, define__sim2c__line_width, &dyna_idx__sim2c__line_width);
  register_dynamic(&dyna_idx__expression_indent);
  register_dynamic(&dyna_idx__line_end_expression_width);
  var._INDENTATION_MARKER = create_future();
  var._INDENTATION_MARKER_HIGH = create_future();
  func__24_13 = create_future();
  func__24_14 = create_future();
  func__24_1 = create_future();
  register_dynamic(&dyna_idx__statement_tag);
  define__statement_tag(undefined);
  register_dynamic(&dyna_idx__spaces);
  define__spaces(create_future());
  func__27_1 = create_future();
  func__28_2 = create_future();
  func__28_30 = create_future();
  func__28_46 = create_future();
  func__28_6 = create_future();
  func__28_1 = create_future();
  define_single_assign_static("sim2c", "print_trees", get__sim2c__print_trees, &var.sim2c__print_trees);
  func__29_1 = create_future();
  func__30_3 = create_future();
  func__30_5 = create_future();
  func__30_1 = create_future();
  func__31_1 = create_future();
  func__32_1 = create_future();
  func__33_1 = create_future();
  func__34_1 = create_future();
  func__35_1 = create_future();
  func__36_1 = create_future();
  func__37_1 = create_future();
  func__38_1 = create_future();
  func__39_1 = create_future();
  func__40_1 = create_future();
  func__41_6 = create_future();
  func__41_23 = create_future();
  func__41_27 = create_future();
  func__41_29 = create_future();
  func__41_28 = create_future();
  func__41_1 = create_future();
  func__42_99 = create_future();
  func__42_111 = create_future();
  func__42_1 = create_future();
  func__43_1 = create_future();
  func__44_11 = create_future();
  func__44_1 = create_future();
  func__45_38 = create_future();
  func__45_1 = create_future();
  func__46_1 = create_future();
  func__47_84 = create_future();
  func__47_87 = create_future();
  func__47_90 = create_future();
  func__47_103 = create_future();
  func__47_134 = create_future();
  func__47_1 = create_future();
  func__48_1 = create_future();
  func__49_4 = create_future();
  func__49_5 = create_future();
  func__49_1 = create_future();
  func__50_4 = create_future();
  func__50_6 = create_future();
  func__50_8 = create_future();
  func__50_10 = create_future();
  func__50_1 = create_future();
  func__51_1 = create_future();
  func__52_1 = create_future();
  func__53_17 = create_future();
  func__53_18 = create_future();
  func__53_19 = create_future();
  func__53_1 = create_future();
  func__54_15 = create_future();
  func__54_1 = create_future();
  func__55_42 = create_future();
  func__55_1 = create_future();
  func__56_1 = create_future();
  func__57_19 = create_future();
  func__57_20 = create_future();
  func__57_1 = create_future();
  func__58_1 = create_future();
  func__59_1 = create_future();
  func__60_1 = create_future();
  func__62_2 = create_future();
  func__62_1 = create_future();
  func__63_10 = create_future();
  func__63_13 = create_future();
  func__63_1 = create_future();
  func__64_1 = create_future();
  func__65_69 = create_future();
  func__65_70 = create_future();
  func__65_1 = create_future();
  func__66_23 = create_future();
  func__66_24 = create_future();
  func__66_1 = create_future();
  func__67_1 = create_future();
  func__68_1 = create_future();
  func__69_1 = create_future();
  func__70_3 = create_future();
  func__70_5 = create_future();
  func__70_1 = create_future();
  func__71_1 = create_future();
  func__72_4 = create_future();
  func__72_8 = create_future();
  func__72_104 = create_future();
  func__72_1 = create_future();
}

static int already_run_phase_4 = false;

EXPORT void phase_4__pretty_printer(void) {
  if (already_run_phase_4) return;
  already_run_phase_4 = true;
  set_module("pretty_printer");
  set_used_namespaces(used_namespaces);
  use_read_only(NULL, "ATTRIBUTE_KIND", &get__ATTRIBUTE_KIND, &get_value_or_future__ATTRIBUTE_KIND);
  use_read_only(NULL, "CONTINUATION_PARAMETER", &get__CONTINUATION_PARAMETER, &get_value_or_future__CONTINUATION_PARAMETER);
  use_read_only(NULL, "HIGHEST_PRECEDENCE", &get__HIGHEST_PRECEDENCE, &get_value_or_future__HIGHEST_PRECEDENCE);
  use_read_only(NULL, "INFIX_PRECEDENCE", &get__INFIX_PRECEDENCE, &get_value_or_future__INFIX_PRECEDENCE);
  use_read_only(NULL, "IN_OUT_PARAMETER", &get__IN_OUT_PARAMETER, &get_value_or_future__IN_OUT_PARAMETER);
  use_read_only(NULL, "IN_PARAMETER", &get__IN_PARAMETER, &get_value_or_future__IN_PARAMETER);
  use_read_only(NULL, "METHOD_KIND", &get__METHOD_KIND, &get_value_or_future__METHOD_KIND);
  use_read_only(NULL, "MYSELF_PARAMETER", &get__MYSELF_PARAMETER, &get_value_or_future__MYSELF_PARAMETER);
  use_read_only(NULL, "OUT_PARAMETER", &get__OUT_PARAMETER, &get_value_or_future__OUT_PARAMETER);
  use_read_only(NULL, "all_of", &get__all_of, &get_value_or_future__all_of);
  use_read_only(NULL, "alt", &get__alt, &get_value_or_future__alt);
  use_read_only(NULL, "any_of", &get__any_of, &get_value_or_future__any_of);
  use_read_only(NULL, "append", &get__append, &get_value_or_future__append);
  use_read_only(NULL, "arguments_of", &get__arguments_of, &get_value_or_future__arguments_of);
  use_read_only(NULL, "attribute_kind_of", &get__attribute_kind_of, &get_value_or_future__attribute_kind_of);
  use_read_only(NULL, "attribute_of", &get__attribute_of, &get_value_or_future__attribute_of);
  use_read_only(NULL, "base_of", &get__base_of, &get_value_or_future__base_of);
  use_read_only(NULL, "case", &get__case, &get_value_or_future__case);
  use_read_only(NULL, "character", &get__character, &get_value_or_future__character);
  use_read_only(NULL, "character_names", &get__character_names, &get_value_or_future__character_names);
  use_read_only(NULL, "cond", &get__cond, &get_value_or_future__cond);
  use_read_only(NULL, "contains", &get__contains, &get_value_or_future__contains);
  use_read_only(NULL, "default_value_of", &get__default_value_of, &get_value_or_future__default_value_of);
  use_read_only(NULL, "do", &get__do, &get_value_or_future__do);
  use_read_only(NULL, "do_while", &get__do_while, &get_value_or_future__do_while);
  use_read_only(NULL, "dup", &get__dup, &get_value_or_future__dup);
  use_read_only(NULL, "empty_list", &get__empty_list, &get_value_or_future__empty_list);
  use_read_only(NULL, "empty_table", &get__empty_table, &get_value_or_future__empty_table);
  use_read_only(NULL, "enumeration_no_of", &get__enumeration_no_of, &get_value_or_future__enumeration_no_of);
  use_read_only(NULL, "false", &get__false, &get_value_or_future__false);
  use_read_only(NULL, "for_each", &get__for_each, &get_value_or_future__for_each);
  use_read_only(NULL, "for_each_from_to", &get__for_each_from_to, &get_value_or_future__for_each_from_to);
  use_read_only(NULL, "for_each_line", &get__for_each_line, &get_value_or_future__for_each_line);
  use_read_only(NULL, "from", &get__from, &get_value_or_future__from);
  use_read_only(NULL, "from_down_to", &get__from_down_to, &get_value_or_future__from_down_to);
  use_read_only(NULL, "functor_of", &get__functor_of, &get_value_or_future__functor_of);
  use_polymorphic_function("grammar", "match", &get__grammar__match, &poly_idx__grammar__match);
  use_read_only(NULL, "has_minimum_length", &get__has_minimum_length, &get_value_or_future__has_minimum_length);
  use_read_only(NULL, "has_prefix", &get__has_prefix, &get_value_or_future__has_prefix);
  use_read_only(NULL, "has_suffix", &get__has_suffix, &get_value_or_future__has_suffix);
  use_read_only(NULL, "hex", &get__hex, &get_value_or_future__hex);
  use_read_only(NULL, "hide_body_statements", &get__hide_body_statements, &get_value_or_future__hide_body_statements);
  use_read_only(NULL, "identifier_of", &get__identifier_of, &get_value_or_future__identifier_of);
  use_read_only(NULL, "if", &get__if, &get_value_or_future__if);
  use_read_only(NULL, "inc", &get__inc, &get_value_or_future__inc);
  use_read_only(NULL, "is_a_body", &get__is_a_body, &get_value_or_future__is_a_body);
  use_read_only(NULL, "is_a_definition", &get__is_a_definition, &get_value_or_future__is_a_definition);
  use_read_only(NULL, "is_a_destination", &get__is_a_destination, &get_value_or_future__is_a_destination);
  use_read_only(NULL, "is_a_function_call", &get__is_a_function_call, &get_value_or_future__is_a_function_call);
  use_read_only(NULL, "is_a_letter", &get__is_a_letter, &get_value_or_future__is_a_letter);
  use_read_only(NULL, "is_a_method_definition", &get__is_a_method_definition, &get_value_or_future__is_a_method_definition);
  use_read_only(NULL, "is_a_parameter", &get__is_a_parameter, &get_value_or_future__is_a_parameter);
  use_read_only(NULL, "is_a_polymorphic_function_constant", &get__is_a_polymorphic_function_constant, &get_value_or_future__is_a_polymorphic_function_constant);
  use_read_only(NULL, "is_a_return", &get__is_a_return, &get_value_or_future__is_a_return);
  use_read_only(NULL, "is_a_setter", &get__is_a_setter, &get_value_or_future__is_a_setter);
  use_read_only(NULL, "is_a_string_literal", &get__is_a_string_literal, &get_value_or_future__is_a_string_literal);
  use_read_only(NULL, "is_a_string_template", &get__is_a_string_template, &get_value_or_future__is_a_string_template);
  use_read_only(NULL, "is_a_unique_item_constant", &get__is_a_unique_item_constant, &get_value_or_future__is_a_unique_item_constant);
  use_read_only(NULL, "is_an_assignment", &get__is_an_assignment, &get_value_or_future__is_an_assignment);
  use_read_only(NULL, "is_an_attribute_access", &get__is_an_attribute_access, &get_value_or_future__is_an_attribute_access);
  use_read_only(NULL, "is_an_attribute_value_pair", &get__is_an_attribute_value_pair, &get_value_or_future__is_an_attribute_value_pair);
  use_read_only(NULL, "is_an_expanded_item", &get__is_an_expanded_item, &get_value_or_future__is_an_expanded_item);
  use_read_only(NULL, "is_an_identifier", &get__is_an_identifier, &get_value_or_future__is_an_identifier);
  use_read_only(NULL, "is_an_operator_symbol", &get__is_an_operator_symbol, &get_value_or_future__is_an_operator_symbol);
  use_read_only(NULL, "is_an_optional_item", &get__is_an_optional_item, &get_value_or_future__is_an_optional_item);
  use_read_only(NULL, "is_defined", &get__is_defined, &get_value_or_future__is_defined);
  use_read_only(NULL, "is_empty", &get__is_empty, &get_value_or_future__is_empty);
  use_read_only(NULL, "is_in_infix_notation", &get__is_in_infix_notation, &get_value_or_future__is_in_infix_notation);
  use_read_only(NULL, "is_left_associative", &get__is_left_associative, &get_value_or_future__is_left_associative);
  use_read_only(NULL, "is_not_used", &get__is_not_used, &get_value_or_future__is_not_used);
  use_read_only(NULL, "is_undefined", &get__is_undefined, &get_value_or_future__is_undefined);
  use_read_only(NULL, "kind_of", &get__kind_of, &get_value_or_future__kind_of);
  use_read_only(NULL, "length_of", &get__length_of, &get_value_or_future__length_of);
  use_single_assign_dynamic(NULL, "line_width", &get__line_width, &define__line_width);
  use_read_only(NULL, "list", &get__list, &get_value_or_future__list);
  use_read_only(NULL, "matches", &get__matches, &get_value_or_future__matches);
  use_read_only(NULL, "max", &get__max, &get_value_or_future__max);
  use_read_only(NULL, "minus", &get__minus, &get_value_or_future__minus);
  use_read_only(NULL, "name_of", &get__name_of, &get_value_or_future__name_of);
  use_read_only(NULL, "namespace_alias_of", &get__namespace_alias_of, &get_value_or_future__namespace_alias_of);
  use_read_only(NULL, "namespace_of", &get__namespace_of, &get_value_or_future__namespace_of);
  use_read_only("node", "filemask_of", &get__node__filemask_of, &get_value_or_future__node__filemask_of);
  use_read_only("node", "filename_of", &get__node__filename_of, &get_value_or_future__node__filename_of);
  use_read_only("node", "text_of", &get__node__text_of, &get_value_or_future__node__text_of);
  use_read_only("node", "type_of", &get__node__type_of, &get_value_or_future__node__type_of);
  use_read_only("node", "value_of", &get__node__value_of, &get_value_or_future__node__value_of);
  use_read_only(NULL, "node_of", &get__node_of, &get_value_or_future__node_of);
  use_read_only(NULL, "not", &get__not, &get_value_or_future__not);
  use_polymorphic_function(NULL, "output_arguments_of", &get__output_arguments_of, &poly_idx__output_arguments_of);
  use_read_only(NULL, "parameter_kind_of", &get__parameter_kind_of, &get_value_or_future__parameter_kind_of);
  use_read_only(NULL, "parameters_of", &get__parameters_of, &get_value_or_future__parameters_of);
  use_read_only(NULL, "pass", &get__pass, &get_value_or_future__pass);
  use_read_only(NULL, "plus", &get__plus, &get_value_or_future__plus);
  use_read_only(NULL, "precedence", &get__precedence, &get_value_or_future__precedence);
  use_read_only(NULL, "push", &get__push, &get_value_or_future__push);
  use_read_only(NULL, "put", &get__put, &get_value_or_future__put);
  use_read_only(NULL, "range", &get__range, &get_value_or_future__range);
  use_read_only(NULL, "remark_lines_behind_of", &get__remark_lines_behind_of, &get_value_or_future__remark_lines_behind_of);
  use_read_only(NULL, "remark_lines_of", &get__remark_lines_of, &get_value_or_future__remark_lines_of);
  use_read_only(NULL, "scope_of", &get__scope_of, &get_value_or_future__scope_of);
  use_read_only("sim2c", "attribute_function_pair", &get__sim2c__attribute_function_pair, &get_value_or_future__sim2c__attribute_function_pair);
  use_read_only("sim2c", "attribute_value_pair", &get__sim2c__attribute_value_pair, &get_value_or_future__sim2c__attribute_value_pair);
  use_read_only("sim2c", "backquoted", &get__sim2c__backquoted, &get_value_or_future__sim2c__backquoted);
  use_read_only("sim2c", "body", &get__sim2c__body, &get_value_or_future__sim2c__body);
  use_read_only("sim2c", "c_code", &get__sim2c__c_code, &get_value_or_future__sim2c__c_code);
  use_read_only("sim2c", "call", &get__sim2c__call, &get_value_or_future__sim2c__call);
  use_read_only("sim2c", "character_literal", &get__sim2c__character_literal, &get_value_or_future__sim2c__character_literal);
  use_read_only("sim2c", "data_instruction", &get__sim2c__data_instruction, &get_value_or_future__sim2c__data_instruction);
  use_read_only("sim2c", "define_dynamic_multi", &get__sim2c__define_dynamic_multi, &get_value_or_future__sim2c__define_dynamic_multi);
  use_read_only("sim2c", "define_dynamic_single", &get__sim2c__define_dynamic_single, &get_value_or_future__sim2c__define_dynamic_single);
  use_read_only("sim2c", "define_static_multi", &get__sim2c__define_static_multi, &get_value_or_future__sim2c__define_static_multi);
  use_read_only("sim2c", "define_static_single", &get__sim2c__define_static_single, &get_value_or_future__sim2c__define_static_single);
  use_read_only("sim2c", "function_call", &get__sim2c__function_call, &get_value_or_future__sim2c__function_call);
  use_read_only("sim2c", "identifier", &get__sim2c__identifier, &get_value_or_future__sim2c__identifier);
  use_read_only("sim2c", "include_instruction", &get__sim2c__include_instruction, &get_value_or_future__sim2c__include_instruction);
  use_read_only("sim2c", "link_instruction", &get__sim2c__link_instruction, &get_value_or_future__sim2c__link_instruction);
  use_read_only("sim2c", "namespace_instruction", &get__sim2c__namespace_instruction, &get_value_or_future__sim2c__namespace_instruction);
  use_read_only("sim2c", "numeric_literal", &get__sim2c__numeric_literal, &get_value_or_future__sim2c__numeric_literal);
  use_read_only("sim2c", "polymorphic_function", &get__sim2c__polymorphic_function, &get_value_or_future__sim2c__polymorphic_function);
  use_read_only("sim2c", "remark_statement", &get__sim2c__remark_statement, &get_value_or_future__sim2c__remark_statement);
  use_read_only("sim2c", "require_instruction", &get__sim2c__require_instruction, &get_value_or_future__sim2c__require_instruction);
  use_read_only("sim2c", "string_literal", &get__sim2c__string_literal, &get_value_or_future__sim2c__string_literal);
  use_read_only("sim2c", "unique_item", &get__sim2c__unique_item, &get_value_or_future__sim2c__unique_item);
  use_read_only("sim2c", "using_instruction", &get__sim2c__using_instruction, &get_value_or_future__sim2c__using_instruction);
  use_read_only(NULL, "some", &get__some, &get_value_or_future__some);
  use_read_only(NULL, "source_of", &get__source_of, &get_value_or_future__source_of);
  use_read_only(NULL, "statements_of", &get__statements_of, &get_value_or_future__statements_of);
  use_read_only("std", "and", &get__std__and, &get_value_or_future__std__and);
  use_read_only("std", "equal", &get__std__equal, &get_value_or_future__std__equal);
  use_read_only("std", "less", &get__std__less, &get_value_or_future__std__less);
  use_read_only("std", "minus", &get__std__minus, &get_value_or_future__std__minus);
  use_read_only("std", "negate", &get__std__negate, &get_value_or_future__std__negate);
  use_read_only("std", "not", &get__std__not, &get_value_or_future__std__not);
  use_read_only("std", "or", &get__std__or, &get_value_or_future__std__or);
  use_read_only("std", "plus", &get__std__plus, &get_value_or_future__std__plus);
  use_read_only("std", "sequence", &get__std__sequence, &get_value_or_future__std__sequence);
  use_read_only("std", "shift_right", &get__std__shift_right, &get_value_or_future__std__shift_right);
  use_read_only("std", "spaces", &get__std__spaces, &get_value_or_future__std__spaces);
  use_read_only("std", "string", &get__std__string, &get_value_or_future__std__string);
  use_read_only("std", "times", &get__std__times, &get_value_or_future__std__times);
  use_read_only(NULL, "string", &get__string, &get_value_or_future__string);
  use_read_only(NULL, "to_integer", &get__to_integer, &get_value_or_future__to_integer);
  use_polymorphic_function(NULL, "to_string", &get__to_string, &poly_idx__to_string);
  use_read_only(NULL, "true", &get__true, &get_value_or_future__true);
  use_read_only(NULL, "truncate_from", &get__truncate_from, &get_value_or_future__truncate_from);
  use_read_only("types", "grammar_node", &get__types__grammar_node, &get_value_or_future__types__grammar_node);
  use_read_only("types", "grammar_object", &get__types__grammar_object, &get_value_or_future__types__grammar_object);
  use_read_only(NULL, "undefined", &get__undefined, &get_value_or_future__undefined);
  use_read_only(NULL, "unless", &get__unless, &get_value_or_future__unless);
  use_read_only(NULL, "while", &get__while, &get_value_or_future__while);
  use_read_only(NULL, "write_to", &get__write_to, &get_value_or_future__write_to);
  use_read_only(NULL, "writeln", &get__writeln, &get_value_or_future__writeln);
  use_read_only(NULL, "writeln_to", &get__writeln_to, &get_value_or_future__writeln_to);
  update_start_p = node_p;
  def_attribute(&var._INDENTATION, poly_idx__grammar__match, func__24_1);
  define_method("types", "grammar_node", poly_idx__to_string, func__34_1);
  define_method("sim2c", "require_instruction", poly_idx__to_string, func__35_1);
  define_method("sim2c", "namespace_instruction", poly_idx__to_string, func__36_1);
  define_method("sim2c", "using_instruction", poly_idx__to_string, func__37_1);
  define_method("sim2c", "include_instruction", poly_idx__to_string, func__38_1);
  define_method("sim2c", "link_instruction", poly_idx__to_string, func__39_1);
  define_method("sim2c", "data_instruction", poly_idx__to_string, func__40_1);
  define_method("sim2c", "remark_statement", poly_idx__to_string, func__41_1);
  define_method("sim2c", "body", poly_idx__to_string, func__42_1);
  define_method("sim2c", "call", poly_idx__to_string, func__47_1);
  define_method("sim2c", "define_static_single", poly_idx__to_string, func__49_1);
  define_method("sim2c", "define_static_multi", poly_idx__to_string, func__50_1);
  define_method("sim2c", "define_dynamic_single", poly_idx__to_string, func__51_1);
  define_method("sim2c", "define_dynamic_multi", poly_idx__to_string, func__52_1);
  define_method("sim2c", "function_call", poly_idx__to_string, func__55_1);
  define_method("sim2c", "backquoted", poly_idx__to_string, func__56_1);
  define_method("sim2c", "attribute_value_pair", poly_idx__to_string, func__58_1);
  define_method("sim2c", "attribute_function_pair", poly_idx__to_string, func__59_1);
  define_method("sim2c", "numeric_literal", poly_idx__to_string, func__60_1);
  define_method("sim2c", "character_literal", poly_idx__to_string, func__64_1);
  define_method("sim2c", "string_literal", poly_idx__to_string, func__68_1);
  define_method("sim2c", "unique_item", poly_idx__to_string, func__69_1);
  define_method("sim2c", "polymorphic_function", poly_idx__to_string, func__70_1);
  define_method("sim2c", "identifier", poly_idx__to_string, func__71_1);
  define_method("sim2c", "c_code", poly_idx__to_string, func__72_1);
}

static int already_run_phase_5 = false;

EXPORT void phase_5__pretty_printer(void) {
  if (already_run_phase_5) return;
  already_run_phase_5 = true;
  assign_value(&var._needs_parenthesis, create_function(type__needs_parenthesis, -1));
  maybe_initialize_future(get__sim2c__hide_body_statements(), get__false());
  assign_value(&var._UNLIMITED, number__999999);
  define__sim2c__line_width(number__80);
  define__expression_indent(number__0);
  define__line_end_expression_width(number__0);
  assign_value(&var._INDENTATION, get__types__grammar_object());
  maybe_initialize_future(get__spaces(), get__std__spaces());
  assign_variable(&var._indentation_string, &func__27_1);
  assign_variable(&var.sim2c__print_trees, &func__28_1);
  assign_variable(&var._line_start_remark_to_string, &func__29_1);
  assign_variable(&var._add_remark_lines, &func__30_1);
  assign_variable(&var._add_remark, &func__31_1);
  assign_variable(&var._add_statement_remark, &func__32_1);
  assign_variable(&var._add_indented_remark, &func__33_1);
  assign_variable(&var._all_arguments_of, &func__43_1);
  assign_variable(&var._argument_to_string, &func__44_1);
  assign_variable(&var._arguments_to_string, &func__45_1);
  assign_variable(&var._call_with_remark_to_string, &func__46_1);
  assign_variable(&var._definition_to_string, &func__48_1);
  assign_variable(&var._precedence_of, &func__53_1);
  assign_variable(&var._operator_of, &func__54_1);
  assign_variable(&var._pair_to_string, &func__57_1);
  assign_variable(&var._create_character_table, &func__62_1);
  assign_variable(&var._escaped_character, &func__63_1);
  assign_variable(&var._analyze_string_literal, &func__65_1);
  assign_variable(&var._print_string_literal, &func__66_1);
  assign_variable(&var._string_template_to_string, &func__67_1);
}

static int already_run_phase_6 = false;

EXPORT void phase_6__pretty_printer(void) {
  if (already_run_phase_6) return;
  already_run_phase_6 = true;
  assign_value(&func__24_13, create_function(entry__24_13, 0));
  assign_value(&func__24_14, create_function(entry__24_14, 0));
  assign_value(&func__24_1, create_function(entry__24_1, 2));
  assign_value(&func__27_1, create_function(entry__27_1, 1));
  assign_value(&func__28_2, create_function(entry__28_2, 1));
  assign_value(&func__28_30, create_function(entry__28_30, 0));
  assign_value(&func__28_46, create_function(entry__28_46, 1));
  assign_value(&func__28_6, create_function(entry__28_6, 2));
  assign_value(&func__28_1, create_function(entry__28_1, 1));
  assign_value(&func__29_1, create_function(entry__29_1, 2));
  assign_value(&func__30_3, create_function(entry__30_3, 0));
  assign_value(&func__30_5, create_function(entry__30_5, 0));
  assign_value(&func__30_1, create_function(entry__30_1, -1));
  assign_value(&func__31_1, create_function(entry__31_1, 2));
  assign_value(&func__32_1, create_function(entry__32_1, 2));
  assign_value(&func__33_1, create_function(entry__33_1, 2));
  assign_value(&func__34_1, create_function(entry__34_1, 1));
  assign_value(&func__35_1, create_function(entry__35_1, 1));
  assign_value(&func__36_1, create_function(entry__36_1, 1));
  assign_value(&func__37_1, create_function(entry__37_1, 1));
  assign_value(&func__38_1, create_function(entry__38_1, 1));
  assign_value(&func__39_1, create_function(entry__39_1, 1));
  assign_value(&func__40_1, create_function(entry__40_1, 1));
  assign_value(&func__41_6, create_function(entry__41_6, 0));
  assign_value(&func__41_23, create_function(entry__41_23, 0));
  assign_value(&func__41_27, create_function(entry__41_27, 0));
  assign_value(&func__41_29, create_function(entry__41_29, 0));
  assign_value(&func__41_28, create_function(entry__41_28, 0));
  assign_value(&func__41_1, create_function(entry__41_1, 1));
  assign_value(&func__42_99, create_function(entry__42_99, 1));
  assign_value(&func__42_111, create_function(entry__42_111, 1));
  assign_value(&func__42_1, create_function(entry__42_1, 1));
  assign_value(&func__43_1, create_function(entry__43_1, 1));
  assign_value(&func__44_11, create_function(entry__44_11, 0));
  assign_value(&func__44_1, create_function(entry__44_1, 1));
  assign_value(&func__45_38, create_function(entry__45_38, 0));
  assign_value(&func__45_1, create_function(entry__45_1, 3));
  assign_value(&func__46_1, create_function(entry__46_1, 3));
  assign_value(&func__47_84, create_function(entry__47_84, 0));
  assign_value(&func__47_87, create_function(entry__47_87, 0));
  assign_value(&func__47_90, create_function(entry__47_90, 0));
  assign_value(&func__47_103, create_function(entry__47_103, 0));
  assign_value(&func__47_134, create_function(entry__47_134, 1));
  assign_value(&func__47_1, create_function(entry__47_1, 1));
  assign_value(&func__48_1, create_function(entry__48_1, 2));
  assign_value(&func__49_4, create_function(entry__49_4, 0));
  assign_value(&func__49_5, create_function(entry__49_5, 0));
  assign_value(&func__49_1, create_function(entry__49_1, 1));
  assign_value(&func__50_4, create_function(entry__50_4, 0));
  assign_value(&func__50_6, create_function(entry__50_6, 0));
  assign_value(&func__50_8, create_function(entry__50_8, 0));
  assign_value(&func__50_10, create_function(entry__50_10, 0));
  assign_value(&func__50_1, create_function(entry__50_1, 1));
  assign_value(&func__51_1, create_function(entry__51_1, 1));
  assign_value(&func__52_1, create_function(entry__52_1, 1));
  assign_value(&func__53_17, create_function(entry__53_17, 0));
  assign_value(&func__53_18, create_function(entry__53_18, 0));
  assign_value(&func__53_19, create_function(entry__53_19, 0));
  assign_value(&func__53_1, create_function(entry__53_1, 1));
  assign_value(&func__54_15, create_function(entry__54_15, 0));
  assign_value(&func__54_1, create_function(entry__54_1, 1));
  assign_value(&func__55_42, create_function(entry__55_42, 0));
  assign_value(&func__55_1, create_function(entry__55_1, 1));
  assign_value(&func__56_1, create_function(entry__56_1, 1));
  assign_value(&func__57_19, create_function(entry__57_19, 0));
  assign_value(&func__57_20, create_function(entry__57_20, 0));
  assign_value(&func__57_1, create_function(entry__57_1, 2));
  assign_value(&func__58_1, create_function(entry__58_1, 1));
  assign_value(&func__59_1, create_function(entry__59_1, 1));
  assign_value(&func__60_1, create_function(entry__60_1, 1));
  assign_value(&func__62_2, create_function(entry__62_2, 2));
  assign_value(&func__62_1, create_function(entry__62_1, 0));
  assign_value(&func__63_10, create_function(entry__63_10, 0));
  assign_value(&func__63_13, create_function(entry__63_13, 0));
  assign_value(&func__63_1, create_function(entry__63_1, 1));
  assign_value(&func__64_1, create_function(entry__64_1, 1));
  assign_value(&func__65_69, create_function(entry__65_69, 0));
  assign_value(&func__65_70, create_function(entry__65_70, 0));
  assign_value(&func__65_1, create_function(entry__65_1, 1));
  assign_value(&func__66_23, create_function(entry__66_23, 0));
  assign_value(&func__66_24, create_function(entry__66_24, 0));
  assign_value(&func__66_1, create_function(entry__66_1, 2));
  assign_value(&func__67_1, create_function(entry__67_1, 1));
  assign_value(&func__68_1, create_function(entry__68_1, 1));
  assign_value(&func__69_1, create_function(entry__69_1, 1));
  assign_value(&func__70_3, create_function(entry__70_3, 0));
  assign_value(&func__70_5, create_function(entry__70_5, 0));
  assign_value(&func__70_1, create_function(entry__70_1, 1));
  assign_value(&func__71_1, create_function(entry__71_1, 1));
  assign_value(&func__72_4, create_function(entry__72_4, 0));
  assign_value(&func__72_8, create_function(entry__72_8, 0));
  assign_value(&func__72_104, create_function(entry__72_104, 0));
  assign_value(&func__72_1, create_function(entry__72_1, 1));
  register_collector(collect__pretty_printer);
}
