#
  Copyright (C) 2020 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU Library General Public License, version 2, or
  (at your option) under the terms of the GNU Lesser General Public License,
  version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser (Library) General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files LGPLv2.txt and LGLPv3.txt or
  http://www.gnu.org/licenses/lgpl-2.0.html
  http://www.gnu.org/licenses/lgpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

$std::plus () # add two numbers
$std::minus () # subtract two numbers
$std::times () # multiply two numbers
$std::over () # divide two numbers
$std::div () # divide two integers giving an integer
$std::mod () # divide two integers and return the modulo
$std::negate () # negate a number
$std::equal () # check two objects for equality
$std::equal_type_and_value () # equal_type_and_value(a b) => hash(a) == hash(b)
$std::less ()
  # check whether the first argument is less than the second argument
$std::numerically_less ()
  # check whether the first argument is numerically less than the second argument
$std::not () # negate the boolean expression

$std::and ()
  #
    "short cut" and-operation

    The left argument must be <std::true> or <std::false>.

    The right argument must be a function that evaluates to
    <std::true> or <std::false>.

    See also: std::or

$std::or ()
  #
    "short cut" or- operation;

    The left argument must be <std::true> or <std::false>.

    The right argument must be a function that evaluates to
    <std::true> or <std::false>.

    See also: std::and

$std::if ()
  #
    classic if; can be used as a function or a procedure

    The first argument must be <std::true> or <std::false>.

    The second argument represents the "then-part" and must be a function; it
    is called, if the first argument is <std::true>.

    The third argument is optional represents the "else-part". if present it
    must be a function and is called, if the first argument is <std::false>.

    The "then-part"- and "else-part" function can return any number of results
    (including none). But both (if then "else-part" is present) should return
    the *same* number of results.

    Topics: Control Flow, Branches

    See also: std::unless

$std::unless ()
  #
    executes a function unless the *condition* is true

    The first argument must be <std::true> or <std::false>.

    The second argument must be a function that does not return any results.

    In the case the first argument is <std::true> nothing is done.

    In the case the first argument is <std::false> the function specified as
    the second argument is called.

    Topics: Control Flow, Branches

    See also: std::if

$std::shift_left ()
  #
    bitwise shift-left operation

    The first operand (must be positive integer) is shifted left by the number
    of bits specified by the second operandt, that must be a positive integer,
    too.

    There is no restriction in the size of the integer numbers!

    See also: std::shift_right, std::bit_and, std::bit_or, std::bit_xor

$std::shift_right ()
  #
    bitwise shift-right operation

    The first operand (must be positive integer) is shifted right by the number
    of bits specified by the second operandt, that must be a positive integer,
    too.

    Bits that are shifted out on the right side are "lost".

    There is no restriction in the size of the integer numbers!

    See also: std::shift_right, std::bit_and, std::bit_or, std::bit_xor

$std::bit_and ()
  #
    bitwise and operation

    The two operands (both must be positive integers of any size) are combined
    bit for bit using an and-operation.

    See also: std::bit_or, std::bit_xor, std::shift_left, std::shift_right

$std::bit_or ()
  #
    bitwise and operation

    The two operands (both must be positive integers of any size) are combined
    bit for bit using an inclusive-or-operation.

    See also: std::bit_and, std::bit_xor, std::shift_left, std::shift_right

$std::bit_xor ()
  #
    bitwise and operation

    The two operands (both must be positive integers of any size) are combined
    bit for bit using an exclusive-or-operation.

    See also: std::bit_and, std::bit_or, std::shift_left, std::shift_right

$std::parameter_count_of (!)
  #
    number of wanted arguments

    This attribute returns the number of arguments to use when calling its
    function. Functions that accept a variable number of arguments will return
    <std::undefined>.

    Attention: Functions accepting a variable number of arguments might have
    a minimum and/or maximum number of expected arguments. These numbers **cannot** be
    retrieved during runtime!

$std::is_defined ()
  #
    check if this object is a descendant of <types::object>

$std::is_undefined ()
  #
    check if this object is <types::undefined>

$std::default_value ()
$std::is_valid ()
$std::to_string ()
$std::to_list ()
$std::serialize ()
$std::serialization_tag_of (!)
$std::to_number ()
$std::parse_number ()
$std::to_integer ()
$std::parse_integer ()
$std::to_real ()
$std::parse_real ()
$std::to_lower_case ()
$std::to_upper_case ()
$std::to_title_case ()
$std::is_empty ()
$std::length_of (!)
$std::type_of (!) # the type of an object (e.g. an event's type)
$std::hash ()
$std::push () # add a single item at the end of a container
$std::pop () # remove (and return) the last item of a container
$std::peek () # return the last item of a container
$std::drop () # removes a single item from the end of a container
$std::put () # add a single item at the front of a container
$std::get () # remove (and return) the first item of a container
$std::next ()
$std::append ()
$std::insert_before ()
$std::insert_behind ()
$std::first_index_of (!)
$std::last_index_of (!)
$std::delete_at ()
$std::union ()
$std::intersection ()
$std::match_character () # try to match the start of a stream with a character
$std::match_string () # try to match the start of a stream with a string
$std::search_character () # search for a specific character within a stream
$std::search_string () # search for a specific string within a stream
$std::match ()
$std::search ()
$std::matches ()
$std::contains ()
$std::has_prefix ()
$std::has_suffix ()
$std::without_prefix ()
$std::without_suffix ()
$std::before ()
$std::truncate_from ()
$std::behind ()
$std::truncate_until ()
$std::from ()
$std::truncate_before ()
$std::until ()
$std::truncate_behind ()
$std::between ()
$std::range ()
$std::merge ()
$std::sort ()
$std::close ()
$std::write_some_bytes_to ()
$std::write_to ()
$std::flush ()
$std::read_some_bytes_from ()
$std::read_from ()
$std::key_of (!)
$std::value_of (!)
$std::keys_of (!)
$std::values_of (!)
$std::lower_bound_of (!)
$std::upper_bound_of (!)
$std::for_each_from_to ()
$std::for_each_from_down_to ()
$std::for_each ()
$std::for_each_downwards ()
$std::update_each_from_to ()
$std::update_each_from_down_to ()
$std::update_each ()
$std::update_each_downwards ()
$std::for_each_pair ()
$std::new_empty_collection ()
$std::filter ()
$std::apply ()
$std::map ()
$std::dup ()
$std::interleave ()
$std::stop ()
$std::get_file_descriptors ()
$std::handle_requests ()
$std::select () # select items from a collection
$std::delete () # delete items from a collection
$std::update () # update items in a collection
$std::call_command () # call a (possibly remote) command
