#
  Copyright (C) 2020 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU Library General Public License, version 2, or
  (at your option) under the terms of the GNU Lesser General Public License,
  version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser (Library) General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files LGPLv2.txt and LGLPv3.txt or
  http://www.gnu.org/licenses/lgpl-2.0.html
  http://www.gnu.org/licenses/lgpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

<include netdb.h>
<include stddef.h>
<include string.h>
<include dirent.h>
<include errno.h>
<include fcntl.h>
<include math.h>
<include signal.h>
<include unistd.h>
<include arpa/inet.h>
<include netinet/in.h>
<include sys/ioctl.h>
<include sys/stat.h>
<include sys/socket.h>
<include sys/types.h>
<include sys/wait.h>

$std::MODE . # mkdir
$std::PARENTS . # mkdir, save

extern $wget "wget"

$std::ioctl ()
  #
    sets file descriptor options

$std::get_terminal_size ()
  #
    retrieves the current width and height of the connected terminal

$std::device_of (!)
  #
    returns the device on which a file is stored

    Used in <types::stat> to store the device number of the device on which the
    file is stored.

    parameter stat: the status-object to be queried

    see also: std::stat
$std::inode_of (!)
  #
    returns the inode no. of a file

    Used in <types::stat> to store the inode number of the file.

    parameter stat: the status-object to be queried

    see also: std::stat
$std::mode_of (!)
  #
    returns the mode of a file

    Used in <types::stat> to store the kind of the file
    (regular file, directory, ...).

    parameter stat: the status-object to be queried

    see also: std::stat,
    std::UNKNOWN, std::FIFO, std::CHARACTER_DEVICE, std::DIRECTORY,
    std::BLOCK_DEVICE, std::REGULAR_FILE, std::LINK, std::SOCKET
$std::link_count_of (!)
  #
    returns the link count of a file

    Used in <types::stat> to store the number of filenames that refer to the
    file.

    parameter stat: the status-object to be queried

    see also: std::stat
$std::user_id_of (!)
  #
    returns the user id of a file

    Used in <types::stat> to store the id of the owner of the specified file.

    parameter stat: the status-object to be queried

    see also: std::stat
$std::group_id_of (!)
  #
    returns the group id of a file

    Used in <types::stat> to store the id of the group that is associated with the specified file.

    parameter stat: the status-object to be queried

    see also: std::stat
$std::size_of (!)
  #
    returns the size (of a file)

    Used in <types::stat> to store the size of the specified file in bytes.

    parameter stat: the status-object to be queried

    see also: std::stat, sector_count_of
$std::block_size_of (!)
  #
    returns the block size (of a file)

    Used in <types::stat> to store the block size of the file.

    Each file consists of one or more blocks. This function returns
    the size of one such block.

    **The size of a block can differ from the size of a sector!**

    parameter stat: the status-object to be queried

    see also: std::stat
$std::sector_count_of (!)
  #
    returns the sector count of a file

    Used in <types::stat> to store the number of sectors occupied by the file.

    **The size of a sector can differ from the size of a block!**

    parameter stat: the status-object to be queried

    see also: std::stat, std::size_of
$std::access_time_of (!)
  #
    returns the access time of a file

    Used in <types::stat> to store the access time of the file.

    A timestamp <types::date_and_time> that tells the date and time of the
    least recent access (reading or writing) to the specified file.

    **Not all file systems update this value!**

    parameter stat: the status-object to be queried

    see also: std::stat,
    std::modification_time_of, std::status_change_time_of
$std::modification_time_of (!)
  #
    returns the modification time of a file

    Used in <types::stat> to store the modification time of the file.

    A timestamp <types::date_and_time> that tells the date and time of the
    least recent write access to the specified file.

    parameter stat: the status-object to be queried

    see also: std::stat, std::access_time_of, std::status_change_time_of
$std::status_change_time_of (!)
  #
    returns the change time of a file

    Used in <types::stat> to store the change time of the file.


    A timestamp <types::date_and_time> that tells the date and time of the
    least recent change to the file's metadata (e.g. owner, access rights, etc.).

    parameter stat: the status-object to be queried

    see also: std::stat, std::access_time_of, std::modification_time_of
$std::creation_time_of (!)
  #
    returns the creation time of a file

    Used in <types::stat> to store the creation time of the file.

    A timestamp <types::date_and_time> that tells when the file was originally
    created.

    **Usually not supported by POSIX-filesystems!**

    parameter stat: the status-object to be queried

    see also: std::stat, std::modification_time_of
$std::filename_of (!)
  #
    returns the name of a file

$std::file_type_of (!)
  #
    returns the *file type*

    File types are: <REGULAR_FILE>, <DIRECTORY>, <LINK>, <FIFO>, <SOCKET>,
    <CHARACTER_DEVICE>, <BLOCK_DEVICE>, and <UNKNOWN>.

$std::pathname_of (!)
  #
    the fullname before the last *directory separator*

$std::fullname_of (!)
  #
    the full pathname

$std::is_a_directory ()
  #
    returns <true> for directories

$std::is_a_regular_file ()
  #
    returns <true> for regular files

$std::is_a_link ()
  #
    returns <true> for symbolic links

$std::listen ()
  #
    listen for new incoming network connections

$std::accept ()
  #
    accept an incoming network connection

$std::connect ()
  #
    connect to a specific network address and port

#
  family (identical to protocol)

  AF_INET 2
  AF_INET6 10

#
  type

  SOCK_STREAM 1
  SOCK_DGRAM 2

#
  protocol

  IPPROTO_ICMP  1 # Internet Control Message Protocol
  IPPROTO_IGMP  2 # Internet Group Management Protocol
  IPPROTO_IPIP  4 # IPIP tunnels
  IPPROTO_TCP   6 # Transmission Control Protocol
  IPPROTO_EGP   8 # Exterior Gateway Protocol
  IPPROTO_PUP  12 # PUP protocol
  IPPROTO_UDP  17 # User Datagram Protocol
  IPPROTO_IPV6 41 # IPv6 header

{
  extern NODE *create__types__positive_integer(uint64_t value);
}

{
  <kind object>
  <name std::O_RDONLY>
  <type types::positive_integer>
  <argument O_RDONLY>

  // used for opening files
}

{
  <kind object>
  <name std::O_WRONLY>
  <type types::positive_integer>
  <argument O_WRONLY>

  // used for opening files
}

{
  <kind object>
  <name std::O_RDWR>
  <type types::positive_integer>
  <argument O_RDWR>

  // used for opening files
}

{
  <kind object>
  <name std::O_CREAT>
  <type types::positive_integer>
  <argument O_CREAT>

  // used for opening files
}

{
  <kind object>
  <name std::O_EXCL>
  <type types::positive_integer>
  <argument O_EXCL>

  // used for opening files
}

{
  <kind object>
  <name std::O_NOCTTY>
  <type types::positive_integer>
  <argument O_NOCTTY>

  // used for opening files
}

{
  <kind object>
  <name std::O_TRUNC>
  <type types::positive_integer>
  <argument O_TRUNC>

  // used for opening files
}

{
  <kind object>
  <name std::O_APPEND>
  <type types::positive_integer>
  <argument O_APPEND>

  // used for opening files
}

{
  <kind object>
  <name std::O_NONBLOCK>
  <type types::positive_integer>
  <argument O_NONBLOCK>

  // used for opening files
}

# not supported by Cygwin
#{
  <kind object>
  <name std::O_ASYNC>
  <type types::positive_integer>
  <argument O_ASYNC>
#}

{
  <kind object>
  <name std::UNKNOWN>
  <type types::positive_integer>
  <argument DT_UNKNOWN>

  // a directory entry of unknown type
  //
  // See also: file_type_of
}

# pipe

{
  <kind object>
  <name std::FIFO>
  <type types::positive_integer>
  <argument DT_FIFO>

  // a directory entry that is a pipe
  //
  // See also: file_type_of
}

{
  <kind object>
  <name std::CHARACTER_DEVICE>
  <type types::positive_integer>
  <argument DT_CHR>

  // a directory entry that is a character device
  //
  // See also: file_type_of
}

{
  <kind object>
  <name std::DIRECTORY>
  <type types::positive_integer>
  <argument DT_DIR>

  // a directory entry that is itself a directory
  //
  // See also: file_type_of
}

{
  <kind object>
  <name std::BLOCK_DEVICE>
  <type types::positive_integer>
  <argument DT_BLK>

  // a directory entry that is a block device
  //
  // See also: file_type_of
}

{
  <kind object>
  <name std::REGULAR_FILE>
  <type types::positive_integer>
  <argument DT_REG>

  // a directory entry that is a regular file
  //
  // See also: file_type_of
}

{
  <kind object>
  <name std::LINK>
  <type types::positive_integer>
  <argument DT_LNK>

  // a directory entry that is a symbolic link
  //
  // See also: file_type_of
}

{
  <kind object>
  <name std::SOCKET>
  <type types::positive_integer>
  <argument DT_SOCK>

  // a directory entry that is a socket
  //
  // See also: file_type_of
}

{
  <kind object>
  <name std::EPERM>
  <type types::positive_integer>
  <argument EPERM>

  // Operation not permitted
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENOENT>
  <type types::positive_integer>
  <argument ENOENT>

  // No such file or directory
  //
  // See also: errno
}

{
  <kind object>
  <name std::ESRCH>
  <type types::positive_integer>
  <argument ESRCH>

  // No such process
  //
  // See also: errno
}

{
  <kind object>
  <name std::EINTR>
  <type types::positive_integer>
  <argument EINTR>

  // Interrupted system call
  //
  // See also: errno
}

{
  <kind object>
  <name std::EIO>
  <type types::positive_integer>
  <argument EIO>

  // I/O error
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENXIO>
  <type types::positive_integer>
  <argument ENXIO>

  // No such device or address
  //
  // See also: errno
}

{
  <kind object>
  <name std::E2BIG>
  <type types::positive_integer>
  <argument E2BIG>

  // Argument list too long
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENOEXEC>
  <type types::positive_integer>
  <argument ENOEXEC>

  // Exec format error
  //
  // See also: errno
}

{
  <kind object>
  <name std::EBADF>
  <type types::positive_integer>
  <argument EBADF>

  // Bad file number
  //
  // See also: errno
}

{
  <kind object>
  <name std::ECHILD>
  <type types::positive_integer>
  <argument ECHILD>

  // No child processes
  //
  // See also: errno
}

{
  <kind object>
  <name std::EAGAIN>
  <type types::positive_integer>
  <argument EAGAIN>

  // Try again
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENOMEM>
  <type types::positive_integer>
  <argument ENOMEM>

  // Out of memory
  //
  // See also: errno
}

{
  <kind object>
  <name std::EACCES>
  <type types::positive_integer>
  <argument EACCES>

  // Permission denied
  //
  // See also: errno
}

{
  <kind object>
  <name std::EFAULT>
  <type types::positive_integer>
  <argument EFAULT>

  // Bad address
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENOTBLK>
  <type types::positive_integer>
  <argument ENOTBLK>

  // Block device required
  //
  // See also: errno
}

{
  <kind object>
  <name std::EBUSY>
  <type types::positive_integer>
  <argument EBUSY>

  // Device or resource busy
  //
  // See also: errno
}

{
  <kind object>
  <name std::EEXIST>
  <type types::positive_integer>
  <argument EEXIST>

  // File exists
  //
  // See also: errno
}

{
  <kind object>
  <name std::EXDEV>
  <type types::positive_integer>
  <argument EXDEV>

  // Cross-device link
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENODEV>
  <type types::positive_integer>
  <argument ENODEV>

  // No such device
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENOTDIR>
  <type types::positive_integer>
  <argument ENOTDIR>

  // Not a directory
  //
  // See also: errno
}

{
  <kind object>
  <name std::EISDIR>
  <type types::positive_integer>
  <argument EISDIR>

  // Is a directory
  //
  // See also: errno
}

{
  <kind object>
  <name std::EINVAL>
  <type types::positive_integer>
  <argument EINVAL>

  // Invalid argument
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENFILE>
  <type types::positive_integer>
  <argument ENFILE>

  // File table overflow
  //
  // See also: errno
}

{
  <kind object>
  <name std::EMFILE>
  <type types::positive_integer>
  <argument EMFILE>

  // Too many open files
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENOTTY>
  <type types::positive_integer>
  <argument ENOTTY>

  // Not a typewriter
  //
  // See also: errno
}

{
  <kind object>
  <name std::ETXTBSY>
  <type types::positive_integer>
  <argument ETXTBSY>

  // Text file busy
  //
  // See also: errno
}

{
  <kind object>
  <name std::EFBIG>
  <type types::positive_integer>
  <argument EFBIG>

  // File too large
  //
  // See also: errno
}

{
  <kind object>
  <name std::ENOSPC>
  <type types::positive_integer>
  <argument ENOSPC>

  // No space left on device
  //
  // See also: errno
}

{
  <kind object>
  <name std::ESPIPE>
  <type types::positive_integer>
  <argument ESPIPE>

  // Illegal seek
  //
  // See also: errno
}

{
  <kind object>
  <name std::EROFS>
  <type types::positive_integer>
  <argument EROFS>

  // Read-only file system
  //
  // See also: errno
}

{
  <kind object>
  <name std::EMLINK>
  <type types::positive_integer>
  <argument EMLINK>

  // Too many links
  //
  // See also: errno
}

{
  <kind object>
  <name std::EPIPE>
  <type types::positive_integer>
  <argument EPIPE>

  // Broken pipe
  //
  // See also: errno
}

{
  <kind object>
  <name std::EDOM>
  <type types::positive_integer>
  <argument EDOM>

  // Math argument out of domain of func
  //
  // See also: errno
}

{
  <kind object>
  <name std::ERANGE>
  <type types::positive_integer>
  <argument ERANGE>

  // Math result not representable
  //
  // See also: errno
}

$std::raise_error:
  #
    raises an error after a failed posix command

    Topic: Error handling

    See also: check_error, raise, errno, strerror
  (
    cmd # a text string to describe the failed command
    args*
  )
  $$info ""
  for_each args: (arg) write_to &info "@(key_of(arg)) = @(value_of(arg))@nl;"
  raise "@(cmd) failed: @(std::strerror(std::errno()))!@nl;@(info)"

$std::check_error:
  #
    raises an error if the last posix command failed

    Topic: Error handling

    See also: raise_error, raise, errno, strerror
  (
    err
    args*
  )
  if err < 0 raise_error args*

$std::errno
  #
    Returns the POSIX error code for the last executed POSIX function.

    If no error occured (the function call was successful) then the integer
    value 0 is returned.

    Topic: Error handling

    see also: std::strerror, check_error, raise_error
  {
    CHECK_ARGUMENTS(0)
    RETURN_SINGLE_RESULT(from_int(errno));
  }

$std::strerror
  #
    Converts a POSIX error code into a human readable error message text.

    parameter err: the error code

    Topic: Error handling

    see also: std::errno
  {
    CHECK_ARGUMENTS(1)
    RETURN_SINGLE_RESULT(from_c_string(strerror(to_int(ARGUMENTS(0)))))
  }

{
  <kind struct>
  <name STAT_BUFFER>

  void *new_location;
  struct stat stat;
}

{
  <kind function>

  STAT_BUFFER *collect_stat_buffer(STAT_BUFFER *buf) {
    if (!IS_COLLECTED(buf)) return buf;
    void *new_location = buf->new_location;
    if (new_location) return new_location;
    STAT_BUFFER *new_buf = copy(buf, sizeof(STAT_BUFFER));
    new_buf->new_location = NULL;
    buf->new_location = new_buf;
    return new_buf;
  }
}

{
  #if defined(__APPLE__) && defined(__MACH__)
    #define st_atim st_atimespec
    #define st_ctim st_ctimespec
    #define st_mtim st_mtimespec
  #endif
}

{
  <kind node>
  <name STAT>

  STAT_BUFFER *buf;
}

{
  <kind type>
  <name types::stat>
  <node STAT>
  <base types::object>
  <argument NULL>

  // an object containing a file's meta-information

  RUNTIME_ERROR("Attempt to call a file status object as a function!")
}

{
  <kind function>

  long types::stat/debug_string(NODE *node, int indent, int max_depth, char *buf) {
    return debug_print(indent, buf, "<stat buffer - inode %ld>",
      from_long(node->stat.buf->stat.st_ino));
  }
}

{
  extern NODE *create__types__date_and_time(int64_t seconds, int32_t nanoseconds);
}

$std::stat
  #
    Retrieves status information about the specified file.

    If a file with the specified name exists a status-object <types::stat> is
    returned which can be queried using functions like <std::size_of>.

    If no such file exists then the value <std::undefined> is returned.

    see also:
    std::device_of, std::inode_of, std::mode_of, std::link_count_of,
    std::user_id_of, std::group_id_of,
    std::size_of, std::block_size_of, std::sector_count_of,
    std::access_time_of, std::modification_time_of,
    std::status_change_time_of,
    std::is_a_directory, std::is_a_regular_file, std::is_a_link

  {
    CHECK_ARGUMENTS(1)
    char *filename = to_c_string(ARGUMENTS(0));
    STAT_BUFFER *buf = allocate(sizeof(STAT_BUFFER));
    int err = stat(filename, &buf->stat);
    deallocate_memory(filename);
    if (err != 0) RETURN_UNDEFINED
    buf->new_location = NULL;
    RETURN_SINGLE_RESULT(create__types__stat(buf))
  }

$std::file_exists
  #
    checks whether the specified file exists

    The type of the file is *not*
    checked - it could as well be a directory or a special file.

    parameter filename: the name of the file to check

    See also: stat

  {
    CHECK_ARGUMENTS(1)
    char *filename = to_c_string(ARGUMENTS(0));
    struct stat buf;
    int err = stat(filename, &buf);
    deallocate_memory(filename);
    RETURN_BOOLEAN(err == 0)
  }

$types::stat/device_of
  #
    the device on which the file is stored

    See also: stat
  {
    CHECK_ARGUMENTS(1)
    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->stat.buf->stat.st_dev))
  }

$types::stat/inode_of
  #
    the inode number of the file

    See also: stat
  {
    CHECK_ARGUMENTS(1)
    RETURN_SINGLE_RESULT(from_long(ARGUMENTS(0)->stat.buf->stat.st_ino))
  }

$types::stat/mode_of
  #
    the access rights of the file

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->stat.buf->stat.st_mode))
  }

$types::stat/link_count_of
  #
    the number of hard links of the file

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_long(ARGUMENTS(0)->stat.buf->stat.st_nlink))
  }

$types::stat/user_id_of
  #
    the user id of the file

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->stat.buf->stat.st_uid))
  }

$types::stat/group_id_of
  #
    the group id of the file

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->stat.buf->stat.st_gid))
  }

$types::stat/size_of
  #
    the size of the file (in bytes)

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_long(ARGUMENTS(0)->stat.buf->stat.st_size))
  }

$types::stat/block_size_of
  #
    the size of a sector on the device of the file

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->stat.buf->stat.st_blksize))
  }

$types::stat/sector_count_of
  #
    the number of sectors used for the file's data

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_long(ARGUMENTS(0)->stat.buf->stat.st_blocks))
  }

$types::stat/access_time_of
  #
    the time the file was last accessed (read or write)

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(
      create__types__date_and_time(
        ARGUMENTS(0)->stat.buf->stat.st_atim.tv_sec,
        ARGUMENTS(0)->stat.buf->stat.st_atim.tv_nsec))
  }

$types::stat/modification_time_of
  #
    the time the file's contents were last modified

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(
      create__types__date_and_time(
        ARGUMENTS(0)->stat.buf->stat.st_mtim.tv_sec,
        ARGUMENTS(0)->stat.buf->stat.st_mtim.tv_nsec))
  }

$types::stat/status_change_time_of
  #
    the time the file's meta-data last change

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(
      create__types__date_and_time(
        ARGUMENTS(0)->stat.buf->stat.st_ctim.tv_sec,
        ARGUMENTS(0)->stat.buf->stat.st_ctim.tv_nsec))
  }

$types::stat/is_a_directory
  #
    returns <true> if the file is a directory

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_bool(S_ISDIR(ARGUMENTS(0)->stat.buf->stat.st_mode)))
  }

$types::stat/is_a_regular_file
  #
    returns <true> if the file is a *regular file*

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_bool(S_ISREG(ARGUMENTS(0)->stat.buf->stat.st_mode)))
  }

$types::stat/is_a_link
  #
    returns <true> if the file is a symbolic link

    See also: stat
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_bool(S_ISLNK(ARGUMENTS(0)->stat.buf->stat.st_mode)))
  }

{
  <kind node>
  <name FILE_DESCRIPTOR>

  int fd;
}

{
  <kind type>
  <name types::file_descriptor>
  <node FILE_DESCRIPTOR>
  <base types::object>
  <scope extern>
  <argument -1>

  // a file descriptor object

  RUNTIME_ERROR("Attempt to call a file_descriptor as a function!")
}

{
  <kind function>

  long types::file_descriptor/debug_string(NODE *node, int indent, int max_depth, char *buf) {
    return debug_print(indent, buf, "<file_descriptor %d>", node->file_descriptor.fd);
  }
}

{
  <kind object>
  <name std::STDIN_FILENO>
  <type types::file_descriptor>
  <argument STDIN_FILENO>

  // the file descriptor object for *stdin*
}

{
  <kind object>
  <name std::STDOUT_FILENO>
  <type types::file_descriptor>
  <argument STDOUT_FILENO>

  // the file descriptor object for *stdout*
}

{
  <kind object>
  <name std::STDERR_FILENO>
  <type types::file_descriptor>
  <argument STDERR_FILENO>

  // the file descriptor object for *stderr*
}

$std::create_file_descriptor
  #
    create a file descriptor object from an integer number

    See also: types::file_descriptor/to_integer
  {
    CHECK_ARGUMENTS(1)
    RETURN_SINGLE_RESULT(create__types__file_descriptor(to_int(ARGUMENTS(0))))
  }

$types::file_descriptor/to_integer
  #
    returns the corresponding integer value of a file descriptor object

    See also: create_file_descriptor
  {
    CHECK_ARGUMENTS(1)
    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->file_descriptor.fd))
  }

$types::file_descriptor/equal
  #
    compares two file descriptor objects
  {
    CHECK_ARGUMENTS(2)
    NODE *right = ARGUMENTS(1);
    if (TYPEOF(right) != TYPE(types::file_descriptor)) RETURN_FALSE
    RETURN_SINGLE_RESULT(
      from_bool(ARGUMENTS(0)->file_descriptor.fd == right->file_descriptor.fd))
  }

$types::file_descriptor/less
  #
    compares two file descriptor objects
  {
    CHECK_ARGUMENTS(2)
    NODE *right = ARGUMENTS(1);
    if (TYPEOF(right) != TYPE(types::file_descriptor)) RETURN_TRUE
    RETURN_SINGLE_RESULT(
      from_bool(ARGUMENTS(0)->file_descriptor.fd < right->file_descriptor.fd))
  }

$types::file_descriptor/hash
  #
    computes the hash value for a file descriptor object
  {
    CHECK_ARGUMENTS(1)
    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->file_descriptor.fd+0xfdec))
  }

$posix_open
  {
    MIN_ARGUMENTS(2)
    MAX_ARGUMENTS(3)
    int fd;
    int flags = to_int(ARGUMENTS(1));
    flags |= O_CLOEXEC;
    mode_t mode = 0644;
    if (ARGUMENT_COUNT == 3) mode = to_uint32(ARGUMENTS(2));
    EVENT(posix_open)
      char *filename = to_c_string(ARGUMENTS(0));
      do {
        fd = open(filename, flags, mode);
      } while (fd == -1 && errno == EINTR);
      deallocate_memory(filename);
    INFO
      INT(fd)
      INT(flags)
      INT(mode)
    DATA
      INT(fd)
    END
    if (fd == -1) RETURN_UNDEFINED
    RETURN_SINGLE_RESULT(create__types__file_descriptor(fd))
  }

$std::open_file:
  #
    opens a file

    See also: close, O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_APPEND, O_TRUNC,
	      O_EXCL, O_NOCTTY, O_NONBLOCK
  (
    filename # the name of the file
    mode # the mode to use for opening the file
  )
  posix_open $$fd filename mode
  if fd.is_defined: !fd.filename_of fullname(filename)
  -> fd

$std::open_file_for_reading:
  #
    opens a file in read-only mode

    On success a valid file descriptor is returned.

    On failure <std::undefined> is returned.

    This function relies on posix-functions if available. So there will
    be no buffering.

    see also: std::open_file_for_writing,
              std::open_file_for_reading_and_writing, std::close, std::read

    Example:

    open_file_for_reading $fd "my_file.txt"
    read_from fd $text 1024
    close fd
  (
    filename # the name of the file to open
  )
  open_file filename std::O_RDONLY

$std::open_file_for_writing:
  #
    opens a file in write-only mode

    On success a valid file descriptor is returned.

    On failure <std::undefined> is returned.

    This function relies on posix-functions if available. So there will
    be no buffering.

    see also: std::open_file_for_reading,
              std::open_file_for_reading_and_writingstd::close, std::read

    Example:

    open_file_for_writing $fd "my_file.txt"
    write_to fd "Hello, world!"
    close fd
  (
    filename # the name of the file to open
  )
  open_file filename std::O_WRONLY

$std::open_file_for_reading_and_writing:
  #
    opens a file in read-write mode

    On success a valid file descriptor is returned.

    On failure <std::undefined> is returned.

    This function relies on posix-functions if available. So there will
    be no buffering.

    see also: std::open_file_for_reading, std::open_file_for_writing,
              std::create_file, std::close, std::read, std::write

    Example:

    open_file_for_reading_and_writing $fd "my_file.dat"
    read fd $first_page 4096
    seek fd 0
    write fd new_page
    close fd
  (
    filename # the name of the file to open
  )
  open_file filename std::O_RDWR

$std::create_file:
  #
    creates a file

    On success a valid file descriptor is returned.

    On failure <std::undefined> is returned.

    This function relies on posix-functions if available. So there will
    be no buffering.

    see also: std::open, std::open_file_for_reading,
	      std::open_file_for_writing,
	      std::open_file_for_reading_and_writing,
              std::close, std::read, std::write
  (
    filename # the name of the file to create
  )
  open_file filename std::O_CREAT | std::O_TRUNC | std::O_RDWR

$types::file_descriptor/close
  #
    close the file
  {
    CHECK_ARGUMENTS(1)
    int err;
    int fd = ARGUMENTS(0)->file_descriptor.fd;
    ACTION(posix_close)
      struct stat statbuf;
      fstat(fd, &statbuf);
      if (S_ISSOCK(statbuf.st_mode)) {
	shutdown(fd, SHUT_RDWR); // fail silent
      }
      do {
        err = close(fd);
      } while (err == -1 && errno == EINTR);
    INFO
      INT(fd)
    DATA
      INT(err, 0)
    END
    if (result_count == 0) {
      if (err != 0) RUNTIME_ERROR("Failed to close file!")
      RETURN_NOTHING
    }
    RETURN_BOOLEAN(err == 0)
  }

$types::file_descriptor/read_some_bytes_from
  #
    try to read the specified number of bytes

    This is a low-level function!

    See also: types::file_descriptor/read_from,
	      types::file_descriptor/write_some_bytes_to
  {
    CHECK_ARGUMENTS(2)
    int fd = ARGUMENTS(0)->file_descriptor.fd;
    long size = to_long(ARGUMENTS(1));
    uint8_t *buf = allocate_memory(size);
    long bytes_read;
    EVENT(read_some_bytes_from)
      do {
        bytes_read = read(fd, buf, size);
      } while (bytes_read == -1 && errno == EINTR);
    DATA
      MEMORY(buf, bytes_read)
    END
    NODE *result = UNDEFINED;
    if (bytes_read >= 0) result = from_latin_1_string((const char *)buf, bytes_read);
    deallocate_memory(buf);
    RETURN_SINGLE_RESULT(result)
  }

$types::file_descriptor/read_from:
  #
    Reads the specified number of bytes from the specified file.

    This call will not return until the specified number of bytes has been read
    or the end of the file is reached.

    If no length ist specified then as many bytes as readily available will
    be read - but at least one byte will be read.

    There might be an upper limit for the number of readily available bytes
    depending on the implementation! This limit must not be less than 1 MiB.

    See also: types::file_descriptor/write_to

    Example:

    read $buf fd 1024 # waits until 1024 bytes are available
    read $line fd # reads as many bytes as are readily available
  (
    fd # the descriptor of the file to read from
    $amount? # the number ob bytes to read
    -> return
  )
  if amount.is_defined:
    $$buf ""
    while -> amount > 0:
      wait_to_read_from fd
      read_some_bytes_from $some_bytes fd amount
      $len length_of(some_bytes)
      if len == 0: return buf
      append &buf some_bytes
      minus &amount len
    return buf
  wait_to_read_from fd
  read_some_bytes_from fd 0x1000000 # 16 MiB limit

$types::file_descriptor/write_some_bytes_to
  #
    try to write the specified number of bytes

    This is a low-level function!

    See also: types::file_descriptor/write_to,
	      types::file_descriptor/read_some_bytes_from
  {
    CHECK_ARGUMENTS(2)
    int fd = ARGUMENTS(0)->file_descriptor.fd;
    long size;
    uint8_t *buf = to_octets(ARGUMENTS(1), &size);
    long bytes_written;
    ACTION(write_some_bytes_to)
      do {
        bytes_written = write(fd, buf, size);
      } while (bytes_written == -1 && errno == EINTR);
    INFO
      INT(fd)
      MEMORY(buf, bytes_written)
    DATA
      LONG(bytes_written, size)
    END
    deallocate_memory(buf);
    RETURN_SINGLE_RESULT(from_long(bytes_written))
  }

$file_description: (fd)
  $filename filename_of(fd)
  if
    filename.is_defined
    -> "@quot;@(filename)@quot;"
    :
      $num fd.to_integer
      case num
	0 -> "<stdin>"
	1 -> "<stdout>"
	2 -> "<stderr>"
        -> "<file descriptor @(num)>"

$WriteError: (fd)
  raise_error "Writing to file @(file_description(fd))"

$types::file_descriptor/write_to:
  #
    writes to the specified file

    All arguments are converted to strings and concatenated. The resulting
    string ist then printed to the specified file.

    See also: types::file_descriptor/read_from, atomic_write_to
  (
    fd # the file descriptor
    args* # a list of arguments
    -> return
  )
  $$data string(args*)
  while -> length_of(data) > 0:
    wait_to_write_to fd
    write_some_bytes_to fd data $bytes_written
    if bytes_written < 0:
      if parameter_count_of(return) == 0: WriteError fd
      return false
    range &data bytes_written+1 -1
  if parameter_count_of(return) == 1: return true

$std::atomic_write_to:
  #
    writes atomically to the specified file

    All arguments are converted to strings and concatenated. The resulting
    string ist then printed to the specified file.

    No other I/O-operations will be handled until all data has been written.

    See also: types::file_descriptor/write_to
  (
    fd # the file descriptor
    args* # a list of arguments
    -> return
  )
  $$data string(args*)
  while -> length_of(data) > 0:
    write_some_bytes_to fd data $bytes_written
    if bytes_written < 0:
      if parameter_count_of(return) == 0: WriteError fd
      return false
    range &data bytes_written+1 -1
  if parameter_count_of(return) == 1: return true

$std::load_file:
  #
    Loads and returns the contents of the specified file.

    On failure <std::undefined> is returned.

    see also: std::save_file,
              std::open_file_for_reading,
              std::read_from,
              std::close

    Example:

    load $settings "my_settings.conf"
  (
    filename # the name of the file to load
  )
  open_file_for_reading $fd filename
  if
    fd.is_defined:
      $$buf ""
      do: (-> break)
	forever:
	  read_from fd $some_bytes
	  if length_of(some_bytes) == 0 break
	  append &buf some_bytes
      close fd
      -> buf
    -> undefined

$std::save_file:
  #
    Saves the specified data to a newly created file.

    Unless a result is requested an exception is raised on failure.

    If a result is requested it will be <std::true> for success and
    <std::false> for failure.

    see also: std::load_file,
              std::open_file_for_reading_and_writing,
              std::write_to,
              std::close

    Example:

    save "my_settings.conf" settings
  (
    filename # the name of file to be created
    data # the data to save
    -> return
  )
  create_file $fd filename
  if
    fd.is_defined:
      if
	parameter_count_of(return) == 0:
	  write_to fd data
	  close fd
	:
	  return write_to(fd data) && close(fd)
    :
      if parameter_count_of(return) == 0:
	raise "
	  Failed to save file "@(filename)@quot;@
      return false

$types::file_descriptor/flush
  #
    flushes all buffers associated with the file
  {
    CHECK_ARGUMENTS(1)
    int fd = ARGUMENTS(0)->file_descriptor.fd;
    if (result_count == 1) {
      int err;
      ACTION(flush)
        err = fsync(fd);
      DATA
        INT(err, 0)
      END
      RETURN_SINGLE_RESULT(from_int(err))
    } else {
      fsync(fd);
      RETURN_NOTHING
    }
  }

$ioctl_value
  {
    CHECK_ARGUMENTS(3)
    int fd = ARGUMENTS(0)->file_descriptor.fd;
    long request = to_long(ARGUMENTS(1));
    long value = to_long(ARGUMENTS(2));
    int err;
    ACTION(ioctl_value)
      err = ioctl(fd, request, value);
    DATA
      INT(err, 0)
    END
    RETURN_SINGLE_RESULT(from_int(err))
  }

$types::file_descriptor/std::ioctl:
  #
    sets file descriptor options
  (
    fd
    request
    value = 0
    -> return
  )
  if
    parameter_count_of(return) == 0:
      if ioctl_value(fd request value) != 0:
	raise "
	  IOCTL failed!
    :
      return ioctl_value(fd request value)

$types::file_descriptor/std::get_terminal_size
  #
    retrieves the current width and height of the terminal

    If the file descriptor is not connected to a terminal then the behaviour
    is undefined.
  {
    CHECK_ARGUMENTS(1)

    int fd = ARGUMENTS(0)->file_descriptor.fd;
    int width, height;
    struct winsize winsize;

    EVENT(get_terminal_size)
      ioctl(fd, TIOCGWINSZ, &winsize);
      width = winsize.ws_col;
      height = winsize.ws_row;
    DATA
      INT(width)
      INT(height)
    END
    NODE *width_node = from_int(width);
    NODE *height_node = from_int(height);
    START_ARGUMENTS(2);
    ARGUMENTS(0) = width_node;
    ARGUMENTS(1) = height_node;
    RETURN
  }

$posix_unlink
  {
    CHECK_ARGUMENTS(1)
    char *filename = to_c_string(ARGUMENTS(0));
    int err;
    ACTION(unlink)
      err = unlink(filename);
    DATA
      INT(err, 0)
    END
    deallocate_memory(filename);
    RETURN_SINGLE_RESULT(from_int(err))
  }

$std::delete_file:
  #
    deletes the specified file
  (
    filename # the name of the file to delete
    -> return
  )
  if
    parameter_count_of(return) == 0:
      if posix_unlink(filename) != 0:
	raise "
	  Failed to delete file "@(filename)@quot;!
    :
      return posix_unlink(filename) == 0

$wait_for_io_ready
  {
    CHECK_ARGUMENTS(4)
    NODE *read_descriptors = ARGUMENTS(0);
    NODE *write_descriptors = ARGUMENTS(1);
    NODE *except_descriptors = ARGUMENTS(2);
    double timeout = 0.0;
    struct timespec timeout_data;
    struct timespec *timeout_ptr = NULL;

    if (TYPEOF(ARGUMENTS(3)) != TYPEOF(undefined)) {
      timeout = to_double(ARGUMENTS(3));
      timeout_data.tv_sec = timeout;
      timeout_data.tv_nsec = 1000000000*(timeout-floor(timeout));
      timeout_ptr = &timeout_data;
    }
    retry:;
    int i, n;
    fd_set read_set, write_set, except_set;
    int last_fd = 0;
    FD_ZERO(&read_set);
    FD_ZERO(&write_set);
    FD_ZERO(&except_set);
    n = length_of(read_descriptors);
    for (i = 0; i < n; ++i) {
      NODE *descriptor = get_item_of(read_descriptors, i);
      if (TYPEOF(descriptor) != TYPE(types::file_descriptor)) INVALID_ARGUMENTS_ERROR
      int fd = descriptor->file_descriptor.fd;
      FD_SET(fd, &read_set);
      if (fd > last_fd) last_fd = fd;
    }
    n = length_of(write_descriptors);
    for (i = 0; i < n; ++i) {
      NODE *descriptor = get_item_of(write_descriptors, i);
      if (TYPEOF(descriptor) != TYPE(types::file_descriptor)) INVALID_ARGUMENTS_ERROR
      int fd = descriptor->file_descriptor.fd;
      FD_SET(fd, &write_set);
      if (fd > last_fd) last_fd = fd;
    }
    n = length_of(except_descriptors);
    for (i = 0; i < n; ++i) {
      NODE *descriptor = get_item_of(except_descriptors, i);
      if (TYPEOF(descriptor) != TYPE(types::file_descriptor)) INVALID_ARGUMENTS_ERROR
      int fd = descriptor->file_descriptor.fd;
      FD_SET(fd, &except_set);
      if (fd > last_fd) last_fd = fd;
    }
    int ret;
    int chld_changed_state = false;
    int win_changed_size = false;
    int read_count = 0;
    int write_count = 0;
    int except_count = 0;
    int descriptor_count = 0;
    int *descriptors = NULL;
    EVENT(wait_for_io)
      sigset_t set;
      sigprocmask(SIG_BLOCK, NULL, &set);
      sigdelset(&set, SIGCHLD);
      sigdelset(&set, SIGWINCH);
      ret = pselect(last_fd+1, &read_set, &write_set, &except_set, timeout_ptr, &set);
      if (ret < 0 && errno == EINTR) {
        if (child_changed_state) {
          child_changed_state = false;
          chld_changed_state = true;
        } else if (window_changed_size) {
          window_changed_size = false;
          win_changed_size = true;
        } else {
          goto retry;
        }
      }
      if (ret > 0) { // success
        int fd;
        for (fd = 0; fd <= last_fd; ++fd) {
          if (FD_ISSET(fd, &read_set)) ++read_count;
          if (FD_ISSET(fd, &write_set)) ++write_count;
          if (FD_ISSET(fd, &except_set)) ++except_count;
        }
        descriptor_count = read_count+write_count+except_count;
        descriptors = allocate_memory(descriptor_count*sizeof(int));
        n = 0;
        if (read_count > 0) {
          for (fd = 0; fd <= last_fd; ++fd) {
            if (FD_ISSET(fd, &read_set)) {
              descriptors[n++] = fd;
            }
          }
        }
        if (write_count > 0) {
          for (fd = 0; fd <= last_fd; ++fd) {
            if (FD_ISSET(fd, &write_set)) {
              // set file descriptor to nonblocking
              int flags = fcntl(fd, F_GETFL, 0);
              if (flags == -1) flags = 0;
              fcntl(fd, F_SETFL, flags|O_NONBLOCK);
              descriptors[n++] = fd;
            }
          }
        }
        if (except_count > 0) {
          for (fd = 0; fd <= last_fd; ++fd) {
            if (FD_ISSET(fd, &except_set)) {
              descriptors[n++] = fd;
            }
          }
        }
      }
    DATA
      INT(ret)
      INT(chld_changed_state)
      INT(win_changed_size)
      INT(read_count)
      INT(write_count)
      INT(except_count)
      INT_ARRAY(descriptors, descriptor_count)
    END
    if (chld_changed_state || win_changed_size) {
      NODE *child_change_state_node = from_bool(chld_changed_state);
      NODE *window_changed_size_node = from_bool(win_changed_size);
      START_ARGUMENTS(6);
      ARGUMENTS(0) = TRUE;
      ARGUMENTS(1) = child_change_state_node;
      ARGUMENTS(2) = window_changed_size_node;
      ARGUMENTS(3) = ZERO;
      ARGUMENTS(4) = ZERO;
      ARGUMENTS(5) = ZERO;
      RETURN
    } else if (ret > 0) { // success
      int i;
      NODE *input_count = from_int(read_count);
      NODE *output_count = from_int(write_count);
      NODE *exception_count = from_int(except_count);
      NODE **descriptor_nodes = allocate(descriptor_count*sizeof(NODE *));
      for (i = 0; i < descriptor_count; ++i) {
        descriptor_nodes[i] = create__types__file_descriptor(descriptors[i]);
      }
      deallocate_memory(descriptors);
      START_ARGUMENTS(6+descriptor_count);
      ARGUMENTS(0) = TRUE;
      ARGUMENTS(1) = FALSE;
      ARGUMENTS(2) = FALSE;
      ARGUMENTS(3) = input_count;
      ARGUMENTS(4) = output_count;
      ARGUMENTS(5) = exception_count;
      for (i = 0; i < descriptor_count; ++i) {
        ARGUMENTS(6+i) = descriptor_nodes[i];
      }
      RETURN
    } else if (ret == 0) { // timeout occured
      START_ARGUMENTS(6);
      ARGUMENTS(0) = FALSE;
      ARGUMENTS(1) = FALSE;
      ARGUMENTS(2) = FALSE;
      ARGUMENTS(3) = ZERO;
      ARGUMENTS(4) = ZERO;
      ARGUMENTS(5) = ZERO;
      RETURN
    } else { // error
      RUNTIME_ERROR("Unexpected I/O-error (%s) during select!", strerror(errno))
    }
  }

$std::get_pid
  #
    return the process id of the current process
  {
    CHECK_ARGUMENTS(0)
    RETURN_SINGLE_RESULT(from_int(getpid()))
  }

$std::wait_pid
  #
    wait for process termination

    ARGUMENTS:
      pid     # the pid of the process (or -1) for all children
      no_hang # if true the call returns immediately

  {
    CHECK_ARGUMENTS(2)
    int pid = to_int(ARGUMENTS(0));
    int no_hang = to_bool(ARGUMENTS(1));
    int status;
    int ret = waitpid(pid, &status, no_hang ? WNOHANG : 0);
    NODE *child_status = from_int(WEXITSTATUS(status));
    NODE *child_pid = from_int(ret);
    START_ARGUMENTS(2);
    ARGUMENTS(0) = child_status;
    ARGUMENTS(1) = child_pid;
    RETURN
  }

$std::wait_for_io:
  #
    wait until any of the supplied descriptors allow I/O
  (
    read_descriptors
    write_descriptors
    except_descriptors
    timeout?
  )
  wait_for_io_ready
    read_descriptors
    write_descriptors
    except_descriptors
    timeout
    $success
    $child_changed_state
    $window_changed_size
    $input_count
    $output_count
    $_exception_count
    $descriptors*
  ->
    child_changed_state
    window_changed_size
    range(descriptors 1 input_count)
    range(descriptors input_count+1 input_count+output_count)
    range(descriptors input_count+output_count+1 -1)
    success

$std::current_path
  #
    returns the current working directory
  {
    CHECK_ARGUMENTS(0)
    char *buf = NULL;
    char *ret;
    long size = 0x80;
    do {
      size += size;
      buf = reallocate_memory(buf, size);
      ret = getcwd(buf, size);
    } while (!ret && errno == ERANGE && size < 0x1000);
    NODE *result;
    if (ret) {
      result = from_c_string(buf);
    } else {
      result = UNDEFINED;
    }
    deallocate_memory(buf);
    RETURN_SINGLE_RESULT(result)
  }

$std::chdir
  #
    changes the current working directory

    This is a low level function.
  {
    CHECK_ARGUMENTS(1)
    char *path = to_c_string(ARGUMENTS(0));
    int err;
    ACTION(chdir)
      err = chdir(path);
    DATA
      INT(err, 0)
    END
    deallocate_memory(path);
    RETURN_SINGLE_RESULT(from_int(err))
  }

$std::change_directory:
  #
    changes the current working directory
  (
    path
  )
  if std::chdir(path) != 0:
    Error "
      Failed to change current directory to "@(path)@quot;!@

$clib_mkdir
  {
    CHECK_ARGUMENTS(2)
    char *path = to_c_string(ARGUMENTS(0));
    int mode = to_int(ARGUMENTS(1));
    int err;
    ACTION(mkdir)
      err = mkdir(path, mode);
    DATA
      INT(err, 0)
    END
    deallocate_memory(path);
    RETURN_SINGLE_RESULT(from_int(err))
  }

$std::mkdir:
  #
    creates a new directory

    This is a low level function.
  (
    options*
    $path
  )

  extract_options
    options
    MODE = 0o755
    $mode
    PARENTS = false
    $do_create_parent_folders

  $fail:
    raise_error
      "mkdir"
      "MODE" = string("0o" oct(mode))
      "PARENTS" = do_create_parent_folders
      "path" = path

  $create_parent_folders: ($partial_path)
    before &partial_path '/' -1
    if partial_path != "":
      create_parent_folders partial_path
      if clib_mkdir(partial_path mode) < 0 && errno() != EEXIST fail

  without_suffix &path '/'
  if do_create_parent_folders: create_parent_folders path
  if clib_mkdir(path mode) < 0:
    unless do_create_parent_folders && errno() == EEXIST fail

$std::create_directory:
  #
    creates a new directory
  (
    path
    mode = 0o755
  )
  if clib_mkdir(path mode) != 0:
    Error "
      Failed to create directory "@(path)@quot;!@

$std::fullname:
  #
    returns the fullname of the specified path- or filename
  (
    $pathname
  )
  unless pathname .has_prefix. '/':
    !pathname string(current_path() "/" pathname)
  unless pathname .has_suffix. '/': push &pathname '/'
  replace_all &pathname many("//") = "/"
  replace_all &pathname "/./" = "/"
  do: (-> break)
    forever:
      $orig_pathname pathname
      replace_all &pathname
	'/', many(not_followed_by('/'), ANY_CHARACTER), "/../" = "/"
      if pathname == orig_pathname break
  unless pathname == "/": range &pathname 1 -2
  -> pathname

{
  <kind node>
  <name DIRECTORY_HANDLE>

  DIR *dir;
}

{
  <kind type>
  <name types::DIR>
  <node DIRECTORY_HANDLE>
  <base types::object>
  <argument NULL>

  // a directory object

  RUNTIME_ERROR("Attempt to call a DIR object as a function!")
}

{
  <kind function>

  long types::DIR/debug_string(NODE *node, int indent, int max_depth, char *buf) {
    return debug_print(indent, buf, "<directory>");
  }
}

{
  <kind struct>
  <name DIRENT_DATA>

  void *new_location;
  ino_t d_ino; // inode number
  unsigned char d_type; //type of file; not supported by all filesystem types
  char d_name[0]; // filename
}

{
  <kind function>

  DIRENT_DATA *collect_dirent_data(DIRENT_DATA *buf) {
    if (!IS_COLLECTED(buf)) return buf;
    void *new_location = buf->new_location;
    if (new_location) return new_location;
    DIRENT_DATA *new_buf =
      copy(
        buf,
        ALLOCATION_SIZE(offsetof(DIRENT_DATA, d_name)+strlen(buf->d_name)+1));
    new_buf->new_location = NULL;
    buf->new_location = new_buf;
    return new_buf;
  }
}

{
  <kind node>
  <name DIRENT>

  DIRENT_DATA *dirent;
}

{
  <kind type>
  <name types::dirent>
  <node DIRENT>
  <base types::object>
  <argument NULL>

  // a directory entry object

  RUNTIME_ERROR("Attempt to call a dirent object as a function!")
}

{
  <kind function>

  long types::dirent/debug_string(NODE *node, int indent, int max_depth, char *buf) {
    return debug_print(indent, buf, "<directory entry \"%s\">",
      node->dirent.dirent->d_name);
  }
}

$std::opendir
  #
    returns a handle for traversing a directory
  {
    CHECK_ARGUMENTS(1)
    NODE *pathname_node = ARGUMENTS(0);
    char *pathname = to_c_string(pathname_node);
    DIR *dir = opendir(pathname);
    if (!dir) RUNTIME_ERROR("Failed to open directory \"%s\"!", pathname)
    deallocate_memory(pathname);
    NODE *result = create__types__DIR(dir);
    result->attributes = copy(result->attributes, sizeof(ATTRIBUTES));
    update_start_p = node_p;
    set_attribute_value(result->attributes, POLY_IDX(std::pathname_of), pathname_node);
    RETURN_SINGLE_RESULT(result)
  }

$types::DIR/close
  #
    ends traversing a directory
  {
    CHECK_ARGUMENTS(1)
    int err;
    do {
      err = closedir(ARGUMENTS(0)->directory_handle.dir);
    } while (err == -1 && errno == EINTR);
    if (result_count == 0) {
      if (err != 0) RUNTIME_ERROR("Failed to close directory!")
      RETURN_NOTHING
    }
    RETURN_SINGLE_RESULT(from_int(err))
  }

$types::DIR/get
  #
    reads a single directory entry
  {
    CHECK_ARGUMENTS(1)
    NODE *dir_node = ARGUMENTS(0);
    struct dirent *dirent = readdir(dir_node->directory_handle.dir);
    if (!dirent) RETURN_UNDEFINED
    DIRENT_DATA *data =
      allocate(
        ALLOCATION_SIZE(offsetof(DIRENT_DATA, d_name)+strlen(dirent->d_name)+1));
    data->new_location = NULL;
    data->d_ino = dirent->d_ino;
    data->d_type = dirent->d_type;
    strcpy(data->d_name, dirent->d_name);
    NODE *pathname_node = get_attribute(dir_node, POLY_IDX(std::pathname_of));
    NODE *result = create__types__dirent(data);
    result->attributes = copy(result->attributes, sizeof(ATTRIBUTES));
    update_start_p = node_p;
    set_attribute(
      result->attributes, POLY_IDX(std::pathname_of), pathname_node);
    RETURN_SINGLE_RESULT(result)
  }

$types::dirent/filename_of
  #
    returns the name of a directory entry
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_c_string(ARGUMENTS(0)->dirent.dirent->d_name))
  }

$types::dirent/inode_of
  #
    returns the inode number of the referred file
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_long(ARGUMENTS(0)->dirent.dirent->d_ino))
  }

$types::dirent/file_type_of
  #
    returns the type of the referred file
  {
    CHECK_ARGUMENTS(1)

    RETURN_SINGLE_RESULT(from_int(ARGUMENTS(0)->dirent.dirent->d_type))
  }

$types::dirent/fullname_of:
  #
    returns the full pathname of a directory entry
  (
    self
  )
  -> string(pathname_of(self) "/" filename_of(self))

$types::dirent/is_a_directory:
  #
    returns <true> if the referred file is a directory
  (
    self
  )
  -> file_type_of(self) == std::DIRECTORY

$types::dirent/is_a_regular_file:
  #
    returns <true> if the referred file is a regular file
  (
    self
  )
  -> file_type_of(self) == std::REGULAR_FILE

$types::dirent/is_a_link:
  #
    returns <true> if the referred file is a symbolic link
  (
    self
  )
  -> file_type_of(self) == std::LINK

$std::directory:
  #
    reads and returns a complete directory
  (
    options*
    pathname
  )
  extract_options options SORT = false $do_sort
  $$entries list()
  $dir std::opendir(fullname(pathname))
  do: (-> break)
    forever:
      $entry get(dir)
      unless entry.is_defined break
      case
	filename_of(entry)
	".", "..":
	  pass
	:
	  push &entries entry
  close dir
  if do_sort:
    sort &entries: (left right) -> filename_of(left) < filename_of(right)
  -> entries

{
  <kind struct>
  <name LIST_DATA>

  long size;
  long length;
  NODE **items;
}

{
  <scope extern>

  NODE *create__types__list(long length, LIST_DATA *data);
}

{
  <kind struct>
  <name ADDRINFO_DATA>

  void *new_location;
  int family;
    // e.g. AF_INET or AF_INET6
  int type;
    // e.g. SOCK_STREAM or SOCK_DGRAM
  int protocol;
    // this is the same number which appears on the protocol field in the
    // IP header of a packet
  struct sockaddr sockaddr;
}

{
  <kind function>

  ADDRINFO_DATA *collect_addrinfo_data(ADDRINFO_DATA *buf) {
    if (!IS_COLLECTED(buf)) return buf;
    void *new_location = buf->new_location;
    if (new_location) return new_location;
    ADDRINFO_DATA *new_buf = copy(buf, sizeof(ADDRINFO_DATA));
    new_buf->new_location = NULL;
    buf->new_location = new_buf;
    return new_buf;
  }
}

{
  <kind node>
  <name ADDRINFO>

  ADDRINFO_DATA *data;
}

{
  <kind type>
  <name types::addrinfo>
  <node ADDRINFO>
  <base types::object>
  <argument NULL>

  // an addrinfo object

  RUNTIME_ERROR("Attempt to call an addrinfo object as a function!")
}

{
  <kind function>

  long types::addrinfo/debug_string(NODE *node, int indent, int max_depth, char *buf) {
    char description[64];
    ADDRINFO_DATA *data = node->addrinfo.data;
    void *ptr;
    switch (data->family) {
      case AF_INET:
        ptr = &((struct sockaddr_in *)&data->sockaddr)->sin_addr;
        break;
      case AF_INET6:
        ptr = &((struct sockaddr_in6 *)&data->sockaddr)->sin6_addr;
        break;
      default:
        ptr = NULL;
      }
    if (
      ptr &&
      inet_ntop(data->family, ptr, description, sizeof(description))
    ) {
      return debug_print(indent, buf, "<addrinfo %s>", description);
    } else {
      return debug_print(indent, buf, "<addrinfo>");
    }
  }
}

$std::get_network_addresses
  #
    get all network addresses
  {
    CHECK_ARGUMENTS(1)
    struct addrinfo *first;
    char *name = to_c_string(ARGUMENTS(0));
    struct addrinfo hints;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_flags = 0;
    hints.ai_family = AF_INET; // only IPv4
    hints.ai_socktype = SOCK_STREAM; // only TCP
    hints.ai_protocol = 0;
    getaddrinfo(name, NULL, &hints, &first);
    deallocate_memory(name);
    struct addrinfo *info = first;
    int len = 0;
    while (info) {
      ++len;
      info = info->ai_next;
    }
    LIST_DATA *list_data = allocate_large(sizeof(LIST_DATA)+len*sizeof(NODE *));
    list_data->size = len;
    list_data->length = len;
    list_data->items = (void *)(list_data+1);
    len = 0;
    info = first;
    while (info) {
      ADDRINFO_DATA *data = allocate(ALLOCATION_SIZE(sizeof(ADDRINFO_DATA)));
      data->family = info->ai_family;
      data->type = info->ai_socktype;
      data->protocol = info->ai_protocol;
      data->sockaddr = *info->ai_addr;
      list_data->items[len] = create__types__addrinfo(data);
      ++len;
      info = info->ai_next;
    }
    freeaddrinfo(first);
    RETURN_SINGLE_RESULT(create__types__list(len, list_data))
  }

$std::get_network_address
  #
    get one network address
  {
    CHECK_ARGUMENTS(1)
    struct addrinfo *first;
    char *name = to_c_string(ARGUMENTS(0));
    struct addrinfo hints;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_flags = 0;
    hints.ai_family = AF_INET; // only IPv4
    hints.ai_socktype = SOCK_STREAM; // only TCP
    hints.ai_protocol = 0;
    getaddrinfo(name, NULL, &hints, &first);
    deallocate_memory(name);
    NODE *node;
    if (first) {
      ADDRINFO_DATA *data = allocate(ALLOCATION_SIZE(sizeof(ADDRINFO_DATA)));
      data->family = first->ai_family;
      data->type = first->ai_socktype;
      data->protocol = first->ai_protocol;
      data->sockaddr = *first->ai_addr;
      node = create__types__addrinfo(data);
    } else {
      node = UNDEFINED;
    }
    freeaddrinfo(first);
    RETURN_SINGLE_RESULT(node)
  }

$types::addrinfo/connect
  #
    connect to the specified address
  {
    CHECK_ARGUMENTS(2)
    ADDRINFO_DATA *data = ARGUMENTS(0)->addrinfo.data;
    int port = to_int(ARGUMENTS(1));
    int sd = socket(data->family, data->type, data->protocol);
    if (sd == -1) RETURN_UNDEFINED
    ((struct sockaddr_in *)&data->sockaddr)->sin_port = htons(port);
    if (connect(sd, &data->sockaddr, sizeof(data->sockaddr)) == 0) {
      RETURN_SINGLE_RESULT(create__types__file_descriptor(sd))
    } else {
      close(sd);
      RETURN_UNDEFINED
    }
  }

$types::string/connect:
  #
    connect to the specified uri/port combination
  (
    uri
    port
  )
  connect get_network_address(uri) port

$types::addrinfo/listen
  #
    listen on the specified socket
  {
    CHECK_ARGUMENTS(2)
    ADDRINFO_DATA *data = ARGUMENTS(0)->addrinfo.data;
    int port = to_int(ARGUMENTS(1));
    int sd = socket(data->family, data->type, data->protocol);
    if (sd == -1) RETURN_UNDEFINED
    int enable = 1;
    setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int));
    struct sockaddr_in sockaddr;
    memset(&sockaddr, 0, sizeof sockaddr);
    sockaddr.sin_family = data->family;
    sockaddr.sin_port = htons(port);
    sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    if (bind(sd, (struct sockaddr *)&sockaddr, sizeof(sockaddr)) == -1) {
      close(sd);
      RETURN_UNDEFINED
    }
    if (listen(sd, 10) == -1) {
      close(sd);
      RETURN_UNDEFINED
    }
    RETURN_SINGLE_RESULT(create__types__file_descriptor(sd))
  }

$types::string/listen:
  #
    listen on the specified uri/port combination
  (
    uri
    port
  )
  listen get_network_address(uri) port

$types::file_descriptor/accept
  #
    accept an incoming connection
  {
    CHECK_ARGUMENTS(1)
    int fd = ARGUMENTS(0)->file_descriptor.fd;
    int new_fd = accept(fd, NULL, NULL);
    if (new_fd == -1) {
      RETURN_UNDEFINED
    } else {
      RETURN_SINGLE_RESULT(create__types__file_descriptor(new_fd))
    }
  }

%std::write:
  #
    writes its arguments (as a single string)

    See also: writeln, ewrite
  (
    args*
  )
  write_to STDOUT_FILENO string(args*).to_utf8

$std::writeln:
  #
    writes its arguments and a trailing newline

    See also: write, ewriteln
  (
    args*
  )
  write args* "@nl;"

%std::ewrite:
  #
    writes its arguments (as a single string) as error
    output

    See also: ewriteln, write
  (
    args*
  )
  atomic_write_to STDERR_FILENO string(args*).to_utf8

$std::ewriteln:
  #
    writes its arguments (as a single string) with a trailing newline as error
    output
  (
    args*
  )
  ewrite args* "@nl;"

%std::read:
  #
    reads a specified amount of data from a default source
  (
    n
  )
  read_from STDIN_FILENO n

$std::readln:
  #
    reads a single line from a default source
  (
    -> return
  )
  $$buf ""
  forever:
    read $chr 1
    if chr == "@nl;" || chr == "": return buf
    append &buf chr

$std::load:
  #
    loads data from a file or a network resource
  (
    filename
  )
  if
    filename .has_prefix. "http://":
      if wget($buf "-q" "-O" "-" filename) (-> buf):
	raise "
	  Load error ("@(filename)@quot;)!@
    :
      load_file filename

$std::save:
  #
    saves data to a file
  (
    options*
    filename
    data
  )
  extract_options options PARENTS = false $do_create_directory
  if do_create_directory:
    $path before(filename '/' -1)
    if path != "": mkdir --PARENTS path
  save_file filename data.to_string
