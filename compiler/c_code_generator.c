#include <runtime/platform.h>

/**********************
D E C L A R A T I O N S
**********************/

#ifndef IMPORT
  #define IMPORT extern
#endif

#ifndef EXPORT
  #define EXPORT
#endif

#ifndef NULL
  #define NULL ((void *)0)
#endif
#define false 0
#define true 1
typedef __INT8_TYPE__ int8_t;
typedef __INT16_TYPE__ int16_t;
typedef __INT32_TYPE__ int32_t;
typedef __INT64_TYPE__ int64_t;
typedef __INTPTR_TYPE__ intptr_t;

#ifdef __UINT8_TYPE__
  typedef __UINT8_TYPE__ uint8_t;
#else
  typedef unsigned __INT8_TYPE__ uint8_t;
#endif

#ifdef __UINT16_TYPE__
  typedef __UINT16_TYPE__ uint16_t;
#else
  typedef unsigned __INT16_TYPE__ uint16_t;
#endif

#ifdef __UINT32_TYPE__
  typedef __UINT32_TYPE__ uint32_t;
#else
  typedef unsigned __INT32_TYPE__ uint32_t;
#endif

#ifdef __UINT64_TYPE__
  typedef __UINT64_TYPE__ uint64_t;
#else
  typedef unsigned __INT64_TYPE__ uint64_t;
#endif

#ifdef __UINTPTR_TYPE__
  typedef __UINTPTR_TYPE__ uintptr_t;
#else
  typedef unsigned __INTPTR_TYPE__ uintptr_t;
#endif
typedef __SIZE_TYPE__ size_t;
typedef union NODE NODE;
IMPORT void *coll_node_buf;
IMPORT void *coll_node_buf_end;
IMPORT void *static_node_buf;
IMPORT void *static_node_buf_end;
typedef void (*DESTRUCTOR)(void *);
typedef struct MEMORY_BLOCK {
  struct MEMORY_BLOCK *link;
  long mark;
  DESTRUCTOR destructor;
} MEMORY_BLOCK;
IMPORT long current_mark;
typedef void (*FUNC)(void);
typedef NODE *(*NODE_GETTER)(void);
typedef void (*NODE_SETTER)(NODE *);
IMPORT NODE *get_dynamic_slot(int id);
IMPORT void define_dynamic_slot(int id, NODE *node);
IMPORT NODE *get_dynamic_cell(int id);
IMPORT void set_dynamic_cell(int id, NODE *node);
IMPORT void define_dynamic_cell(int id, NODE *node);
typedef struct FRAME_INFO {
  int var_count;
  const char *var_names[];
} FRAME_INFO;
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define REGISTER register
#else
  #define REGISTER IMPORT
#endif
typedef struct FRAME {
  FUNC cont;
  struct FRAME *caller_frame;
  long caller_result_count;
  long slot_count;
  NODE *slots[0];
} FRAME;
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define ASM(x) asm(x)
#else
  #define ASM(x)
#endif
REGISTER FRAME *arguments ASM("r12");
IMPORT int result_count;
typedef struct CONTINUATION_INFO {
  FUNC continuation;
  struct FRAME_INFO *frame_info;
  uint16_t first_line;
  uint16_t last_line;
  uint8_t first_column;
  uint8_t last_column;
  uint8_t submodule_index;
  uint8_t unused;
} CONTINUATION_INFO;
typedef void *COLLECTOR(void *);
IMPORT uint32_t to_int8(NODE *node);
IMPORT uint64_t to_int16(NODE *node);
IMPORT uint32_t to_int32(NODE *node);
IMPORT uint64_t to_int64(NODE *node);
IMPORT uint32_t to_uint8(NODE *node);
IMPORT uint64_t to_uint16(NODE *node);
IMPORT uint32_t to_uint32(NODE *node);
IMPORT uint64_t to_uint64(NODE *node);
IMPORT uint32_t to_uchar32(NODE *node);
IMPORT int to_bool(NODE *node);
IMPORT int to_int(NODE *node);
IMPORT long to_long(NODE *node);
IMPORT double to_double(NODE *node);
IMPORT char *to_c_string(NODE *node);
IMPORT uint8_t *to_octets(NODE *node, long *size_p);
IMPORT NODE *get_item_of(NODE *node, long idx);
IMPORT long length_of(NODE *node);
IMPORT void unfold(NODE *node);
IMPORT long debug_string(NODE *node, int indent, int max_depth, char *buf);
typedef struct VTABLE {
  size_t size;
  COLLECTOR *collect;
  int8_t (*to_int8)(NODE *);
  int16_t (*to_int16)(NODE *);
  int32_t (*to_int32)(NODE *);
  int64_t (*to_int64)(NODE *);
  uint8_t (*to_uint8)(NODE *);
  uint16_t (*to_uint16)(NODE *);
  uint32_t (*to_uint32)(NODE *);
  uint64_t (*to_uint64)(NODE *);
  uint32_t (*to_uchar32)(NODE *);
  int (*to_bool)(NODE *);
  int (*to_int)(NODE *);
  long (*to_long)(NODE *);
  double (*to_double)(NODE *);
  char *(*to_c_string)(NODE *);
  uint8_t *(*to_octets)(NODE *, long *size_p);
  NODE *(*get_item_of)(NODE *, long idx);
  long (*length_of)(NODE *);
  void (*unfold)(NODE *);
  long (*debug_string)(NODE *, int indent, int max_depth, char *buf);
} VTABLE;
typedef struct OCTREE {
  struct OCTREE *nodes[8];
} OCTREE;
typedef struct ATTRIBUTES {
  struct VTABLE *vtable;
  struct OCTREE *nodes[7];
} ATTRIBUTES;
typedef struct DYNAMICS {
  struct OCTREE *nodes[8];
} DYNAMICS;
typedef struct CONTINUATION {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int result_count;
  struct FRAME *frame;
  struct DYNAMICS *dynamics;
  struct FRAME *exit_frame; // used by exit-functions
} CONTINUATION;
typedef struct CLOSURE {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int parameter_count;
  struct FRAME *frame;
} CLOSURE;
REGISTER int argument_count ASM("ebx");
IMPORT void too_few_arguments_error(void);
REGISTER NODE *myself ASM("r13");
IMPORT NODE *get_attribute(NODE *node, int idx);
IMPORT void invalid_arguments_error(void);
IMPORT NODE *clone_object_and_attributes(NODE *node);
IMPORT void *update_start_p;
IMPORT void *node_p;
IMPORT void set_attribute_value(ATTRIBUTES *attributes, int idx, void *attr);
REGISTER FUNC func ASM("r14");
REGISTER FRAME *frame ASM("r15");
typedef struct MODULE_INFO {
  struct MODULE_INFO *link;
  const char *name;
  struct CONTINUATION_INFO *continuation_info;
  int continuation_count;
  NODE **var_tab;
  const char **var_names;
  int top_level_count;
  const char **used_namespaces;
  const char *filenames[];
} MODULE_INFO;
IMPORT void allocate_initialized_frame_gc(int slot_idx, int slot_count);
IMPORT NODE *undefined;
IMPORT void initialize_maybe_future(NODE *var, NODE *val);
IMPORT void invalid_results_error(void);
IMPORT NODE *create_closure(FUNC type, int par_count);
IMPORT NODE *empty_string;
IMPORT NODE *create_cell(void);
typedef struct CELL {
  FUNC type;
  struct ATTRIBUTES *attributes;
  NODE *contents;
} CELL;
IMPORT NODE *create_continuation(void);
IMPORT NODE *create_future(void);
IMPORT void initialize_future(NODE *var, NODE *val);
IMPORT void allocate_arguments(void);
IMPORT NODE *from_arguments(int first_idx, int count);
IMPORT void optional_item(NODE *item);
IMPORT void too_many_arguments_error(void);
IMPORT NODE *create_cell_with_contents(NODE *contents);
IMPORT NODE *create_continuation_with_exit(FUNC exit_func);
IMPORT void def_attribute(NODE **var_p, int idx, void *attr);
IMPORT void continuation_trampoline(void);
IMPORT void continuation_type_function(void);
IMPORT __attribute__ ((noreturn)) void invalid_continuation_error(void);
IMPORT NODE *create_function(FUNC func, int par_count);
IMPORT NODE *from_latin_1_string(const char *str, long len);
IMPORT NODE *from_uint32_string(const uint32_t *str, long len);
IMPORT NODE *register_unique_item(const char *name);
IMPORT void assign_value(NODE **dest, NODE *val);
IMPORT void assign_variable(NODE **dest, NODE **var_p);
IMPORT void maybe_initialize_future(NODE *var, NODE *val);
IMPORT NODE *collect_node(NODE *node);
IMPORT void register_dynamic(int *id_p);
IMPORT void define_single_assign_static(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE **var_p
);
IMPORT void define_multi_assign_static(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER setter
);
IMPORT void define_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER definer,
  int *id_p
);
IMPORT void define_multi_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER setter, NODE_SETTER definer,
  int *id_p
);
IMPORT void define_attribute(
  const char *namespace, const char *name,
  int id, NODE *attribute
);
IMPORT void define_method(
  const char *namespace, const char *name,
  int id, NODE *method
);
IMPORT void define_type_function(
  const char *namespace, const char *name, FUNC type, int par_cnt
);
IMPORT void define_privileged_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER getter, int id,
  NODE **var_p
);
IMPORT void define_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER getter, int *id_p,
  NODE **var_p
);
IMPORT void register_polymorphic_function(const char *name, int *id_p);
typedef struct SIMPLE_NODE {
  FUNC type;
  struct ATTRIBUTES *attributes;
} SIMPLE_NODE;
IMPORT void *allocate(long size);
IMPORT ATTRIBUTES *collect_attributes(ATTRIBUTES *attributes);
IMPORT void no_such_function(void);
IMPORT OCTREE no_attributes_level_1;
IMPORT OCTREE no_attributes_level_2;
IMPORT OCTREE no_attributes_level_3;
IMPORT OCTREE no_attributes_level_4;
IMPORT OCTREE no_attributes_level_5;
IMPORT OCTREE no_attributes_level_6;
IMPORT OCTREE no_attributes_level_7;
IMPORT OCTREE undefined_attributes_level_1;
IMPORT OCTREE undefined_attributes_level_2;
IMPORT OCTREE undefined_attributes_level_3;
IMPORT OCTREE undefined_attributes_level_4;
IMPORT OCTREE undefined_attributes_level_5;
IMPORT OCTREE undefined_attributes_level_6;
IMPORT OCTREE undefined_attributes_level_7;
IMPORT void collect_static_attributes(ATTRIBUTES *attributes);
IMPORT void define_c_function(const char *name, void *func);
IMPORT NODE *create_future_with_prototype(NODE *prototype);
IMPORT void set_attribute(ATTRIBUTES *attributes, int idx, void *attr);
IMPORT void register_module_info(MODULE_INFO *info);
IMPORT void set_module(const char *name);
IMPORT NODE *from_uchar32(unsigned int chr);
IMPORT NODE *from_uint32(uint32_t val);
IMPORT void set_used_namespaces(const char **namespaces);
IMPORT void use_read_only(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_GETTER *get_value_or_future
);
IMPORT void use_multi_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *setter, NODE_SETTER *definer
);
IMPORT void use_read_write(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *setter
);
IMPORT void use_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER *getter, int *id
);
IMPORT void use_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *definer
);
IMPORT void register_collector(FUNC collector);


#if UINTPTR_MAX == 0xffffffffffffffff
  #define FIRST_INVALID_ADDRESS 0xc000000000000000UL
  #define SAMPLE_POINTER ((void *)0x123456789abcdef0UL)
#else
  #define FIRST_INVALID_ADDRESS 0xc0000000
  #define SAMPLE_POINTER ((void *)0x12345678)
#endif

#define MAKE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)+1))
#define RETRIEVE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)-1))
#define CONTAINS_AN_ATTRIBUTE_VALUE(node) (((uintptr_t)node)&1)

#define ENCODE_ADDRESS(addr) ((void *)((uintptr_t)addr | 2))
#define DECODE_ADDRESS(addr) ((void *)((uintptr_t)addr & -3))
#define IS_AN_INVALID_ADDRESS(addr) ((uintptr_t)addr & 2)

#define MSB (1L << (8*sizeof(void *)-1))
#define ENCODE_TO_LENGTH(addr) ((void *)(((uintptr_t)addr >> 1) | MSB))
#define DECODE_FROM_LENGTH(addr) ((void *)((uintptr_t)addr << 1))
#define IS_AN_INVALID_LENGTH(addr) ((uintptr_t)addr & MSB)

#define IS_COLLECTED(addr) (((void *)(addr)) >= coll_node_buf && ((void *)(addr)) < coll_node_buf_end)
#define IS_STATIC(addr) (((void *)(addr)) >= static_node_buf && ((void *)(addr)) < static_node_buf_end)
#define MARK(addr) (((MEMORY_BLOCK *)(addr))-1)->mark = current_mark;

#define ALLOCATION_SIZE(size) (((size)+sizeof(void *)-1)&-sizeof(void *))
#define TYPEOF(node) (node)->type
#define SIZEOF(node) (node)->attributes->vtable->size

#ifdef WITHIN_LIBRARY
  #define DEBUG_FILENAME(filename) filename
#else
  #define DEBUG_FILENAME(filename) "./" filename
#endif

#ifdef __CYGWIN__
  extern FUNC invalid_continuation;
#else
  extern void invalid_continuation(void);
#endif
static NODE_GETTER get__ATTRIBUTE_KIND;
static NODE_GETTER get_value_or_future__ATTRIBUTE_KIND;
static NODE_GETTER get__CONTINUATION_PARAMETER;
static NODE_GETTER get_value_or_future__CONTINUATION_PARAMETER;
static NODE_GETTER get__DYNAMIC_MULTI;
static NODE_GETTER get_value_or_future__DYNAMIC_MULTI;
static NODE_GETTER get__DYNAMIC_SINGLE;
static NODE_GETTER get_value_or_future__DYNAMIC_SINGLE;
static NODE_GETTER get__Error;
static NODE_GETTER get_value_or_future__Error;
static NODE_GETTER get__IN_OUT_PARAMETER;
static NODE_GETTER get_value_or_future__IN_OUT_PARAMETER;
static NODE_GETTER get__METHOD_KIND;
static NODE_GETTER get_value_or_future__METHOD_KIND;
static NODE_GETTER get__MYSELF_PARAMETER;
static NODE_GETTER get_value_or_future__MYSELF_PARAMETER;
static NODE_GETTER get__NONE;
static NODE_GETTER get_value_or_future__NONE;
static NODE_GETTER get__OUT_PARAMETER;
static NODE_GETTER get_value_or_future__OUT_PARAMETER;
static NODE_GETTER get__POLYMORPHIC;
static NODE_GETTER get_value_or_future__POLYMORPHIC;
static NODE_GETTER get__STATIC_MULTI;
static NODE_GETTER get_value_or_future__STATIC_MULTI;
static NODE_GETTER get__STATIC_SINGLE;
static NODE_GETTER get_value_or_future__STATIC_SINGLE;
static NODE_GETTER get__SyntaxError;
static NODE_GETTER get_value_or_future__SyntaxError;
static NODE_GETTER get__alt;
static NODE_GETTER get_value_or_future__alt;
static NODE_GETTER get__any_of;
static NODE_GETTER get_value_or_future__any_of;
static NODE_GETTER get__append;
static NODE_GETTER get_value_or_future__append;
static NODE_GETTER get__arguments_of;
static NODE_GETTER get_value_or_future__arguments_of;
static NODE_GETTER get__assignment_to_c;
static NODE_GETTER get_value_or_future__assignment_to_c;
static NODE_GETTER get__attribute_kind_of;
static NODE_GETTER get_value_or_future__attribute_kind_of;
static NODE_GETTER get__attribute_of;
static NODE_GETTER get_value_or_future__attribute_of;
static NODE_GETTER get__base_of;
static NODE_GETTER get_value_or_future__base_of;
static NODE_GETTER get__before;
static NODE_GETTER get_value_or_future__before;
static NODE_GETTER get__begin_continuation;
static NODE_GETTER get_value_or_future__begin_continuation;
static NODE_GETTER get__behind;
static NODE_GETTER get_value_or_future__behind;
static NODE_GETTER get__between;
static NODE_GETTER get_value_or_future__between;
static NODE_GETTER get__case;
static NODE_GETTER get_value_or_future__case;
static NODE_GETTER get__collect_output;
static NODE_GETTER get_value_or_future__collect_output;
static NODE_GETTER get__compiler__body;
static NODE_GETTER get_value_or_future__compiler__body;
static NODE_GETTER get__compiler__c_body;
static NODE_GETTER get_value_or_future__compiler__c_body;
static NODE_GETTER get__compiler__character_literal;
static NODE_GETTER get_value_or_future__compiler__character_literal;
static NODE_GETTER get__compiler__current_continuation_info;
static NODE_SETTER set__compiler__current_continuation_info;
static NODE_SETTER define__compiler__current_continuation_info;
static NODE_GETTER get__compiler__definition;
static NODE_GETTER get_value_or_future__compiler__definition;
static NODE_GETTER get__compiler__identifier;
static NODE_GETTER get_value_or_future__compiler__identifier;
static NODE_GETTER get__compiler__numeric_literal;
static NODE_GETTER get_value_or_future__compiler__numeric_literal;
static NODE_GETTER get__compiler__string_literal;
static NODE_GETTER get_value_or_future__compiler__string_literal;
static NODE_GETTER get__compiler__unique_item;
static NODE_GETTER get_value_or_future__compiler__unique_item;
static NODE_GETTER get__cond;
static NODE_GETTER get_value_or_future__cond;
static NODE_GETTER get__contains;
static NODE_GETTER get_value_or_future__contains;
static NODE_GETTER get__continuation_of;
static NODE_GETTER get_value_or_future__continuation_of;
static NODE_GETTER get__converted;
static NODE_GETTER get_value_or_future__converted;
static NODE_GETTER get__count_character_occurrences;
static NODE_GETTER get_value_or_future__count_character_occurrences;
static NODE_GETTER get__current_continuation_info;
static NODE_SETTER set__current_continuation_info;
static NODE_GETTER get__dec;
static NODE_GETTER get_value_or_future__dec;
static NODE_GETTER get__default_value;
static NODE_GETTER get_value_or_future__default_value;
static NODE_GETTER get__default_value_of;
static NODE_GETTER get_value_or_future__default_value_of;
static NODE_GETTER get__defined_functions;
static NODE_GETTER get_value_or_future__defined_functions;
static NODE_GETTER get__defined_names_of;
static NODE_GETTER get_value_or_future__defined_names_of;
static NODE_GETTER get__defined_nodes;
static NODE_GETTER get_value_or_future__defined_nodes;
static NODE_GETTER get__defined_structs;
static NODE_GETTER get_value_or_future__defined_structs;
static NODE_GETTER get__defines_a_dynamic;
static NODE_GETTER get_value_or_future__defines_a_dynamic;
static NODE_GETTER get__definitions_of;
static NODE_GETTER get_value_or_future__definitions_of;
static NODE_GETTER get__delayed_code;
static NODE_SETTER set__delayed_code;
static NODE_GETTER get__do;
static NODE_GETTER get_value_or_future__do;
static NODE_GETTER get__do_show_compiler_debug_infos;
static NODE_GETTER get_value_or_future__do_show_compiler_debug_infos;
static NODE_GETTER get__dup;
static NODE_GETTER get_value_or_future__dup;
static NODE_GETTER get__empty_insert_order_table;
static NODE_GETTER get_value_or_future__empty_insert_order_table;
static NODE_GETTER get__empty_list;
static NODE_GETTER get_value_or_future__empty_list;
static NODE_GETTER get__empty_set;
static NODE_GETTER get_value_or_future__empty_set;
static NODE_GETTER get__empty_table;
static NODE_GETTER get_value_or_future__empty_table;
static NODE_GETTER get__end_continuation;
static NODE_GETTER get_value_or_future__end_continuation;
static NODE_GETTER get__end_position_of;
static NODE_GETTER get_value_or_future__end_position_of;
static NODE_GETTER get__ewriteln;
static NODE_GETTER get_value_or_future__ewriteln;
static NODE_GETTER get__exported_names;
static NODE_GETTER get_value_or_future__exported_names;
static NODE_GETTER get__false;
static NODE_GETTER get_value_or_future__false;
static NODE_GETTER get__for_each;
static NODE_GETTER get_value_or_future__for_each;
static NODE_GETTER get__for_each_from_to;
static NODE_GETTER get_value_or_future__for_each_from_to;
static NODE_GETTER get__for_each_line;
static NODE_GETTER get_value_or_future__for_each_line;
static NODE_GETTER get__fragment_of;
static NODE_GETTER get_value_or_future__fragment_of;
static NODE_GETTER get__from;
static NODE_GETTER get_value_or_future__from;
static NODE_GETTER get__from_down_to;
static NODE_GETTER get_value_or_future__from_down_to;
static NODE_GETTER get__from_to;
static NODE_GETTER get_value_or_future__from_to;
static NODE_GETTER get__functor_of;
static NODE_GETTER get_value_or_future__functor_of;
static NODE_GETTER get__generate_dispatcher_function;
static NODE_GETTER get_value_or_future__generate_dispatcher_function;
static NODE_GETTER get__generate_statement;
static NODE_GETTER get_value_or_future__generate_statement;
static NODE_GETTER get__global_names;
static NODE_GETTER get_value_or_future__global_names;
static NODE_GETTER get__has_prefix;
static NODE_GETTER get_value_or_future__has_prefix;
static NODE_GETTER get__has_suffix;
static NODE_GETTER get_value_or_future__has_suffix;
static NODE_GETTER get__hash2;
static NODE_GETTER get_value_or_future__hash2;
static NODE_GETTER get__hex;
static NODE_GETTER get_value_or_future__hex;
static NODE_GETTER get__identifier_of;
static NODE_GETTER get_value_or_future__identifier_of;
static NODE_GETTER get__if;
static NODE_GETTER get_value_or_future__if;
static NODE_GETTER get__inc;
static NODE_GETTER get_value_or_future__inc;
static NODE_GETTER get__indent_marker;
static NODE_GETTER get_value_or_future__indent_marker;
static NODE_GETTER get__indented;
static NODE_GETTER get_value_or_future__indented;
static NODE_GETTER get__indents_of;
static NODE_GETTER get_value_or_future__indents_of;
static NODE_GETTER get__index;
static NODE_SETTER set__index;
static NODE_GETTER get__inherited_names_of;
static NODE_GETTER get_value_or_future__inherited_names_of;
static NODE_GETTER get__is_a_constant;
static NODE_GETTER get_value_or_future__is_a_constant;
static NODE_GETTER get__is_a_definition;
static NODE_GETTER get_value_or_future__is_a_definition;
static NODE_GETTER get__is_a_destination;
static NODE_GETTER get_value_or_future__is_a_destination;
static NODE_GETTER get__is_a_function_call;
static NODE_GETTER get_value_or_future__is_a_function_call;
static NODE_GETTER get__is_a_key_value_pair;
static NODE_GETTER get_value_or_future__is_a_key_value_pair;
static NODE_GETTER get__is_a_latin_1_string;
static NODE_GETTER get_value_or_future__is_a_latin_1_string;
static NODE_GETTER get__is_a_multi_assign_definition;
static NODE_GETTER get_value_or_future__is_a_multi_assign_definition;
static NODE_GETTER get__is_a_parameter;
static NODE_GETTER get_value_or_future__is_a_parameter;
static NODE_GETTER get__is_a_procedure_call;
static NODE_GETTER get_value_or_future__is_a_procedure_call;
static NODE_GETTER get__is_a_reference;
static NODE_GETTER get_value_or_future__is_a_reference;
static NODE_GETTER get__is_a_return;
static NODE_GETTER get_value_or_future__is_a_return;
static NODE_GETTER get__is_a_single_assign_definition;
static NODE_GETTER get_value_or_future__is_a_single_assign_definition;
static NODE_GETTER get__is_a_static_definition;
static NODE_GETTER get_value_or_future__is_a_static_definition;
static NODE_GETTER get__is_a_string;
static NODE_GETTER get_value_or_future__is_a_string;
static NODE_GETTER get__is_a_temporary;
static NODE_GETTER get_value_or_future__is_a_temporary;
static NODE_GETTER get__is_an_assignment;
static NODE_GETTER get_value_or_future__is_an_assignment;
static NODE_GETTER get__is_an_attribute_function_pair;
static NODE_GETTER get_value_or_future__is_an_attribute_function_pair;
static NODE_GETTER get__is_an_attribute_value_pair;
static NODE_GETTER get_value_or_future__is_an_attribute_value_pair;
static NODE_GETTER get__is_an_expanded_item;
static NODE_GETTER get_value_or_future__is_an_expanded_item;
static NODE_GETTER get__is_an_identifier;
static NODE_GETTER get_value_or_future__is_an_identifier;
static NODE_GETTER get__is_an_initialization;
static NODE_GETTER get_value_or_future__is_an_initialization;
static NODE_GETTER get__is_an_input_output_argument;
static NODE_GETTER get_value_or_future__is_an_input_output_argument;
static NODE_GETTER get__is_an_optional_item;
static NODE_GETTER get_value_or_future__is_an_optional_item;
static NODE_GETTER get__is_defined;
static NODE_GETTER get_value_or_future__is_defined;
static NODE_GETTER get__is_empty;
static NODE_GETTER get_value_or_future__is_empty;
static NODE_GETTER get__is_undefined;
static NODE_GETTER get_value_or_future__is_undefined;
static NODE_GETTER get__key_of;
static NODE_GETTER get_value_or_future__key_of;
static NODE_GETTER get__kind_of;
static NODE_GETTER get_value_or_future__kind_of;
static NODE_GETTER get__length_of;
static NODE_GETTER get_value_or_future__length_of;
static NODE_GETTER get__line_no_of;
static NODE_GETTER get_value_or_future__line_no_of;
static NODE_GETTER get__list;
static NODE_GETTER get_value_or_future__list;
static NODE_GETTER get__mangled_name_of;
static NODE_GETTER get_value_or_future__mangled_name_of;
static NODE_GETTER get__max;
static NODE_GETTER get_value_or_future__max;
static NODE_GETTER get__might_be_constant;
static NODE_GETTER get_value_or_future__might_be_constant;
static NODE_GETTER get__module_name;
static NODE_GETTER get_value_or_future__module_name;
static NODE_GETTER get__name_of;
static NODE_GETTER get_value_or_future__name_of;
static NODE_GETTER get__namespace_of;
static NODE_GETTER get_value_or_future__namespace_of;
static NODE_GETTER get__needed_names;
static NODE_GETTER get_value_or_future__needed_names;
static NODE_GETTER get__newline;
static NODE_GETTER get_value_or_future__newline;
static NODE_GETTER get__next_continuation;
static NODE_GETTER get_value_or_future__next_continuation;
static NODE_GETTER get__node__text_of;
static NODE_GETTER get_value_or_future__node__text_of;
static NODE_GETTER get__node__type_of;
static NODE_GETTER get_value_or_future__node__type_of;
static NODE_GETTER get__node__value_of;
static NODE_GETTER get_value_or_future__node__value_of;
static NODE_GETTER get__node_of;
static NODE_GETTER get_value_or_future__node_of;
static NODE_GETTER get__normalize;
static NODE_GETTER get_value_or_future__normalize;
static NODE_GETTER get__not;
static NODE_GETTER get_value_or_future__not;
static NODE_GETTER get__oct;
static NODE_GETTER get_value_or_future__oct;
static NODE_GETTER get__outdent_marker;
static NODE_GETTER get_value_or_future__outdent_marker;
static NODE_GETTER get__pad_left;
static NODE_GETTER get_value_or_future__pad_left;
static NODE_GETTER get__parameter_count_of;
static NODE_GETTER get_value_or_future__parameter_count_of;
static NODE_GETTER get__parameter_kind_of;
static NODE_GETTER get_value_or_future__parameter_kind_of;
static NODE_GETTER get__parameters_of;
static NODE_GETTER get_value_or_future__parameters_of;
static NODE_GETTER get__plus;
static NODE_GETTER get_value_or_future__plus;
static NODE_GETTER get__privileged_polymorphic_functions;
static NODE_GETTER get_value_or_future__privileged_polymorphic_functions;
static NODE_GETTER get__push;
static NODE_GETTER get_value_or_future__push;
static NODE_GETTER get__range;
static NODE_GETTER get_value_or_future__range;
static NODE_GETTER get__replace_all;
static NODE_GETTER get_value_or_future__replace_all;
static NODE_GETTER get__result_count_of;
static NODE_GETTER get_value_or_future__result_count_of;
static NODE_GETTER get__scope_of;
static NODE_GETTER get_value_or_future__scope_of;
static NODE_GETTER get__search_character;
static NODE_GETTER get_value_or_future__search_character;
static NODE_GETTER get__show_compiler_debug_info;
static NODE_GETTER get_value_or_future__show_compiler_debug_info;
static NODE_GETTER get__source_of;
static NODE_GETTER get_value_or_future__source_of;
static NODE_GETTER get__source_position_of;
static NODE_GETTER get_value_or_future__source_position_of;
static NODE_GETTER get__statements_of;
static NODE_GETTER get_value_or_future__statements_of;
static NODE_GETTER get__std__and;
static NODE_GETTER get_value_or_future__std__and;
static NODE_GETTER get__std__equal;
static NODE_GETTER get_value_or_future__std__equal;
static NODE_GETTER get__std__key_value_pair;
static NODE_GETTER get_value_or_future__std__key_value_pair;
static NODE_GETTER get__std__less;
static NODE_GETTER get_value_or_future__std__less;
static NODE_GETTER get__std__minus;
static NODE_GETTER get_value_or_future__std__minus;
static NODE_GETTER get__std__negate;
static NODE_GETTER get_value_or_future__std__negate;
static NODE_GETTER get__std__not;
static NODE_GETTER get_value_or_future__std__not;
static NODE_GETTER get__std__or;
static NODE_GETTER get_value_or_future__std__or;
static NODE_GETTER get__std__plus;
static NODE_GETTER get_value_or_future__std__plus;
static NODE_GETTER get__std__sequence;
static NODE_GETTER get_value_or_future__std__sequence;
static NODE_GETTER get__std__string;
static NODE_GETTER get_value_or_future__std__string;
static NODE_GETTER get__std__value_of;
static NODE_GETTER get_value_or_future__std__value_of;
static NODE_GETTER get__string;
static NODE_GETTER get_value_or_future__string;
static NODE_GETTER get__string_literals;
static NODE_SETTER set__string_literals;
static NODE_GETTER get__submodule_no_of;
static NODE_GETTER get_value_or_future__submodule_no_of;
static NODE_GETTER get__suffix;
static NODE_GETTER get_value_or_future__suffix;
static NODE_GETTER get__temporary_count_of;
static NODE_GETTER get_value_or_future__temporary_count_of;
static int poly_idx__to_c;
static NODE_GETTER get__to_c;
static NODE_GETTER get__to_integer;
static NODE_GETTER get_value_or_future__to_integer;
static NODE_GETTER get__to_lower_case;
static NODE_GETTER get_value_or_future__to_lower_case;
static NODE_GETTER get__to_string;
static NODE_GETTER get_value_or_future__to_string;
static NODE_GETTER get__trim;
static NODE_GETTER get_value_or_future__trim;
static NODE_GETTER get__true;
static NODE_GETTER get_value_or_future__true;
static NODE_GETTER get__truncate_behind;
static NODE_GETTER get_value_or_future__truncate_behind;
static NODE_GETTER get__truncate_from;
static NODE_GETTER get_value_or_future__truncate_from;
static NODE_GETTER get__truncate_until;
static NODE_GETTER get_value_or_future__truncate_until;
static NODE_GETTER get__types__grammar_node;
static NODE_GETTER get_value_or_future__types__grammar_node;
static NODE_GETTER get__undefined;
static NODE_GETTER get_value_or_future__undefined;
static NODE_GETTER get__unique_item_index;
static NODE_SETTER set__unique_item_index;
static NODE_GETTER get__unless;
static NODE_GETTER get_value_or_future__unless;
static NODE_GETTER get__until;
static NODE_GETTER get_value_or_future__until;
static NODE_GETTER get__use_literal;
static NODE_GETTER get_value_or_future__use_literal;
static NODE_GETTER get__used_string_literals;
static NODE_SETTER set__used_string_literals;
static NODE_GETTER get__used_unique_items;
static NODE_SETTER set__used_unique_items;
static NODE_GETTER get__variable_kind_of;
static NODE_GETTER get_value_or_future__variable_kind_of;
static NODE_GETTER get__vtable_entries;
static NODE_GETTER get_value_or_future__vtable_entries;
static NODE_GETTER get__while;
static NODE_GETTER get_value_or_future__while;
static NODE_GETTER get__without_suffix;
static NODE_GETTER get_value_or_future__without_suffix;
static NODE_GETTER get__write;
static NODE_GETTER get_value_or_future__write;
static NODE_GETTER get__write_source_as_remark;
static NODE_GETTER get_value_or_future__write_source_as_remark;
static NODE_GETTER get__write_to;
static NODE_GETTER get_value_or_future__write_to;
static NODE_GETTER get__write_to_continuation_table;
static NODE_SETTER define__write_to_continuation_table;
static NODE_GETTER get__write_to_declarations;
static NODE_GETTER get_value_or_future__write_to_declarations;
static NODE_GETTER get__write_to_delayed_continuation_table;
static NODE_GETTER get_value_or_future__write_to_delayed_continuation_table;
static NODE_GETTER get__write_to_generated_collections;
static NODE_GETTER get_value_or_future__write_to_generated_collections;
static NODE_GETTER get__write_to_global_variable_declarations;
static NODE_GETTER get_value_or_future__write_to_global_variable_declarations;
static NODE_GETTER get__write_to_phase_1;
static NODE_GETTER get_value_or_future__write_to_phase_1;
static NODE_GETTER get__write_to_phase_2;
static NODE_GETTER get_value_or_future__write_to_phase_2;
static NODE_GETTER get__write_to_phase_3;
static NODE_GETTER get_value_or_future__write_to_phase_3;
static NODE_GETTER get__write_to_phase_4;
static NODE_GETTER get_value_or_future__write_to_phase_4;
static NODE_GETTER get__write_to_phase_5;
static NODE_GETTER get_value_or_future__write_to_phase_5;
static NODE_GETTER get__write_to_top_level_variable_declarations;
static NODE_GETTER get_value_or_future__write_to_top_level_variable_declarations;
static NODE_GETTER get__write_to_top_level_variable_names;
static NODE_GETTER get_value_or_future__write_to_top_level_variable_names;
static NODE_GETTER get__writeln;
static NODE_GETTER get_value_or_future__writeln;
static struct {
  NODE *compiler__to_c;
  NODE *compiler__begin_continuation;
  NODE *compiler__end_continuation;
  NODE *compiler__next_continuation;
  NODE *compiler__assignment_to_c;
  NODE *compiler__write_source_as_remark;
  NODE *compiler__is_single_assign;
  NODE *compiler__might_be_constant;
  NODE *compiler__define_variable;
  NODE *compiler__define_attribute;
  NODE *compiler__define_method;
  NODE *compiler__define_type_function;
  NODE *compiler__define_polymorphic_function;
  NODE *compiler__define_c_code;
  NODE *compiler__generate_statement;
} var;
static const char *var_names[] = {
};
static int poly_idx__compiler__to_c;
static void type__compiler__to_c(void);
static NODE *get__compiler__to_c(void) {
  return var.compiler__to_c;
}
static int dyna_idx__compiler__suffix;
static NODE *get__compiler__suffix(void) {
  return get_dynamic_slot(dyna_idx__compiler__suffix);
}
static void define__compiler__suffix(NODE *node) {
  define_dynamic_slot(dyna_idx__compiler__suffix, node);
}
static int dyna_idx__level;
static NODE *get__level(void) {
  return get_dynamic_slot(dyna_idx__level);
}
static void define__level(NODE *node) {
  define_dynamic_slot(dyna_idx__level, node);
}
static int dyna_idx__cont_suffix;
static NODE *get__cont_suffix(void) {
  return get_dynamic_slot(dyna_idx__cont_suffix);
}
static void define__cont_suffix(NODE *node) {
  define_dynamic_slot(dyna_idx__cont_suffix, node);
}
static int dyna_idx__current_locals;
static NODE *get__current_locals(void) {
  return get_dynamic_slot(dyna_idx__current_locals);
}
static void define__current_locals(NODE *node) {
  define_dynamic_slot(dyna_idx__current_locals, node);
}
static int dyna_idx__current_frame;
static NODE *get__current_frame(void) {
  return get_dynamic_slot(dyna_idx__current_frame);
}
static void define__current_frame(NODE *node) {
  define_dynamic_slot(dyna_idx__current_frame, node);
}
static int dyna_idx__is_a_shared_local;
static NODE *get__is_a_shared_local(void) {
  return get_dynamic_slot(dyna_idx__is_a_shared_local);
}
static void define__is_a_shared_local(NODE *node) {
  define_dynamic_slot(dyna_idx__is_a_shared_local, node);
}
static int dyna_idx__temporary_offset;
static NODE *get__temporary_offset(void) {
  return get_dynamic_slot(dyna_idx__temporary_offset);
}
static void define__temporary_offset(NODE *node) {
  define_dynamic_slot(dyna_idx__temporary_offset, node);
}
static int dyna_idx__compiler__delayed_code;
static NODE *get__compiler__delayed_code(void) {
  return get_dynamic_cell(dyna_idx__compiler__delayed_code);
}
static void set__compiler__delayed_code(NODE *node) {
  set_dynamic_cell(dyna_idx__compiler__delayed_code, node);
}
static void define__compiler__delayed_code(NODE *node) {
  define_dynamic_cell(dyna_idx__compiler__delayed_code, node);
}
static NODE *func__var_name;
static void entry__var_name(void);
static FRAME_INFO frame__var_name = {1, {"name"}};
static NODE *string__2d7981f4e5f02b9a;
static void cont__var_name_3(void);
static NODE *func__var_name_4;
static void entry__var_name_4(void);
static FRAME_INFO frame__var_name_4 = {1, {"name"}};
static NODE *func__var_name_5;
static void entry__var_name_5(void);
static FRAME_INFO frame__var_name_5 = {1, {"name"}};
static void cont__var_name_6(void);
static NODE *func__var_entry;
static void entry__var_entry(void);
static FRAME_INFO frame__var_entry = {1, {"name"}};
static void cont__var_entry_2(void);
static NODE *func__var_entry_3;
static void entry__var_entry_3(void);
static FRAME_INFO frame__var_entry_3 = {1, {"name"}};
static NODE *string__2e0ae90b5df07d17;
static void cont__var_entry_5(void);
static NODE *func__var_entry_6;
static void entry__var_entry_6(void);
static FRAME_INFO frame__var_entry_6 = {1, {"name"}};
static NODE *string__485aef83e8b97008;
static void cont__var_entry_8(void);
static NODE *func__insert_delayed;
static void entry__insert_delayed(void);
static FRAME_INFO frame__insert_delayed = {0, {}};
static void cont__insert_delayed_2(void);
static NODE *func__delayed;
static void entry__delayed(void);
static FRAME_INFO frame__delayed = {2, {"body", "cont_tab_entries"}};
static NODE *func__delayed_2;
static void entry__delayed_2(void);
static FRAME_INFO frame__delayed_2 = {4, {"return__1", "cont_tab_entries", "body", "output"}};
static NODE *func__delayed_3;
static void entry__delayed_3(void);
static FRAME_INFO frame__delayed_3 = {2, {"args", "cont_tab_entries"}};
static void cont__delayed_4(void);
static void cont__delayed_5(void);
static void cont__delayed_6(void);
static void cont__delayed_7(void);
static NODE *func__compiler__begin_continuation;
static void entry__compiler__begin_continuation(void);
static FRAME_INFO frame__compiler__begin_continuation = {1, {"name"}};
static NODE *string__94d1722d4e0367ec;
static NODE *string__66ccbf91860d092a;
static void cont__compiler__begin_continuation_4(void);
static void cont__compiler__begin_continuation_5(void);
static void cont__compiler__begin_continuation_6(void);
static NODE *string__fc8c36a84adb366f;
static void cont__compiler__begin_continuation_8(void);
static void cont__compiler__begin_continuation_9(void);
static NODE *string__fa730415f296bb7;
static NODE *string__2d7981f4e6682be5;
static void cont__compiler__begin_continuation_12(void);
static void cont__compiler__begin_continuation_13(void);
static void cont__compiler__begin_continuation_14(void);
static NODE *func__compiler__begin_continuation_15;
static void entry__compiler__begin_continuation_15(void);
static FRAME_INFO frame__compiler__begin_continuation_15 = {0, {}};
static NODE *string__578a5af303e9cc7;
static void cont__compiler__begin_continuation_17(void);
static NODE *func__compiler__begin_continuation_18;
static void entry__compiler__begin_continuation_18(void);
static FRAME_INFO frame__compiler__begin_continuation_18 = {0, {}};
static NODE *string__1f5d5783d902f7;
static void cont__compiler__begin_continuation_20(void);
static NODE *get__compiler__begin_continuation(void) {
  return var.compiler__begin_continuation;
}
static NODE *func__compiler__end_continuation;
static void entry__compiler__end_continuation(void);
static FRAME_INFO frame__compiler__end_continuation = {0, {}};
static void cont__compiler__end_continuation_2(void);
static NODE *func__compiler__end_continuation_3;
static void entry__compiler__end_continuation_3(void);
static FRAME_INFO frame__compiler__end_continuation_3 = {0, {}};
static NODE *string__fa727015f496bc6;
static void cont__compiler__end_continuation_5(void);
static void cont__compiler__end_continuation_6(void);
static NODE *func__compiler__end_continuation_7;
static void entry__compiler__end_continuation_7(void);
static FRAME_INFO frame__compiler__end_continuation_7 = {0, {}};
static NODE *get__compiler__end_continuation(void) {
  return var.compiler__end_continuation;
}
static NODE *func__compiler__next_continuation;
static void entry__compiler__next_continuation(void);
static FRAME_INFO frame__compiler__next_continuation = {1, {"name"}};
static void cont__compiler__next_continuation_2(void);
static NODE *get__compiler__next_continuation(void) {
  return var.compiler__next_continuation;
}
static NODE *func__count_arguments;
static void entry__count_arguments(void);
static FRAME_INFO frame__count_arguments = {3, {"arguments", "return", "inputs_count"}};
static NODE *func__count_arguments_2;
static void entry__count_arguments_2(void);
static FRAME_INFO frame__count_arguments_2 = {3, {"argument", "return", "inputs_count"}};
static void cont__count_arguments_3(void);
static NODE *func__count_arguments_4;
static void entry__count_arguments_4(void);
static FRAME_INFO frame__count_arguments_4 = {1, {"argument"}};
static void cont__count_arguments_5(void);
static void cont__count_arguments_6(void);
static NODE *func__count_arguments_7;
static void entry__count_arguments_7(void);
static FRAME_INFO frame__count_arguments_7 = {1, {"return"}};
static NODE *func__count_arguments_8;
static void entry__count_arguments_8(void);
static FRAME_INFO frame__count_arguments_8 = {1, {"inputs_count"}};
static void cont__count_arguments_9(void);
static void cont__count_arguments_10(void);
static NODE *func__generate_c_arguments;
static void entry__generate_c_arguments(void);
static FRAME_INFO frame__generate_c_arguments = {4, {"arguments", "within_exit_function", "inputs_count", "idx"}};
static void cont__generate_c_arguments_2(void);
static NODE *func__generate_c_arguments_3;
static void entry__generate_c_arguments_3(void);
static FRAME_INFO frame__generate_c_arguments_3 = {1, {"inputs_count"}};
static void cont__generate_c_arguments_4(void);
static NODE *func__generate_c_arguments_5;
static void entry__generate_c_arguments_5(void);
static FRAME_INFO frame__generate_c_arguments_5 = {1, {"inputs_count"}};
static NODE *string__a1d76a17b79c4b5;
static NODE *string__2d7981f4e6d02bcf;
static void cont__generate_c_arguments_8(void);
static NODE *func__generate_c_arguments_9;
static void entry__generate_c_arguments_9(void);
static FRAME_INFO frame__generate_c_arguments_9 = {1, {"inputs_count"}};
static void cont__generate_c_arguments_10(void);
static NODE *string__3892a143ae642f72;
static NODE *string__13889e43284fcd2b;
static void cont__generate_c_arguments_13(void);
static void cont__generate_c_arguments_14(void);
static NODE *func__generate_c_arguments_15;
static void entry__generate_c_arguments_15(void);
static FRAME_INFO frame__generate_c_arguments_15 = {4, {"argument", "inputs_count", "idx", "src"}};
static void cont__generate_c_arguments_16(void);
static NODE *func__generate_c_arguments_17;
static void entry__generate_c_arguments_17(void);
static FRAME_INFO frame__generate_c_arguments_17 = {2, {"argument", "src"}};
static void cont__generate_c_arguments_18(void);
static NODE *func__generate_c_arguments_19;
static void entry__generate_c_arguments_19(void);
static FRAME_INFO frame__generate_c_arguments_19 = {1, {"src"}};
static NODE *string__7834b5f7cd2908a7;
static NODE *string__fa732015ff16bc6;
static void cont__generate_c_arguments_22(void);
static NODE *func__generate_c_arguments_23;
static void entry__generate_c_arguments_23(void);
static FRAME_INFO frame__generate_c_arguments_23 = {2, {"argument", "src"}};
static void cont__generate_c_arguments_24(void);
static NODE *func__generate_c_arguments_25;
static void entry__generate_c_arguments_25(void);
static FRAME_INFO frame__generate_c_arguments_25 = {1, {"src"}};
static NODE *string__70e425abc2231c8d;
static void cont__generate_c_arguments_27(void);
static NODE *func__generate_c_arguments_28;
static void entry__generate_c_arguments_28(void);
static FRAME_INFO frame__generate_c_arguments_28 = {4, {"inputs_count", "idx", "src", "slot_idx"}};
static void cont__generate_c_arguments_29(void);
static NODE *func__generate_c_arguments_30;
static void entry__generate_c_arguments_30(void);
static FRAME_INFO frame__generate_c_arguments_30 = {1, {"idx"}};
static NODE *func__generate_c_arguments_31;
static void entry__generate_c_arguments_31(void);
static FRAME_INFO frame__generate_c_arguments_31 = {0, {}};
static NODE *string__4808b9f7f52b8767;
static void cont__generate_c_arguments_33(void);
static NODE *string__fd6b440801406c9;
static NODE *string__780af94b5f887d19;
static void cont__generate_c_arguments_36(void);
static void cont__generate_c_arguments_37(void);
static void cont__generate_c_arguments_38(void);
static NODE *func__get_func_and_myself;
static void entry__get_func_and_myself(void);
static FRAME_INFO frame__get_func_and_myself = {4, {"functor", "cont", "insertion_line", "insertion"}};
static NODE *func__get_func_and_myself_2;
static void entry__get_func_and_myself_2(void);
static FRAME_INFO frame__get_func_and_myself_2 = {2, {"indent", "insertion_line"}};
static void cont__get_func_and_myself_3(void);
static NODE *func__get_func_and_myself_4;
static void entry__get_func_and_myself_4(void);
static FRAME_INFO frame__get_func_and_myself_4 = {2, {"indent", "insertion_line"}};
static void cont__get_func_and_myself_5(void);
static void cont__get_func_and_myself_6(void);
static NODE *func__get_func_and_myself_7;
static void entry__get_func_and_myself_7(void);
static FRAME_INFO frame__get_func_and_myself_7 = {0, {}};
static void cont__get_func_and_myself_8(void);
static void cont__get_func_and_myself_9(void);
static NODE *string__8c93215920e16830;
static NODE *string__b99451f7c76bbc46;
static NODE *string__578a5af303e9ceb;
static void cont__get_func_and_myself_13(void);
static void cont__get_func_and_myself_14(void);
static NODE *string__6c9a2bd2e7c4af5;
static void cont__get_func_and_myself_16(void);
static void cont__get_func_and_myself_17(void);
static NODE *func__get_func_and_myself_18;
static void entry__get_func_and_myself_18(void);
static FRAME_INFO frame__get_func_and_myself_18 = {1, {"cont"}};
static NODE *string__7c88f48f8c83734e;
static void cont__get_func_and_myself_20(void);
static NODE *func__compiler__assignment_to_c;
static void entry__compiler__assignment_to_c(void);
static FRAME_INFO frame__compiler__assignment_to_c = {5, {"prefix", "destination", "src", "return", "dest"}};
static NODE *string__2d7981f4e6082be5;
static void cont__compiler__assignment_to_c_3(void);
static NODE *func__compiler__assignment_to_c_4;
static void entry__compiler__assignment_to_c_4(void);
static FRAME_INFO frame__compiler__assignment_to_c_4 = {4, {"destination", "return", "prefix", "src"}};
static void cont__compiler__assignment_to_c_5(void);
static NODE *func__compiler__assignment_to_c_6;
static void entry__compiler__assignment_to_c_6(void);
static FRAME_INFO frame__compiler__assignment_to_c_6 = {4, {"destination", "return", "prefix", "src"}};
static void cont__compiler__assignment_to_c_7(void);
static NODE *func__compiler__assignment_to_c_8;
static void entry__compiler__assignment_to_c_8(void);
static FRAME_INFO frame__compiler__assignment_to_c_8 = {4, {"return", "prefix", "destination", "src"}};
static void cont__compiler__assignment_to_c_9(void);
static NODE *string__b4b0e7de47027f92;
static void cont__compiler__assignment_to_c_11(void);
static NODE *func__compiler__assignment_to_c_12;
static void entry__compiler__assignment_to_c_12(void);
static FRAME_INFO frame__compiler__assignment_to_c_12 = {4, {"return", "prefix", "destination", "src"}};
static void cont__compiler__assignment_to_c_13(void);
static NODE *string__fa730415fc16bec;
static void cont__compiler__assignment_to_c_15(void);
static NODE *func__compiler__assignment_to_c_16;
static void entry__compiler__assignment_to_c_16(void);
static FRAME_INFO frame__compiler__assignment_to_c_16 = {4, {"destination", "return", "prefix", "src"}};
static void cont__compiler__assignment_to_c_17(void);
static NODE *func__compiler__assignment_to_c_18;
static void entry__compiler__assignment_to_c_18(void);
static FRAME_INFO frame__compiler__assignment_to_c_18 = {4, {"return", "prefix", "destination", "src"}};
static void cont__compiler__assignment_to_c_19(void);
static void cont__compiler__assignment_to_c_20(void);
static NODE *func__compiler__assignment_to_c_21;
static void entry__compiler__assignment_to_c_21(void);
static FRAME_INFO frame__compiler__assignment_to_c_21 = {5, {"destination", "return", "prefix", "src", "mangled_name"}};
static void cont__compiler__assignment_to_c_22(void);
static void cont__compiler__assignment_to_c_23(void);
static NODE *string__7280ac95052d00ff;
static NODE *string__578a5af303e9cc9;
static void cont__compiler__assignment_to_c_26(void);
static NODE *func__compiler__assignment_to_c_27;
static void entry__compiler__assignment_to_c_27(void);
static FRAME_INFO frame__compiler__assignment_to_c_27 = {5, {"destination", "return", "prefix", "src", "mangled_name"}};
static void cont__compiler__assignment_to_c_28(void);
static void cont__compiler__assignment_to_c_29(void);
static void cont__compiler__assignment_to_c_30(void);
static NODE *func__compiler__assignment_to_c_31;
static void entry__compiler__assignment_to_c_31(void);
static FRAME_INFO frame__compiler__assignment_to_c_31 = {4, {"return", "prefix", "mangled_name", "src"}};
static NODE *string__405aee03eb312008;
static void cont__compiler__assignment_to_c_33(void);
static NODE *func__compiler__assignment_to_c_34;
static void entry__compiler__assignment_to_c_34(void);
static FRAME_INFO frame__compiler__assignment_to_c_34 = {4, {"return", "prefix", "mangled_name", "src"}};
static void cont__compiler__assignment_to_c_35(void);
static void cont__compiler__assignment_to_c_36(void);
static void cont__compiler__assignment_to_c_37(void);
static NODE *string__c0ae80b5dc07d66;
static void cont__compiler__assignment_to_c_39(void);
static NODE *func__compiler__assignment_to_c_40;
static void entry__compiler__assignment_to_c_40(void);
static FRAME_INFO frame__compiler__assignment_to_c_40 = {3, {"prefix", "dest", "src"}};
static void cont__compiler__assignment_to_c_41(void);
static void cont__compiler__assignment_to_c_42(void);
static NODE *string__240ae80b5dc07d66;
static void cont__compiler__assignment_to_c_44(void);
static NODE *func__compiler__assignment_to_c_45;
static void entry__compiler__assignment_to_c_45(void);
static FRAME_INFO frame__compiler__assignment_to_c_45 = {3, {"prefix", "dest", "src"}};
static void cont__compiler__assignment_to_c_46(void);
static void cont__compiler__assignment_to_c_47(void);
static NODE *get__compiler__assignment_to_c(void) {
  return var.compiler__assignment_to_c;
}
static NODE *func__assign_argument_or_result;
static void entry__assign_argument_or_result(void);
static FRAME_INFO frame__assign_argument_or_result = {4, {"prefix", "kind", "destination", "src"}};
static void cont__assign_argument_or_result_2(void);
static NODE *func__assign_argument_or_result_3;
static void entry__assign_argument_or_result_3(void);
static FRAME_INFO frame__assign_argument_or_result_3 = {1, {"kind"}};
static NODE *string__64ac252603a3a696;
static void cont__assign_argument_or_result_5(void);
static void cont__assign_argument_or_result_6(void);
static NODE *func__assign_argument_or_result_7;
static void entry__assign_argument_or_result_7(void);
static FRAME_INFO frame__assign_argument_or_result_7 = {4, {"destination", "prefix", "src", "name"}};
static void cont__assign_argument_or_result_8(void);
static void cont__assign_argument_or_result_9(void);
static void cont__assign_argument_or_result_10(void);
static NODE *string__9d12bd49b1f09f10;
static NODE *string__ca5af8c3e89bc077;
static NODE *string__64bada731157029;
static void cont__assign_argument_or_result_14(void);
static NODE *func__assign_argument_or_result_15;
static void entry__assign_argument_or_result_15(void);
static FRAME_INFO frame__assign_argument_or_result_15 = {3, {"prefix", "destination", "src"}};
static void cont__assign_argument_or_result_16(void);
static NODE *func__extract;
static void entry__extract(void);
static FRAME_INFO frame__extract = {7, {"kind", "outputs", "fixed_count", "total_count", "right_count", "unlimited", "has_complex_default_values"}};
static NODE *func__extract_2;
static void entry__extract_2(void);
static FRAME_INFO frame__extract_2 = {6, {"output", "total_count", "has_complex_default_values", "unlimited", "fixed_count", "right_count"}};
static NODE *func__extract_3;
static void entry__extract_3(void);
static FRAME_INFO frame__extract_3 = {3, {"output", "total_count", "has_complex_default_values"}};
static void cont__extract_4(void);
static NODE *func__extract_5;
static void entry__extract_5(void);
static FRAME_INFO frame__extract_5 = {4, {"total_count", "output", "has_complex_default_values", "default_value"}};
static void cont__extract_6(void);
static void cont__extract_7(void);
static void cont__extract_8(void);
static NODE *func__extract_9;
static void entry__extract_9(void);
static FRAME_INFO frame__extract_9 = {1, {"default_value"}};
static void cont__extract_10(void);
static void cont__extract_11(void);
static NODE *func__extract_12;
static void entry__extract_12(void);
static FRAME_INFO frame__extract_12 = {1, {"has_complex_default_values"}};
static NODE *func__extract_13;
static void entry__extract_13(void);
static FRAME_INFO frame__extract_13 = {2, {"output", "unlimited"}};
static void cont__extract_14(void);
static NODE *func__extract_15;
static void entry__extract_15(void);
static FRAME_INFO frame__extract_15 = {1, {"unlimited"}};
static NODE *func__extract_16;
static void entry__extract_16(void);
static FRAME_INFO frame__extract_16 = {4, {"fixed_count", "total_count", "unlimited", "right_count"}};
static void cont__extract_17(void);
static void cont__extract_18(void);
static NODE *func__extract_19;
static void entry__extract_19(void);
static FRAME_INFO frame__extract_19 = {2, {"fixed_count", "total_count"}};
static void cont__extract_20(void);
static void cont__extract_21(void);
static NODE *func__extract_22;
static void entry__extract_22(void);
static FRAME_INFO frame__extract_22 = {1, {"right_count"}};
static void cont__extract_23(void);
static void cont__extract_24(void);
static NODE *func__extract_25;
static void entry__extract_25(void);
static FRAME_INFO frame__extract_25 = {2, {"fixed_count", "total_count"}};
static void cont__extract_26(void);
static void cont__extract_27(void);
static NODE *func__extract_28;
static void entry__extract_28(void);
static FRAME_INFO frame__extract_28 = {4, {"fixed_count", "kind", "unlimited", "total_count"}};
static void cont__extract_29(void);
static NODE *func__extract_30;
static void entry__extract_30(void);
static FRAME_INFO frame__extract_30 = {2, {"fixed_count", "kind"}};
static NODE *string__3a411e083dfe7a1;
static NODE *string__163aca4ea3526a62;
static NODE *string__46700f340c500fa1;
static void cont__extract_34(void);
static void cont__extract_35(void);
static NODE *func__extract_36;
static void entry__extract_36(void);
static FRAME_INFO frame__extract_36 = {2, {"total_count", "kind"}};
static NODE *string__3a411e083cfe7a1;
static NODE *string__5a751cd352200189;
static void cont__extract_39(void);
static NODE *func__extract_40;
static void entry__extract_40(void);
static FRAME_INFO frame__extract_40 = {2, {"fixed_count", "kind"}};
static NODE *string__8f0419bf3de01d00;
static NODE *string__23ec94223c989c2;
static void cont__extract_43(void);
static void cont__extract_44(void);
static NODE *string__984c0ed0151bf089;
static void cont__extract_46(void);
static NODE *func__extract_47;
static void entry__extract_47(void);
static FRAME_INFO frame__extract_47 = {1, {"unlimited"}};
static void cont__extract_48(void);
static NODE *func__extract_49;
static void entry__extract_49(void);
static FRAME_INFO frame__extract_49 = {0, {}};
static NODE *string__858e9ccf5a7e0845;
static void cont__extract_51(void);
static void cont__extract_52(void);
static NODE *func__extract_53;
static void entry__extract_53(void);
static FRAME_INFO frame__extract_53 = {6, {"idx", "outputs", "kind", "unlimited", "has_complex_default_values", "output"}};
static void cont__extract_54(void);
static void cont__extract_55(void);
static NODE *func__extract_56;
static void entry__extract_56(void);
static FRAME_INFO frame__extract_56 = {3, {"output", "unlimited", "has_complex_default_values"}};
static void cont__extract_57(void);
static NODE *func__extract_58;
static void entry__extract_58(void);
static FRAME_INFO frame__extract_58 = {2, {"unlimited", "has_complex_default_values"}};
static NODE *func__extract_59;
static void entry__extract_59(void);
static FRAME_INFO frame__extract_59 = {1, {"has_complex_default_values"}};
static void cont__extract_60(void);
static void cont__extract_61(void);
static void cont__extract_62(void);
static NODE *func__extract_63;
static void entry__extract_63(void);
static FRAME_INFO frame__extract_63 = {3, {"kind", "output", "idx"}};
static void cont__extract_64(void);
static NODE *string__f8fbbe9f15fa69de;
static NODE *string__578a5af303e9cbc;
static void cont__extract_67(void);
static void cont__extract_68(void);
static NODE *func__extract_69;
static void entry__extract_69(void);
static FRAME_INFO frame__extract_69 = {3, {"idx", "kind", "outputs"}};
static void cont__extract_70(void);
static void cont__extract_71(void);
static void cont__extract_72(void);
static NODE *string__41a90e180f1f464a;
static void cont__extract_74(void);
static void cont__extract_75(void);
static NODE *func__extract_76;
static void entry__extract_76(void);
static FRAME_INFO frame__extract_76 = {4, {"kind", "outputs", "total_count", "right_count"}};
static void cont__extract_77(void);
static void cont__extract_78(void);
static void cont__extract_79(void);
static void cont__extract_80(void);
static NODE *string__c641af060b3640ca;
static NODE *string__eb230bd48e24a88;
static NODE *string__578a5af303e9cc8;
static void cont__extract_84(void);
static void cont__extract_85(void);
static void cont__extract_86(void);
static NODE *func__extract_87;
static void entry__extract_87(void);
static FRAME_INFO frame__extract_87 = {7, {"total_count", "right_count", "fixed_count", "kind", "outputs", "has_complex_default_values", "indices"}};
static NODE *string__fcf46690a35325f6;
static void cont__extract_89(void);
static void cont__extract_90(void);
static void cont__extract_91(void);
static void cont__extract_92(void);
static NODE *func__extract_93;
static void entry__extract_93(void);
static FRAME_INFO frame__extract_93 = {7, {"idx", "right_count", "total_count", "kind", "outputs", "n", "cnt"}};
static void cont__extract_94(void);
static void cont__extract_95(void);
static NODE *func__extract_96;
static void entry__extract_96(void);
static FRAME_INFO frame__extract_96 = {1, {"n"}};
static NODE *string__485aefc3eae02077;
static void cont__extract_98(void);
static NODE *func__extract_99;
static void entry__extract_99(void);
static FRAME_INFO frame__extract_99 = {0, {}};
static NODE *string__b014089015daa08e;
static void cont__extract_101(void);
static NODE *string__820af94b5f607d19;
static NODE *string__2d7981f4e6d82be5;
static void cont__extract_104(void);
static void cont__extract_105(void);
static void cont__extract_106(void);
static void cont__extract_107(void);
static void cont__extract_108(void);
static NODE *string__6db0224cc22b4c85;
static NODE *string__3d141c30a0902819;
static void cont__extract_111(void);
static void cont__extract_112(void);
static NODE *func__extract_113;
static void entry__extract_113(void);
static FRAME_INFO frame__extract_113 = {6, {"total_count", "right_count", "fixed_count", "indices", "outputs", "kind"}};
static void cont__extract_114(void);
static void cont__extract_115(void);
static void cont__extract_116(void);
static NODE *func__extract_117;
static void entry__extract_117(void);
static FRAME_INFO frame__extract_117 = {6, {"idx", "right_count", "total_count", "indices", "n", "cnt"}};
static void cont__extract_118(void);
static void cont__extract_119(void);
static NODE *func__extract_120;
static void entry__extract_120(void);
static FRAME_INFO frame__extract_120 = {1, {"n"}};
static void cont__extract_121(void);
static NODE *func__extract_122;
static void entry__extract_122(void);
static FRAME_INFO frame__extract_122 = {0, {}};
static void cont__extract_123(void);
static void cont__extract_124(void);
static void cont__extract_125(void);
static NODE *string__3d6fbe7ddbf3d274;
static NODE *string__578a5af303e9cbe;
static NODE *string__1392ca21613062f7;
static void cont__extract_129(void);
static void cont__extract_130(void);
static NODE *string__336c1dff155460f0;
static void cont__extract_132(void);
static void cont__extract_133(void);
static void cont__extract_134(void);
static void cont__extract_135(void);
static void cont__extract_136(void);
static NODE *func__extract_137;
static void entry__extract_137(void);
static FRAME_INFO frame__extract_137 = {8, {"idx", "outputs", "kind", "indices", "right_count", "output", "default_value", "cont_idx"}};
static void cont__extract_138(void);
static void cont__extract_139(void);
static void cont__extract_140(void);
static NODE *func__extract_141;
static void entry__extract_141(void);
static FRAME_INFO frame__extract_141 = {3, {"default_value", "output", "kind"}};
static void cont__extract_142(void);
static NODE *func__extract_143;
static void entry__extract_143(void);
static FRAME_INFO frame__extract_143 = {1, {"output"}};
static void cont__extract_144(void);
static NODE *func__extract_145;
static void entry__extract_145(void);
static FRAME_INFO frame__extract_145 = {1, {"statement"}};
static NODE *func__extract_146;
static void entry__extract_146(void);
static FRAME_INFO frame__extract_146 = {3, {"kind", "output", "default_value"}};
static void cont__extract_147(void);
static NODE *func__extract_148;
static void entry__extract_148(void);
static FRAME_INFO frame__extract_148 = {2, {"kind", "output"}};
static NODE *string__7ca0252e172b1501;
static void cont__extract_150(void);
static void cont__extract_151(void);
static void cont__extract_152(void);
static NODE *string__456a7fcebab856fe;
static NODE *string__b40af3cb5d887d33;
static void cont__extract_155(void);
static void cont__extract_156(void);
static NODE *string__40aea8b5d107d4d;
static void cont__extract_158(void);
static NODE *func__extract_159;
static void entry__extract_159(void);
static FRAME_INFO frame__extract_159 = {5, {"fixed_count", "right_count", "total_count", "outputs", "kind"}};
static void cont__extract_160(void);
static void cont__extract_161(void);
static void cont__extract_162(void);
static NODE *func__extract_163;
static void entry__extract_163(void);
static FRAME_INFO frame__extract_163 = {7, {"idx", "outputs", "right_count", "kind", "output", "default_value", "value"}};
static void cont__extract_164(void);
static void cont__extract_165(void);
static void cont__extract_166(void);
static NODE *func__extract_167;
static void entry__extract_167(void);
static FRAME_INFO frame__extract_167 = {1, {"default_value"}};
static void cont__extract_168(void);
static NODE *func__extract_169;
static void entry__extract_169(void);
static FRAME_INFO frame__extract_169 = {0, {}};
static void cont__extract_170(void);
static void cont__extract_171(void);
static void cont__extract_172(void);
static void cont__extract_173(void);
static void cont__extract_174(void);
static NODE *string__820af94b5d887d33;
static NODE *func__write_as_remark;
static void entry__write_as_remark(void);
static FRAME_INFO frame__write_as_remark = {1, {"str"}};
static NODE *string__d81f45b583c652f7;
static void cont__write_as_remark_3(void);
static void cont__write_as_remark_4(void);
static NODE *string__ca5af8c3e8b41077;
static NODE *func__compute_column_no;
static void entry__compute_column_no(void);
static FRAME_INFO frame__compute_column_no = {2, {"str", "i"}};
static void cont__compute_column_no_2(void);
static NODE *func__compute_column_no_3;
static void entry__compute_column_no_3(void);
static FRAME_INFO frame__compute_column_no_3 = {2, {"str", "i"}};
static void cont__compute_column_no_4(void);
static void cont__compute_column_no_5(void);
static void cont__compute_column_no_6(void);
static NODE *func__compute_column_no_7;
static void entry__compute_column_no_7(void);
static FRAME_INFO frame__compute_column_no_7 = {2, {"str", "i"}};
static void cont__compute_column_no_8(void);
static void cont__compute_column_no_9(void);
static void cont__compute_column_no_10(void);
static void cont__compute_column_no_11(void);
static NODE *func__compute_column_no_12;
static void entry__compute_column_no_12(void);
static FRAME_INFO frame__compute_column_no_12 = {1, {"i"}};
static void cont__compute_column_no_13(void);
static void cont__compute_column_no_14(void);
static void cont__compute_column_no_15(void);
static NODE *func__compute_source_text_info;
static void entry__compute_source_text_info(void);
static FRAME_INFO frame__compute_source_text_info = {17, {"node", "print_remark", "is_an_exit", "fragment", "fragment_source", "offset", "pos", "prefix", "fragment_line_no", "indents", "line_no", "column_no", "source", "last_line_no", "last_column_no", "submodule_no", "continuation_info"}};
static void cont__compute_source_text_info_2(void);
static void cont__compute_source_text_info_3(void);
static void cont__compute_source_text_info_4(void);
static void cont__compute_source_text_info_5(void);
static void cont__compute_source_text_info_6(void);
static void cont__compute_source_text_info_7(void);
static void cont__compute_source_text_info_8(void);
static void cont__compute_source_text_info_9(void);
static void cont__compute_source_text_info_10(void);
static void cont__compute_source_text_info_11(void);
static void cont__compute_source_text_info_12(void);
static void cont__compute_source_text_info_13(void);
static void cont__compute_source_text_info_14(void);
static void cont__compute_source_text_info_15(void);
static NODE *func__compute_source_text_info_16;
static void entry__compute_source_text_info_16(void);
static FRAME_INFO frame__compute_source_text_info_16 = {3, {"prefix", "indents", "line_no"}};
static void cont__compute_source_text_info_17(void);
static void cont__compute_source_text_info_18(void);
static void cont__compute_source_text_info_19(void);
static NODE *func__compute_source_text_info_20;
static void entry__compute_source_text_info_20(void);
static FRAME_INFO frame__compute_source_text_info_20 = {1, {"prefix"}};
static void cont__compute_source_text_info_21(void);
static void cont__compute_source_text_info_22(void);
static void cont__compute_source_text_info_23(void);
static void cont__compute_source_text_info_24(void);
static void cont__compute_source_text_info_25(void);
static void cont__compute_source_text_info_26(void);
static void cont__compute_source_text_info_27(void);
static void cont__compute_source_text_info_28(void);
static void cont__compute_source_text_info_29(void);
static void cont__compute_source_text_info_30(void);
static void cont__compute_source_text_info_31(void);
static void cont__compute_source_text_info_32(void);
static void cont__compute_source_text_info_33(void);
static void cont__compute_source_text_info_34(void);
static void cont__compute_source_text_info_35(void);
static NODE *func__compute_source_text_info_36;
static void entry__compute_source_text_info_36(void);
static FRAME_INFO frame__compute_source_text_info_36 = {3, {"source", "indents", "last_line_no"}};
static void cont__compute_source_text_info_37(void);
static void cont__compute_source_text_info_38(void);
static void cont__compute_source_text_info_39(void);
static void cont__compute_source_text_info_40(void);
static NODE *func__compute_source_text_info_41;
static void entry__compute_source_text_info_41(void);
static FRAME_INFO frame__compute_source_text_info_41 = {2, {"column_no", "source"}};
static void cont__compute_source_text_info_42(void);
static void cont__compute_source_text_info_43(void);
static void cont__compute_source_text_info_44(void);
static void cont__compute_source_text_info_45(void);
static void cont__compute_source_text_info_46(void);
static void cont__compute_source_text_info_47(void);
static void cont__compute_source_text_info_48(void);
static NODE *func__compute_source_text_info_49;
static void entry__compute_source_text_info_49(void);
static FRAME_INFO frame__compute_source_text_info_49 = {4, {"line_no", "last_line_no", "column_no", "last_column_no"}};
static void cont__compute_source_text_info_50(void);
static void cont__compute_source_text_info_51(void);
static void cont__compute_source_text_info_52(void);
static NODE *func__compute_source_text_info_53;
static void entry__compute_source_text_info_53(void);
static FRAME_INFO frame__compute_source_text_info_53 = {1, {"fragment"}};
static void cont__compute_source_text_info_54(void);
static void cont__compute_source_text_info_55(void);
static NODE *func__compute_source_text_info_56;
static void entry__compute_source_text_info_56(void);
static FRAME_INFO frame__compute_source_text_info_56 = {0, {}};
static void cont__compute_source_text_info_57(void);
static void cont__compute_source_text_info_58(void);
static NODE *func__compute_source_text_info_59;
static void entry__compute_source_text_info_59(void);
static FRAME_INFO frame__compute_source_text_info_59 = {8, {"line_no", "last_line_no", "prefix", "source", "indent", "do_print_dots", "width", "write_line_start"}};
static NODE *func__compute_source_text_info_60;
static void entry__compute_source_text_info_60(void);
static FRAME_INFO frame__compute_source_text_info_60 = {3, {"line_no", "width", "indent"}};
static void cont__compute_source_text_info_61(void);
static void cont__compute_source_text_info_62(void);
static void cont__compute_source_text_info_63(void);
static void cont__compute_source_text_info_64(void);
static void cont__compute_source_text_info_65(void);
static void cont__compute_source_text_info_66(void);
static void cont__compute_source_text_info_67(void);
static void cont__compute_source_text_info_68(void);
static NODE *func__compute_source_text_info_69;
static void entry__compute_source_text_info_69(void);
static FRAME_INFO frame__compute_source_text_info_69 = {3, {"last_line_no", "line_no", "do_print_dots"}};
static void cont__compute_source_text_info_70(void);
static void cont__compute_source_text_info_71(void);
static void cont__compute_source_text_info_72(void);
static void cont__compute_source_text_info_73(void);
static void cont__compute_source_text_info_74(void);
static void cont__compute_source_text_info_75(void);
static NODE *func__compute_source_text_info_76;
static void entry__compute_source_text_info_76(void);
static FRAME_INFO frame__compute_source_text_info_76 = {1, {"prefix"}};
static void cont__compute_source_text_info_77(void);
static void cont__compute_source_text_info_78(void);
static void cont__compute_source_text_info_79(void);
static void cont__compute_source_text_info_80(void);
static NODE *func__compute_source_text_info_81;
static void entry__compute_source_text_info_81(void);
static FRAME_INFO frame__compute_source_text_info_81 = {1, {"prefix"}};
static void cont__compute_source_text_info_82(void);
static void cont__compute_source_text_info_83(void);
static void cont__compute_source_text_info_84(void);
static void cont__compute_source_text_info_85(void);
static void cont__compute_source_text_info_86(void);
static void cont__compute_source_text_info_87(void);
static NODE *func__compute_source_text_info_88;
static void entry__compute_source_text_info_88(void);
static FRAME_INFO frame__compute_source_text_info_88 = {1, {"source"}};
static NODE *string__9e0afacb5f107d19;
static void cont__compute_source_text_info_90(void);
static void cont__compute_source_text_info_91(void);
static void cont__compute_source_text_info_92(void);
static void cont__compute_source_text_info_93(void);
static void cont__compute_source_text_info_94(void);
static NODE *func__compute_source_text_info_95;
static void entry__compute_source_text_info_95(void);
static FRAME_INFO frame__compute_source_text_info_95 = {1, {"source"}};
static void cont__compute_source_text_info_96(void);
static void cont__compute_source_text_info_97(void);
static void cont__compute_source_text_info_98(void);
static NODE *func__compute_source_text_info_99;
static void entry__compute_source_text_info_99(void);
static FRAME_INFO frame__compute_source_text_info_99 = {7, {"break", "source", "indent", "last_line_no", "line_no", "write_line_start", "do_print_dots"}};
static NODE *func__compute_source_text_info_100;
static void entry__compute_source_text_info_100(void);
static FRAME_INFO frame__compute_source_text_info_100 = {8, {"idx", "chr", "indent", "last_line_no", "line_no", "write_line_start", "do_print_dots", "break"}};
static void cont__compute_source_text_info_101(void);
static NODE *func__compute_source_text_info_102;
static void entry__compute_source_text_info_102(void);
static FRAME_INFO frame__compute_source_text_info_102 = {7, {"chr", "indent", "last_line_no", "line_no", "write_line_start", "do_print_dots", "break"}};
static void cont__compute_source_text_info_103(void);
static NODE *func__compute_source_text_info_104;
static void entry__compute_source_text_info_104(void);
static FRAME_INFO frame__compute_source_text_info_104 = {1, {"indent"}};
static void cont__compute_source_text_info_105(void);
static void cont__compute_source_text_info_106(void);
static void cont__compute_source_text_info_107(void);
static void cont__compute_source_text_info_108(void);
static void cont__compute_source_text_info_109(void);
static NODE *func__compute_source_text_info_110;
static void entry__compute_source_text_info_110(void);
static FRAME_INFO frame__compute_source_text_info_110 = {2, {"do_print_dots", "break"}};
static NODE *func__compute_source_text_info_111;
static void entry__compute_source_text_info_111(void);
static FRAME_INFO frame__compute_source_text_info_111 = {0, {}};
static NODE *string__ef94be7186a1680e;
static void cont__compute_source_text_info_113(void);
static NODE *func__compute_source_text_info_114;
static void entry__compute_source_text_info_114(void);
static FRAME_INFO frame__compute_source_text_info_114 = {1, {"indent"}};
static void cont__compute_source_text_info_115(void);
static NODE *func__compute_source_text_info_116;
static void entry__compute_source_text_info_116(void);
static FRAME_INFO frame__compute_source_text_info_116 = {1, {"chr"}};
static void cont__compute_source_text_info_117(void);
static void cont__compute_source_text_info_118(void);
static NODE *func__compiler__write_source_as_remark;
static void entry__compiler__write_source_as_remark(void);
static FRAME_INFO frame__compiler__write_source_as_remark = {1, {"node"}};
static void cont__compiler__write_source_as_remark_2(void);
static void cont__compiler__write_source_as_remark_3(void);
static NODE *func__compiler__write_source_as_remark_4;
static void entry__compiler__write_source_as_remark_4(void);
static FRAME_INFO frame__compiler__write_source_as_remark_4 = {1, {"node"}};
static void cont__compiler__write_source_as_remark_5(void);
static NODE *get__compiler__write_source_as_remark(void) {
  return var.compiler__write_source_as_remark;
}
static NODE *func__get_kind;
static void entry__get_kind(void);
static FRAME_INFO frame__get_kind = {2, {"source", "return"}};
static NODE *func__get_kind_2;
static void entry__get_kind_2(void);
static FRAME_INFO frame__get_kind_2 = {2, {"source", "return"}};
static void cont__get_kind_3(void);
static NODE *func__get_kind_4;
static void entry__get_kind_4(void);
static FRAME_INFO frame__get_kind_4 = {1, {"return"}};
static NODE *unique__EARLY;
static NODE *func__get_kind_5;
static void entry__get_kind_5(void);
static FRAME_INFO frame__get_kind_5 = {2, {"source", "return"}};
static void cont__get_kind_6(void);
static NODE *func__get_kind_7;
static void entry__get_kind_7(void);
static FRAME_INFO frame__get_kind_7 = {1, {"return"}};
static NODE *unique__STANDARD;
static NODE *func__get_kind_8;
static void entry__get_kind_8(void);
static FRAME_INFO frame__get_kind_8 = {3, {"source", "return", "name"}};
static void cont__get_kind_9(void);
static NODE *func__get_kind_10;
static void entry__get_kind_10(void);
static FRAME_INFO frame__get_kind_10 = {2, {"name", "return"}};
static void cont__get_kind_11(void);
static void cont__get_kind_12(void);
static NODE *func__get_kind_13;
static void entry__get_kind_13(void);
static FRAME_INFO frame__get_kind_13 = {2, {"return", "name"}};
static void cont__get_kind_14(void);
static NODE *func__get_kind_15;
static void entry__get_kind_15(void);
static FRAME_INFO frame__get_kind_15 = {0, {}};
static NODE *func__get_kind_16;
static void entry__get_kind_16(void);
static FRAME_INFO frame__get_kind_16 = {0, {}};
static void cont__get_kind_17(void);
static NODE *func__get_kind_18;
static void entry__get_kind_18(void);
static FRAME_INFO frame__get_kind_18 = {2, {"name", "return"}};
static void cont__get_kind_19(void);
static void cont__get_kind_20(void);
static NODE *func__get_kind_21;
static void entry__get_kind_21(void);
static FRAME_INFO frame__get_kind_21 = {2, {"name", "return"}};
static void cont__get_kind_22(void);
static void cont__get_kind_23(void);
static NODE *func__get_kind_24;
static void entry__get_kind_24(void);
static FRAME_INFO frame__get_kind_24 = {1, {"return"}};
static NODE *unique__UNKNOWN;
static void cont__get_kind_25(void);
static NODE *func__get_kind_26;
static void entry__get_kind_26(void);
static FRAME_INFO frame__get_kind_26 = {1, {"return"}};
static NODE *func__get_kind_27;
static void entry__get_kind_27(void);
static FRAME_INFO frame__get_kind_27 = {1, {"return"}};
static NODE *func__get_kind_28;
static void entry__get_kind_28(void);
static FRAME_INFO frame__get_kind_28 = {4, {"source", "name", "return", "variable_kind"}};
static void cont__get_kind_29(void);
static void cont__get_kind_30(void);
static NODE *func__get_kind_31;
static void entry__get_kind_31(void);
static FRAME_INFO frame__get_kind_31 = {1, {"source"}};
static void cont__get_kind_32(void);
static void cont__get_kind_33(void);
static void cont__get_kind_34(void);
static void cont__get_kind_35(void);
static void cont__get_kind_36(void);
static NODE *func__get_kind_37;
static void entry__get_kind_37(void);
static FRAME_INFO frame__get_kind_37 = {1, {"name"}};
static void cont__get_kind_38(void);
static void cont__get_kind_39(void);
static void cont__get_kind_40(void);
static void cont__get_kind_41(void);
static NODE *func__get_kind_42;
static void entry__get_kind_42(void);
static FRAME_INFO frame__get_kind_42 = {1, {"return"}};
static NODE *func__get_kind_43;
static void entry__get_kind_43(void);
static FRAME_INFO frame__get_kind_43 = {1, {"return"}};
static void cont__get_kind_44(void);
static NODE *func__types__grammar_node___to_c;
static void entry__types__grammar_node___to_c(void);
static FRAME_INFO frame__types__grammar_node___to_c = {1, {"self"}};
static NODE *string__bce93a997a35ab67;
static void cont__types__grammar_node___to_c_3(void);
static NODE *string__fa737815fd16bf3;
static NODE *func__compiler__body___to_c;
static void entry__compiler__body___to_c(void);
static FRAME_INFO frame__compiler__body___to_c = {8, {"self", "return", "outer_level", "parent_locals", "is_an_inherited_shared_local", "body_name", "body_suffix", "par_count"}};
static NODE *string__463afb92a66256b1;
static void cont__compiler__body___to_c_3(void);
static void cont__compiler__body___to_c_4(void);
static void cont__compiler__body___to_c_5(void);
static NODE *func__compiler__body__to_c_6;
static void entry__compiler__body__to_c_6(void);
static FRAME_INFO frame__compiler__body__to_c_6 = {1, {"body_name"}};
static void cont__compiler__body__to_c_7(void);
static NODE *func__compiler__body__to_c_8;
static void entry__compiler__body__to_c_8(void);
static FRAME_INFO frame__compiler__body__to_c_8 = {0, {}};
static void cont__compiler__body__to_c_9(void);
static void cont__compiler__body__to_c_10(void);
static void cont__compiler__body___to_c_11(void);
static void cont__compiler__body___to_c_12(void);
static NODE *func__compiler__body__to_c_13;
static void entry__compiler__body__to_c_13(void);
static FRAME_INFO frame__compiler__body__to_c_13 = {2, {"return", "body_suffix"}};
static NODE *string__e0aec0b5d107d5a;
static void cont__compiler__body__to_c_15(void);
static void cont__compiler__body___to_c_16(void);
static void cont__compiler__body___to_c_17(void);
static void cont__compiler__body___to_c_18(void);
static NODE *func__compiler__body__to_c_19;
static void entry__compiler__body__to_c_19(void);
static FRAME_INFO frame__compiler__body__to_c_19 = {1, {"body_suffix"}};
static NODE *func__compiler__body__to_c_20;
static void entry__compiler__body__to_c_20(void);
static FRAME_INFO frame__compiler__body__to_c_20 = {0, {}};
static void cont__compiler__body___to_c_21(void);
static NODE *func__compiler__body__to_c_22;
static void entry__compiler__body__to_c_22(void);
static FRAME_INFO frame__compiler__body__to_c_22 = {26, {"return__2", "outer_level", "self", "par_count", "is_an_inherited_shared_local", "body_suffix", "parent_locals", "slot_idx", "locals", "is_shared", "min_par_cnt", "max_par_cnt", "right_par_cnt", "has_rest_parameter", "has_complex_default_values", "myself_parameter", "continuation_parameter", "input_parameters", "output_parameters", "implicit_parameters", "locals_idx", "total_slots", "extract_destination_and_source", "extract_source_or_create_future", "statements", "generate_exit"}};
static NODE *func__compiler__body__to_c_23;
static void entry__compiler__body__to_c_23(void);
static FRAME_INFO frame__compiler__body__to_c_23 = {3, {"definition", "destination", "source"}};
static void cont__compiler__body__to_c_24(void);
static NODE *func__compiler__body__to_c_25;
static void entry__compiler__body__to_c_25(void);
static FRAME_INFO frame__compiler__body__to_c_25 = {1, {"definition"}};
static void cont__compiler__body__to_c_26(void);
static NODE *func__compiler__body__to_c_27;
static void entry__compiler__body__to_c_27(void);
static FRAME_INFO frame__compiler__body__to_c_27 = {1, {"definition"}};
static void cont__compiler__body__to_c_28(void);
static void cont__compiler__body__to_c_29(void);
static NODE *func__compiler__body__to_c_30;
static void entry__compiler__body__to_c_30(void);
static FRAME_INFO frame__compiler__body__to_c_30 = {1, {"definition"}};
static void cont__compiler__body__to_c_31(void);
static NODE *func__compiler__body__to_c_32;
static void entry__compiler__body__to_c_32(void);
static FRAME_INFO frame__compiler__body__to_c_32 = {0, {}};
static void cont__compiler__body__to_c_33(void);
static NODE *func__compiler__body__to_c_34;
static void entry__compiler__body__to_c_34(void);
static FRAME_INFO frame__compiler__body__to_c_34 = {1, {"source"}};
static void cont__compiler__body__to_c_35(void);
static NODE *func__compiler__body__to_c_36;
static void entry__compiler__body__to_c_36(void);
static FRAME_INFO frame__compiler__body__to_c_36 = {1, {"source"}};
static void cont__compiler__body__to_c_37(void);
static NODE *func__compiler__body__to_c_38;
static void entry__compiler__body__to_c_38(void);
static FRAME_INFO frame__compiler__body__to_c_38 = {1, {"source"}};
static void cont__compiler__body__to_c_39(void);
static NODE *string__7f76cf7c934307b4;
static NODE *string__2d7981f4e6482bec;
static void cont__compiler__body__to_c_42(void);
static NODE *func__compiler__body__to_c_43;
static void entry__compiler__body__to_c_43(void);
static FRAME_INFO frame__compiler__body__to_c_43 = {1, {"source"}};
static void cont__compiler__body__to_c_44(void);
static NODE *func__compiler__body__to_c_45;
static void entry__compiler__body__to_c_45(void);
static FRAME_INFO frame__compiler__body__to_c_45 = {0, {}};
static NODE *string__3e418beaa4f754e1;
static NODE *func__compiler__body__to_c_47;
static void entry__compiler__body__to_c_47(void);
static FRAME_INFO frame__compiler__body__to_c_47 = {0, {}};
static NODE *func__compiler__body__to_c_48;
static void entry__compiler__body__to_c_48(void);
static FRAME_INFO frame__compiler__body__to_c_48 = {3, {"self", "continuation_parameter", "output_parameters"}};
static void cont__compiler__body__to_c_49(void);
static NODE *func__compiler__body__to_c_50;
static void entry__compiler__body__to_c_50(void);
static FRAME_INFO frame__compiler__body__to_c_50 = {1, {"continuation_parameter"}};
static void cont__compiler__body__to_c_51(void);
static NODE *func__compiler__body__to_c_52;
static void entry__compiler__body__to_c_52(void);
static FRAME_INFO frame__compiler__body__to_c_52 = {1, {"continuation_parameter"}};
static void cont__compiler__body__to_c_53(void);
static void cont__compiler__body__to_c_54(void);
static void cont__compiler__body__to_c_55(void);
static void cont__compiler__body__to_c_56(void);
static NODE *func__compiler__body__to_c_57;
static void entry__compiler__body__to_c_57(void);
static FRAME_INFO frame__compiler__body__to_c_57 = {1, {"continuation_parameter"}};
static void cont__compiler__body__to_c_58(void);
static NODE *string__ed9510e8330beabe;
static NODE *string__53a8ae7fafe9c367;
static void cont__compiler__body__to_c_61(void);
static NODE *func__compiler__body__to_c_62;
static void entry__compiler__body__to_c_62(void);
static FRAME_INFO frame__compiler__body__to_c_62 = {2, {"self", "output_parameters"}};
static void cont__compiler__body__to_c_63(void);
static void cont__compiler__body__to_c_64(void);
static NODE *string__b30064368698509a;
static void cont__compiler__body__to_c_66(void);
static void cont__compiler__body__to_c_67(void);
static NODE *func__compiler__body__to_c_68;
static void entry__compiler__body__to_c_68(void);
static FRAME_INFO frame__compiler__body__to_c_68 = {7, {"parameter", "has_complex_default_values", "output_parameters", "input_parameters", "implicit_parameters", "kind", "default_value"}};
static void cont__compiler__body__to_c_69(void);
static void cont__compiler__body__to_c_70(void);
static void cont__compiler__body__to_c_71(void);
static NODE *func__compiler__body__to_c_72;
static void entry__compiler__body__to_c_72(void);
static FRAME_INFO frame__compiler__body__to_c_72 = {1, {"default_value"}};
static void cont__compiler__body__to_c_73(void);
static void cont__compiler__body__to_c_74(void);
static NODE *func__compiler__body__to_c_75;
static void entry__compiler__body__to_c_75(void);
static FRAME_INFO frame__compiler__body__to_c_75 = {1, {"has_complex_default_values"}};
static void cont__compiler__body__to_c_76(void);
static NODE *func__compiler__body__to_c_77;
static void entry__compiler__body__to_c_77(void);
static FRAME_INFO frame__compiler__body__to_c_77 = {2, {"output_parameters", "parameter"}};
static void cont__compiler__body__to_c_78(void);
static NODE *func__compiler__body__to_c_79;
static void entry__compiler__body__to_c_79(void);
static FRAME_INFO frame__compiler__body__to_c_79 = {3, {"input_parameters", "parameter", "output_parameters"}};
static void cont__compiler__body__to_c_80(void);
static void cont__compiler__body__to_c_81(void);
static void cont__compiler__body__to_c_82(void);
static NODE *func__compiler__body__to_c_83;
static void entry__compiler__body__to_c_83(void);
static FRAME_INFO frame__compiler__body__to_c_83 = {2, {"implicit_parameters", "parameter"}};
static void cont__compiler__body__to_c_84(void);
static NODE *func__compiler__body__to_c_85;
static void entry__compiler__body__to_c_85(void);
static FRAME_INFO frame__compiler__body__to_c_85 = {2, {"input_parameters", "parameter"}};
static void cont__compiler__body__to_c_86(void);
static void cont__compiler__body__to_c_87(void);
static NODE *func__compiler__body__to_c_88;
static void entry__compiler__body__to_c_88(void);
static FRAME_INFO frame__compiler__body__to_c_88 = {9, {"parameter", "max_par_cnt", "has_rest_parameter", "min_par_cnt", "right_par_cnt", "locals", "slot_idx", "is_shared", "name"}};
static void cont__compiler__body__to_c_89(void);
static void cont__compiler__body__to_c_90(void);
static NODE *func__compiler__body__to_c_91;
static void entry__compiler__body__to_c_91(void);
static FRAME_INFO frame__compiler__body__to_c_91 = {2, {"parameter", "max_par_cnt"}};
static void cont__compiler__body__to_c_92(void);
static NODE *func__compiler__body__to_c_93;
static void entry__compiler__body__to_c_93(void);
static FRAME_INFO frame__compiler__body__to_c_93 = {1, {"max_par_cnt"}};
static void cont__compiler__body__to_c_94(void);
static NODE *func__compiler__body__to_c_95;
static void entry__compiler__body__to_c_95(void);
static FRAME_INFO frame__compiler__body__to_c_95 = {2, {"parameter", "has_rest_parameter"}};
static void cont__compiler__body__to_c_96(void);
static NODE *func__compiler__body__to_c_97;
static void entry__compiler__body__to_c_97(void);
static FRAME_INFO frame__compiler__body__to_c_97 = {1, {"has_rest_parameter"}};
static NODE *func__compiler__body__to_c_98;
static void entry__compiler__body__to_c_98(void);
static FRAME_INFO frame__compiler__body__to_c_98 = {3, {"min_par_cnt", "max_par_cnt", "right_par_cnt"}};
static void cont__compiler__body__to_c_99(void);
static void cont__compiler__body__to_c_100(void);
static void cont__compiler__body__to_c_101(void);
static NODE *func__compiler__body__to_c_102;
static void entry__compiler__body__to_c_102(void);
static FRAME_INFO frame__compiler__body__to_c_102 = {1, {"right_par_cnt"}};
static void cont__compiler__body__to_c_103(void);
static void cont__compiler__body__to_c_104(void);
static void cont__compiler__body__to_c_105(void);
static void cont__compiler__body__to_c_106(void);
static void cont__compiler__body__to_c_107(void);
static void cont__compiler__body__to_c_108(void);
static void cont__compiler__body__to_c_109(void);
static NODE *func__compiler__body__to_c_110;
static void entry__compiler__body__to_c_110(void);
static FRAME_INFO frame__compiler__body__to_c_110 = {7, {"parameter", "myself_parameter", "continuation_parameter", "locals", "slot_idx", "is_shared", "name"}};
static void cont__compiler__body__to_c_111(void);
static void cont__compiler__body__to_c_112(void);
static void cont__compiler__body__to_c_113(void);
static NODE *func__compiler__body__to_c_114;
static void entry__compiler__body__to_c_114(void);
static FRAME_INFO frame__compiler__body__to_c_114 = {2, {"myself_parameter", "parameter"}};
static NODE *func__compiler__body__to_c_115;
static void entry__compiler__body__to_c_115(void);
static FRAME_INFO frame__compiler__body__to_c_115 = {2, {"continuation_parameter", "parameter"}};
static void cont__compiler__body__to_c_116(void);
static void cont__compiler__body__to_c_117(void);
static void cont__compiler__body__to_c_118(void);
static void cont__compiler__body__to_c_119(void);
static void cont__compiler__body__to_c_120(void);
static void cont__compiler__body__to_c_121(void);
static NODE *func__compiler__body__to_c_122;
static void entry__compiler__body__to_c_122(void);
static FRAME_INFO frame__compiler__body__to_c_122 = {2, {"max_par_cnt", "min_par_cnt"}};
static void cont__compiler__body__to_c_123(void);
static void cont__compiler__body__to_c_124(void);
static void cont__compiler__body__to_c_125(void);
static NODE *func__compiler__body__to_c_126;
static void entry__compiler__body__to_c_126(void);
static FRAME_INFO frame__compiler__body__to_c_126 = {1, {"max_par_cnt"}};
static NODE *func__compiler__body__to_c_127;
static void entry__compiler__body__to_c_127(void);
static FRAME_INFO frame__compiler__body__to_c_127 = {0, {}};
static void cont__compiler__body__to_c_128(void);
static void cont__compiler__body__to_c_129(void);
static void cont__compiler__body__to_c_130(void);
static NODE *func__compiler__body__to_c_131;
static void entry__compiler__body__to_c_131(void);
static FRAME_INFO frame__compiler__body__to_c_131 = {6, {"name", "info", "locals", "slot_idx", "is_shared", "is_an_inherited_shared_local"}};
static void cont__compiler__body__to_c_132(void);
static void cont__compiler__body__to_c_133(void);
static void cont__compiler__body__to_c_134(void);
static void cont__compiler__body__to_c_135(void);
static void cont__compiler__body__to_c_136(void);
static void cont__compiler__body__to_c_137(void);
static NODE *func__compiler__body__to_c_138;
static void entry__compiler__body__to_c_138(void);
static FRAME_INFO frame__compiler__body__to_c_138 = {5, {"name", "info", "locals", "slot_idx", "is_shared"}};
static void cont__compiler__body__to_c_139(void);
static NODE *func__compiler__body__to_c_140;
static void entry__compiler__body__to_c_140(void);
static FRAME_INFO frame__compiler__body__to_c_140 = {1, {"info"}};
static void cont__compiler__body__to_c_141(void);
static void cont__compiler__body__to_c_142(void);
static void cont__compiler__body__to_c_143(void);
static void cont__compiler__body__to_c_144(void);
static NODE *func__compiler__body__to_c_145;
static void entry__compiler__body__to_c_145(void);
static FRAME_INFO frame__compiler__body__to_c_145 = {5, {"locals", "name", "slot_idx", "is_shared", "info"}};
static void cont__compiler__body__to_c_146(void);
static void cont__compiler__body__to_c_147(void);
static void cont__compiler__body__to_c_148(void);
static void cont__compiler__body__to_c_149(void);
static void cont__compiler__body__to_c_150(void);
static void cont__compiler__body__to_c_151(void);
static void cont__compiler__body__to_c_152(void);
static NODE *string__6b846eb6691a1cd5;
static void cont__compiler__body__to_c_154(void);
static void cont__compiler__body__to_c_155(void);
static NODE *func__compiler__body__to_c_156;
static void entry__compiler__body__to_c_156(void);
static FRAME_INFO frame__compiler__body__to_c_156 = {2, {"return__1", "body_suffix"}};
static NODE *string__565aee03ea58402e;
static void cont__compiler__body__to_c_158(void);
static void cont__compiler__body__to_c_159(void);
static void cont__compiler__body__to_c_160(void);
static NODE *func__compiler__body__to_c_161;
static void entry__compiler__body__to_c_161(void);
static FRAME_INFO frame__compiler__body__to_c_161 = {1, {"has_complex_default_values"}};
static void cont__compiler__body__to_c_162(void);
static NODE *func__compiler__body__to_c_163;
static void entry__compiler__body__to_c_163(void);
static FRAME_INFO frame__compiler__body__to_c_163 = {0, {}};
static NODE *string__e67ad3f0422c2c7e;
static void cont__compiler__body__to_c_165(void);
static void cont__compiler__body__to_c_166(void);
static NODE *func__compiler__body__to_c_167;
static void entry__compiler__body__to_c_167(void);
static FRAME_INFO frame__compiler__body__to_c_167 = {1, {"continuation_parameter"}};
static void cont__compiler__body__to_c_168(void);
static void cont__compiler__body__to_c_169(void);
static NODE *func__compiler__body__to_c_170;
static void entry__compiler__body__to_c_170(void);
static FRAME_INFO frame__compiler__body__to_c_170 = {0, {}};
static NODE *string__2acb68f672d208ee;
static void cont__compiler__body__to_c_172(void);
static NODE *string__81412d4a12e22ca0;
static void cont__compiler__body__to_c_174(void);
static void cont__compiler__body__to_c_175(void);
static NODE *string__b723bfa8a9fda3ff;
static void cont__compiler__body__to_c_177(void);
static void cont__compiler__body__to_c_178(void);
static NODE *string__d564cec0827db510;
static NODE *string__820afe0b5f607d42;
static NODE *string__fa733415f296bb7;
static void cont__compiler__body__to_c_182(void);
static void cont__compiler__body__to_c_183(void);
static NODE *func__compiler__body__to_c_184;
static void entry__compiler__body__to_c_184(void);
static FRAME_INFO frame__compiler__body__to_c_184 = {2, {"name", "slot"}};
static void cont__compiler__body__to_c_185(void);
static void cont__compiler__body__to_c_186(void);
static void cont__compiler__body__to_c_187(void);
static void cont__compiler__body__to_c_188(void);
static NODE *func__compiler__body__to_c_189;
static void entry__compiler__body__to_c_189(void);
static FRAME_INFO frame__compiler__body__to_c_189 = {0, {}};
static void cont__compiler__body__to_c_190(void);
static NODE *string__578a5af303e9cc3;
static void cont__compiler__body__to_c_192(void);
static void cont__compiler__body__to_c_193(void);
static NODE *string__380aee0b5fb87d33;
static void cont__compiler__body__to_c_195(void);
static NODE *string__6e5aeb43eaa07032;
static void cont__compiler__body__to_c_197(void);
static void cont__compiler__body__to_c_198(void);
static NODE *func__compiler__body__to_c_199;
static void entry__compiler__body__to_c_199(void);
static FRAME_INFO frame__compiler__body__to_c_199 = {3, {"continuation_parameter", "output_parameters", "body_suffix"}};
static void cont__compiler__body__to_c_200(void);
static NODE *func__compiler__body__to_c_201;
static void entry__compiler__body__to_c_201(void);
static FRAME_INFO frame__compiler__body__to_c_201 = {1, {"body_suffix"}};
static NODE *string__dd22cae03536c939;
static void cont__compiler__body__to_c_203(void);
static void cont__compiler__body__to_c_204(void);
static NODE *string__cec1f2b7e8b1bf6a;
static void cont__compiler__body__to_c_206(void);
static NODE *func__compiler__body__to_c_207;
static void entry__compiler__body__to_c_207(void);
static FRAME_INFO frame__compiler__body__to_c_207 = {0, {}};
static NODE *string__ce243b1c25d80854;
static void cont__compiler__body__to_c_209(void);
static void cont__compiler__body__to_c_210(void);
static void cont__compiler__body__to_c_211(void);
static NODE *func__compiler__body__to_c_212;
static void entry__compiler__body__to_c_212(void);
static FRAME_INFO frame__compiler__body__to_c_212 = {3, {"name", "info", "parent_locals"}};
static void cont__compiler__body__to_c_213(void);
static void cont__compiler__body__to_c_214(void);
static NODE *string__6c6dcf991c09c1f6;
static NODE *string__716ce75c96089b20;
static NODE *string__d81f459e03efe2f7;
static NODE *string__820afbcb5f187d33;
static void cont__compiler__body__to_c_219(void);
static void cont__compiler__body__to_c_220(void);
static void cont__compiler__body__to_c_221(void);
static NODE *func__compiler__body__to_c_222;
static void entry__compiler__body__to_c_222(void);
static FRAME_INFO frame__compiler__body__to_c_222 = {6, {"definition", "extract_destination_and_source", "extract_source_or_create_future", "locals", "destination", "source"}};
static void cont__compiler__body__to_c_223(void);
static void cont__compiler__body__to_c_224(void);
static NODE *func__compiler__body__to_c_225;
static void entry__compiler__body__to_c_225(void);
static FRAME_INFO frame__compiler__body__to_c_225 = {1, {"definition"}};
static void cont__compiler__body__to_c_226(void);
static void cont__compiler__body__to_c_227(void);
static NODE *string__7c84ae5484fdf7e0;
static NODE *string__578a5af303e9cc1;
static void cont__compiler__body__to_c_230(void);
static void cont__compiler__body__to_c_231(void);
static void cont__compiler__body__to_c_232(void);
static void cont__compiler__body__to_c_233(void);
static NODE *func__compiler__body__to_c_234;
static void entry__compiler__body__to_c_234(void);
static FRAME_INFO frame__compiler__body__to_c_234 = {3, {"destination", "extract_source_or_create_future", "source"}};
static void cont__compiler__body__to_c_235(void);
static void cont__compiler__body__to_c_236(void);
static NODE *func__compiler__body__to_c_237;
static void entry__compiler__body__to_c_237(void);
static FRAME_INFO frame__compiler__body__to_c_237 = {4, {"extract_source_or_create_future", "source", "destination", "src"}};
static void cont__compiler__body__to_c_238(void);
static void cont__compiler__body__to_c_239(void);
static NODE *func__compiler__body__to_c_240;
static void entry__compiler__body__to_c_240(void);
static FRAME_INFO frame__compiler__body__to_c_240 = {3, {"destination", "locals", "name"}};
static void cont__compiler__body__to_c_241(void);
static void cont__compiler__body__to_c_242(void);
static void cont__compiler__body__to_c_243(void);
static NODE *string__78fdfa78a6dea8bb;
static void cont__compiler__body__to_c_245(void);
static NODE *func__compiler__body__to_c_246;
static void entry__compiler__body__to_c_246(void);
static FRAME_INFO frame__compiler__body__to_c_246 = {1, {"destination"}};
static void cont__compiler__body__to_c_247(void);
static void cont__compiler__body__to_c_248(void);
static void cont__compiler__body__to_c_249(void);
static NODE *func__compiler__body__to_c_250;
static void entry__compiler__body__to_c_250(void);
static FRAME_INFO frame__compiler__body__to_c_250 = {5, {"definition", "extract_destination_and_source", "extract_source_or_create_future", "destination", "source"}};
static void cont__compiler__body__to_c_251(void);
static void cont__compiler__body__to_c_252(void);
static void cont__compiler__body__to_c_253(void);
static NODE *func__compiler__body__to_c_254;
static void entry__compiler__body__to_c_254(void);
static FRAME_INFO frame__compiler__body__to_c_254 = {1, {"destination"}};
static void cont__compiler__body__to_c_255(void);
static void cont__compiler__body__to_c_256(void);
static void cont__compiler__body__to_c_257(void);
static void cont__compiler__body__to_c_258(void);
static NODE *func__compiler__body__to_c_259;
static void entry__compiler__body__to_c_259(void);
static FRAME_INFO frame__compiler__body__to_c_259 = {3, {"destination", "extract_source_or_create_future", "source"}};
static void cont__compiler__body__to_c_260(void);
static NODE *func__compiler__body__to_c_261;
static void entry__compiler__body__to_c_261(void);
static FRAME_INFO frame__compiler__body__to_c_261 = {6, {"extract_source_or_create_future", "source", "destination", "src", "attribute_name", "dest"}};
static void cont__compiler__body__to_c_262(void);
static void cont__compiler__body__to_c_263(void);
static void cont__compiler__body__to_c_264(void);
static void cont__compiler__body__to_c_265(void);
static void cont__compiler__body__to_c_266(void);
static NODE *string__fccc671c88ddb4ed;
static NODE *string__82b9fe52d4649726;
static NODE *string__23db4977718ddc08;
static NODE *string__900afb0b5fb87d33;
static void cont__compiler__body__to_c_271(void);
static NODE *func__compiler__body__to_c_272;
static void entry__compiler__body__to_c_272(void);
static FRAME_INFO frame__compiler__body__to_c_272 = {3, {"destination", "extract_source_or_create_future", "source"}};
static void cont__compiler__body__to_c_273(void);
static void cont__compiler__body__to_c_274(void);
static NODE *func__compiler__body__to_c_275;
static void entry__compiler__body__to_c_275(void);
static FRAME_INFO frame__compiler__body__to_c_275 = {6, {"extract_source_or_create_future", "source", "destination", "src", "attribute_name", "dest"}};
static void cont__compiler__body__to_c_276(void);
static void cont__compiler__body__to_c_277(void);
static void cont__compiler__body__to_c_278(void);
static void cont__compiler__body__to_c_279(void);
static void cont__compiler__body__to_c_280(void);
static void cont__compiler__body__to_c_281(void);
static NODE *func__compiler__body__to_c_282;
static void entry__compiler__body__to_c_282(void);
static FRAME_INFO frame__compiler__body__to_c_282 = {5, {"source", "destination", "entry", "fun_par_count", "dest"}};
static void cont__compiler__body__to_c_283(void);
static void cont__compiler__body__to_c_284(void);
static void cont__compiler__body__to_c_285(void);
static NODE *string__c21f422683de52f7;
static void cont__compiler__body__to_c_287(void);
static void cont__compiler__body__to_c_288(void);
static NODE *func__compiler__body__to_c_289;
static void entry__compiler__body__to_c_289(void);
static FRAME_INFO frame__compiler__body__to_c_289 = {2, {"input_parameters", "code"}};
static NODE *func__compiler__body__to_c_290;
static void entry__compiler__body__to_c_290(void);
static FRAME_INFO frame__compiler__body__to_c_290 = {1, {"input_parameters"}};
static void cont__compiler__body__to_c_291(void);
static void cont__compiler__body__to_c_292(void);
static void cont__compiler__body__to_c_293(void);
static NODE *func__compiler__body__to_c_294;
static void entry__compiler__body__to_c_294(void);
static FRAME_INFO frame__compiler__body__to_c_294 = {1, {"myself_parameter"}};
static NODE *string__7e1f570601dbc2b1;
static void cont__compiler__body__to_c_296(void);
static NODE *func__compiler__body__to_c_297;
static void entry__compiler__body__to_c_297(void);
static FRAME_INFO frame__compiler__body__to_c_297 = {2, {"parameter", "locals"}};
static void cont__compiler__body__to_c_298(void);
static void cont__compiler__body__to_c_299(void);
static NODE *func__compiler__body__to_c_300;
static void entry__compiler__body__to_c_300(void);
static FRAME_INFO frame__compiler__body__to_c_300 = {3, {"parameter", "locals", "name"}};
static void cont__compiler__body__to_c_301(void);
static void cont__compiler__body__to_c_302(void);
static void cont__compiler__body__to_c_303(void);
static void cont__compiler__body__to_c_304(void);
static void cont__compiler__body__to_c_305(void);
static void cont__compiler__body__to_c_306(void);
static void cont__compiler__body__to_c_307(void);
static NODE *func__compiler__body__to_c_308;
static void entry__compiler__body__to_c_308(void);
static FRAME_INFO frame__compiler__body__to_c_308 = {1, {"statement"}};
static void cont__compiler__body__to_c_309(void);
static void cont__compiler__body__to_c_310(void);
static NODE *func__compiler__body__to_c_311;
static void entry__compiler__body__to_c_311(void);
static FRAME_INFO frame__compiler__body__to_c_311 = {5, {"statements", "continuation_parameter", "output_parameters", "generate_exit", "statement"}};
static void cont__compiler__body__to_c_312(void);
static void cont__compiler__body__to_c_313(void);
static NODE *func__compiler__body__to_c_314;
static void entry__compiler__body__to_c_314(void);
static FRAME_INFO frame__compiler__body__to_c_314 = {3, {"statement", "continuation_parameter", "output_parameters"}};
static void cont__compiler__body__to_c_315(void);
static NODE *func__compiler__body__to_c_316;
static void entry__compiler__body__to_c_316(void);
static FRAME_INFO frame__compiler__body__to_c_316 = {3, {"statement", "continuation_parameter", "output_parameters"}};
static void cont__compiler__body__to_c_317(void);
static void cont__compiler__body__to_c_318(void);
static NODE *func__compiler__body__to_c_319;
static void entry__compiler__body__to_c_319(void);
static FRAME_INFO frame__compiler__body__to_c_319 = {2, {"statement", "continuation_parameter"}};
static void cont__compiler__body__to_c_320(void);
static void cont__compiler__body__to_c_321(void);
static void cont__compiler__body__to_c_322(void);
static void cont__compiler__body__to_c_323(void);
static NODE *func__compiler__body__to_c_324;
static void entry__compiler__body__to_c_324(void);
static FRAME_INFO frame__compiler__body__to_c_324 = {2, {"output_parameters", "statement"}};
static void cont__compiler__body__to_c_325(void);
static void cont__compiler__body__to_c_326(void);
static void cont__compiler__body__to_c_327(void);
static NODE *func__compiler__body__to_c_328;
static void entry__compiler__body__to_c_328(void);
static FRAME_INFO frame__compiler__body__to_c_328 = {3, {"statement", "output_parameters", "continuation_parameter"}};
static void cont__compiler__body__to_c_329(void);
static NODE *func__compiler__body__to_c_330;
static void entry__compiler__body__to_c_330(void);
static FRAME_INFO frame__compiler__body__to_c_330 = {1, {"statement"}};
static void cont__compiler__body__to_c_331(void);
static void cont__compiler__body__to_c_332(void);
static void cont__compiler__body__to_c_333(void);
static void cont__compiler__body__to_c_334(void);
static NODE *func__compiler__body__to_c_335;
static void entry__compiler__body__to_c_335(void);
static FRAME_INFO frame__compiler__body__to_c_335 = {6, {"statement", "output_parameters", "continuation_parameter", "functor", "input_arguments", "result_count"}};
static void cont__compiler__body__to_c_336(void);
static void cont__compiler__body__to_c_337(void);
static void cont__compiler__body__to_c_338(void);
static void cont__compiler__body__to_c_339(void);
static void cont__compiler__body__to_c_340(void);
static void cont__compiler__body__to_c_341(void);
static void cont__compiler__body__to_c_342(void);
static NODE *func__compiler__body__to_c_343;
static void entry__compiler__body__to_c_343(void);
static FRAME_INFO frame__compiler__body__to_c_343 = {2, {"functor", "statement"}};
static NODE *string__db8268c5e3e3998;
static void cont__compiler__body__to_c_345(void);
static void cont__compiler__body__to_c_346(void);
static void cont__compiler__body__to_c_347(void);
static NODE *string__3404e8fb37dde7ec;
static NODE *string__6b3b62c960789ef;
static void cont__compiler__body__to_c_350(void);
static NODE *func__compiler__body__to_c_351;
static void entry__compiler__body__to_c_351(void);
static FRAME_INFO frame__compiler__body__to_c_351 = {5, {"result_count", "continuation_parameter", "functor", "statement", "output_parameters"}};
static NODE *func__compiler__body__to_c_352;
static void entry__compiler__body__to_c_352(void);
static FRAME_INFO frame__compiler__body__to_c_352 = {1, {"result_count"}};
static NODE *string__c178c7d8fee76458;
static NODE *string__8f22c8f0e8431566;
static NODE *string__290419bf9766c0f0;
static void cont__compiler__body__to_c_356(void);
static NODE *func__compiler__body__to_c_357;
static void entry__compiler__body__to_c_357(void);
static FRAME_INFO frame__compiler__body__to_c_357 = {0, {}};
static NODE *string__b0a76bfaa09e5475;
static NODE *func__compiler__body__to_c_359;
static void entry__compiler__body__to_c_359(void);
static FRAME_INFO frame__compiler__body__to_c_359 = {0, {}};
static NODE *string__3f31837fe07336b7;
static void cont__compiler__body__to_c_361(void);
static NODE *func__compiler__body__to_c_362;
static void entry__compiler__body__to_c_362(void);
static FRAME_INFO frame__compiler__body__to_c_362 = {3, {"continuation_parameter", "functor", "statement"}};
static void cont__compiler__body__to_c_363(void);
static NODE *func__compiler__body__to_c_364;
static void entry__compiler__body__to_c_364(void);
static FRAME_INFO frame__compiler__body__to_c_364 = {3, {"functor", "statement", "continuation_parameter"}};
static void cont__compiler__body__to_c_365(void);
static void cont__compiler__body__to_c_366(void);
static void cont__compiler__body__to_c_367(void);
static NODE *string__2d7981f4e4e02bcf;
static void cont__compiler__body__to_c_369(void);
static void cont__compiler__body__to_c_370(void);
static void cont__compiler__body__to_c_371(void);
static void cont__compiler__body__to_c_372(void);
static void cont__compiler__body__to_c_373(void);
static void cont__compiler__body__to_c_374(void);
static NODE *func__compiler__body__to_c_375;
static void entry__compiler__body__to_c_375(void);
static FRAME_INFO frame__compiler__body__to_c_375 = {2, {"output_parameters", "functor"}};
static void cont__compiler__body__to_c_376(void);
static void cont__compiler__body__to_c_377(void);
static NODE *func__compiler__body__to_c_378;
static void entry__compiler__body__to_c_378(void);
static FRAME_INFO frame__compiler__body__to_c_378 = {3, {"functor", "output_parameters", "n"}};
static void cont__compiler__body__to_c_379(void);
static void cont__compiler__body__to_c_380(void);
static void cont__compiler__body__to_c_381(void);
static void cont__compiler__body__to_c_382(void);
static void cont__compiler__body__to_c_383(void);
static void cont__compiler__body__to_c_384(void);
static void cont__compiler__body__to_c_385(void);
static void cont__compiler__body__to_c_386(void);
static NODE *func__compiler__body__to_c_387;
static void entry__compiler__body__to_c_387(void);
static FRAME_INFO frame__compiler__body__to_c_387 = {2, {"n", "output_parameters"}};
static NODE *string__add2b8040716429a;
static NODE *string__fc381eaca84ce05b;
static void cont__compiler__body__to_c_390(void);
static void cont__compiler__body__to_c_391(void);
static NODE *func__compiler__body__to_c_392;
static void entry__compiler__body__to_c_392(void);
static FRAME_INFO frame__compiler__body__to_c_392 = {1, {"output_parameters"}};
static NODE *string__ba62772f4c1bf545;
static void cont__compiler__body__to_c_394(void);
static void cont__compiler__body__to_c_395(void);
static NODE *string__7b93af9dc5bb91ae;
static void cont__compiler__body__to_c_397(void);
static NODE *func__compiler__body__to_c_398;
static void entry__compiler__body__to_c_398(void);
static FRAME_INFO frame__compiler__body__to_c_398 = {1, {"functor"}};
static NODE *string__da5f7a92b20e4d64;
static NODE *func__compiler__body__to_c_400;
static void entry__compiler__body__to_c_400(void);
static FRAME_INFO frame__compiler__body__to_c_400 = {2, {"statement", "generate_exit"}};
static void cont__compiler__body__to_c_401(void);
static void cont__compiler__body__to_c_402(void);
static void cont__compiler__body__to_c_403(void);
static void cont__compiler__body__to_c_404(void);
static void cont__compiler__body__to_c_405(void);
static NODE *func__compiler__body__to_c_406;
static void entry__compiler__body__to_c_406(void);
static FRAME_INFO frame__compiler__body__to_c_406 = {1, {"output_parameters"}};
static void cont__compiler__body__to_c_407(void);
static void cont__compiler__body__to_c_408(void);
static void cont__compiler__body__to_c_409(void);
static NODE *func__compiler__body__to_c_410;
static void entry__compiler__body__to_c_410(void);
static FRAME_INFO frame__compiler__body__to_c_410 = {3, {"body_suffix", "output_parameters", "n"}};
static NODE *string__357d878b1635920f;
static void cont__compiler__body__to_c_412(void);
static void cont__compiler__body__to_c_413(void);
static void cont__compiler__body__to_c_414(void);
static void cont__compiler__body__to_c_415(void);
static NODE *func__compiler__body__to_c_416;
static void entry__compiler__body__to_c_416(void);
static FRAME_INFO frame__compiler__body__to_c_416 = {2, {"n", "output_parameters"}};
static void cont__compiler__body__to_c_417(void);
static void cont__compiler__body__to_c_418(void);
static NODE *func__compiler__body__to_c_419;
static void entry__compiler__body__to_c_419(void);
static FRAME_INFO frame__compiler__body__to_c_419 = {1, {"output_parameters"}};
static void cont__compiler__body__to_c_420(void);
static void cont__compiler__body__to_c_421(void);
static void cont__compiler__body__to_c_422(void);
static NODE *string__8e4c39950c6aecc7;
static void cont__compiler__body__to_c_424(void);
static void cont__compiler__body___to_c_425(void);
static void cont__compiler__body___to_c_426(void);
static void cont__compiler__body___to_c_427(void);
static NODE *func__compiler__body__to_c_428;
static void entry__compiler__body__to_c_428(void);
static FRAME_INFO frame__compiler__body__to_c_428 = {3, {"return", "body_suffix", "par_count"}};
static void cont__compiler__body__to_c_429(void);
static void cont__compiler__body___to_c_430(void);
static void cont__compiler__body___to_c_431(void);
static void cont__compiler__body___to_c_432(void);
static NODE *func__compiler__body__to_c_433;
static void entry__compiler__body__to_c_433(void);
static FRAME_INFO frame__compiler__body__to_c_433 = {3, {"body_suffix", "par_count", "return"}};
static NODE *string__541f532081ce52b4;
static NODE *string__86eff1a866fd255c;
static void cont__compiler__body__to_c_436(void);
static void cont__compiler__body__to_c_437(void);
static void cont__compiler__body__to_c_438(void);
static NODE *func__compiler__body__to_c_439;
static void entry__compiler__body__to_c_439(void);
static FRAME_INFO frame__compiler__body__to_c_439 = {3, {"return", "body_suffix", "par_count"}};
static NODE *string__4f4f87201b84976a;
static void cont__compiler__body__to_c_441(void);
static void cont__compiler__body___to_c_442(void);
static NODE *func__compiler__definition___to_c;
static void entry__compiler__definition___to_c(void);
static FRAME_INFO frame__compiler__definition___to_c = {2, {"self", "return"}};
static NODE *string__b285329ce73409a7;
static void cont__compiler__definition___to_c_3(void);
static void cont__compiler__definition___to_c_4(void);
static void cont__compiler__definition___to_c_5(void);
static void cont__compiler__definition___to_c_6(void);
static NODE *func__compiler__definition__to_c_7;
static void entry__compiler__definition__to_c_7(void);
static FRAME_INFO frame__compiler__definition__to_c_7 = {2, {"return", "self"}};
static void cont__compiler__definition__to_c_8(void);
static void cont__compiler__definition__to_c_9(void);
static void cont__compiler__definition__to_c_10(void);
static void cont__compiler__definition__to_c_11(void);
static void cont__compiler__definition__to_c_12(void);
static void cont__compiler__definition___to_c_13(void);
static void cont__compiler__definition___to_c_14(void);
static void cont__compiler__definition___to_c_15(void);
static NODE *func__compiler__numeric_literal___to_c;
static void entry__compiler__numeric_literal___to_c(void);
static FRAME_INFO frame__compiler__numeric_literal___to_c = {2, {"self", "name"}};
static NODE *string__b19618e04d55f805;
static void cont__compiler__numeric_literal___to_c_3(void);
static void cont__compiler__numeric_literal___to_c_4(void);
static NODE *string__64c0a950852db1bf;
static void cont__compiler__numeric_literal___to_c_6(void);
static void cont__compiler__numeric_literal___to_c_7(void);
static NODE *func__compiler__character_literal___to_c;
static void entry__compiler__character_literal___to_c(void);
static FRAME_INFO frame__compiler__character_literal___to_c = {2, {"self", "name"}};
static NODE *string__96912fd9d89a615a;
static void cont__compiler__character_literal___to_c_3(void);
static void cont__compiler__character_literal___to_c_4(void);
static void cont__compiler__character_literal___to_c_5(void);
static NODE *string__4ad975da2ff0e93f;
static void cont__compiler__character_literal___to_c_7(void);
static void cont__compiler__character_literal___to_c_8(void);
static NODE *func__to_c_string;
static void entry__to_c_string(void);
static FRAME_INFO frame__to_c_string = {3, {"str", "buf", "s"}};
static NODE *func__to_c_string_2;
static void entry__to_c_string_2(void);
static FRAME_INFO frame__to_c_string_2 = {5, {"idx", "chr", "buf", "str", "s"}};
static void cont__to_c_string_3(void);
static NODE *func__to_c_string_4;
static void entry__to_c_string_4(void);
static FRAME_INFO frame__to_c_string_4 = {1, {"chr"}};
static void cont__to_c_string_5(void);
static NODE *func__to_c_string_6;
static void entry__to_c_string_6(void);
static FRAME_INFO frame__to_c_string_6 = {1, {"chr"}};
static void cont__to_c_string_7(void);
static NODE *func__to_c_string_8;
static void entry__to_c_string_8(void);
static FRAME_INFO frame__to_c_string_8 = {1, {"chr"}};
static void cont__to_c_string_9(void);
static void cont__to_c_string_10(void);
static void cont__to_c_string_11(void);
static void cont__to_c_string_12(void);
static NODE *func__to_c_string_13;
static void entry__to_c_string_13(void);
static FRAME_INFO frame__to_c_string_13 = {5, {"buf", "str", "s", "idx", "chr"}};
static void cont__to_c_string_14(void);
static void cont__to_c_string_15(void);
static void cont__to_c_string_16(void);
static void cont__to_c_string_17(void);
static void cont__to_c_string_18(void);
static NODE *string__578a5af303e9cd1;
static void cont__to_c_string_20(void);
static NODE *string__578a5af303e9cbd;
static void cont__to_c_string_22(void);
static void cont__to_c_string_23(void);
static void cont__to_c_string_24(void);
static void cont__to_c_string_25(void);
static void cont__to_c_string_26(void);
static void cont__to_c_string_27(void);
static NODE *func__to_c_string_28;
static void entry__to_c_string_28(void);
static FRAME_INFO frame__to_c_string_28 = {3, {"buf", "str", "s"}};
static void cont__to_c_string_29(void);
static void cont__to_c_string_30(void);
static void cont__to_c_string_31(void);
static void cont__to_c_string_32(void);
static NODE *func__register_string;
static void entry__register_string(void);
static FRAME_INFO frame__register_string = {2, {"str", "len"}};
static void cont__register_string_2(void);
static void cont__register_string_3(void);
static NODE *func__register_string_4;
static void entry__register_string_4(void);
static FRAME_INFO frame__register_string_4 = {4, {"str", "len", "name", "stored"}};
static void cont__register_string_5(void);
static void cont__register_string_6(void);
static void cont__register_string_7(void);
static void cont__register_string_8(void);
static void cont__register_string_9(void);
static NODE *func__register_string_10;
static void entry__register_string_10(void);
static FRAME_INFO frame__register_string_10 = {3, {"stored", "str", "name"}};
static void cont__register_string_11(void);
static void cont__register_string_12(void);
static NODE *func__register_string_13;
static void entry__register_string_13(void);
static FRAME_INFO frame__register_string_13 = {3, {"stored", "str", "name"}};
static void cont__register_string_14(void);
static NODE *func__register_string_15;
static void entry__register_string_15(void);
static FRAME_INFO frame__register_string_15 = {1, {"stored"}};
static void cont__register_string_16(void);
static void cont__register_string_17(void);
static NODE *func__register_string_18;
static void entry__register_string_18(void);
static FRAME_INFO frame__register_string_18 = {4, {"break", "stored", "str", "name"}};
static NODE *func__register_string_19;
static void entry__register_string_19(void);
static FRAME_INFO frame__register_string_19 = {5, {"idx", "stored_str", "str", "name", "break"}};
static void cont__register_string_20(void);
static NODE *func__register_string_21;
static void entry__register_string_21(void);
static FRAME_INFO frame__register_string_21 = {3, {"idx", "name", "break"}};
static void cont__register_string_22(void);
static NODE *func__register_string_23;
static void entry__register_string_23(void);
static FRAME_INFO frame__register_string_23 = {2, {"name", "idx"}};
static void cont__register_string_24(void);
static void cont__register_string_25(void);
static void cont__register_string_26(void);
static void cont__register_string_27(void);
static void cont__register_string_28(void);
static void cont__register_string_29(void);
static void cont__register_string_30(void);
static NODE *func__register_string_31;
static void entry__register_string_31(void);
static FRAME_INFO frame__register_string_31 = {2, {"name", "str"}};
static void cont__register_string_32(void);
static void cont__register_string_33(void);
static NODE *string__72c4ac1f052d021f;
static void cont__register_string_35(void);
static NODE *string__cb6a78473f66a6a1;
static void cont__register_string_37(void);
static void cont__register_string_38(void);
static void cont__register_string_39(void);
static NODE *func__register_string_40;
static void entry__register_string_40(void);
static FRAME_INFO frame__register_string_40 = {4, {"name", "str", "len", "n"}};
static NODE *string__a3d95bf5db908e15;
static void cont__register_string_42(void);
static void cont__register_string_43(void);
static void cont__register_string_44(void);
static void cont__register_string_45(void);
static NODE *func__register_string_46;
static void entry__register_string_46(void);
static FRAME_INFO frame__register_string_46 = {2, {"n", "len"}};
static void cont__register_string_47(void);
static void cont__register_string_48(void);
static NODE *func__register_string_49;
static void entry__register_string_49(void);
static FRAME_INFO frame__register_string_49 = {2, {"str", "len"}};
static NODE *func__register_string_50;
static void entry__register_string_50(void);
static FRAME_INFO frame__register_string_50 = {1, {"line"}};
static void cont__register_string_51(void);
static NODE *string__d81f467583be52f5;
static NODE *func__register_string_53;
static void entry__register_string_53(void);
static FRAME_INFO frame__register_string_53 = {0, {}};
static NODE *string__fa72f415d596bee;
static void cont__register_string_55(void);
static void cont__register_string_56(void);
static void cont__register_string_57(void);
static void cont__register_string_58(void);
static NODE *func__register_string_59;
static void entry__register_string_59(void);
static FRAME_INFO frame__register_string_59 = {0, {}};
static NODE *func__register_string_60;
static void entry__register_string_60(void);
static FRAME_INFO frame__register_string_60 = {0, {}};
static void cont__register_string_61(void);
static NODE *string__d81f466683bcf2f7;
static void cont__register_string_63(void);
static NODE *func__register_string_64;
static void entry__register_string_64(void);
static FRAME_INFO frame__register_string_64 = {2, {"str", "len"}};
static void cont__register_string_65(void);
static NODE *string__fa730c15f496bec;
static void cont__register_string_67(void);
static NODE *func__register_string_68;
static void entry__register_string_68(void);
static FRAME_INFO frame__register_string_68 = {3, {"name", "len", "str"}};
static NODE *string__24e73e91baac9a30;
static NODE *string__4a9426e6bd63257e;
static NODE *string__ca5afc43e8cbc02c;
static void cont__register_string_72(void);
static void cont__register_string_73(void);
static NODE *func__register_string_74;
static void entry__register_string_74(void);
static FRAME_INFO frame__register_string_74 = {1, {"chr"}};
static void cont__register_string_75(void);
static void cont__register_string_76(void);
static NODE *func__register_string_77;
static void entry__register_string_77(void);
static FRAME_INFO frame__register_string_77 = {1, {"chr"}};
static void cont__register_string_78(void);
static void cont__register_string_79(void);
static NODE *func__register_string_80;
static void entry__register_string_80(void);
static FRAME_INFO frame__register_string_80 = {1, {"chr"}};
static void cont__register_string_81(void);
static void cont__register_string_82(void);
static NODE *func__register_string_83;
static void entry__register_string_83(void);
static FRAME_INFO frame__register_string_83 = {1, {"chr"}};
static void cont__register_string_84(void);
static void cont__register_string_85(void);
static NODE *func__register_string_86;
static void entry__register_string_86(void);
static FRAME_INFO frame__register_string_86 = {1, {"chr"}};
static void cont__register_string_87(void);
static void cont__register_string_88(void);
static void cont__register_string_89(void);
static void cont__register_string_90(void);
static void cont__register_string_91(void);
static void cont__register_string_92(void);
static NODE *func__register_string_93;
static void entry__register_string_93(void);
static FRAME_INFO frame__register_string_93 = {1, {"chr"}};
static void cont__register_string_94(void);
static void cont__register_string_95(void);
static NODE *func__register_string_96;
static void entry__register_string_96(void);
static FRAME_INFO frame__register_string_96 = {1, {"chr"}};
static void cont__register_string_97(void);
static void cont__register_string_98(void);
static void cont__register_string_99(void);
static void cont__register_string_100(void);
static NODE *func__register_string_101;
static void entry__register_string_101(void);
static FRAME_INFO frame__register_string_101 = {1, {"chr"}};
static NODE *func__register_string_102;
static void entry__register_string_102(void);
static FRAME_INFO frame__register_string_102 = {1, {"chr"}};
static void cont__register_string_103(void);
static void cont__register_string_104(void);
static NODE *string__2d7981f4e6882bbd;
static NODE *func__register_string_106;
static void entry__register_string_106(void);
static FRAME_INFO frame__register_string_106 = {0, {}};
static void cont__register_string_107(void);
static NODE *string__fa727015ff16bc6;
static void cont__register_string_109(void);
static NODE *string__6bf55d38c602d6fa;
static NODE *string__3735eb19284a5481;
static void cont__register_string_112(void);
static void cont__register_string_113(void);
static NODE *func__register_string_114;
static void entry__register_string_114(void);
static FRAME_INFO frame__register_string_114 = {0, {}};
static NODE *string__ee21fa04ce7f45ad;
static NODE *func__compiler__string_literal___to_c;
static void entry__compiler__string_literal___to_c(void);
static FRAME_INFO frame__compiler__string_literal___to_c = {3, {"self", "text", "literal"}};
static NODE *string__92bdd3e04dbbd1c4;
static void cont__compiler__string_literal___to_c_3(void);
static void cont__compiler__string_literal___to_c_4(void);
static void cont__compiler__string_literal___to_c_5(void);
static void cont__compiler__string_literal___to_c_6(void);
static NODE *func__compiler__string_literal__to_c_7;
static void entry__compiler__string_literal__to_c_7(void);
static FRAME_INFO frame__compiler__string_literal__to_c_7 = {1, {"literal"}};
static NODE *func__compiler__string_literal__to_c_8;
static void entry__compiler__string_literal__to_c_8(void);
static FRAME_INFO frame__compiler__string_literal__to_c_8 = {2, {"text", "new_literal"}};
static void cont__compiler__string_literal__to_c_9(void);
static void cont__compiler__string_literal__to_c_10(void);
static NODE *func__compiler__unique_item___to_c;
static void entry__compiler__unique_item___to_c(void);
static FRAME_INFO frame__compiler__unique_item___to_c = {3, {"self", "name", "reg_name"}};
static NODE *string__d48b67664260d740;
static void cont__compiler__unique_item___to_c_3(void);
static void cont__compiler__unique_item___to_c_4(void);
static void cont__compiler__unique_item___to_c_5(void);
static NODE *func__compiler__unique_item__to_c_6;
static void entry__compiler__unique_item__to_c_6(void);
static FRAME_INFO frame__compiler__unique_item__to_c_6 = {1, {"self"}};
static void cont__compiler__unique_item__to_c_7(void);
static NODE *func__compiler__unique_item__to_c_8;
static void entry__compiler__unique_item__to_c_8(void);
static FRAME_INFO frame__compiler__unique_item__to_c_8 = {0, {}};
static void cont__compiler__unique_item__to_c_9(void);
static void cont__compiler__unique_item___to_c_10(void);
static NODE *string__44acac92852c82df;
static void cont__compiler__unique_item___to_c_12(void);
static void cont__compiler__unique_item___to_c_13(void);
static void cont__compiler__unique_item___to_c_14(void);
static NODE *func__compiler__unique_item__to_c_15;
static void entry__compiler__unique_item__to_c_15(void);
static FRAME_INFO frame__compiler__unique_item__to_c_15 = {1, {"self"}};
static void cont__compiler__unique_item__to_c_16(void);
static NODE *func__compiler__unique_item__to_c_17;
static void entry__compiler__unique_item__to_c_17(void);
static FRAME_INFO frame__compiler__unique_item__to_c_17 = {1, {"name"}};
static void cont__compiler__unique_item___to_c_18(void);
static void cont__compiler__unique_item___to_c_19(void);
static NODE *func__compiler__unique_item__to_c_20;
static void entry__compiler__unique_item__to_c_20(void);
static FRAME_INFO frame__compiler__unique_item__to_c_20 = {2, {"name", "reg_name"}};
static void cont__compiler__unique_item__to_c_21(void);
static void cont__compiler__unique_item__to_c_22(void);
static void cont__compiler__unique_item__to_c_23(void);
static NODE *string__8b8ef598707f4603;
static NODE *string__860afb0b5fb87d33;
static void cont__compiler__unique_item__to_c_26(void);
static void cont__compiler__unique_item___to_c_27(void);
static NODE *func__compiler__identifier___to_c;
static void entry__compiler__identifier___to_c(void);
static FRAME_INFO frame__compiler__identifier___to_c = {2, {"self", "name"}};
static NODE *string__d48f33204edcb4ea;
static void cont__compiler__identifier___to_c_3(void);
static void cont__compiler__identifier___to_c_4(void);
static NODE *func__compiler__identifier__to_c_5;
static void entry__compiler__identifier__to_c_5(void);
static FRAME_INFO frame__compiler__identifier__to_c_5 = {2, {"self", "name"}};
static void cont__compiler__identifier__to_c_6(void);
static NODE *func__compiler__identifier__to_c_7;
static void entry__compiler__identifier__to_c_7(void);
static FRAME_INFO frame__compiler__identifier__to_c_7 = {1, {"name"}};
static void cont__compiler__identifier__to_c_8(void);
static NODE *func__compiler__identifier__to_c_9;
static void entry__compiler__identifier__to_c_9(void);
static FRAME_INFO frame__compiler__identifier__to_c_9 = {2, {"name", "idx"}};
static void cont__compiler__identifier__to_c_10(void);
static void cont__compiler__identifier__to_c_11(void);
static void cont__compiler__identifier__to_c_12(void);
static void cont__compiler__identifier__to_c_13(void);
static NODE *string__fa730415f796be3;
static void cont__compiler__identifier__to_c_15(void);
static NODE *func__compiler__identifier__to_c_16;
static void entry__compiler__identifier__to_c_16(void);
static FRAME_INFO frame__compiler__identifier__to_c_16 = {1, {"name"}};
static void cont__compiler__identifier__to_c_17(void);
static NODE *func__compiler__identifier__to_c_18;
static void entry__compiler__identifier__to_c_18(void);
static FRAME_INFO frame__compiler__identifier__to_c_18 = {1, {"name"}};
static void cont__compiler__identifier__to_c_19(void);
static void cont__compiler__identifier__to_c_20(void);
static NODE *func__compiler__identifier__to_c_21;
static void entry__compiler__identifier__to_c_21(void);
static FRAME_INFO frame__compiler__identifier__to_c_21 = {1, {"name"}};
static void cont__compiler__identifier__to_c_22(void);
static NODE *func__compiler__identifier__to_c_23;
static void entry__compiler__identifier__to_c_23(void);
static FRAME_INFO frame__compiler__identifier__to_c_23 = {1, {"name"}};
static void cont__compiler__identifier__to_c_24(void);
static NODE *string__58e06d42b95eed3d;
static NODE *string__713cab8df53e8c2e;
static void cont__compiler__identifier__to_c_27(void);
static NODE *func__compiler__identifier__to_c_28;
static void entry__compiler__identifier__to_c_28(void);
static FRAME_INFO frame__compiler__identifier__to_c_28 = {1, {"name"}};
static void cont__compiler__identifier__to_c_29(void);
static void cont__compiler__identifier__to_c_30(void);
static void cont__compiler__identifier__to_c_31(void);
static NODE *func__compiler__identifier__to_c_32;
static void entry__compiler__identifier__to_c_32(void);
static FRAME_INFO frame__compiler__identifier__to_c_32 = {1, {"name"}};
static void cont__compiler__identifier__to_c_33(void);
static void cont__compiler__identifier__to_c_34(void);
static NODE *func__compiler__identifier__to_c_35;
static void entry__compiler__identifier__to_c_35(void);
static FRAME_INFO frame__compiler__identifier__to_c_35 = {1, {"name"}};
static NODE *string__405aee03eb306008;
static void cont__compiler__identifier__to_c_37(void);
static NODE *func__compiler__identifier__to_c_38;
static void entry__compiler__identifier__to_c_38(void);
static FRAME_INFO frame__compiler__identifier__to_c_38 = {2, {"self", "name"}};
static NODE *func__compiler__identifier__to_c_39;
static void entry__compiler__identifier__to_c_39(void);
static FRAME_INFO frame__compiler__identifier__to_c_39 = {3, {"self", "name", "variable_kind"}};
static void cont__compiler__identifier__to_c_40(void);
static void cont__compiler__identifier__to_c_41(void);
static NODE *func__compiler__identifier__to_c_42;
static void entry__compiler__identifier__to_c_42(void);
static FRAME_INFO frame__compiler__identifier__to_c_42 = {1, {"self"}};
static void cont__compiler__identifier__to_c_43(void);
static void cont__compiler__identifier__to_c_44(void);
static void cont__compiler__identifier__to_c_45(void);
static void cont__compiler__identifier__to_c_46(void);
static void cont__compiler__identifier__to_c_47(void);
static NODE *func__compiler__identifier__to_c_48;
static void entry__compiler__identifier__to_c_48(void);
static FRAME_INFO frame__compiler__identifier__to_c_48 = {1, {"name"}};
static void cont__compiler__identifier__to_c_49(void);
static void cont__compiler__identifier__to_c_50(void);
static void cont__compiler__identifier__to_c_51(void);
static void cont__compiler__identifier__to_c_52(void);
static NODE *func__compiler__identifier__to_c_53;
static void entry__compiler__identifier__to_c_53(void);
static FRAME_INFO frame__compiler__identifier__to_c_53 = {1, {"name"}};
static void cont__compiler__identifier__to_c_54(void);
static NODE *func__compiler__identifier__to_c_55;
static void entry__compiler__identifier__to_c_55(void);
static FRAME_INFO frame__compiler__identifier__to_c_55 = {1, {"name"}};
static void cont__compiler__identifier__to_c_56(void);
static void cont__compiler__identifier__to_c_57(void);
static NODE *func__compiler__c_body___to_c;
static void entry__compiler__c_body___to_c(void);
static FRAME_INFO frame__compiler__c_body___to_c = {3, {"self", "body_suffix", "continuation_info"}};
static NODE *string__9495a9c10d9ac4d0;
static void cont__compiler__c_body___to_c_3(void);
static void cont__compiler__c_body___to_c_4(void);
static void cont__compiler__c_body___to_c_5(void);
static void cont__compiler__c_body___to_c_6(void);
static void cont__compiler__c_body___to_c_7(void);
static NODE *func__compiler__c_body__to_c_8;
static void entry__compiler__c_body__to_c_8(void);
static FRAME_INFO frame__compiler__c_body__to_c_8 = {2, {"continuation_info", "self"}};
static void cont__compiler__c_body__to_c_9(void);
static void cont__compiler__c_body___to_c_10(void);
static NODE *func__compiler__c_body__to_c_11;
static void entry__compiler__c_body__to_c_11(void);
static FRAME_INFO frame__compiler__c_body__to_c_11 = {4, {"self", "body_suffix", "continuation_info", "par_count"}};
static void cont__compiler__c_body__to_c_12(void);
static NODE *string__8d88533a39505214;
static void cont__compiler__c_body__to_c_14(void);
static NODE *func__compiler__c_body__to_c_15;
static void entry__compiler__c_body__to_c_15(void);
static FRAME_INFO frame__compiler__c_body__to_c_15 = {1, {"self"}};
static void cont__compiler__c_body__to_c_16(void);
static void cont__compiler__c_body__to_c_17(void);
static NODE *func__compiler__c_body__to_c_18;
static void entry__compiler__c_body__to_c_18(void);
static FRAME_INFO frame__compiler__c_body__to_c_18 = {0, {}};
static void cont__compiler__c_body__to_c_19(void);
static void cont__compiler__c_body__to_c_20(void);
static NODE *string__7b01aef649fee96f;
static NODE *string__c1009742fcdd65b8;
static void cont__compiler__c_body__to_c_23(void);
static void cont__compiler__c_body__to_c_24(void);
static void cont__compiler__c_body__to_c_25(void);
static NODE *func__compiler__c_body__to_c_26;
static void entry__compiler__c_body__to_c_26(void);
static FRAME_INFO frame__compiler__c_body__to_c_26 = {2, {"body_suffix", "continuation_info"}};
static NODE *string__7394a8db8445c859;
static NODE *string__3794a6c106b6c980;
static void cont__compiler__c_body__to_c_29(void);
static void cont__compiler__c_body__to_c_30(void);
static void cont__compiler__c_body__to_c_31(void);
static void cont__compiler__c_body__to_c_32(void);
static void cont__compiler__c_body__to_c_33(void);
static NODE *string__fa73ac15dc16bc6;
static void cont__compiler__c_body__to_c_35(void);
static void cont__compiler__c_body__to_c_36(void);
static void cont__compiler__c_body__to_c_37(void);
static void cont__compiler__c_body___to_c_38(void);
static void cont__compiler__c_body___to_c_39(void);
static NODE *func__extract_destination;
static void entry__extract_destination(void);
static FRAME_INFO frame__extract_destination = {2, {"destination", "identifier"}};
static void cont__extract_destination_2(void);
static void cont__extract_destination_3(void);
static void cont__extract_destination_4(void);
static void cont__extract_destination_5(void);
static NODE *func__compiler__is_single_assign;
static void entry__compiler__is_single_assign(void);
static FRAME_INFO frame__compiler__is_single_assign = {3, {"expr", "return", "info"}};
static void cont__compiler__is_single_assign_2(void);
static NODE *func__compiler__is_single_assign_3;
static void entry__compiler__is_single_assign_3(void);
static FRAME_INFO frame__compiler__is_single_assign_3 = {1, {"expr"}};
static void cont__compiler__is_single_assign_4(void);
static void cont__compiler__is_single_assign_5(void);
static void cont__compiler__is_single_assign_6(void);
static NODE *func__compiler__is_single_assign_7;
static void entry__compiler__is_single_assign_7(void);
static FRAME_INFO frame__compiler__is_single_assign_7 = {1, {"return"}};
static void cont__compiler__is_single_assign_8(void);
static void cont__compiler__is_single_assign_9(void);
static void cont__compiler__is_single_assign_10(void);
static NODE *func__compiler__is_single_assign_11;
static void entry__compiler__is_single_assign_11(void);
static FRAME_INFO frame__compiler__is_single_assign_11 = {2, {"expr", "namespaces"}};
static void cont__compiler__is_single_assign_12(void);
static void cont__compiler__is_single_assign_13(void);
static void cont__compiler__is_single_assign_14(void);
static NODE *func__compiler__is_single_assign_15;
static void entry__compiler__is_single_assign_15(void);
static FRAME_INFO frame__compiler__is_single_assign_15 = {2, {"namespaces", "expr"}};
static void cont__compiler__is_single_assign_16(void);
static void cont__compiler__is_single_assign_17(void);
static NODE *func__compiler__is_single_assign_18;
static void entry__compiler__is_single_assign_18(void);
static FRAME_INFO frame__compiler__is_single_assign_18 = {0, {}};
static void cont__compiler__is_single_assign_19(void);
static NODE *func__compiler__is_single_assign_20;
static void entry__compiler__is_single_assign_20(void);
static FRAME_INFO frame__compiler__is_single_assign_20 = {1, {"expr"}};
static void cont__compiler__is_single_assign_21(void);
static void cont__compiler__is_single_assign_22(void);
static void cont__compiler__is_single_assign_23(void);
static void cont__compiler__is_single_assign_24(void);
static NODE *func__compiler__is_single_assign_25;
static void entry__compiler__is_single_assign_25(void);
static FRAME_INFO frame__compiler__is_single_assign_25 = {1, {"info"}};
static void cont__compiler__is_single_assign_26(void);
static void cont__compiler__is_single_assign_27(void);
static NODE *get__compiler__is_single_assign(void) {
  return var.compiler__is_single_assign;
}
static NODE *func__compiler__might_be_constant;
static void entry__compiler__might_be_constant(void);
static FRAME_INFO frame__compiler__might_be_constant = {3, {"expr", "return", "info"}};
static void cont__compiler__might_be_constant_2(void);
static NODE *func__compiler__might_be_constant_3;
static void entry__compiler__might_be_constant_3(void);
static FRAME_INFO frame__compiler__might_be_constant_3 = {1, {"expr"}};
static void cont__compiler__might_be_constant_4(void);
static void cont__compiler__might_be_constant_5(void);
static void cont__compiler__might_be_constant_6(void);
static NODE *func__compiler__might_be_constant_7;
static void entry__compiler__might_be_constant_7(void);
static FRAME_INFO frame__compiler__might_be_constant_7 = {1, {"return"}};
static void cont__compiler__might_be_constant_8(void);
static void cont__compiler__might_be_constant_9(void);
static void cont__compiler__might_be_constant_10(void);
static NODE *func__compiler__might_be_constant_11;
static void entry__compiler__might_be_constant_11(void);
static FRAME_INFO frame__compiler__might_be_constant_11 = {2, {"expr", "namespaces"}};
static void cont__compiler__might_be_constant_12(void);
static void cont__compiler__might_be_constant_13(void);
static void cont__compiler__might_be_constant_14(void);
static NODE *func__compiler__might_be_constant_15;
static void entry__compiler__might_be_constant_15(void);
static FRAME_INFO frame__compiler__might_be_constant_15 = {2, {"namespaces", "expr"}};
static void cont__compiler__might_be_constant_16(void);
static void cont__compiler__might_be_constant_17(void);
static NODE *func__compiler__might_be_constant_18;
static void entry__compiler__might_be_constant_18(void);
static FRAME_INFO frame__compiler__might_be_constant_18 = {0, {}};
static void cont__compiler__might_be_constant_19(void);
static NODE *func__compiler__might_be_constant_20;
static void entry__compiler__might_be_constant_20(void);
static FRAME_INFO frame__compiler__might_be_constant_20 = {1, {"expr"}};
static void cont__compiler__might_be_constant_21(void);
static void cont__compiler__might_be_constant_22(void);
static void cont__compiler__might_be_constant_23(void);
static void cont__compiler__might_be_constant_24(void);
static NODE *get__compiler__might_be_constant(void) {
  return var.compiler__might_be_constant;
}
static NODE *func__assign;
static void entry__assign(void);
static FRAME_INFO frame__assign = {2, {"dest", "src"}};
static NODE *func__assign_2;
static void entry__assign_2(void);
static FRAME_INFO frame__assign_2 = {2, {"src", "dest"}};
static NODE *string__441f568380430288;
static void cont__assign_4(void);
static void cont__assign_5(void);
static NODE *func__assign_6;
static void entry__assign_6(void);
static FRAME_INFO frame__assign_6 = {2, {"dest", "src"}};
static NODE *string__468aa0a9b0dabd58;
static NODE *string__fa733415f296bea;
static void cont__assign_9(void);
static NODE *func__assign_10;
static void entry__assign_10(void);
static FRAME_INFO frame__assign_10 = {2, {"src", "dest"}};
static void cont__assign_11(void);
static NODE *func__assign_12;
static void entry__assign_12(void);
static FRAME_INFO frame__assign_12 = {2, {"dest", "src"}};
static NODE *string__7d5cf5d8cf0f5f69;
static void cont__assign_14(void);
static NODE *func__assign_15;
static void entry__assign_15(void);
static FRAME_INFO frame__assign_15 = {2, {"dest", "src"}};
static void cont__assign_16(void);
static NODE *func__compiler__define_variable;
static void entry__compiler__define_variable(void);
static FRAME_INFO frame__compiler__define_variable = {7, {"definition", "source", "is_a_prototype", "namespace", "name", "mangled_name", "kind"}};
static void cont__compiler__define_variable_2(void);
static void cont__compiler__define_variable_3(void);
static NODE *func__compiler__define_variable_4;
static void entry__compiler__define_variable_4(void);
static FRAME_INFO frame__compiler__define_variable_4 = {1, {"mangled_name"}};
static void cont__compiler__define_variable_5(void);
static void cont__compiler__define_variable_6(void);
static NODE *string__29d4ac87c65f0ce6;
static void cont__compiler__define_variable_8(void);
static void cont__compiler__define_variable_9(void);
static void cont__compiler__define_variable_10(void);
static void cont__compiler__define_variable_11(void);
static NODE *func__compiler__define_variable_12;
static void entry__compiler__define_variable_12(void);
static FRAME_INFO frame__compiler__define_variable_12 = {1, {"kind"}};
static void cont__compiler__define_variable_13(void);
static void cont__compiler__define_variable_14(void);
static NODE *func__compiler__define_variable_15;
static void entry__compiler__define_variable_15(void);
static FRAME_INFO frame__compiler__define_variable_15 = {3, {"is_a_prototype", "mangled_name", "source"}};
static NODE *func__compiler__define_variable_16;
static void entry__compiler__define_variable_16(void);
static FRAME_INFO frame__compiler__define_variable_16 = {2, {"mangled_name", "source"}};
static void cont__compiler__define_variable_17(void);
static NODE *string__dc0dbf3dca1e95fd;
static void cont__compiler__define_variable_19(void);
static void cont__compiler__define_variable_20(void);
static void cont__compiler__define_variable_21(void);
static void cont__compiler__define_variable_22(void);
static NODE *string__e24c48ad3fbdc6fa;
static void cont__compiler__define_variable_24(void);
static NODE *func__compiler__define_variable_25;
static void entry__compiler__define_variable_25(void);
static FRAME_INFO frame__compiler__define_variable_25 = {2, {"mangled_name", "source"}};
static void cont__compiler__define_variable_26(void);
static void cont__compiler__define_variable_27(void);
static void cont__compiler__define_variable_28(void);
static void cont__compiler__define_variable_29(void);
static NODE *func__compiler__define_variable_30;
static void entry__compiler__define_variable_30(void);
static FRAME_INFO frame__compiler__define_variable_30 = {4, {"kind", "mangled_name", "namespace", "name"}};
static NODE *func__compiler__define_variable_31;
static void entry__compiler__define_variable_31(void);
static FRAME_INFO frame__compiler__define_variable_31 = {3, {"mangled_name", "namespace", "name"}};
static NODE *string__2794a48106d7680a;
static void cont__compiler__define_variable_33(void);
static void cont__compiler__define_variable_34(void);
static NODE *string__55b34e50e74b4c7c;
static NODE *string__5a35746c23f76309;
static void cont__compiler__define_variable_37(void);
static void cont__compiler__define_variable_38(void);
static void cont__compiler__define_variable_39(void);
static NODE *string__b29ac022d5eddd84;
static NODE *string__860afa4b5f607d1b;
static NODE *string__65a4a8f6052de83f;
static void cont__compiler__define_variable_43(void);
static NODE *func__compiler__define_variable_44;
static void entry__compiler__define_variable_44(void);
static FRAME_INFO frame__compiler__define_variable_44 = {3, {"mangled_name", "namespace", "name"}};
static void cont__compiler__define_variable_45(void);
static void cont__compiler__define_variable_46(void);
static NODE *string__51b735d4017b50ea;
static NODE *string__8454c532619bd34d;
static NODE *string__833e0a9b7bc3bd8b;
static void cont__compiler__define_variable_50(void);
static void cont__compiler__define_variable_51(void);
static NODE *string__e8ada4deabe9f7ad;
static NODE *string__b93408f29443f0a5;
static void cont__compiler__define_variable_54(void);
static NODE *func__compiler__define_variable_55;
static void entry__compiler__define_variable_55(void);
static FRAME_INFO frame__compiler__define_variable_55 = {3, {"mangled_name", "namespace", "name"}};
static NODE *string__dd395a997055f7fe;
static NODE *string__34fd7239574f514;
static NODE *string__70ebfdeaadefaa37;
static NODE *string__5226770621835bc8;
static NODE *string__473bf089a0140715;
static NODE *string__36cf2bd921e53ad9;
static void cont__compiler__define_variable_62(void);
static void cont__compiler__define_variable_63(void);
static NODE *string__152abda47b75d554;
static NODE *string__29727158e7d3e55e;
static NODE *string__4a6ef2ffac34c765;
static void cont__compiler__define_variable_67(void);
static NODE *func__compiler__define_variable_68;
static void entry__compiler__define_variable_68(void);
static FRAME_INFO frame__compiler__define_variable_68 = {3, {"mangled_name", "namespace", "name"}};
static NODE *string__746bfddaaddfea37;
static NODE *string__13372791bc1cbb98;
static NODE *string__8224dc1c3f83e7f2;
static NODE *string__1e8f2aa38d3f4060;
static NODE *string__43bbf0b9a0244715;
static void cont__compiler__define_variable_74(void);
static void cont__compiler__define_variable_75(void);
static NODE *string__32c94d852a3f04ef;
static NODE *string__5e7cd5f37502c62e;
static NODE *string__4a4ee6e733be0622;
static void cont__compiler__define_variable_79(void);
static NODE *func__compiler__define_variable_80;
static void entry__compiler__define_variable_80(void);
static FRAME_INFO frame__compiler__define_variable_80 = {4, {"kind", "mangled_name", "source", "name"}};
static NODE *func__compiler__define_variable_81;
static void entry__compiler__define_variable_81(void);
static FRAME_INFO frame__compiler__define_variable_81 = {3, {"mangled_name", "source", "name"}};
static NODE *string__fa730415f296bee;
static NODE *string__fa730c15f496bc6;
static void cont__compiler__define_variable_84(void);
static void cont__compiler__define_variable_85(void);
static void cont__compiler__define_variable_86(void);
static void cont__compiler__define_variable_87(void);
static void cont__compiler__define_variable_88(void);
static void cont__compiler__define_variable_89(void);
static NODE *func__compiler__define_variable_90;
static void entry__compiler__define_variable_90(void);
static FRAME_INFO frame__compiler__define_variable_90 = {1, {"name"}};
static void cont__compiler__define_variable_91(void);
static void cont__compiler__define_variable_92(void);
static NODE *func__compiler__define_variable_93;
static void entry__compiler__define_variable_93(void);
static FRAME_INFO frame__compiler__define_variable_93 = {1, {"mangled_name"}};
static void cont__compiler__define_variable_94(void);
static void cont__compiler__define_variable_95(void);
static void cont__compiler__define_variable_96(void);
static void cont__compiler__define_variable_97(void);
static NODE *func__compiler__define_variable_98;
static void entry__compiler__define_variable_98(void);
static FRAME_INFO frame__compiler__define_variable_98 = {2, {"name", "source"}};
static void cont__compiler__define_variable_99(void);
static void cont__compiler__define_variable_100(void);
static NODE *string__4c5ea74244cf1425;
static void cont__compiler__define_variable_102(void);
static void cont__compiler__define_variable_103(void);
static void cont__compiler__define_variable_104(void);
static NODE *func__compiler__define_variable_105;
static void entry__compiler__define_variable_105(void);
static FRAME_INFO frame__compiler__define_variable_105 = {1, {"name"}};
static NODE *string__29721158e7d3e55e;
static NODE *string__8275ab8967245782;
static void cont__compiler__define_variable_108(void);
static NODE *func__compiler__define_variable_109;
static void entry__compiler__define_variable_109(void);
static FRAME_INFO frame__compiler__define_variable_109 = {1, {"name"}};
static void cont__compiler__define_variable_110(void);
static void cont__compiler__define_variable_111(void);
static void cont__compiler__define_variable_112(void);
static void cont__compiler__define_variable_113(void);
static void cont__compiler__define_variable_114(void);
static NODE *func__compiler__define_variable_115;
static void entry__compiler__define_variable_115(void);
static FRAME_INFO frame__compiler__define_variable_115 = {1, {"kind"}};
static void cont__compiler__define_variable_116(void);
static void cont__compiler__define_variable_117(void);
static NODE *func__compiler__define_variable_118;
static void entry__compiler__define_variable_118(void);
static FRAME_INFO frame__compiler__define_variable_118 = {2, {"source", "mangled_name"}};
static void cont__compiler__define_variable_119(void);
static NODE *func__compiler__define_variable_120;
static void entry__compiler__define_variable_120(void);
static FRAME_INFO frame__compiler__define_variable_120 = {2, {"mangled_name", "source"}};
static void cont__compiler__define_variable_121(void);
static void cont__compiler__define_variable_122(void);
static NODE *func__compiler__define_variable_123;
static void entry__compiler__define_variable_123(void);
static FRAME_INFO frame__compiler__define_variable_123 = {2, {"source", "mangled_name"}};
static void cont__compiler__define_variable_124(void);
static NODE *func__compiler__define_variable_125;
static void entry__compiler__define_variable_125(void);
static FRAME_INFO frame__compiler__define_variable_125 = {2, {"mangled_name", "source"}};
static void cont__compiler__define_variable_126(void);
static void cont__compiler__define_variable_127(void);
static void cont__compiler__define_variable_128(void);
static NODE *func__compiler__define_variable_129;
static void entry__compiler__define_variable_129(void);
static FRAME_INFO frame__compiler__define_variable_129 = {2, {"mangled_name", "source"}};
static void cont__compiler__define_variable_130(void);
static NODE *string__2690e3d8e7540abd;
static NODE *string__920afb0b5f007d19;
static void cont__compiler__define_variable_133(void);
static NODE *func__compiler__define_variable_134;
static void entry__compiler__define_variable_134(void);
static FRAME_INFO frame__compiler__define_variable_134 = {2, {"mangled_name", "source"}};
static void cont__compiler__define_variable_135(void);
static NODE *string__55defe7d73d85409;
static void cont__compiler__define_variable_137(void);
static NODE *get__compiler__define_variable(void) {
  return var.compiler__define_variable;
}
static NODE *func__namespace_argument;
static void entry__namespace_argument(void);
static FRAME_INFO frame__namespace_argument = {1, {"namespace"}};
static void cont__namespace_argument_2(void);
static NODE *func__namespace_argument_3;
static void entry__namespace_argument_3(void);
static FRAME_INFO frame__namespace_argument_3 = {1, {"namespace"}};
static void cont__namespace_argument_4(void);
static NODE *func__namespace_argument_5;
static void entry__namespace_argument_5(void);
static FRAME_INFO frame__namespace_argument_5 = {0, {}};
static NODE *string__5e0ae40b5c007d75;
static NODE *func__compiler__define_attribute;
static void entry__compiler__define_attribute(void);
static FRAME_INFO frame__compiler__define_attribute = {7, {"definition", "source", "namespace", "name", "mangled_name", "attribute_name", "src"}};
static void cont__compiler__define_attribute_2(void);
static void cont__compiler__define_attribute_3(void);
static void cont__compiler__define_attribute_4(void);
static void cont__compiler__define_attribute_5(void);
static NODE *func__compiler__define_attribute_6;
static void entry__compiler__define_attribute_6(void);
static FRAME_INFO frame__compiler__define_attribute_6 = {2, {"src", "source"}};
static void cont__compiler__define_attribute_7(void);
static NODE *func__compiler__define_attribute_8;
static void entry__compiler__define_attribute_8(void);
static FRAME_INFO frame__compiler__define_attribute_8 = {3, {"src", "mangled_name", "attribute_name"}};
static NODE *string__485aef83eb317008;
static void cont__compiler__define_attribute_10(void);
static void cont__compiler__define_attribute_11(void);
static void cont__compiler__define_attribute_12(void);
static void cont__compiler__define_attribute_13(void);
static NODE *func__compiler__define_attribute_14;
static void entry__compiler__define_attribute_14(void);
static FRAME_INFO frame__compiler__define_attribute_14 = {1, {"name"}};
static void cont__compiler__define_attribute_15(void);
static void cont__compiler__define_attribute_16(void);
static void cont__compiler__define_attribute_17(void);
static NODE *func__compiler__define_attribute_18;
static void entry__compiler__define_attribute_18(void);
static FRAME_INFO frame__compiler__define_attribute_18 = {4, {"namespace", "name", "attribute_name", "src"}};
static void cont__compiler__define_attribute_19(void);
static NODE *string__74e31c7f67a4e996;
static NODE *string__fa733415f296bee;
static NODE *string__ca0e521fba2cc724;
static void cont__compiler__define_attribute_23(void);
static NODE *func__compiler__define_attribute_24;
static void entry__compiler__define_attribute_24(void);
static FRAME_INFO frame__compiler__define_attribute_24 = {3, {"name", "attribute_name", "src"}};
static void cont__compiler__define_attribute_25(void);
static void cont__compiler__define_attribute_26(void);
static NODE *get__compiler__define_attribute(void) {
  return var.compiler__define_attribute;
}
static NODE *func__compiler__define_method;
static void entry__compiler__define_method(void);
static FRAME_INFO frame__compiler__define_method = {7, {"definition", "source", "namespace", "name", "mangled_name", "attribute_name", "src"}};
static void cont__compiler__define_method_2(void);
static void cont__compiler__define_method_3(void);
static void cont__compiler__define_method_4(void);
static void cont__compiler__define_method_5(void);
static NODE *func__compiler__define_method_6;
static void entry__compiler__define_method_6(void);
static FRAME_INFO frame__compiler__define_method_6 = {2, {"src", "source"}};
static void cont__compiler__define_method_7(void);
static NODE *func__compiler__define_method_8;
static void entry__compiler__define_method_8(void);
static FRAME_INFO frame__compiler__define_method_8 = {3, {"src", "mangled_name", "attribute_name"}};
static void cont__compiler__define_method_9(void);
static void cont__compiler__define_method_10(void);
static void cont__compiler__define_method_11(void);
static void cont__compiler__define_method_12(void);
static NODE *func__compiler__define_method_13;
static void entry__compiler__define_method_13(void);
static FRAME_INFO frame__compiler__define_method_13 = {1, {"name"}};
static void cont__compiler__define_method_14(void);
static void cont__compiler__define_method_15(void);
static void cont__compiler__define_method_16(void);
static NODE *func__compiler__define_method_17;
static void entry__compiler__define_method_17(void);
static FRAME_INFO frame__compiler__define_method_17 = {4, {"namespace", "name", "attribute_name", "src"}};
static void cont__compiler__define_method_18(void);
static NODE *string__45b0be3ac644df67;
static void cont__compiler__define_method_20(void);
static NODE *func__compiler__define_method_21;
static void entry__compiler__define_method_21(void);
static FRAME_INFO frame__compiler__define_method_21 = {3, {"name", "attribute_name", "src"}};
static void cont__compiler__define_method_22(void);
static void cont__compiler__define_method_23(void);
static NODE *get__compiler__define_method(void) {
  return var.compiler__define_method;
}
static NODE *func__compiler__define_type_function;
static void entry__compiler__define_type_function(void);
static FRAME_INFO frame__compiler__define_type_function = {7, {"definition", "source", "namespace", "name", "mangled_name", "entry", "par_count"}};
static void cont__compiler__define_type_function_2(void);
static void cont__compiler__define_type_function_3(void);
static void cont__compiler__define_type_function_4(void);
static NODE *func__compiler__define_type_function_5;
static void entry__compiler__define_type_function_5(void);
static FRAME_INFO frame__compiler__define_type_function_5 = {1, {"name"}};
static void cont__compiler__define_type_function_6(void);
static void cont__compiler__define_type_function_7(void);
static void cont__compiler__define_type_function_8(void);
static NODE *func__compiler__define_type_function_9;
static void entry__compiler__define_type_function_9(void);
static FRAME_INFO frame__compiler__define_type_function_9 = {4, {"namespace", "name", "entry", "par_count"}};
static void cont__compiler__define_type_function_10(void);
static NODE *string__292e5d6949e4a763;
static void cont__compiler__define_type_function_12(void);
static NODE *func__compiler__define_type_function_13;
static void entry__compiler__define_type_function_13(void);
static FRAME_INFO frame__compiler__define_type_function_13 = {2, {"name", "entry"}};
static void cont__compiler__define_type_function_14(void);
static void cont__compiler__define_type_function_15(void);
static NODE *get__compiler__define_type_function(void) {
  return var.compiler__define_type_function;
}
static NODE *func__compiler__define_polymorphic_function;
static void entry__compiler__define_polymorphic_function(void);
static FRAME_INFO frame__compiler__define_polymorphic_function = {8, {"definition", "is_a_setter", "with_setter", "namespace", "name", "mangled_name", "id", "info"}};
static NODE *func__compiler__define_polymorphic_function_2;
static void entry__compiler__define_polymorphic_function_2(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_2 = {1, {"is_a_setter"}};
static NODE *func__compiler__define_polymorphic_function_3;
static void entry__compiler__define_polymorphic_function_3(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_3 = {0, {}};
static NODE *string__62213544ce52579e;
static NODE *func__compiler__define_polymorphic_function_5;
static void entry__compiler__define_polymorphic_function_5(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_5 = {0, {}};
static void cont__compiler__define_polymorphic_function_6(void);
static void cont__compiler__define_polymorphic_function_7(void);
static NODE *func__compiler__define_polymorphic_function_8;
static void entry__compiler__define_polymorphic_function_8(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_8 = {1, {"mangled_name"}};
static void cont__compiler__define_polymorphic_function_9(void);
static NODE *func__compiler__define_polymorphic_function_10;
static void entry__compiler__define_polymorphic_function_10(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_10 = {1, {"mangled_name"}};
static void cont__compiler__define_polymorphic_function_11(void);
static void cont__compiler__define_polymorphic_function_12(void);
static void cont__compiler__define_polymorphic_function_13(void);
static void cont__compiler__define_polymorphic_function_14(void);
static void cont__compiler__define_polymorphic_function_15(void);
static void cont__compiler__define_polymorphic_function_16(void);
static void cont__compiler__define_polymorphic_function_17(void);
static NODE *func__compiler__define_polymorphic_function_18;
static void entry__compiler__define_polymorphic_function_18(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_18 = {1, {"id"}};
static void cont__compiler__define_polymorphic_function_19(void);
static NODE *func__compiler__define_polymorphic_function_20;
static void entry__compiler__define_polymorphic_function_20(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_20 = {0, {}};
static void cont__compiler__define_polymorphic_function_21(void);
static NODE *string__dd59fa996655f7be;
static void cont__compiler__define_polymorphic_function_23(void);
static void cont__compiler__define_polymorphic_function_24(void);
static void cont__compiler__define_polymorphic_function_25(void);
static void cont__compiler__define_polymorphic_function_26(void);
static void cont__compiler__define_polymorphic_function_27(void);
static void cont__compiler__define_polymorphic_function_28(void);
static void cont__compiler__define_polymorphic_function_29(void);
static void cont__compiler__define_polymorphic_function_30(void);
static NODE *string__4edc27e6c3faecfa;
static void cont__compiler__define_polymorphic_function_32(void);
static void cont__compiler__define_polymorphic_function_33(void);
static void cont__compiler__define_polymorphic_function_34(void);
static void cont__compiler__define_polymorphic_function_35(void);
static NODE *string__63e6320520af81f6;
static NODE *string__fd94bfb0860889aa;
static void cont__compiler__define_polymorphic_function_38(void);
static void cont__compiler__define_polymorphic_function_39(void);
static void cont__compiler__define_polymorphic_function_40(void);
static NODE *func__compiler__define_polymorphic_function_41;
static void entry__compiler__define_polymorphic_function_41(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_41 = {5, {"namespace", "name", "id", "mangled_name", "with_setter"}};
static void cont__compiler__define_polymorphic_function_42(void);
static void cont__compiler__define_polymorphic_function_43(void);
static void cont__compiler__define_polymorphic_function_44(void);
static NODE *func__compiler__define_polymorphic_function_45;
static void entry__compiler__define_polymorphic_function_45(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_45 = {4, {"namespace", "name", "mangled_name", "id"}};
static void cont__compiler__define_polymorphic_function_46(void);
static NODE *string__94aa6a2a3d156a1a;
static void cont__compiler__define_polymorphic_function_48(void);
static NODE *func__compiler__define_polymorphic_function_49;
static void entry__compiler__define_polymorphic_function_49(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_49 = {4, {"with_setter", "namespace", "name", "mangled_name"}};
static void cont__compiler__define_polymorphic_function_50(void);
static void cont__compiler__define_polymorphic_function_51(void);
static NODE *string__3764e728034d321b;
static NODE *string__2d7981f4e6482be7;
static NODE *string__4a0e52ffba34c725;
static void cont__compiler__define_polymorphic_function_55(void);
static NODE *func__compiler__define_polymorphic_function_56;
static void entry__compiler__define_polymorphic_function_56(void);
static FRAME_INFO frame__compiler__define_polymorphic_function_56 = {2, {"with_setter", "name"}};
static void cont__compiler__define_polymorphic_function_57(void);
static NODE *string__6a22d67b14b60a68;
static NODE *string__fa732415f396b93;
static NODE *string__2d7981f4e6d82bff;
static NODE *string__286520bd3a268298;
static void cont__compiler__define_polymorphic_function_62(void);
static NODE *get__compiler__define_polymorphic_function(void) {
  return var.compiler__define_polymorphic_function;
}
static NODE *func__compiler__define_c_code;
static void entry__compiler__define_c_code(void);
static FRAME_INFO frame__compiler__define_c_code = {1, {"self"}};
static NODE *string__456a9bb1ba62862f;
static void cont__compiler__define_c_code_3(void);
static NODE *func__compiler__define_c_code_4;
static void entry__compiler__define_c_code_4(void);
static FRAME_INFO frame__compiler__define_c_code_4 = {10, {"self", "kind", "source", "scope", "identifier", "namespace", "name", "mangled_name", "type", "initialize_object"}};
static NODE *func__compiler__define_c_code_5;
static void entry__compiler__define_c_code_5(void);
static FRAME_INFO frame__compiler__define_c_code_5 = {6, {"obj_type", "as_a_future", "self", "mangled_name", "namespace", "arguments"}};
static void cont__compiler__define_c_code_6(void);
static NODE *func__compiler__define_c_code_7;
static void entry__compiler__define_c_code_7(void);
static FRAME_INFO frame__compiler__define_c_code_7 = {2, {"argument", "arguments"}};
static void cont__compiler__define_c_code_8(void);
static NODE *func__compiler__define_c_code_9;
static void entry__compiler__define_c_code_9(void);
static FRAME_INFO frame__compiler__define_c_code_9 = {1, {"arguments"}};
static void cont__compiler__define_c_code_10(void);
static void cont__compiler__define_c_code_11(void);
static void cont__compiler__define_c_code_12(void);
static NODE *func__compiler__define_c_code_13;
static void entry__compiler__define_c_code_13(void);
static FRAME_INFO frame__compiler__define_c_code_13 = {1, {"mangled_name"}};
static void cont__compiler__define_c_code_14(void);
static NODE *func__compiler__define_c_code_15;
static void entry__compiler__define_c_code_15(void);
static FRAME_INFO frame__compiler__define_c_code_15 = {1, {"mangled_name"}};
static void cont__compiler__define_c_code_16(void);
static void cont__compiler__define_c_code_17(void);
static void cont__compiler__define_c_code_18(void);
static void cont__compiler__define_c_code_19(void);
static void cont__compiler__define_c_code_20(void);
static void cont__compiler__define_c_code_21(void);
static void cont__compiler__define_c_code_22(void);
static void cont__compiler__define_c_code_23(void);
static void cont__compiler__define_c_code_24(void);
static NODE *func__compiler__define_c_code_25;
static void entry__compiler__define_c_code_25(void);
static FRAME_INFO frame__compiler__define_c_code_25 = {3, {"mangled_name", "obj_type", "arguments"}};
static void cont__compiler__define_c_code_26(void);
static NODE *string__ed193cb4814526fb;
static void cont__compiler__define_c_code_28(void);
static NODE *func__compiler__define_c_code_29;
static void entry__compiler__define_c_code_29(void);
static FRAME_INFO frame__compiler__define_c_code_29 = {3, {"mangled_name", "obj_type", "arguments"}};
static void cont__compiler__define_c_code_30(void);
static NODE *string__a897d8196ef1bb0f;
static void cont__compiler__define_c_code_32(void);
static void cont__compiler__define_c_code_33(void);
static void cont__compiler__define_c_code_34(void);
static NODE *func__compiler__define_c_code_35;
static void entry__compiler__define_c_code_35(void);
static FRAME_INFO frame__compiler__define_c_code_35 = {1, {"mangled_name"}};
static void cont__compiler__define_c_code_36(void);
static NODE *string__327b6356c2c20676;
static void cont__compiler__define_c_code_38(void);
static void cont__compiler__define_c_code_39(void);
static void cont__compiler__define_c_code_40(void);
static void cont__compiler__define_c_code_41(void);
static NODE *string__9a4c0f9815d2209f;
static NODE *func__compiler__define_c_code_43;
static void entry__compiler__define_c_code_43(void);
static FRAME_INFO frame__compiler__define_c_code_43 = {0, {}};
static NODE *string__461f56c301b292bb;
static NODE *func__compiler__define_c_code_45;
static void entry__compiler__define_c_code_45(void);
static FRAME_INFO frame__compiler__define_c_code_45 = {0, {}};
static NODE *string__701f5702012bd2b9;
static NODE *func__compiler__define_c_code_47;
static void entry__compiler__define_c_code_47(void);
static FRAME_INFO frame__compiler__define_c_code_47 = {0, {}};
static NODE *string__b810095e95cb80da;
static NODE *func__compiler__define_c_code_49;
static void entry__compiler__define_c_code_49(void);
static FRAME_INFO frame__compiler__define_c_code_49 = {0, {}};
static NODE *string__9a480f9895a2d0da;
static void cont__compiler__define_c_code_51(void);
static void cont__compiler__define_c_code_52(void);
static void cont__compiler__define_c_code_53(void);
static NODE *func__compiler__define_c_code_54;
static void entry__compiler__define_c_code_54(void);
static FRAME_INFO frame__compiler__define_c_code_54 = {1, {"identifier"}};
static void cont__compiler__define_c_code_55(void);
static NODE *func__compiler__define_c_code_56;
static void entry__compiler__define_c_code_56(void);
static FRAME_INFO frame__compiler__define_c_code_56 = {0, {}};
static void cont__compiler__define_c_code_57(void);
static void cont__compiler__define_c_code_58(void);
static NODE *func__compiler__define_c_code_59;
static void entry__compiler__define_c_code_59(void);
static FRAME_INFO frame__compiler__define_c_code_59 = {1, {"identifier"}};
static void cont__compiler__define_c_code_60(void);
static NODE *func__compiler__define_c_code_61;
static void entry__compiler__define_c_code_61(void);
static FRAME_INFO frame__compiler__define_c_code_61 = {0, {}};
static void cont__compiler__define_c_code_62(void);
static void cont__compiler__define_c_code_63(void);
static NODE *func__compiler__define_c_code_64;
static void entry__compiler__define_c_code_64(void);
static FRAME_INFO frame__compiler__define_c_code_64 = {1, {"self"}};
static void cont__compiler__define_c_code_65(void);
static void cont__compiler__define_c_code_66(void);
static NODE *func__compiler__define_c_code_67;
static void entry__compiler__define_c_code_67(void);
static FRAME_INFO frame__compiler__define_c_code_67 = {0, {}};
static void cont__compiler__define_c_code_68(void);
static void cont__compiler__define_c_code_69(void);
static void cont__compiler__define_c_code_70(void);
static NODE *func__compiler__define_c_code_71;
static void entry__compiler__define_c_code_71(void);
static FRAME_INFO frame__compiler__define_c_code_71 = {1, {"self"}};
static void cont__compiler__define_c_code_72(void);
static void cont__compiler__define_c_code_73(void);
static NODE *func__compiler__define_c_code_74;
static void entry__compiler__define_c_code_74(void);
static FRAME_INFO frame__compiler__define_c_code_74 = {0, {}};
static void cont__compiler__define_c_code_75(void);
static NODE *func__compiler__define_c_code_76;
static void entry__compiler__define_c_code_76(void);
static FRAME_INFO frame__compiler__define_c_code_76 = {2, {"mangled_name", "source"}};
static void cont__compiler__define_c_code_77(void);
static NODE *string__3148e46705c3e08c;
static NODE *string__44fc2666d9a259c5;
static NODE *string__fa730415df16bc6;
static NODE *string__d60aee0b5fb87d33;
static void cont__compiler__define_c_code_82(void);
static NODE *func__compiler__define_c_code_83;
static void entry__compiler__define_c_code_83(void);
static FRAME_INFO frame__compiler__define_c_code_83 = {4, {"source", "mangled_name", "scope", "collector_name"}};
static void cont__compiler__define_c_code_84(void);
static NODE *string__dd8b990a9b395bcf;
static NODE *string__fa73ac15dc16bec;
static void cont__compiler__define_c_code_87(void);
static void cont__compiler__define_c_code_88(void);
static void cont__compiler__define_c_code_89(void);
static NODE *string__64a8ad100475501f;
static void cont__compiler__define_c_code_91(void);
static void cont__compiler__define_c_code_92(void);
static NODE *func__compiler__define_c_code_93;
static void entry__compiler__define_c_code_93(void);
static FRAME_INFO frame__compiler__define_c_code_93 = {4, {"scope", "collector_name", "mangled_name", "source"}};
static NODE *string__4a1f574b83baa2fd;
static NODE *string__3cc912e9d780065b;
static NODE *string__ace7f55a2ad7b400;
static NODE *string__c14689165b56e017;
static void cont__compiler__define_c_code_98(void);
static void cont__compiler__define_c_code_99(void);
static NODE *func__compiler__define_c_code_100;
static void entry__compiler__define_c_code_100(void);
static FRAME_INFO frame__compiler__define_c_code_100 = {4, {"line", "field_type", "field_name", "base_type"}};
static NODE *string__2d7981f4e6702bea;
static void cont__compiler__define_c_code_102(void);
static void cont__compiler__define_c_code_103(void);
static void cont__compiler__define_c_code_104(void);
static void cont__compiler__define_c_code_105(void);
static void cont__compiler__define_c_code_106(void);
static void cont__compiler__define_c_code_107(void);
static void cont__compiler__define_c_code_108(void);
static void cont__compiler__define_c_code_109(void);
static void cont__compiler__define_c_code_110(void);
static void cont__compiler__define_c_code_111(void);
static void cont__compiler__define_c_code_112(void);
static NODE *func__compiler__define_c_code_113;
static void entry__compiler__define_c_code_113(void);
static FRAME_INFO frame__compiler__define_c_code_113 = {1, {"field_type"}};
static NODE *string__2d7981f4e6082bef;
static void cont__compiler__define_c_code_115(void);
static NODE *func__compiler__define_c_code_116;
static void entry__compiler__define_c_code_116(void);
static FRAME_INFO frame__compiler__define_c_code_116 = {1, {"field_type"}};
static void cont__compiler__define_c_code_117(void);
static void cont__compiler__define_c_code_118(void);
static NODE *func__compiler__define_c_code_119;
static void entry__compiler__define_c_code_119(void);
static FRAME_INFO frame__compiler__define_c_code_119 = {1, {"field_type"}};
static void cont__compiler__define_c_code_120(void);
static NODE *func__compiler__define_c_code_121;
static void entry__compiler__define_c_code_121(void);
static FRAME_INFO frame__compiler__define_c_code_121 = {1, {"field_type"}};
static void cont__compiler__define_c_code_122(void);
static void cont__compiler__define_c_code_123(void);
static NODE *func__compiler__define_c_code_124;
static void entry__compiler__define_c_code_124(void);
static FRAME_INFO frame__compiler__define_c_code_124 = {0, {}};
static NODE *func__compiler__define_c_code_125;
static void entry__compiler__define_c_code_125(void);
static FRAME_INFO frame__compiler__define_c_code_125 = {0, {}};
static void cont__compiler__define_c_code_126(void);
static void cont__compiler__define_c_code_127(void);
static NODE *func__compiler__define_c_code_128;
static void entry__compiler__define_c_code_128(void);
static FRAME_INFO frame__compiler__define_c_code_128 = {1, {"base_type"}};
static void cont__compiler__define_c_code_129(void);
static void cont__compiler__define_c_code_130(void);
static NODE *func__compiler__define_c_code_131;
static void entry__compiler__define_c_code_131(void);
static FRAME_INFO frame__compiler__define_c_code_131 = {2, {"field_name", "base_type"}};
static void cont__compiler__define_c_code_132(void);
static NODE *string__8221090a5decf427;
static NODE *string__8ae3d99defa96b0f;
static NODE *string__bb240c9597d230c4;
static void cont__compiler__define_c_code_136(void);
static NODE *func__compiler__define_c_code_137;
static void entry__compiler__define_c_code_137(void);
static FRAME_INFO frame__compiler__define_c_code_137 = {1, {"field_name"}};
static NODE *string__67b027ebc06b8f3b;
static void cont__compiler__define_c_code_139(void);
static void cont__compiler__define_c_code_140(void);
static NODE *string__109c72e613b07f37;
static NODE *func__compiler__define_c_code_142;
static void entry__compiler__define_c_code_142(void);
static FRAME_INFO frame__compiler__define_c_code_142 = {13, {"self", "initialize_object", "mangled_name", "namespace", "name", "scope", "source", "node_name", "node", "arguments", "initializers", "attributes_declaration", "constructor_name"}};
static void cont__compiler__define_c_code_143(void);
static void cont__compiler__define_c_code_144(void);
static void cont__compiler__define_c_code_145(void);
static NODE *func__compiler__define_c_code_146;
static void entry__compiler__define_c_code_146(void);
static FRAME_INFO frame__compiler__define_c_code_146 = {1, {"node_name"}};
static NODE *string__b03fb6d3baf99607;
static NODE *string__2d7981f4e6182be4;
static void cont__compiler__define_c_code_149(void);
static void cont__compiler__define_c_code_150(void);
static void cont__compiler__define_c_code_151(void);
static void cont__compiler__define_c_code_152(void);
static NODE *func__compiler__define_c_code_153;
static void entry__compiler__define_c_code_153(void);
static FRAME_INFO frame__compiler__define_c_code_153 = {3, {"initialize_object", "mangled_name", "self"}};
static void cont__compiler__define_c_code_154(void);
static void cont__compiler__define_c_code_155(void);
static void cont__compiler__define_c_code_156(void);
static void cont__compiler__define_c_code_157(void);
static NODE *func__compiler__define_c_code_158;
static void entry__compiler__define_c_code_158(void);
static FRAME_INFO frame__compiler__define_c_code_158 = {2, {"initialize_object", "mangled_name"}};
static void cont__compiler__define_c_code_159(void);
static void cont__compiler__define_c_code_160(void);
static NODE *func__compiler__define_c_code_161;
static void entry__compiler__define_c_code_161(void);
static FRAME_INFO frame__compiler__define_c_code_161 = {3, {"namespace", "name", "mangled_name"}};
static void cont__compiler__define_c_code_162(void);
static void cont__compiler__define_c_code_163(void);
static void cont__compiler__define_c_code_164(void);
static void cont__compiler__define_c_code_165(void);
static NODE *func__compiler__define_c_code_166;
static void entry__compiler__define_c_code_166(void);
static FRAME_INFO frame__compiler__define_c_code_166 = {6, {"line", "arguments", "initializers", "node_name", "field_type", "field_name"}};
static void cont__compiler__define_c_code_167(void);
static void cont__compiler__define_c_code_168(void);
static void cont__compiler__define_c_code_169(void);
static void cont__compiler__define_c_code_170(void);
static void cont__compiler__define_c_code_171(void);
static void cont__compiler__define_c_code_172(void);
static void cont__compiler__define_c_code_173(void);
static void cont__compiler__define_c_code_174(void);
static void cont__compiler__define_c_code_175(void);
static void cont__compiler__define_c_code_176(void);
static void cont__compiler__define_c_code_177(void);
static void cont__compiler__define_c_code_178(void);
static void cont__compiler__define_c_code_179(void);
static NODE *func__compiler__define_c_code_180;
static void entry__compiler__define_c_code_180(void);
static FRAME_INFO frame__compiler__define_c_code_180 = {1, {"arguments"}};
static void cont__compiler__define_c_code_181(void);
static void cont__compiler__define_c_code_182(void);
static void cont__compiler__define_c_code_183(void);
static void cont__compiler__define_c_code_184(void);
static NODE *string__6794ac9106bd681e;
static NODE *string__578a5af303e9ccf;
static void cont__compiler__define_c_code_187(void);
static void cont__compiler__define_c_code_188(void);
static NODE *func__compiler__define_c_code_189;
static void entry__compiler__define_c_code_189(void);
static FRAME_INFO frame__compiler__define_c_code_189 = {1, {"arguments"}};
static void cont__compiler__define_c_code_190(void);
static void cont__compiler__define_c_code_191(void);
static void cont__compiler__define_c_code_192(void);
static void cont__compiler__define_c_code_193(void);
static void cont__compiler__define_c_code_194(void);
static NODE *string__734b84c8aaa0637f;
static NODE *string__6b4ef47674efbb78;
static NODE *string__ff4aca011f98585e;
static NODE *string__2d7981f4e6682bcf;
static void cont__compiler__define_c_code_199(void);
static NODE *func__compiler__define_c_code_200;
static void entry__compiler__define_c_code_200(void);
static FRAME_INFO frame__compiler__define_c_code_200 = {6, {"entry", "namespace", "name", "attributes_declaration", "mangled_name", "func_name"}};
static void cont__compiler__define_c_code_201(void);
static NODE *func__compiler__define_c_code_202;
static void entry__compiler__define_c_code_202(void);
static FRAME_INFO frame__compiler__define_c_code_202 = {1, {"namespace"}};
static void cont__compiler__define_c_code_203(void);
static NODE *func__compiler__define_c_code_204;
static void entry__compiler__define_c_code_204(void);
static FRAME_INFO frame__compiler__define_c_code_204 = {0, {}};
static void cont__compiler__define_c_code_205(void);
static void cont__compiler__define_c_code_206(void);
static void cont__compiler__define_c_code_207(void);
static NODE *func__compiler__define_c_code_208;
static void entry__compiler__define_c_code_208(void);
static FRAME_INFO frame__compiler__define_c_code_208 = {3, {"attributes_declaration", "mangled_name", "entry"}};
static NODE *string__73a8266fc3fa2cfa;
static NODE *string__fa72f815cd16b93;
static void cont__compiler__define_c_code_211(void);
static NODE *func__compiler__define_c_code_212;
static void entry__compiler__define_c_code_212(void);
static FRAME_INFO frame__compiler__define_c_code_212 = {1, {"attributes_declaration"}};
static NODE *string__eaff60749c89e4cd;
static void cont__compiler__define_c_code_214(void);
static NODE *func__compiler__define_c_code_215;
static void entry__compiler__define_c_code_215(void);
static FRAME_INFO frame__compiler__define_c_code_215 = {1, {"attributes_declaration"}};
static void cont__compiler__define_c_code_216(void);
static void cont__compiler__define_c_code_217(void);
static void cont__compiler__define_c_code_218(void);
static NODE *string__cd95367056669d06;
static void cont__compiler__define_c_code_220(void);
static NODE *func__compiler__define_c_code_221;
static void entry__compiler__define_c_code_221(void);
static FRAME_INFO frame__compiler__define_c_code_221 = {1, {"attributes_declaration"}};
static NODE *string__c94100bb7a7ab992;
static void cont__compiler__define_c_code_223(void);
static NODE *func__compiler__define_c_code_224;
static void entry__compiler__define_c_code_224(void);
static FRAME_INFO frame__compiler__define_c_code_224 = {2, {"attributes_declaration", "mangled_name"}};
static NODE *string__a56c0e191d6c2c6;
static NODE *string__2fd6cd588445ce22;
static NODE *string__b0750f892a4c2658;
static void cont__compiler__define_c_code_228(void);
static void cont__compiler__define_c_code_229(void);
static void cont__compiler__define_c_code_230(void);
static void cont__compiler__define_c_code_231(void);
static NODE *string__7ddeab9420211acf;
static void cont__compiler__define_c_code_233(void);
static void cont__compiler__define_c_code_234(void);
static void cont__compiler__define_c_code_235(void);
static void cont__compiler__define_c_code_236(void);
static NODE *string__21dd4811a7f03bfa;
static void cont__compiler__define_c_code_238(void);
static void cont__compiler__define_c_code_239(void);
static NODE *string__46dcac94852d801f;
static void cont__compiler__define_c_code_241(void);
static void cont__compiler__define_c_code_242(void);
static NODE *func__compiler__define_c_code_243;
static void entry__compiler__define_c_code_243(void);
static FRAME_INFO frame__compiler__define_c_code_243 = {6, {"scope", "constructor_name", "arguments", "node_name", "mangled_name", "initializers"}};
static NODE *string__101f5f1783b8a2fd;
static void cont__compiler__define_c_code_245(void);
static void cont__compiler__define_c_code_246(void);
static NODE *string__1c6c7289032a5d69;
static void cont__compiler__define_c_code_248(void);
static NODE *func__compiler__define_c_code_249;
static void entry__compiler__define_c_code_249(void);
static FRAME_INFO frame__compiler__define_c_code_249 = {4, {"mangled_name", "scope", "constructor_name", "arguments"}};
static NODE *string__94481952eb48e343;
static NODE *string__505bb7858ec4a9cf;
static NODE *string__b067b139c37c931b;
static NODE *string__89ac1b3296eec0f0;
static NODE *string__a9ca63e3254dce43;
static NODE *string__8359f29999c3244b;
static void cont__compiler__define_c_code_256(void);
static NODE *func__compiler__define_c_code_257;
static void entry__compiler__define_c_code_257(void);
static FRAME_INFO frame__compiler__define_c_code_257 = {6, {"scope", "constructor_name", "arguments", "node_name", "mangled_name", "initializers"}};
static NODE *string__27970d05ed81c641;
static NODE *string__8262d9eaa714e89c;
static NODE *string__16179a4c575e7ddc;
static NODE *string__59fe708e86aaa5e8;
static void cont__compiler__define_c_code_262(void);
static NODE *func__compiler__define_c_code_263;
static void entry__compiler__define_c_code_263(void);
static FRAME_INFO frame__compiler__define_c_code_263 = {5, {"initialize_object", "type", "namespace", "name", "mangled_name"}};
static void cont__compiler__define_c_code_264(void);
static void cont__compiler__define_c_code_265(void);
static NODE *func__compiler__define_c_code_266;
static void entry__compiler__define_c_code_266(void);
static FRAME_INFO frame__compiler__define_c_code_266 = {3, {"namespace", "name", "mangled_name"}};
static void cont__compiler__define_c_code_267(void);
static void cont__compiler__define_c_code_268(void);
static NODE *func__compiler__define_c_code_269;
static void entry__compiler__define_c_code_269(void);
static FRAME_INFO frame__compiler__define_c_code_269 = {10, {"source", "self", "scope", "raw_declaration", "type_and_name", "function_name", "mangled_function_name", "function_type", "arguments", "declaration"}};
static void cont__compiler__define_c_code_270(void);
static void cont__compiler__define_c_code_271(void);
static void cont__compiler__define_c_code_272(void);
static void cont__compiler__define_c_code_273(void);
static void cont__compiler__define_c_code_274(void);
static void cont__compiler__define_c_code_275(void);
static void cont__compiler__define_c_code_276(void);
static NODE *func__compiler__define_c_code_277;
static void entry__compiler__define_c_code_277(void);
static FRAME_INFO frame__compiler__define_c_code_277 = {1, {"function_name"}};
static NODE *string__748827e691fbe65a;
static void cont__compiler__define_c_code_279(void);
static NODE *func__compiler__define_c_code_280;
static void entry__compiler__define_c_code_280(void);
static FRAME_INFO frame__compiler__define_c_code_280 = {1, {"function_name"}};
static void cont__compiler__define_c_code_281(void);
static void cont__compiler__define_c_code_282(void);
static void cont__compiler__define_c_code_283(void);
static void cont__compiler__define_c_code_284(void);
static void cont__compiler__define_c_code_285(void);
static void cont__compiler__define_c_code_286(void);
static void cont__compiler__define_c_code_287(void);
static NODE *func__compiler__define_c_code_288;
static void entry__compiler__define_c_code_288(void);
static FRAME_INFO frame__compiler__define_c_code_288 = {0, {}};
static NODE *func__compiler__define_c_code_289;
static void entry__compiler__define_c_code_289(void);
static FRAME_INFO frame__compiler__define_c_code_289 = {0, {}};
static void cont__compiler__define_c_code_290(void);
static void cont__compiler__define_c_code_291(void);
static void cont__compiler__define_c_code_292(void);
static void cont__compiler__define_c_code_293(void);
static void cont__compiler__define_c_code_294(void);
static void cont__compiler__define_c_code_295(void);
static void cont__compiler__define_c_code_296(void);
static NODE *func__compiler__define_c_code_297;
static void entry__compiler__define_c_code_297(void);
static FRAME_INFO frame__compiler__define_c_code_297 = {2, {"function_name", "mangled_function_name"}};
static NODE *string__3d3ee41dbe82cf11;
static void cont__compiler__define_c_code_299(void);
static NODE *func__compiler__define_c_code_300;
static void entry__compiler__define_c_code_300(void);
static FRAME_INFO frame__compiler__define_c_code_300 = {2, {"scope", "declaration"}};
static void cont__compiler__define_c_code_301(void);
static void cont__compiler__define_c_code_302(void);
static void cont__compiler__define_c_code_303(void);
static void cont__compiler__define_c_code_304(void);
static void cont__compiler__define_c_code_305(void);
static NODE *func__compiler__define_c_code_306;
static void entry__compiler__define_c_code_306(void);
static FRAME_INFO frame__compiler__define_c_code_306 = {2, {"source", "scope"}};
static void cont__compiler__define_c_code_307(void);
static NODE *func__compiler__define_c_code_308;
static void entry__compiler__define_c_code_308(void);
static FRAME_INFO frame__compiler__define_c_code_308 = {2, {"line", "scope"}};
static void cont__compiler__define_c_code_309(void);
static NODE *func__compiler__define_c_code_310;
static void entry__compiler__define_c_code_310(void);
static FRAME_INFO frame__compiler__define_c_code_310 = {1, {"line"}};
static void cont__compiler__define_c_code_311(void);
static void cont__compiler__define_c_code_312(void);
static void cont__compiler__define_c_code_313(void);
static NODE *func__compiler__define_c_code_314;
static void entry__compiler__define_c_code_314(void);
static FRAME_INFO frame__compiler__define_c_code_314 = {2, {"line", "scope"}};
static NODE *string__b8540cde1593c09c;
static void cont__compiler__define_c_code_316(void);
static void cont__compiler__define_c_code_317(void);
static NODE *func__compiler__define_c_code_318;
static void entry__compiler__define_c_code_318(void);
static FRAME_INFO frame__compiler__define_c_code_318 = {1, {"scope"}};
static void cont__compiler__define_c_code_319(void);
static void cont__compiler__define_c_code_320(void);
static NODE *func__compiler__define_c_code_321;
static void entry__compiler__define_c_code_321(void);
static FRAME_INFO frame__compiler__define_c_code_321 = {1, {"kind"}};
static NODE *string__dc390a4415e8342c;
static NODE *string__3cadee4d21d69e73;
static void cont__compiler__define_c_code_324(void);
static NODE *string__7c1f530901a312a3;
static NODE *string__1e0aea8b5d407d5c;
static NODE *string__2a0aef0b5de07d5c;
static NODE *string__4c1f570701a272a3;
static NODE *string__46c0af9104ada08e;
static NODE *get__compiler__define_c_code(void) {
  return var.compiler__define_c_code;
}
static NODE *func__assign_attributes;
static void entry__assign_attributes(void);
static FRAME_INFO frame__assign_attributes = {4, {"destination", "source", "attributes", "code"}};
static void cont__assign_attributes_2(void);
static NODE *string__5aaca17e38892df6;
static NODE *string__3374d958c75663b2;
static void cont__assign_attributes_5(void);
static void cont__assign_attributes_6(void);
static NODE *func__assign_attributes_7;
static void entry__assign_attributes_7(void);
static FRAME_INFO frame__assign_attributes_7 = {3, {"attribute", "identifier", "value"}};
static void cont__assign_attributes_8(void);
static void cont__assign_attributes_9(void);
static void cont__assign_attributes_10(void);
static void cont__assign_attributes_11(void);
static void cont__assign_attributes_12(void);
static NODE *func__assign_attributes_13;
static void entry__assign_attributes_13(void);
static FRAME_INFO frame__assign_attributes_13 = {4, {"attribute", "identifier", "value", "kind"}};
static void cont__assign_attributes_14(void);
static NODE *func__assign_attributes_15;
static void entry__assign_attributes_15(void);
static FRAME_INFO frame__assign_attributes_15 = {0, {}};
static NODE *func__assign_attributes_16;
static void entry__assign_attributes_16(void);
static FRAME_INFO frame__assign_attributes_16 = {0, {}};
static NODE *string__5a1f555f011332b2;
static void cont__assign_attributes_18(void);
static void cont__assign_attributes_19(void);
static NODE *string__4913e735c7c32ec6;
static NODE *string__e44f3203f587e9fa;
static void cont__assign_attributes_22(void);
static NODE *func__assign_attributes_23;
static void entry__assign_attributes_23(void);
static FRAME_INFO frame__assign_attributes_23 = {1, {"value"}};
static NODE *string__7128a00098ab7c5;
static NODE *string__4fecac9c060c098a;
static void cont__assign_attributes_26(void);
static void cont__assign_attributes_27(void);
static NODE *string__2a0ae80b5d087d49;
static void cont__assign_attributes_29(void);
static NODE *string__ca5afb03ea26b05d;
static void cont__assign_attributes_31(void);
static NODE *func__compiler__generate_statement;
static void entry__compiler__generate_statement(void);
static FRAME_INFO frame__compiler__generate_statement = {4, {"statement", "functor", "input_arguments", "output_arguments"}};
static NODE *func__compiler__generate_statement_2;
static void entry__compiler__generate_statement_2(void);
static FRAME_INFO frame__compiler__generate_statement_2 = {1, {"statement"}};
static NODE *func__compiler__generate_statement_3;
static void entry__compiler__generate_statement_3(void);
static FRAME_INFO frame__compiler__generate_statement_3 = {1, {"statement"}};
static void cont__compiler__generate_statement_4(void);
static NODE *func__compiler__generate_statement_5;
static void entry__compiler__generate_statement_5(void);
static FRAME_INFO frame__compiler__generate_statement_5 = {0, {}};
static NODE *string__1f458f464eec9b66;
static NODE *func__compiler__generate_statement_7;
static void entry__compiler__generate_statement_7(void);
static FRAME_INFO frame__compiler__generate_statement_7 = {1, {"statement"}};
static void cont__compiler__generate_statement_8(void);
static NODE *func__compiler__generate_statement_9;
static void entry__compiler__generate_statement_9(void);
static FRAME_INFO frame__compiler__generate_statement_9 = {0, {}};
static NODE *string__80851998713c7b1d;
static NODE *func__compiler__generate_statement_11;
static void entry__compiler__generate_statement_11(void);
static FRAME_INFO frame__compiler__generate_statement_11 = {0, {}};
static NODE *string__8b102f799cb53c4;
static void cont__compiler__generate_statement_13(void);
static void cont__compiler__generate_statement_14(void);
static void cont__compiler__generate_statement_15(void);
static void cont__compiler__generate_statement_16(void);
static NODE *func__compiler__generate_statement_17;
static void entry__compiler__generate_statement_17(void);
static FRAME_INFO frame__compiler__generate_statement_17 = {3, {"argument", "output_arguments", "input_arguments"}};
static void cont__compiler__generate_statement_18(void);
static NODE *func__compiler__generate_statement_19;
static void entry__compiler__generate_statement_19(void);
static FRAME_INFO frame__compiler__generate_statement_19 = {3, {"output_arguments", "argument", "input_arguments"}};
static void cont__compiler__generate_statement_20(void);
static void cont__compiler__generate_statement_21(void);
static NODE *func__compiler__generate_statement_22;
static void entry__compiler__generate_statement_22(void);
static FRAME_INFO frame__compiler__generate_statement_22 = {2, {"input_arguments", "argument"}};
static void cont__compiler__generate_statement_23(void);
static NODE *func__compiler__generate_statement_24;
static void entry__compiler__generate_statement_24(void);
static FRAME_INFO frame__compiler__generate_statement_24 = {2, {"input_arguments", "argument"}};
static void cont__compiler__generate_statement_25(void);
static void cont__compiler__generate_statement_26(void);
static void cont__compiler__generate_statement_27(void);
static void cont__compiler__generate_statement_28(void);
static void cont__compiler__generate_statement_29(void);
static NODE *func__compiler__generate_statement_30;
static void entry__compiler__generate_statement_30(void);
static FRAME_INFO frame__compiler__generate_statement_30 = {1, {"input_arguments"}};
static void cont__compiler__generate_statement_31(void);
static void cont__compiler__generate_statement_32(void);
static void cont__compiler__generate_statement_33(void);
static void cont__compiler__generate_statement_34(void);
static NODE *func__compiler__generate_statement_35;
static void entry__compiler__generate_statement_35(void);
static FRAME_INFO frame__compiler__generate_statement_35 = {5, {"output_arguments", "functor", "input_arguments", "destination", "source"}};
static void cont__compiler__generate_statement_36(void);
static void cont__compiler__generate_statement_37(void);
static NODE *func__compiler__generate_statement_38;
static void entry__compiler__generate_statement_38(void);
static FRAME_INFO frame__compiler__generate_statement_38 = {1, {"functor"}};
static NODE *func__compiler__generate_statement_39;
static void entry__compiler__generate_statement_39(void);
static FRAME_INFO frame__compiler__generate_statement_39 = {1, {"destination"}};
static void cont__compiler__generate_statement_40(void);
static NODE *func__compiler__generate_statement_41;
static void entry__compiler__generate_statement_41(void);
static FRAME_INFO frame__compiler__generate_statement_41 = {4, {"functor", "input_arguments", "statement", "output_arguments"}};
static void cont__compiler__generate_statement_42(void);
static NODE *func__compiler__generate_statement_43;
static void entry__compiler__generate_statement_43(void);
static FRAME_INFO frame__compiler__generate_statement_43 = {5, {"input_arguments", "statement", "output_arguments", "functor", "sfx"}};
static void cont__compiler__generate_statement_44(void);
static NODE *func__compiler__generate_statement_45;
static void entry__compiler__generate_statement_45(void);
static FRAME_INFO frame__compiler__generate_statement_45 = {1, {"statement"}};
static void cont__compiler__generate_statement_46(void);
static void cont__compiler__generate_statement_47(void);
static NODE *func__compiler__generate_statement_48;
static void entry__compiler__generate_statement_48(void);
static FRAME_INFO frame__compiler__generate_statement_48 = {1, {"statement"}};
static void cont__compiler__generate_statement_49(void);
static void cont__compiler__generate_statement_50(void);
static NODE *string__2c055578f6e77c80;
static NODE *string__2d7981f4e6402bfe;
static void cont__compiler__generate_statement_53(void);
static NODE *func__compiler__generate_statement_54;
static void entry__compiler__generate_statement_54(void);
static FRAME_INFO frame__compiler__generate_statement_54 = {1, {"statement"}};
static void cont__compiler__generate_statement_55(void);
static void cont__compiler__generate_statement_56(void);
static NODE *func__compiler__generate_statement_57;
static void entry__compiler__generate_statement_57(void);
static FRAME_INFO frame__compiler__generate_statement_57 = {1, {"statement"}};
static NODE *string__d263a6c16aa42f0f;
static NODE *func__compiler__generate_statement_59;
static void entry__compiler__generate_statement_59(void);
static FRAME_INFO frame__compiler__generate_statement_59 = {2, {"output_arguments", "result_count"}};
static void cont__compiler__generate_statement_60(void);
static NODE *func__compiler__generate_statement_61;
static void entry__compiler__generate_statement_61(void);
static FRAME_INFO frame__compiler__generate_statement_61 = {1, {"result_count"}};
static NODE *string__47feaa767baa1465;
static NODE *string__578a5af303e9cda;
static void cont__compiler__generate_statement_64(void);
static NODE *func__compiler__generate_statement_65;
static void entry__compiler__generate_statement_65(void);
static FRAME_INFO frame__compiler__generate_statement_65 = {0, {}};
static NODE *string__ca8ff614ed7f5413;
static void cont__compiler__generate_statement_67(void);
static void cont__compiler__generate_statement_68(void);
static void cont__compiler__generate_statement_69(void);
static NODE *func__compiler__generate_statement_70;
static void entry__compiler__generate_statement_70(void);
static FRAME_INFO frame__compiler__generate_statement_70 = {0, {}};
static NODE *func__compiler__generate_statement_71;
static void entry__compiler__generate_statement_71(void);
static FRAME_INFO frame__compiler__generate_statement_71 = {0, {}};
static void cont__compiler__generate_statement_72(void);
static void cont__compiler__generate_statement_73(void);
static void cont__compiler__generate_statement_74(void);
static void cont__compiler__generate_statement_75(void);
static void cont__compiler__generate_statement_76(void);
static void cont__compiler__generate_statement_77(void);
static NODE *func__compiler__generate_statement_78;
static void entry__compiler__generate_statement_78(void);
static FRAME_INFO frame__compiler__generate_statement_78 = {4, {"output_arguments", "input_arguments", "destination", "source"}};
static void cont__compiler__generate_statement_79(void);
static void cont__compiler__generate_statement_80(void);
static void cont__compiler__generate_statement_81(void);
static NODE *func__compiler__generate_statement_82;
static void entry__compiler__generate_statement_82(void);
static FRAME_INFO frame__compiler__generate_statement_82 = {1, {"source"}};
static void cont__compiler__generate_statement_83(void);
static void cont__compiler__generate_statement_84(void);
static NODE *func__compiler__generate_statement_85;
static void entry__compiler__generate_statement_85(void);
static FRAME_INFO frame__compiler__generate_statement_85 = {2, {"destination", "source"}};
static void cont__compiler__generate_statement_86(void);
static void cont__compiler__generate_statement_87(void);
static NODE *string__b0d32d3bb6b3b99c;
static void cont__compiler__generate_statement_89(void);
static NODE *func__compiler__generate_statement_90;
static void entry__compiler__generate_statement_90(void);
static FRAME_INFO frame__compiler__generate_statement_90 = {2, {"destination", "source"}};
static void cont__compiler__generate_statement_91(void);
static void cont__compiler__generate_statement_92(void);
static NODE *get__compiler__generate_statement(void) {
  return var.compiler__generate_statement;
}
void run__c_code_generator(void);

static CONTINUATION_INFO continuation_info[] = {
  {type__compiler__to_c, NULL, 32, 32, 2, 15},
  {run__c_code_generator, NULL, 41, 41, 1, 34},
  {entry__var_name_4, NULL, 46, 46, 5, 11},
  {entry__var_name_5, NULL, 47, 47, 8, 23},
  {cont__var_name_6, &frame__var_name_5, 47, 47, 5, 23},
  {entry__var_name, NULL, 45, 45, 5, 24},
  {cont__var_name_3, &frame__var_name, 44, 47, 3, 23},
  {entry__var_entry_3, NULL, 52, 52, 8, 26},
  {cont__var_entry_5, &frame__var_entry_3, 52, 52, 5, 26},
  {entry__var_entry_6, NULL, 53, 53, 8, 27},
  {cont__var_entry_8, &frame__var_entry_6, 53, 53, 5, 27},
  {entry__var_entry, NULL, 51, 51, 5, 24},
  {cont__var_entry_2, &frame__var_entry, 50, 53, 3, 27},
  {entry__insert_delayed, NULL, 56, 56, 3, 20},
  {cont__insert_delayed_2, &frame__insert_delayed, 57, 57, 18, 18},
  {entry__delayed_3, NULL, 64, 64, 43, 74},
  {cont__delayed_4, &frame__delayed_3, 64, 64, 74, 74},
  {entry__delayed_2, NULL, 66, 66, 5, 31},
  {cont__delayed_5, &frame__delayed_2, 67, 67, 5, 31},
  {cont__delayed_6, &frame__delayed_2, },
  {entry__delayed, NULL, 61, 67, 3, 31},
  {cont__delayed_7, &frame__delayed, 68, 68, 3, 54},
  {entry__compiler__begin_continuation_15, NULL, 80, 80, 10, 30},
  {cont__compiler__begin_continuation_17, &frame__compiler__begin_continuation_15, 80, 80, 7, 30},
  {entry__compiler__begin_continuation_18, NULL, 81, 81, 7, 17},
  {entry__compiler__begin_continuation, NULL, 71, 72, 25, 30},
  {cont__compiler__begin_continuation_4, &frame__compiler__begin_continuation, 71, 72, 3, 30},
  {cont__compiler__begin_continuation_5, &frame__compiler__begin_continuation, 73, 73, 3, 16},
  {cont__compiler__begin_continuation_6, &frame__compiler__begin_continuation, 74, 75, 9, 31},
  {cont__compiler__begin_continuation_8, &frame__compiler__begin_continuation, 74, 75, 3, 31},
  {cont__compiler__begin_continuation_9, &frame__compiler__begin_continuation, 76, 76, 31, 44},
  {cont__compiler__begin_continuation_12, &frame__compiler__begin_continuation, 76, 76, 3, 44},
  {cont__compiler__begin_continuation_13, &frame__compiler__begin_continuation, 79, 79, 7, 30},
  {cont__compiler__begin_continuation_14, &frame__compiler__begin_continuation, },
  {cont__compiler__begin_continuation_20, &frame__compiler__begin_continuation, 77, 81, 3, 18},
  {entry__compiler__end_continuation_3, NULL, 86, 86, 35, 70},
  {cont__compiler__end_continuation_5, &frame__compiler__end_continuation_3, 86, 86, 7, 70},
  {cont__compiler__end_continuation_6, &frame__compiler__end_continuation_3, 87, 87, 42, 42},
  {entry__compiler__end_continuation_7, NULL, 89, 89, 7, 42},
  {entry__compiler__end_continuation, NULL, 85, 85, 5, 40},
  {cont__compiler__end_continuation_2, &frame__compiler__end_continuation, 84, 89, 3, 43},
  {entry__compiler__next_continuation, NULL, 92, 92, 3, 18},
  {cont__compiler__next_continuation_2, &frame__compiler__next_continuation, 93, 93, 3, 25},
  {entry__count_arguments_4, NULL, 103, 103, 39, 66},
  {cont__count_arguments_5, &frame__count_arguments_4, 103, 103, 39, 66},
  {entry__count_arguments_7, NULL, 104, 104, 9, 24},
  {entry__count_arguments_8, NULL, 106, 106, 9, 25},
  {cont__count_arguments_9, &frame__count_arguments_8, 106, 106, 25, 25},
  {entry__count_arguments_2, NULL, 103, 103, 7, 34},
  {cont__count_arguments_3, &frame__count_arguments_2, 103, 103, 7, 66},
  {cont__count_arguments_6, &frame__count_arguments_2, 102, 106, 5, 26},
  {entry__count_arguments, NULL, 101, 106, 3, 27},
  {cont__count_arguments_10, &frame__count_arguments, 107, 107, 3, 17},
  {entry__generate_c_arguments_5, NULL, 118, 118, 15, 56},
  {cont__generate_c_arguments_8, &frame__generate_c_arguments_5, 118, 118, 9, 56},
  {entry__generate_c_arguments_3, NULL, 117, 117, 10, 32},
  {cont__generate_c_arguments_4, &frame__generate_c_arguments_3, 117, 118, 7, 56},
  {entry__generate_c_arguments_9, NULL, 122, 122, 32, 60},
  {cont__generate_c_arguments_10, &frame__generate_c_arguments_9, 120, 123, 13, 31},
  {cont__generate_c_arguments_13, &frame__generate_c_arguments_9, 120, 123, 7, 31},
  {entry__generate_c_arguments_19, NULL, 128, 128, 46, 75},
  {cont__generate_c_arguments_22, &frame__generate_c_arguments_19, 128, 128, 40, 75},
  {entry__generate_c_arguments_17, NULL, 128, 128, 10, 37},
  {cont__generate_c_arguments_18, &frame__generate_c_arguments_17, 128, 128, 7, 75},
  {entry__generate_c_arguments_25, NULL, 129, 129, 46, 68},
  {cont__generate_c_arguments_27, &frame__generate_c_arguments_25, 129, 129, 40, 68},
  {entry__generate_c_arguments_23, NULL, 129, 129, 10, 37},
  {cont__generate_c_arguments_24, &frame__generate_c_arguments_23, 129, 129, 7, 68},
  {entry__generate_c_arguments_30, NULL, 134, 134, 13, 18},
  {entry__generate_c_arguments_31, NULL, 135, 135, 13, 33},
  {entry__generate_c_arguments_28, NULL, 133, 133, 13, 35},
  {cont__generate_c_arguments_29, &frame__generate_c_arguments_28, 131, 135, 9, 34},
  {cont__generate_c_arguments_33, &frame__generate_c_arguments_28, 137, 137, 15, 61},
  {cont__generate_c_arguments_36, &frame__generate_c_arguments_28, 137, 137, 9, 61},
  {cont__generate_c_arguments_37, &frame__generate_c_arguments_28, 138, 138, 9, 16},
  {cont__generate_c_arguments_38, &frame__generate_c_arguments_28, 138, 138, 16, 16},
  {entry__generate_c_arguments_15, NULL, 126, 126, 5, 22},
  {cont__generate_c_arguments_16, &frame__generate_c_arguments_15, 127, 138, 5, 17},
  {entry__generate_c_arguments, NULL, 114, 114, 3, 42},
  {cont__generate_c_arguments_2, &frame__generate_c_arguments, 115, 123, 3, 33},
  {cont__generate_c_arguments_14, &frame__generate_c_arguments, 125, 138, 3, 18},
  {entry__get_func_and_myself_4, NULL, 144, 144, 26, 54},
  {cont__get_func_and_myself_5, &frame__get_func_and_myself_4, 144, 144, 10, 55},
  {cont__get_func_and_myself_6, &frame__get_func_and_myself_4, 144, 144, 7, 55},
  {entry__get_func_and_myself_7, NULL, 145, 145, 7, 11},
  {entry__get_func_and_myself_2, NULL, 143, 143, 7, 31},
  {cont__get_func_and_myself_3, &frame__get_func_and_myself_2, 142, 145, 5, 11},
  {entry__get_func_and_myself_18, NULL, 151, 151, 35, 64},
  {cont__get_func_and_myself_20, &frame__get_func_and_myself_18, 151, 151, 29, 64},
  {entry__get_func_and_myself, NULL, 149, 149, 20, 31},
  {cont__get_func_and_myself_8, &frame__get_func_and_myself, 150, 150, 31, 42},
  {cont__get_func_and_myself_9, &frame__get_func_and_myself, 147, 150, 9, 43},
  {cont__get_func_and_myself_13, &frame__get_func_and_myself, 147, 150, 3, 43},
  {cont__get_func_and_myself_14, &frame__get_func_and_myself, 151, 151, 6, 26},
  {cont__get_func_and_myself_16, &frame__get_func_and_myself, 151, 151, 6, 26},
  {cont__get_func_and_myself_17, &frame__get_func_and_myself, 151, 151, 3, 64},
  {entry__compiler__assignment_to_c_8, NULL, 166, 166, 45, 60},
  {cont__compiler__assignment_to_c_9, &frame__compiler__assignment_to_c_8, 166, 166, 15, 76},
  {cont__compiler__assignment_to_c_11, &frame__compiler__assignment_to_c_8, 165, 166, 13, 76},
  {entry__compiler__assignment_to_c_12, NULL, 168, 168, 32, 47},
  {cont__compiler__assignment_to_c_13, &frame__compiler__assignment_to_c_12, 168, 168, 20, 63},
  {cont__compiler__assignment_to_c_15, &frame__compiler__assignment_to_c_12, 168, 168, 13, 63},
  {entry__compiler__assignment_to_c_6, NULL, 164, 164, 11, 42},
  {cont__compiler__assignment_to_c_7, &frame__compiler__assignment_to_c_6, 163, 168, 9, 64},
  {entry__compiler__assignment_to_c_18, NULL, 173, 173, 45, 60},
  {cont__compiler__assignment_to_c_19, &frame__compiler__assignment_to_c_18, 173, 173, 15, 76},
  {cont__compiler__assignment_to_c_20, &frame__compiler__assignment_to_c_18, 172, 173, 13, 76},
  {entry__compiler__assignment_to_c_21, NULL, 175, 175, 43, 68},
  {cont__compiler__assignment_to_c_22, &frame__compiler__assignment_to_c_21, 175, 175, 13, 69},
  {cont__compiler__assignment_to_c_23, &frame__compiler__assignment_to_c_21, 176, 176, 20, 66},
  {cont__compiler__assignment_to_c_26, &frame__compiler__assignment_to_c_21, 176, 176, 13, 66},
  {entry__compiler__assignment_to_c_16, NULL, 171, 171, 11, 42},
  {cont__compiler__assignment_to_c_17, &frame__compiler__assignment_to_c_16, 170, 176, 9, 67},
  {entry__compiler__assignment_to_c_31, NULL, 181, 181, 20, 63},
  {cont__compiler__assignment_to_c_33, &frame__compiler__assignment_to_c_31, 181, 181, 13, 63},
  {entry__compiler__assignment_to_c_34, NULL, 183, 183, 20, 66},
  {cont__compiler__assignment_to_c_35, &frame__compiler__assignment_to_c_34, 183, 183, 13, 66},
  {entry__compiler__assignment_to_c_27, NULL, 178, 178, 39, 64},
  {cont__compiler__assignment_to_c_28, &frame__compiler__assignment_to_c_27, 178, 178, 9, 65},
  {cont__compiler__assignment_to_c_29, &frame__compiler__assignment_to_c_27, 180, 180, 11, 42},
  {cont__compiler__assignment_to_c_30, &frame__compiler__assignment_to_c_27, 179, 183, 9, 67},
  {entry__compiler__assignment_to_c_4, NULL, 161, 161, 10, 38},
  {cont__compiler__assignment_to_c_5, &frame__compiler__assignment_to_c_4, 161, 183, 5, 69},
  {entry__compiler__assignment_to_c_40, NULL, 187, 187, 38, 38},
  {cont__compiler__assignment_to_c_41, &frame__compiler__assignment_to_c_40, 187, 187, 24, 39},
  {cont__compiler__assignment_to_c_42, &frame__compiler__assignment_to_c_40, 187, 187, 8, 54},
  {cont__compiler__assignment_to_c_44, &frame__compiler__assignment_to_c_40, 187, 187, 5, 54},
  {entry__compiler__assignment_to_c_45, NULL, 188, 188, 8, 39},
  {cont__compiler__assignment_to_c_46, &frame__compiler__assignment_to_c_45, 188, 188, 5, 39},
  {entry__compiler__assignment_to_c, NULL, 160, 160, 6, 32},
  {cont__compiler__assignment_to_c_3, &frame__compiler__assignment_to_c, 160, 183, 3, 70},
  {cont__compiler__assignment_to_c_36, &frame__compiler__assignment_to_c, 184, 184, 3, 24},
  {cont__compiler__assignment_to_c_37, &frame__compiler__assignment_to_c, 186, 186, 5, 28},
  {cont__compiler__assignment_to_c_39, &frame__compiler__assignment_to_c, 185, 188, 3, 39},
  {cont__compiler__assignment_to_c_47, &frame__compiler__assignment_to_c, 188, 188, 39, 39},
  {entry__assign_argument_or_result_3, NULL, 198, 198, 49, 67},
  {cont__assign_argument_or_result_5, &frame__assign_argument_or_result_3, 198, 198, 49, 67},
  {entry__assign_argument_or_result_7, NULL, 199, 199, 21, 46},
  {cont__assign_argument_or_result_8, &frame__assign_argument_or_result_7, 199, 199, 7, 47},
  {cont__assign_argument_or_result_9, &frame__assign_argument_or_result_7, 201, 201, 33, 52},
  {cont__assign_argument_or_result_10, &frame__assign_argument_or_result_7, 200, 202, 13, 47},
  {cont__assign_argument_or_result_14, &frame__assign_argument_or_result_7, 200, 202, 7, 47},
  {entry__assign_argument_or_result_15, NULL, 204, 204, 13, 51},
  {cont__assign_argument_or_result_16, &frame__assign_argument_or_result_15, 204, 204, 7, 51},
  {entry__assign_argument_or_result, NULL, 198, 198, 5, 44},
  {cont__assign_argument_or_result_2, &frame__assign_argument_or_result, 198, 198, 5, 67},
  {cont__assign_argument_or_result_6, &frame__assign_argument_or_result, 197, 204, 3, 52},
  {entry__extract_9, NULL, 221, 221, 40, 71},
  {cont__extract_10, &frame__extract_9, 221, 221, 40, 71},
  {entry__extract_12, NULL, 222, 222, 42, 42},
  {entry__extract_5, NULL, 219, 219, 9, 24},
  {cont__extract_6, &frame__extract_5, 220, 220, 9, 47},
  {cont__extract_7, &frame__extract_5, 221, 221, 12, 35},
  {cont__extract_8, &frame__extract_5, 221, 221, 12, 71},
  {cont__extract_11, &frame__extract_5, 221, 222, 9, 42},
  {entry__extract_3, NULL, 218, 218, 10, 35},
  {cont__extract_4, &frame__extract_3, 218, 222, 7, 43},
  {entry__extract_15, NULL, 223, 223, 52, 52},
  {entry__extract_13, NULL, 223, 223, 10, 35},
  {cont__extract_14, &frame__extract_13, 223, 223, 7, 52},
  {entry__extract_19, NULL, 227, 227, 25, 49},
  {cont__extract_20, &frame__extract_19, 227, 227, 25, 49},
  {entry__extract_22, NULL, 227, 227, 52, 67},
  {cont__extract_23, &frame__extract_22, 227, 227, 67, 67},
  {entry__extract_16, NULL, 225, 225, 9, 24},
  {cont__extract_17, &frame__extract_16, 226, 226, 9, 24},
  {cont__extract_18, &frame__extract_16, 227, 227, 12, 49},
  {cont__extract_21, &frame__extract_16, 227, 227, 9, 67},
  {entry__extract_2, NULL, 217, 227, 5, 68},
  {entry__extract_25, NULL, 229, 229, 18, 42},
  {cont__extract_26, &frame__extract_25, 229, 229, 18, 42},
  {entry__extract_30, NULL, 231, 236, 15, 15},
  {cont__extract_34, &frame__extract_30, 231, 236, 9, 15},
  {entry__extract_36, NULL, 238, 243, 15, 15},
  {cont__extract_39, &frame__extract_36, 238, 243, 9, 15},
  {entry__extract_28, NULL, 230, 230, 10, 24},
  {cont__extract_29, &frame__extract_28, 230, 236, 7, 16},
  {cont__extract_35, &frame__extract_28, 237, 243, 7, 16},
  {entry__extract_40, NULL, 245, 250, 13, 13},
  {cont__extract_43, &frame__extract_40, 245, 250, 7, 13},
  {entry__extract_47, NULL, 251, 251, 27, 35},
  {entry__extract_49, NULL, 251, 251, 38, 70},
  {entry__extract_59, NULL, 262, 262, 9, 34},
  {entry__extract_58, NULL, 262, 262, 9, 34},
  {cont__extract_60, &frame__extract_58, },
  {entry__extract_56, NULL, 260, 260, 9, 43},
  {cont__extract_57, &frame__extract_56, },
  {cont__extract_61, &frame__extract_56, },
  {entry__extract_63, NULL, 264, 264, 67, 71},
  {cont__extract_64, &frame__extract_63, 264, 264, 47, 74},
  {cont__extract_67, &frame__extract_63, 264, 264, 9, 74},
  {entry__extract_53, NULL, 256, 256, 5, 24},
  {cont__extract_54, &frame__extract_53, 259, 259, 9, 25},
  {cont__extract_55, &frame__extract_53, },
  {cont__extract_62, &frame__extract_53, 257, 264, 5, 75},
  {entry__extract_69, NULL, 271, 271, 16, 18},
  {cont__extract_70, &frame__extract_69, 271, 271, 7, 19},
  {cont__extract_71, &frame__extract_69, 272, 272, 42, 44},
  {cont__extract_72, &frame__extract_69, 272, 272, 7, 47},
  {cont__extract_74, &frame__extract_69, 269, 272, 5, 47},
  {entry__extract_76, NULL, 277, 277, 44, 66},
  {cont__extract_77, &frame__extract_76, 277, 277, 44, 68},
  {cont__extract_78, &frame__extract_76, 277, 277, 36, 69},
  {cont__extract_79, &frame__extract_76, 278, 278, 24, 46},
  {cont__extract_80, &frame__extract_76, 277, 278, 71, 80},
  {cont__extract_84, &frame__extract_76, 277, 278, 5, 80},
  {entry__extract_96, NULL, 293, 293, 14, 24},
  {cont__extract_98, &frame__extract_96, 293, 293, 11, 24},
  {entry__extract_99, NULL, 292, 292, 11, 22},
  {entry__extract_93, NULL, 287, 287, 7, 24},
  {cont__extract_94, &frame__extract_93, 291, 291, 11, 26},
  {cont__extract_95, &frame__extract_93, 289, 293, 7, 25},
  {cont__extract_101, &frame__extract_93, 296, 296, 9, 22},
  {cont__extract_104, &frame__extract_93, 298, 298, 9, 20},
  {cont__extract_105, &frame__extract_93, 299, 299, 29, 33},
  {cont__extract_106, &frame__extract_93, 299, 299, 9, 36},
  {cont__extract_107, &frame__extract_93, 295, 299, 7, 36},
  {entry__extract_120, NULL, 315, 315, 18, 28},
  {cont__extract_121, &frame__extract_120, 315, 315, 15, 28},
  {entry__extract_122, NULL, 314, 314, 15, 26},
  {entry__extract_117, NULL, 309, 309, 11, 28},
  {cont__extract_118, &frame__extract_117, 313, 313, 15, 30},
  {cont__extract_119, &frame__extract_117, 311, 315, 11, 29},
  {cont__extract_123, &frame__extract_117, 317, 317, 11, 20},
  {cont__extract_124, &frame__extract_117, 318, 318, 11, 21},
  {cont__extract_125, &frame__extract_117, 319, 323, 17, 31},
  {cont__extract_129, &frame__extract_117, 319, 323, 11, 31},
  {entry__extract_145, NULL, 336, 336, 21, 48},
  {entry__extract_143, NULL, 335, 335, 28, 48},
  {cont__extract_144, &frame__extract_143, 335, 336, 19, 48},
  {entry__extract_146, NULL, 338, 338, 57, 74},
  {cont__extract_147, &frame__extract_146, 338, 338, 19, 74},
  {entry__extract_141, NULL, 334, 334, 17, 48},
  {cont__extract_142, &frame__extract_141, 333, 338, 15, 75},
  {entry__extract_148, NULL, 340, 340, 15, 63},
  {entry__extract_137, NULL, 329, 329, 11, 30},
  {cont__extract_138, &frame__extract_137, 330, 330, 11, 49},
  {cont__extract_139, &frame__extract_137, 332, 332, 13, 36},
  {cont__extract_140, &frame__extract_137, 331, 340, 11, 64},
  {cont__extract_150, &frame__extract_137, 341, 341, 29, 43},
  {cont__extract_151, &frame__extract_137, 341, 341, 11, 44},
  {cont__extract_152, &frame__extract_137, 342, 344, 17, 13},
  {cont__extract_155, &frame__extract_137, 342, 344, 11, 13},
  {cont__extract_156, &frame__extract_137, 345, 345, 29, 55},
  {cont__extract_158, &frame__extract_137, 345, 345, 11, 55},
  {entry__extract_113, NULL, 308, 308, 22, 44},
  {cont__extract_114, &frame__extract_113, 308, 308, 46, 68},
  {cont__extract_115, &frame__extract_113, 308, 308, 46, 70},
  {cont__extract_116, &frame__extract_113, 308, 323, 9, 32},
  {cont__extract_130, &frame__extract_113, 324, 327, 15, 15},
  {cont__extract_132, &frame__extract_113, 324, 327, 9, 15},
  {cont__extract_133, &frame__extract_113, 328, 328, 17, 39},
  {cont__extract_134, &frame__extract_113, 328, 328, 17, 41},
  {cont__extract_135, &frame__extract_113, 328, 328, 43, 65},
  {cont__extract_136, &frame__extract_113, 328, 345, 9, 55},
  {entry__extract_167, NULL, 354, 354, 18, 35},
  {cont__extract_168, &frame__extract_167, 354, 354, 15, 35},
  {entry__extract_169, NULL, 355, 355, 15, 28},
  {entry__extract_163, NULL, 348, 348, 11, 30},
  {cont__extract_164, &frame__extract_163, 349, 349, 11, 49},
  {cont__extract_165, &frame__extract_163, 353, 353, 15, 38},
  {cont__extract_166, &frame__extract_163, 351, 355, 11, 29},
  {cont__extract_170, &frame__extract_163, 358, 358, 25, 39},
  {cont__extract_171, &frame__extract_163, 358, 358, 25, 41},
  {cont__extract_172, &frame__extract_163, 358, 358, 13, 45},
  {cont__extract_173, &frame__extract_163, 357, 361, 11, 17},
  {entry__extract_159, NULL, 347, 347, 17, 39},
  {cont__extract_160, &frame__extract_159, 347, 347, 17, 41},
  {cont__extract_161, &frame__extract_159, 347, 347, 43, 65},
  {cont__extract_162, &frame__extract_159, 347, 361, 9, 18},
  {cont__extract_174, &frame__extract_159, 362, 364, 9, 15},
  {entry__extract_87, NULL, 283, 285, 5, 34},
  {cont__extract_89, &frame__extract_87, 286, 286, 18, 40},
  {cont__extract_90, &frame__extract_87, 286, 286, 42, 64},
  {cont__extract_91, &frame__extract_87, 286, 286, 42, 66},
  {cont__extract_92, &frame__extract_87, 286, 299, 5, 37},
  {cont__extract_108, &frame__extract_87, 300, 304, 11, 34},
  {cont__extract_111, &frame__extract_87, 300, 304, 5, 34},
  {cont__extract_112, &frame__extract_87, 306, 364, 5, 17},
  {entry__extract, NULL, 216, 227, 3, 69},
  {cont__extract_24, &frame__extract, 229, 229, 5, 42},
  {cont__extract_27, &frame__extract, 228, 250, 3, 15},
  {cont__extract_44, &frame__extract, 251, 251, 6, 22},
  {cont__extract_46, &frame__extract, 251, 251, 6, 35},
  {cont__extract_48, &frame__extract, 251, 251, 3, 70},
  {cont__extract_51, &frame__extract, 255, 255, 13, 35},
  {cont__extract_52, &frame__extract, 255, 264, 3, 76},
  {cont__extract_68, &frame__extract, 268, 272, 3, 48},
  {cont__extract_75, &frame__extract, 276, 278, 3, 81},
  {cont__extract_85, &frame__extract, 282, 282, 6, 30},
  {cont__extract_86, &frame__extract, 282, 364, 3, 18},
  {entry__write_as_remark, NULL, 371, 376, 7, 19},
  {cont__write_as_remark_3, &frame__write_as_remark, },
  {cont__write_as_remark_4, &frame__write_as_remark, 367, 376, 3, 21},
  {entry__compute_column_no_7, NULL, 380, 380, 33, 38},
  {cont__compute_column_no_8, &frame__compute_column_no_7, 380, 380, 33, 55},
  {cont__compute_column_no_9, &frame__compute_column_no_7, 380, 380, 33, 55},
  {cont__compute_column_no_10, &frame__compute_column_no_7, 380, 380, 33, 55},
  {entry__compute_column_no_12, NULL, 380, 380, 58, 63},
  {cont__compute_column_no_13, &frame__compute_column_no_12, 380, 380, 63, 63},
  {entry__compute_column_no_3, NULL, 380, 380, 12, 17},
  {cont__compute_column_no_4, &frame__compute_column_no_3, 380, 380, 12, 28},
  {cont__compute_column_no_5, &frame__compute_column_no_3, 380, 380, 12, 28},
  {cont__compute_column_no_6, &frame__compute_column_no_3, 380, 380, 12, 55},
  {cont__compute_column_no_11, &frame__compute_column_no_3, 380, 380, 9, 63},
  {entry__compute_column_no, NULL, 379, 379, 3, 8},
  {cont__compute_column_no_2, &frame__compute_column_no, 380, 380, 3, 63},
  {cont__compute_column_no_14, &frame__compute_column_no, 381, 381, 7, 7},
  {cont__compute_column_no_15, &frame__compute_column_no, 381, 381, 3, 7},
  {entry__compute_source_text_info_16, NULL, 405, 405, 10, 34},
  {cont__compute_source_text_info_17, &frame__compute_source_text_info_16, 405, 405, 36, 51},
  {cont__compute_source_text_info_18, &frame__compute_source_text_info_16, 405, 405, 10, 51},
  {cont__compute_source_text_info_19, &frame__compute_source_text_info_16, 405, 405, 7, 51},
  {entry__compute_source_text_info_20, NULL, 406, 406, 10, 26},
  {cont__compute_source_text_info_21, &frame__compute_source_text_info_20, 406, 406, 10, 28},
  {cont__compute_source_text_info_22, &frame__compute_source_text_info_20, 406, 406, 7, 28},
  {entry__compute_source_text_info_36, NULL, 421, 421, 12, 36},
  {cont__compute_source_text_info_37, &frame__compute_source_text_info_36, 421, 421, 38, 58},
  {cont__compute_source_text_info_38, &frame__compute_source_text_info_36, 421, 421, 12, 58},
  {cont__compute_source_text_info_39, &frame__compute_source_text_info_36, 421, 421, 12, 60},
  {cont__compute_source_text_info_40, &frame__compute_source_text_info_36, 421, 421, 9, 60},
  {entry__compute_source_text_info_41, NULL, 422, 422, 22, 38},
  {cont__compute_source_text_info_42, &frame__compute_source_text_info_41, 422, 422, 12, 38},
  {cont__compute_source_text_info_43, &frame__compute_source_text_info_41, 422, 422, 9, 38},
  {entry__compute_source_text_info_49, NULL, 430, 430, 29, 29},
  {entry__compute_source_text_info_53, NULL, 434, 434, 37, 61},
  {cont__compute_source_text_info_54, &frame__compute_source_text_info_53, 434, 434, 32, 63},
  {cont__compute_source_text_info_55, &frame__compute_source_text_info_53, 434, 434, 29, 63},
  {entry__compute_source_text_info_56, NULL, 434, 434, 66, 70},
  {entry__compute_source_text_info_60, NULL, 453, 453, 21, 43},
  {cont__compute_source_text_info_61, &frame__compute_source_text_info_60, 453, 453, 13, 47},
  {cont__compute_source_text_info_62, &frame__compute_source_text_info_60, 453, 453, 58, 70},
  {cont__compute_source_text_info_63, &frame__compute_source_text_info_60, 453, 453, 49, 71},
  {cont__compute_source_text_info_64, &frame__compute_source_text_info_60, 453, 453, 7, 71},
  {cont__compute_source_text_info_65, &frame__compute_source_text_info_60, 454, 454, 7, 18},
  {cont__compute_source_text_info_66, &frame__compute_source_text_info_60, 454, 454, 18, 18},
  {entry__compute_source_text_info_69, NULL, 440, 440, 7, 29},
  {cont__compute_source_text_info_70, &frame__compute_source_text_info_69, 441, 441, 25, 25},
  {entry__compute_source_text_info_81, NULL, 447, 447, 17, 17},
  {cont__compute_source_text_info_82, &frame__compute_source_text_info_81, 447, 447, 9, 18},
  {cont__compute_source_text_info_83, &frame__compute_source_text_info_81, 447, 447, 9, 35},
  {cont__compute_source_text_info_84, &frame__compute_source_text_info_81, 447, 447, 9, 35},
  {cont__compute_source_text_info_85, &frame__compute_source_text_info_81, 447, 447, 9, 35},
  {entry__compute_source_text_info_76, NULL, 446, 446, 17, 17},
  {cont__compute_source_text_info_77, &frame__compute_source_text_info_76, 446, 446, 9, 18},
  {cont__compute_source_text_info_78, &frame__compute_source_text_info_76, 446, 446, 9, 29},
  {cont__compute_source_text_info_79, &frame__compute_source_text_info_76, 446, 446, 9, 29},
  {cont__compute_source_text_info_80, &frame__compute_source_text_info_76, 447, 447, 9, 35},
  {cont__compute_source_text_info_86, &frame__compute_source_text_info_76, },
  {entry__compute_source_text_info_88, NULL, 449, 449, 9, 29},
  {cont__compute_source_text_info_90, &frame__compute_source_text_info_88, 449, 449, 29, 29},
  {entry__compute_source_text_info_95, NULL, 450, 450, 35, 54},
  {cont__compute_source_text_info_96, &frame__compute_source_text_info_95, 450, 450, 54, 54},
  {entry__compute_source_text_info_104, NULL, 461, 461, 38, 48},
  {cont__compute_source_text_info_105, &frame__compute_source_text_info_104, 461, 461, 48, 48},
  {entry__compute_source_text_info_111, NULL, 467, 467, 35, 52},
  {entry__compute_source_text_info_110, NULL, 467, 467, 17, 52},
  {cont__compute_source_text_info_113, &frame__compute_source_text_info_110, 468, 468, 17, 21},
  {entry__compute_source_text_info_102, NULL, 461, 461, 16, 35},
  {cont__compute_source_text_info_103, &frame__compute_source_text_info_102, 461, 461, 13, 48},
  {cont__compute_source_text_info_106, &frame__compute_source_text_info_102, 462, 462, 13, 19},
  {cont__compute_source_text_info_107, &frame__compute_source_text_info_102, 464, 464, 15, 37},
  {cont__compute_source_text_info_108, &frame__compute_source_text_info_102, 464, 464, 15, 37},
  {cont__compute_source_text_info_109, &frame__compute_source_text_info_102, 463, 468, 13, 22},
  {entry__compute_source_text_info_114, NULL, 470, 470, 13, 23},
  {cont__compute_source_text_info_115, &frame__compute_source_text_info_114, 470, 470, 23, 23},
  {entry__compute_source_text_info_116, NULL, 472, 472, 13, 21},
  {entry__compute_source_text_info_100, NULL, 460, 460, 11, 32},
  {cont__compute_source_text_info_101, &frame__compute_source_text_info_100, 459, 472, 9, 22},
  {entry__compute_source_text_info_99, NULL, 458, 472, 7, 23},
  {cont__compute_source_text_info_117, &frame__compute_source_text_info_99, 472, 472, 23, 23},
  {entry__compute_source_text_info_59, NULL, 439, 439, 23, 31},
  {cont__compute_source_text_info_67, &frame__compute_source_text_info_59, 439, 439, 8, 31},
  {cont__compute_source_text_info_68, &frame__compute_source_text_info_59, 439, 441, 5, 25},
  {cont__compute_source_text_info_71, &frame__compute_source_text_info_59, 442, 442, 22, 44},
  {cont__compute_source_text_info_72, &frame__compute_source_text_info_59, 442, 442, 5, 45},
  {cont__compute_source_text_info_73, &frame__compute_source_text_info_59, 445, 445, 9, 25},
  {cont__compute_source_text_info_74, &frame__compute_source_text_info_59, 445, 445, 9, 29},
  {cont__compute_source_text_info_75, &frame__compute_source_text_info_59, },
  {cont__compute_source_text_info_87, &frame__compute_source_text_info_59, 443, 449, 5, 30},
  {cont__compute_source_text_info_91, &frame__compute_source_text_info_59, 450, 450, 20, 20},
  {cont__compute_source_text_info_92, &frame__compute_source_text_info_59, 450, 450, 12, 21},
  {cont__compute_source_text_info_93, &frame__compute_source_text_info_59, 450, 450, 12, 32},
  {cont__compute_source_text_info_94, &frame__compute_source_text_info_59, 450, 450, 5, 54},
  {cont__compute_source_text_info_97, &frame__compute_source_text_info_59, 456, 456, 5, 20},
  {cont__compute_source_text_info_98, &frame__compute_source_text_info_59, 457, 472, 5, 24},
  {entry__compute_source_text_info, NULL, 389, 389, 3, 29},
  {cont__compute_source_text_info_2, &frame__compute_source_text_info, 390, 390, 3, 38},
  {cont__compute_source_text_info_3, &frame__compute_source_text_info, 391, 391, 3, 34},
  {cont__compute_source_text_info_4, &frame__compute_source_text_info, 392, 392, 8, 33},
  {cont__compute_source_text_info_5, &frame__compute_source_text_info, 392, 392, 8, 40},
  {cont__compute_source_text_info_6, &frame__compute_source_text_info, 392, 392, 3, 42},
  {cont__compute_source_text_info_7, &frame__compute_source_text_info, 393, 393, 35, 39},
  {cont__compute_source_text_info_8, &frame__compute_source_text_info, 393, 393, 3, 40},
  {cont__compute_source_text_info_9, &frame__compute_source_text_info, 394, 394, 3, 40},
  {cont__compute_source_text_info_10, &frame__compute_source_text_info, 395, 395, 3, 31},
  {cont__compute_source_text_info_11, &frame__compute_source_text_info, 399, 399, 7, 49},
  {cont__compute_source_text_info_12, &frame__compute_source_text_info, 400, 400, 7, 55},
  {cont__compute_source_text_info_13, &frame__compute_source_text_info, 397, 400, 3, 56},
  {cont__compute_source_text_info_14, &frame__compute_source_text_info, 404, 404, 7, 17},
  {cont__compute_source_text_info_15, &frame__compute_source_text_info, 402, 406, 3, 29},
  {cont__compute_source_text_info_23, &frame__compute_source_text_info, 408, 408, 35, 40},
  {cont__compute_source_text_info_24, &frame__compute_source_text_info, 408, 408, 43, 43},
  {cont__compute_source_text_info_25, &frame__compute_source_text_info, 408, 408, 3, 44},
  {cont__compute_source_text_info_26, &frame__compute_source_text_info, 409, 409, 23, 43},
  {cont__compute_source_text_info_27, &frame__compute_source_text_info, 409, 409, 21, 43},
  {cont__compute_source_text_info_28, &frame__compute_source_text_info, 409, 409, 21, 44},
  {cont__compute_source_text_info_29, &frame__compute_source_text_info, 409, 409, 3, 44},
  {cont__compute_source_text_info_30, &frame__compute_source_text_info, 414, 414, 7, 49},
  {cont__compute_source_text_info_31, &frame__compute_source_text_info, },
  {cont__compute_source_text_info_32, &frame__compute_source_text_info, 415, 415, 7, 55},
  {cont__compute_source_text_info_33, &frame__compute_source_text_info, 411, 415, 3, 56},
  {cont__compute_source_text_info_34, &frame__compute_source_text_info, 420, 420, 9, 30},
  {cont__compute_source_text_info_35, &frame__compute_source_text_info, 422, 422, 9, 38},
  {cont__compute_source_text_info_44, &frame__compute_source_text_info, 417, 423, 3, 8},
  {cont__compute_source_text_info_45, &frame__compute_source_text_info, 425, 425, 3, 32},
  {cont__compute_source_text_info_46, &frame__compute_source_text_info, 426, 426, 3, 37},
  {cont__compute_source_text_info_47, &frame__compute_source_text_info, 427, 427, 3, 41},
  {cont__compute_source_text_info_48, &frame__compute_source_text_info, 428, 430, 3, 29},
  {cont__compute_source_text_info_50, &frame__compute_source_text_info, 434, 434, 10, 26},
  {cont__compute_source_text_info_51, &frame__compute_source_text_info, 434, 434, 10, 26},
  {cont__compute_source_text_info_52, &frame__compute_source_text_info, 434, 434, 7, 71},
  {cont__compute_source_text_info_57, &frame__compute_source_text_info, 432, 434, 3, 73},
  {cont__compute_source_text_info_58, &frame__compute_source_text_info, 436, 472, 3, 25},
  {cont__compute_source_text_info_118, &frame__compute_source_text_info, 473, 473, 3, 22},
  {entry__compiler__write_source_as_remark_4, NULL, 477, 477, 5, 65},
  {cont__compiler__write_source_as_remark_5, &frame__compiler__write_source_as_remark_4, 477, 477, 65, 65},
  {entry__compiler__write_source_as_remark, NULL, 476, 476, 6, 26},
  {cont__compiler__write_source_as_remark_2, &frame__compiler__write_source_as_remark, 476, 476, 6, 37},
  {cont__compiler__write_source_as_remark_3, &frame__compiler__write_source_as_remark, 476, 477, 3, 65},
  {entry__get_kind_4, NULL, 489, 489, 30, 41},
  {entry__get_kind_2, NULL, 489, 489, 8, 27},
  {cont__get_kind_3, &frame__get_kind_2, 489, 489, 5, 41},
  {entry__get_kind_7, NULL, 490, 490, 31, 45},
  {entry__get_kind_5, NULL, 490, 490, 8, 28},
  {cont__get_kind_6, &frame__get_kind_5, 490, 490, 5, 45},
  {entry__get_kind_15, NULL, 498, 498, 15, 25},
  {entry__get_kind_16, NULL, 499, 499, 15, 22},
  {entry__get_kind_13, NULL, 497, 497, 15, 36},
  {cont__get_kind_14, &frame__get_kind_13, },
  {cont__get_kind_17, &frame__get_kind_13, 495, 499, 11, 23},
  {entry__get_kind_10, NULL, 494, 494, 12, 31},
  {cont__get_kind_11, &frame__get_kind_10, 494, 494, 12, 42},
  {cont__get_kind_12, &frame__get_kind_10, 494, 499, 9, 24},
  {entry__get_kind_24, NULL, 503, 503, 15, 28},
  {entry__get_kind_26, NULL, 505, 505, 15, 26},
  {entry__get_kind_27, NULL, 507, 507, 15, 29},
  {entry__get_kind_21, NULL, 501, 501, 33, 50},
  {cont__get_kind_22, &frame__get_kind_21, 501, 501, 16, 51},
  {cont__get_kind_23, &frame__get_kind_21, 504, 504, 13, 39},
  {cont__get_kind_25, &frame__get_kind_21, 501, 507, 11, 30},
  {entry__get_kind_18, NULL, 500, 500, 12, 29},
  {cont__get_kind_19, &frame__get_kind_18, 500, 500, 12, 40},
  {cont__get_kind_20, &frame__get_kind_18, 500, 507, 9, 31},
  {entry__get_kind_31, NULL, 514, 514, 51, 70},
  {cont__get_kind_32, &frame__get_kind_31, 514, 514, 34, 48},
  {cont__get_kind_33, &frame__get_kind_31, 514, 514, 19, 49},
  {cont__get_kind_34, &frame__get_kind_31, 514, 514, 19, 71},
  {cont__get_kind_35, &frame__get_kind_31, },
  {cont__get_kind_36, &frame__get_kind_31, 512, 514, 15, 72},
  {entry__get_kind_37, NULL, 515, 515, 35, 52},
  {cont__get_kind_38, &frame__get_kind_37, 515, 515, 18, 53},
  {cont__get_kind_39, &frame__get_kind_37, 515, 515, 15, 53},
  {entry__get_kind_42, NULL, 520, 520, 15, 29},
  {entry__get_kind_43, NULL, 522, 522, 15, 26},
  {entry__get_kind_28, NULL, 511, 511, 15, 34},
  {cont__get_kind_29, &frame__get_kind_28, 511, 511, 15, 45},
  {cont__get_kind_30, &frame__get_kind_28, 509, 515, 11, 54},
  {cont__get_kind_40, &frame__get_kind_28, 519, 519, 13, 39},
  {cont__get_kind_41, &frame__get_kind_28, 517, 522, 11, 27},
  {entry__get_kind_8, NULL, 492, 492, 7, 35},
  {cont__get_kind_9, &frame__get_kind_8, 493, 522, 7, 29},
  {entry__get_kind, NULL, 488, 522, 3, 31},
  {cont__get_kind_44, &frame__get_kind, 523, 523, 3, 12},
  {entry__types__grammar_node___to_c, NULL, 529, 529, 3, 48},
  {cont__types__grammar_node___to_c_3, &frame__types__grammar_node___to_c, 530, 530, 3, 10},
  {entry__compiler__body__to_c_6, NULL, 549, 549, 10, 31},
  {cont__compiler__body__to_c_7, &frame__compiler__body__to_c_6, 549, 549, 7, 31},
  {entry__compiler__body__to_c_8, NULL, 550, 550, 28, 34},
  {cont__compiler__body__to_c_9, &frame__compiler__body__to_c_8, 550, 550, 10, 35},
  {cont__compiler__body__to_c_10, &frame__compiler__body__to_c_8, 550, 550, 7, 35},
  {entry__compiler__body__to_c_13, NULL, 552, 552, 34, 53},
  {cont__compiler__body__to_c_15, &frame__compiler__body__to_c_13, 552, 552, 27, 53},
  {entry__compiler__body__to_c_19, NULL, 558, 558, 7, 20},
  {entry__compiler__body__to_c_20, NULL, 559, 559, 7, 15},
  {entry__compiler__body__to_c_25, NULL, 690, 690, 14, 31},
  {cont__compiler__body__to_c_26, &frame__compiler__body__to_c_25, 690, 690, 11, 31},
  {entry__compiler__body__to_c_27, NULL, 691, 691, 11, 23},
  {entry__compiler__body__to_c_30, NULL, 696, 696, 14, 38},
  {cont__compiler__body__to_c_31, &frame__compiler__body__to_c_30, 696, 696, 11, 38},
  {entry__compiler__body__to_c_32, NULL, 697, 697, 11, 22},
  {entry__compiler__body__to_c_23, NULL, 689, 689, 11, 40},
  {cont__compiler__body__to_c_24, &frame__compiler__body__to_c_23, 687, 691, 7, 24},
  {cont__compiler__body__to_c_28, &frame__compiler__body__to_c_23, 695, 695, 11, 40},
  {cont__compiler__body__to_c_29, &frame__compiler__body__to_c_23, 693, 697, 7, 23},
  {cont__compiler__body__to_c_33, &frame__compiler__body__to_c_23, 699, 699, 7, 27},
  {entry__compiler__body__to_c_38, NULL, 708, 708, 40, 62},
  {cont__compiler__body__to_c_39, &frame__compiler__body__to_c_38, 708, 708, 16, 66},
  {cont__compiler__body__to_c_42, &frame__compiler__body__to_c_38, 708, 708, 13, 66},
  {entry__compiler__body__to_c_43, NULL, 711, 711, 16, 26},
  {cont__compiler__body__to_c_44, &frame__compiler__body__to_c_43, 711, 711, 13, 26},
  {entry__compiler__body__to_c_45, NULL, 710, 710, 13, 32},
  {entry__compiler__body__to_c_36, NULL, 706, 706, 16, 31},
  {cont__compiler__body__to_c_37, &frame__compiler__body__to_c_36, 706, 711, 11, 26},
  {entry__compiler__body__to_c_47, NULL, 704, 704, 9, 28},
  {entry__compiler__body__to_c_34, NULL, 703, 703, 9, 27},
  {cont__compiler__body__to_c_35, &frame__compiler__body__to_c_34, 702, 711, 7, 28},
  {entry__compiler__body__to_c_52, NULL, 787, 787, 13, 52},
  {cont__compiler__body__to_c_53, &frame__compiler__body__to_c_52, 787, 787, 13, 68},
  {cont__compiler__body__to_c_54, &frame__compiler__body__to_c_52, 787, 787, 13, 68},
  {entry__compiler__body__to_c_50, NULL, 786, 786, 13, 45},
  {cont__compiler__body__to_c_51, &frame__compiler__body__to_c_50, 785, 787, 11, 68},
  {cont__compiler__body__to_c_55, &frame__compiler__body__to_c_50, 785, 787, 11, 68},
  {entry__compiler__body__to_c_57, NULL, 793, 793, 28, 54},
  {cont__compiler__body__to_c_58, &frame__compiler__body__to_c_57, 789, 795, 17, 51},
  {cont__compiler__body__to_c_61, &frame__compiler__body__to_c_57, 789, 795, 11, 51},
  {entry__compiler__body__to_c_62, NULL, 797, 797, 11, 77},
  {cont__compiler__body__to_c_63, &frame__compiler__body__to_c_62, 798, 798, 11, 48},
  {cont__compiler__body__to_c_64, &frame__compiler__body__to_c_62, 799, 803, 11, 51},
  {entry__compiler__body__to_c_48, NULL, 784, 784, 11, 32},
  {cont__compiler__body__to_c_49, &frame__compiler__body__to_c_48, 783, 787, 9, 69},
  {cont__compiler__body__to_c_56, &frame__compiler__body__to_c_48, 782, 803, 7, 53},
  {entry__compiler__body__to_c_72, NULL, 580, 580, 38, 69},
  {cont__compiler__body__to_c_73, &frame__compiler__body__to_c_72, 580, 580, 38, 69},
  {entry__compiler__body__to_c_75, NULL, 581, 581, 40, 40},
  {entry__compiler__body__to_c_77, NULL, 584, 584, 11, 43},
  {cont__compiler__body__to_c_78, &frame__compiler__body__to_c_77, 584, 584, 43, 43},
  {entry__compiler__body__to_c_79, NULL, 586, 586, 11, 42},
  {cont__compiler__body__to_c_80, &frame__compiler__body__to_c_79, 587, 587, 11, 43},
  {cont__compiler__body__to_c_81, &frame__compiler__body__to_c_79, 587, 587, 43, 43},
  {entry__compiler__body__to_c_83, NULL, 589, 589, 11, 45},
  {cont__compiler__body__to_c_84, &frame__compiler__body__to_c_83, 589, 589, 45, 45},
  {entry__compiler__body__to_c_85, NULL, 591, 591, 11, 42},
  {cont__compiler__body__to_c_86, &frame__compiler__body__to_c_85, 591, 591, 42, 42},
  {entry__compiler__body__to_c_68, NULL, 578, 578, 7, 40},
  {cont__compiler__body__to_c_69, &frame__compiler__body__to_c_68, 579, 579, 7, 48},
  {cont__compiler__body__to_c_70, &frame__compiler__body__to_c_68, 580, 580, 10, 33},
  {cont__compiler__body__to_c_71, &frame__compiler__body__to_c_68, 580, 580, 10, 69},
  {cont__compiler__body__to_c_74, &frame__compiler__body__to_c_68, 580, 581, 7, 40},
  {cont__compiler__body__to_c_76, &frame__compiler__body__to_c_68, 588, 588, 9, 48},
  {cont__compiler__body__to_c_82, &frame__compiler__body__to_c_68, 582, 591, 7, 43},
  {entry__compiler__body__to_c_93, NULL, 598, 598, 43, 58},
  {cont__compiler__body__to_c_94, &frame__compiler__body__to_c_93, 598, 598, 58, 58},
  {entry__compiler__body__to_c_91, NULL, 598, 598, 12, 40},
  {cont__compiler__body__to_c_92, &frame__compiler__body__to_c_91, 598, 598, 9, 58},
  {entry__compiler__body__to_c_97, NULL, 599, 599, 66, 66},
  {entry__compiler__body__to_c_95, NULL, 599, 599, 12, 40},
  {cont__compiler__body__to_c_96, &frame__compiler__body__to_c_95, 599, 599, 9, 66},
  {entry__compiler__body__to_c_102, NULL, 603, 603, 41, 58},
  {cont__compiler__body__to_c_103, &frame__compiler__body__to_c_102, 603, 603, 58, 58},
  {entry__compiler__body__to_c_98, NULL, 601, 601, 11, 26},
  {cont__compiler__body__to_c_99, &frame__compiler__body__to_c_98, 602, 602, 11, 26},
  {cont__compiler__body__to_c_100, &frame__compiler__body__to_c_98, 603, 603, 14, 38},
  {cont__compiler__body__to_c_101, &frame__compiler__body__to_c_98, 603, 603, 11, 58},
  {entry__compiler__body__to_c_88, NULL, 596, 596, 21, 44},
  {cont__compiler__body__to_c_89, &frame__compiler__body__to_c_88, 596, 596, 7, 45},
  {cont__compiler__body__to_c_90, &frame__compiler__body__to_c_88, 597, 603, 7, 59},
  {cont__compiler__body__to_c_104, &frame__compiler__body__to_c_88, 604, 604, 7, 19},
  {cont__compiler__body__to_c_105, &frame__compiler__body__to_c_88, 605, 605, 7, 61},
  {cont__compiler__body__to_c_106, &frame__compiler__body__to_c_88, 605, 605, 7, 22},
  {cont__compiler__body__to_c_107, &frame__compiler__body__to_c_88, 606, 606, 7, 19},
  {cont__compiler__body__to_c_108, &frame__compiler__body__to_c_88, 606, 606, 19, 19},
  {entry__compiler__body__to_c_114, NULL, 611, 611, 37, 37},
  {entry__compiler__body__to_c_115, NULL, 613, 613, 43, 43},
  {entry__compiler__body__to_c_110, NULL, 608, 608, 21, 44},
  {cont__compiler__body__to_c_111, &frame__compiler__body__to_c_110, 608, 608, 7, 45},
  {cont__compiler__body__to_c_112, &frame__compiler__body__to_c_110, 609, 609, 12, 39},
  {cont__compiler__body__to_c_113, &frame__compiler__body__to_c_110, 609, 613, 7, 44},
  {cont__compiler__body__to_c_116, &frame__compiler__body__to_c_110, 614, 614, 7, 19},
  {cont__compiler__body__to_c_117, &frame__compiler__body__to_c_110, 615, 615, 7, 61},
  {cont__compiler__body__to_c_118, &frame__compiler__body__to_c_110, 615, 615, 7, 22},
  {cont__compiler__body__to_c_119, &frame__compiler__body__to_c_110, 616, 616, 7, 19},
  {cont__compiler__body__to_c_120, &frame__compiler__body__to_c_110, 616, 616, 19, 19},
  {entry__compiler__body__to_c_122, NULL, 619, 619, 31, 56},
  {cont__compiler__body__to_c_123, &frame__compiler__body__to_c_122, 619, 619, 31, 56},
  {cont__compiler__body__to_c_124, &frame__compiler__body__to_c_122, 619, 619, 31, 56},
  {entry__compiler__body__to_c_126, NULL, 621, 621, 9, 22},
  {entry__compiler__body__to_c_127, NULL, 620, 620, 13, 13},
  {cont__compiler__body__to_c_128, &frame__compiler__body__to_c_127, 620, 620, 9, 13},
  {entry__compiler__body__to_c_131, NULL, 626, 626, 7, 19},
  {cont__compiler__body__to_c_132, &frame__compiler__body__to_c_131, 627, 627, 7, 57},
  {cont__compiler__body__to_c_133, &frame__compiler__body__to_c_131, 627, 627, 7, 22},
  {cont__compiler__body__to_c_134, &frame__compiler__body__to_c_131, 628, 628, 7, 19},
  {cont__compiler__body__to_c_135, &frame__compiler__body__to_c_131, 628, 628, 19, 19},
  {entry__compiler__body__to_c_140, NULL, 634, 634, 37, 59},
  {cont__compiler__body__to_c_141, &frame__compiler__body__to_c_140, 634, 634, 37, 76},
  {cont__compiler__body__to_c_142, &frame__compiler__body__to_c_140, 634, 634, 37, 76},
  {cont__compiler__body__to_c_143, &frame__compiler__body__to_c_140, 634, 634, 37, 76},
  {entry__compiler__body__to_c_145, NULL, 635, 635, 9, 21},
  {cont__compiler__body__to_c_146, &frame__compiler__body__to_c_145, 636, 636, 9, 58},
  {cont__compiler__body__to_c_147, &frame__compiler__body__to_c_145, 636, 636, 9, 24},
  {cont__compiler__body__to_c_148, &frame__compiler__body__to_c_145, 637, 637, 9, 21},
  {cont__compiler__body__to_c_149, &frame__compiler__body__to_c_145, 637, 637, 21, 21},
  {entry__compiler__body__to_c_138, NULL, 634, 634, 14, 32},
  {cont__compiler__body__to_c_139, &frame__compiler__body__to_c_138, 634, 634, 14, 76},
  {cont__compiler__body__to_c_144, &frame__compiler__body__to_c_138, 634, 637, 7, 21},
  {entry__compiler__body__to_c_156, NULL, 645, 645, 26, 46},
  {cont__compiler__body__to_c_158, &frame__compiler__body__to_c_156, 645, 645, 7, 46},
  {cont__compiler__body__to_c_159, &frame__compiler__body__to_c_156, 645, 645, 46, 46},
  {entry__compiler__body__to_c_161, NULL, 646, 646, 30, 55},
  {entry__compiler__body__to_c_163, NULL, 647, 649, 7, 33},
  {entry__compiler__body__to_c_167, NULL, 653, 653, 9, 59},
  {cont__compiler__body__to_c_168, &frame__compiler__body__to_c_167, 653, 653, 9, 59},
  {entry__compiler__body__to_c_170, NULL, 655, 657, 9, 35},
  {entry__compiler__body__to_c_189, NULL, 664, 664, 21, 46},
  {entry__compiler__body__to_c_184, NULL, 663, 663, 15, 37},
  {cont__compiler__body__to_c_185, &frame__compiler__body__to_c_184, 663, 663, 7, 37},
  {cont__compiler__body__to_c_186, &frame__compiler__body__to_c_184, 664, 664, 10, 18},
  {cont__compiler__body__to_c_187, &frame__compiler__body__to_c_184, 664, 664, 10, 18},
  {cont__compiler__body__to_c_188, &frame__compiler__body__to_c_184, 664, 664, 7, 46},
  {cont__compiler__body__to_c_190, &frame__compiler__body__to_c_184, 665, 665, 29, 49},
  {cont__compiler__body__to_c_192, &frame__compiler__body__to_c_184, 665, 665, 7, 49},
  {entry__compiler__body__to_c_201, NULL, 677, 678, 35, 51},
  {cont__compiler__body__to_c_203, &frame__compiler__body__to_c_201, 677, 678, 13, 51},
  {cont__compiler__body__to_c_204, &frame__compiler__body__to_c_201, 679, 679, 16, 66},
  {cont__compiler__body__to_c_206, &frame__compiler__body__to_c_201, 679, 679, 13, 66},
  {entry__compiler__body__to_c_207, NULL, 675, 675, 11, 36},
  {entry__compiler__body__to_c_199, NULL, 674, 674, 11, 36},
  {cont__compiler__body__to_c_200, &frame__compiler__body__to_c_199, 676, 679, 11, 66},
  {cont__compiler__body__to_c_209, &frame__compiler__body__to_c_199, 670, 679, 7, 68},
  {entry__compiler__body__to_c_212, NULL, 683, 683, 28, 47},
  {cont__compiler__body__to_c_213, &frame__compiler__body__to_c_212, 684, 684, 40, 58},
  {cont__compiler__body__to_c_214, &frame__compiler__body__to_c_212, 681, 684, 13, 75},
  {cont__compiler__body__to_c_219, &frame__compiler__body__to_c_212, 681, 684, 7, 75},
  {entry__compiler__body__to_c_225, NULL, 717, 717, 22, 39},
  {cont__compiler__body__to_c_226, &frame__compiler__body__to_c_225, 717, 717, 44, 68},
  {cont__compiler__body__to_c_227, &frame__compiler__body__to_c_225, 717, 717, 11, 70},
  {cont__compiler__body__to_c_230, &frame__compiler__body__to_c_225, 716, 717, 9, 70},
  {entry__compiler__body__to_c_237, NULL, 721, 721, 13, 55},
  {cont__compiler__body__to_c_238, &frame__compiler__body__to_c_237, 722, 722, 19, 50},
  {cont__compiler__body__to_c_239, &frame__compiler__body__to_c_237, 722, 722, 13, 50},
  {entry__compiler__body__to_c_234, NULL, 720, 720, 14, 43},
  {cont__compiler__body__to_c_235, &frame__compiler__body__to_c_234, 720, 720, 14, 51},
  {cont__compiler__body__to_c_236, &frame__compiler__body__to_c_234, 720, 722, 11, 50},
  {entry__compiler__body__to_c_240, NULL, 724, 724, 25, 50},
  {cont__compiler__body__to_c_241, &frame__compiler__body__to_c_240, 724, 724, 11, 51},
  {cont__compiler__body__to_c_242, &frame__compiler__body__to_c_240, 727, 727, 32, 43},
  {cont__compiler__body__to_c_243, &frame__compiler__body__to_c_240, 725, 727, 17, 76},
  {cont__compiler__body__to_c_245, &frame__compiler__body__to_c_240, 725, 727, 11, 76},
  {entry__compiler__body__to_c_246, NULL, 729, 729, 17, 56},
  {cont__compiler__body__to_c_247, &frame__compiler__body__to_c_246, 729, 729, 11, 56},
  {entry__compiler__body__to_c_222, NULL, 714, 714, 7, 68},
  {cont__compiler__body__to_c_223, &frame__compiler__body__to_c_222, 715, 715, 10, 26},
  {cont__compiler__body__to_c_224, &frame__compiler__body__to_c_222, 715, 717, 7, 71},
  {cont__compiler__body__to_c_231, &frame__compiler__body__to_c_222, 718, 718, 12, 40},
  {cont__compiler__body__to_c_232, &frame__compiler__body__to_c_222, 719, 719, 9, 37},
  {cont__compiler__body__to_c_233, &frame__compiler__body__to_c_222, 718, 729, 7, 57},
  {entry__compiler__body__to_c_254, NULL, 735, 735, 11, 40},
  {cont__compiler__body__to_c_255, &frame__compiler__body__to_c_254, 735, 735, 11, 48},
  {cont__compiler__body__to_c_256, &frame__compiler__body__to_c_254, 735, 735, 11, 48},
  {cont__compiler__body__to_c_257, &frame__compiler__body__to_c_254, 735, 735, 11, 48},
  {entry__compiler__body__to_c_261, NULL, 739, 739, 15, 57},
  {cont__compiler__body__to_c_262, &frame__compiler__body__to_c_261, 740, 740, 47, 71},
  {cont__compiler__body__to_c_263, &frame__compiler__body__to_c_261, 740, 740, 15, 72},
  {cont__compiler__body__to_c_264, &frame__compiler__body__to_c_261, 741, 741, 21, 46},
  {cont__compiler__body__to_c_265, &frame__compiler__body__to_c_261, 741, 741, 15, 51},
  {cont__compiler__body__to_c_266, &frame__compiler__body__to_c_261, 742, 746, 21, 46},
  {cont__compiler__body__to_c_271, &frame__compiler__body__to_c_261, 742, 746, 15, 46},
  {entry__compiler__body__to_c_275, NULL, 750, 750, 19, 61},
  {cont__compiler__body__to_c_276, &frame__compiler__body__to_c_275, 751, 751, 51, 75},
  {cont__compiler__body__to_c_277, &frame__compiler__body__to_c_275, 751, 751, 19, 76},
  {cont__compiler__body__to_c_278, &frame__compiler__body__to_c_275, 752, 752, 25, 50},
  {cont__compiler__body__to_c_279, &frame__compiler__body__to_c_275, 752, 752, 19, 55},
  {cont__compiler__body__to_c_280, &frame__compiler__body__to_c_275, 753, 757, 25, 28},
  {cont__compiler__body__to_c_281, &frame__compiler__body__to_c_275, 753, 757, 19, 28},
  {entry__compiler__body__to_c_282, NULL, 759, 759, 19, 52},
  {cont__compiler__body__to_c_283, &frame__compiler__body__to_c_282, 763, 763, 25, 50},
  {cont__compiler__body__to_c_284, &frame__compiler__body__to_c_282, 763, 763, 19, 55},
  {cont__compiler__body__to_c_285, &frame__compiler__body__to_c_282, 764, 767, 25, 62},
  {cont__compiler__body__to_c_287, &frame__compiler__body__to_c_282, 764, 767, 19, 62},
  {entry__compiler__body__to_c_272, NULL, 749, 749, 17, 41},
  {cont__compiler__body__to_c_273, &frame__compiler__body__to_c_272, 749, 749, 17, 52},
  {cont__compiler__body__to_c_274, &frame__compiler__body__to_c_272, 748, 767, 15, 64},
  {entry__compiler__body__to_c_259, NULL, 737, 737, 16, 45},
  {cont__compiler__body__to_c_260, &frame__compiler__body__to_c_259, 737, 767, 11, 66},
  {entry__compiler__body__to_c_250, NULL, 731, 731, 7, 68},
  {cont__compiler__body__to_c_251, &frame__compiler__body__to_c_250, 734, 734, 11, 39},
  {cont__compiler__body__to_c_252, &frame__compiler__body__to_c_250, 734, 734, 11, 56},
  {cont__compiler__body__to_c_253, &frame__compiler__body__to_c_250, 733, 735, 9, 48},
  {cont__compiler__body__to_c_258, &frame__compiler__body__to_c_250, 732, 767, 7, 68},
  {entry__compiler__body__to_c_290, NULL, 769, 769, 29, 64},
  {entry__compiler__body__to_c_289, NULL, 769, 769, 7, 64},
  {cont__compiler__body__to_c_291, &frame__compiler__body__to_c_289, 770, 770, 7, 16},
  {entry__compiler__body__to_c_294, NULL, 772, 772, 7, 69},
  {entry__compiler__body__to_c_300, NULL, 775, 775, 23, 46},
  {cont__compiler__body__to_c_301, &frame__compiler__body__to_c_300, 775, 775, 9, 47},
  {cont__compiler__body__to_c_302, &frame__compiler__body__to_c_300, 778, 778, 30, 41},
  {cont__compiler__body__to_c_303, &frame__compiler__body__to_c_300, 776, 778, 15, 74},
  {cont__compiler__body__to_c_304, &frame__compiler__body__to_c_300, 776, 778, 9, 74},
  {entry__compiler__body__to_c_297, NULL, 774, 774, 14, 41},
  {cont__compiler__body__to_c_298, &frame__compiler__body__to_c_297, 774, 774, 14, 61},
  {cont__compiler__body__to_c_299, &frame__compiler__body__to_c_297, 774, 778, 7, 75},
  {entry__compiler__body__to_c_308, NULL, 805, 805, 51, 78},
  {entry__compiler__body__to_c_319, NULL, 824, 824, 38, 60},
  {cont__compiler__body__to_c_320, &frame__compiler__body__to_c_319, 824, 824, 17, 60},
  {cont__compiler__body__to_c_321, &frame__compiler__body__to_c_319, 827, 827, 34, 60},
  {cont__compiler__body__to_c_322, &frame__compiler__body__to_c_319, 825, 829, 23, 57},
  {cont__compiler__body__to_c_323, &frame__compiler__body__to_c_319, 825, 829, 17, 57},
  {entry__compiler__body__to_c_324, NULL, 832, 832, 44, 66},
  {cont__compiler__body__to_c_325, &frame__compiler__body__to_c_324, 832, 832, 19, 67},
  {cont__compiler__body__to_c_326, &frame__compiler__body__to_c_324, 831, 832, 17, 67},
  {cont__compiler__body__to_c_327, &frame__compiler__body__to_c_324, 833, 837, 17, 57},
  {entry__compiler__body__to_c_316, NULL, 813, 813, 13, 44},
  {cont__compiler__body__to_c_317, &frame__compiler__body__to_c_316, 823, 823, 15, 47},
  {cont__compiler__body__to_c_318, &frame__compiler__body__to_c_316, 822, 837, 13, 59},
  {entry__compiler__body__to_c_314, NULL, 812, 812, 14, 34},
  {cont__compiler__body__to_c_315, &frame__compiler__body__to_c_314, 812, 837, 11, 60},
  {entry__compiler__body__to_c_330, NULL, 841, 841, 26, 48},
  {cont__compiler__body__to_c_331, &frame__compiler__body__to_c_330, 841, 841, 19, 66},
  {cont__compiler__body__to_c_332, &frame__compiler__body__to_c_330, 841, 841, 15, 67},
  {cont__compiler__body__to_c_333, &frame__compiler__body__to_c_330, 841, 841, 15, 67},
  {entry__compiler__body__to_c_343, NULL, 850, 850, 19, 71},
  {cont__compiler__body__to_c_345, &frame__compiler__body__to_c_343, 853, 853, 45, 70},
  {cont__compiler__body__to_c_346, &frame__compiler__body__to_c_343, 853, 853, 45, 75},
  {cont__compiler__body__to_c_347, &frame__compiler__body__to_c_343, 851, 858, 25, 82},
  {cont__compiler__body__to_c_350, &frame__compiler__body__to_c_343, 851, 858, 19, 82},
  {entry__compiler__body__to_c_352, NULL, 870, 874, 29, 80},
  {cont__compiler__body__to_c_356, &frame__compiler__body__to_c_352, 870, 874, 23, 80},
  {entry__compiler__body__to_c_357, NULL, 862, 864, 23, 46},
  {entry__compiler__body__to_c_359, NULL, 866, 868, 23, 70},
  {entry__compiler__body__to_c_364, NULL, 877, 877, 23, 32},
  {cont__compiler__body__to_c_365, &frame__compiler__body__to_c_364, 878, 878, 51, 79},
  {cont__compiler__body__to_c_366, &frame__compiler__body__to_c_364, 878, 878, 23, 79},
  {cont__compiler__body__to_c_367, &frame__compiler__body__to_c_364, 879, 879, 23, 35},
  {cont__compiler__body__to_c_369, &frame__compiler__body__to_c_364, 880, 880, 41, 69},
  {cont__compiler__body__to_c_370, &frame__compiler__body__to_c_364, 880, 880, 23, 69},
  {cont__compiler__body__to_c_371, &frame__compiler__body__to_c_364, 881, 885, 23, 50},
  {cont__compiler__body__to_c_372, &frame__compiler__body__to_c_364, 888, 888, 40, 66},
  {cont__compiler__body__to_c_373, &frame__compiler__body__to_c_364, 886, 890, 29, 63},
  {cont__compiler__body__to_c_374, &frame__compiler__body__to_c_364, 886, 890, 23, 63},
  {entry__compiler__body__to_c_362, NULL, 876, 876, 24, 56},
  {cont__compiler__body__to_c_363, &frame__compiler__body__to_c_362, 876, 890, 21, 64},
  {entry__compiler__body__to_c_387, NULL, 899, 904, 33, 33},
  {cont__compiler__body__to_c_390, &frame__compiler__body__to_c_387, 899, 904, 27, 33},
  {cont__compiler__body__to_c_391, &frame__compiler__body__to_c_387, 905, 905, 27, 69},
  {entry__compiler__body__to_c_392, NULL, 907, 912, 27, 53},
  {cont__compiler__body__to_c_394, &frame__compiler__body__to_c_392, 913, 913, 27, 64},
  {cont__compiler__body__to_c_395, &frame__compiler__body__to_c_392, 914, 919, 27, 33},
  {entry__compiler__body__to_c_378, NULL, 892, 892, 23, 32},
  {cont__compiler__body__to_c_379, &frame__compiler__body__to_c_378, 893, 893, 51, 79},
  {cont__compiler__body__to_c_380, &frame__compiler__body__to_c_378, 893, 893, 23, 79},
  {cont__compiler__body__to_c_381, &frame__compiler__body__to_c_378, 894, 894, 23, 35},
  {cont__compiler__body__to_c_382, &frame__compiler__body__to_c_378, 895, 895, 41, 69},
  {cont__compiler__body__to_c_383, &frame__compiler__body__to_c_378, 895, 895, 23, 69},
  {cont__compiler__body__to_c_384, &frame__compiler__body__to_c_378, 896, 896, 23, 59},
  {cont__compiler__body__to_c_385, &frame__compiler__body__to_c_378, 898, 898, 25, 36},
  {cont__compiler__body__to_c_386, &frame__compiler__body__to_c_378, 897, 919, 23, 35},
  {cont__compiler__body__to_c_397, &frame__compiler__body__to_c_378, 920, 924, 23, 63},
  {entry__compiler__body__to_c_375, NULL, 891, 891, 28, 53},
  {cont__compiler__body__to_c_376, &frame__compiler__body__to_c_375, 891, 891, 24, 54},
  {cont__compiler__body__to_c_377, &frame__compiler__body__to_c_375, 891, 924, 21, 64},
  {entry__compiler__body__to_c_398, NULL, 926, 929, 23, 54},
  {entry__compiler__body__to_c_351, NULL, 860, 874, 19, 82},
  {cont__compiler__body__to_c_361, &frame__compiler__body__to_c_351, 875, 929, 19, 56},
  {entry__compiler__body__to_c_335, NULL, 843, 843, 15, 46},
  {cont__compiler__body__to_c_336, &frame__compiler__body__to_c_335, 844, 844, 15, 44},
  {cont__compiler__body__to_c_337, &frame__compiler__body__to_c_335, 845, 845, 15, 54},
  {cont__compiler__body__to_c_338, &frame__compiler__body__to_c_335, 846, 846, 15, 62},
  {cont__compiler__body__to_c_339, &frame__compiler__body__to_c_335, 847, 847, 15, 50},
  {cont__compiler__body__to_c_340, &frame__compiler__body__to_c_335, 849, 849, 17, 42},
  {cont__compiler__body__to_c_341, &frame__compiler__body__to_c_335, 849, 849, 17, 53},
  {cont__compiler__body__to_c_342, &frame__compiler__body__to_c_335, 848, 929, 15, 58},
  {entry__compiler__body__to_c_328, NULL, 840, 840, 15, 43},
  {cont__compiler__body__to_c_329, &frame__compiler__body__to_c_328, 839, 841, 13, 67},
  {cont__compiler__body__to_c_334, &frame__compiler__body__to_c_328, 838, 929, 11, 60},
  {entry__compiler__body__to_c_400, NULL, 931, 931, 13, 40},
  {cont__compiler__body__to_c_401, &frame__compiler__body__to_c_400, 932, 932, 13, 25},
  {entry__compiler__body__to_c_311, NULL, 810, 810, 32, 32},
  {cont__compiler__body__to_c_312, &frame__compiler__body__to_c_311, 810, 810, 9, 33},
  {cont__compiler__body__to_c_313, &frame__compiler__body__to_c_311, 811, 932, 9, 26},
  {entry__compiler__body__to_c_406, NULL, 935, 935, 49, 74},
  {cont__compiler__body__to_c_407, &frame__compiler__body__to_c_406, 935, 935, 45, 75},
  {cont__compiler__body__to_c_408, &frame__compiler__body__to_c_406, 935, 935, 45, 75},
  {entry__compiler__body__to_c_416, NULL, 944, 949, 17, 17},
  {cont__compiler__body__to_c_417, &frame__compiler__body__to_c_416, 944, 949, 11, 17},
  {cont__compiler__body__to_c_418, &frame__compiler__body__to_c_416, 950, 950, 11, 53},
  {entry__compiler__body__to_c_419, NULL, 952, 957, 11, 37},
  {cont__compiler__body__to_c_420, &frame__compiler__body__to_c_419, 958, 958, 11, 48},
  {cont__compiler__body__to_c_421, &frame__compiler__body__to_c_419, 959, 963, 11, 17},
  {entry__compiler__body__to_c_410, NULL, 938, 940, 13, 57},
  {cont__compiler__body__to_c_412, &frame__compiler__body__to_c_410, 938, 940, 7, 57},
  {cont__compiler__body__to_c_413, &frame__compiler__body__to_c_410, 941, 941, 7, 43},
  {cont__compiler__body__to_c_414, &frame__compiler__body__to_c_410, 943, 943, 9, 20},
  {cont__compiler__body__to_c_415, &frame__compiler__body__to_c_410, 942, 963, 7, 19},
  {cont__compiler__body__to_c_422, &frame__compiler__body__to_c_410, 964, 966, 7, 9},
  {entry__compiler__body__to_c_22, NULL, 563, 563, 5, 24},
  {cont__compiler__body__to_c_66, &frame__compiler__body__to_c_22, 577, 577, 14, 32},
  {cont__compiler__body__to_c_67, &frame__compiler__body__to_c_22, 577, 591, 5, 44},
  {cont__compiler__body__to_c_87, &frame__compiler__body__to_c_22, 595, 606, 5, 19},
  {cont__compiler__body__to_c_109, &frame__compiler__body__to_c_22, 607, 616, 5, 19},
  {cont__compiler__body__to_c_121, &frame__compiler__body__to_c_22, 619, 619, 9, 56},
  {cont__compiler__body__to_c_125, &frame__compiler__body__to_c_22, 617, 621, 5, 23},
  {cont__compiler__body__to_c_129, &frame__compiler__body__to_c_22, 625, 625, 14, 37},
  {cont__compiler__body__to_c_130, &frame__compiler__body__to_c_22, 625, 628, 5, 19},
  {cont__compiler__body__to_c_136, &frame__compiler__body__to_c_22, 633, 633, 14, 35},
  {cont__compiler__body__to_c_137, &frame__compiler__body__to_c_22, 633, 637, 5, 22},
  {cont__compiler__body__to_c_150, &frame__compiler__body__to_c_22, 638, 638, 27, 50},
  {cont__compiler__body__to_c_151, &frame__compiler__body__to_c_22, 638, 638, 5, 50},
  {cont__compiler__body__to_c_152, &frame__compiler__body__to_c_22, 642, 642, 27, 64},
  {cont__compiler__body__to_c_154, &frame__compiler__body__to_c_22, 642, 642, 5, 64},
  {cont__compiler__body__to_c_155, &frame__compiler__body__to_c_22, 643, 645, 5, 46},
  {cont__compiler__body__to_c_160, &frame__compiler__body__to_c_22, 646, 646, 8, 55},
  {cont__compiler__body__to_c_162, &frame__compiler__body__to_c_22, 646, 649, 5, 34},
  {cont__compiler__body__to_c_165, &frame__compiler__body__to_c_22, 652, 652, 9, 41},
  {cont__compiler__body__to_c_166, &frame__compiler__body__to_c_22, 651, 653, 7, 59},
  {cont__compiler__body__to_c_169, &frame__compiler__body__to_c_22, 650, 657, 5, 37},
  {cont__compiler__body__to_c_172, &frame__compiler__body__to_c_22, 658, 658, 11, 79},
  {cont__compiler__body__to_c_174, &frame__compiler__body__to_c_22, 658, 658, 5, 79},
  {cont__compiler__body__to_c_175, &frame__compiler__body__to_c_22, 659, 659, 5, 36},
  {cont__compiler__body__to_c_177, &frame__compiler__body__to_c_22, 661, 661, 51, 75},
  {cont__compiler__body__to_c_178, &frame__compiler__body__to_c_22, 661, 661, 7, 80},
  {cont__compiler__body__to_c_182, &frame__compiler__body__to_c_22, 660, 661, 5, 80},
  {cont__compiler__body__to_c_183, &frame__compiler__body__to_c_22, 662, 665, 5, 49},
  {cont__compiler__body__to_c_193, &frame__compiler__body__to_c_22, 666, 667, 5, 9},
  {cont__compiler__body__to_c_195, &frame__compiler__body__to_c_22, 668, 668, 5, 40},
  {cont__compiler__body__to_c_197, &frame__compiler__body__to_c_22, 669, 669, 8, 40},
  {cont__compiler__body__to_c_198, &frame__compiler__body__to_c_22, 669, 679, 5, 69},
  {cont__compiler__body__to_c_210, &frame__compiler__body__to_c_22, 680, 680, 14, 37},
  {cont__compiler__body__to_c_211, &frame__compiler__body__to_c_22, 680, 684, 5, 76},
  {cont__compiler__body__to_c_220, &frame__compiler__body__to_c_22, 713, 713, 14, 33},
  {cont__compiler__body__to_c_221, &frame__compiler__body__to_c_22, 713, 729, 5, 58},
  {cont__compiler__body__to_c_248, &frame__compiler__body__to_c_22, 730, 730, 14, 33},
  {cont__compiler__body__to_c_249, &frame__compiler__body__to_c_22, 730, 767, 5, 69},
  {cont__compiler__body__to_c_288, &frame__compiler__body__to_c_22, 768, 770, 5, 16},
  {cont__compiler__body__to_c_292, &frame__compiler__body__to_c_22, 771, 771, 8, 34},
  {cont__compiler__body__to_c_293, &frame__compiler__body__to_c_22, 771, 772, 5, 69},
  {cont__compiler__body__to_c_296, &frame__compiler__body__to_c_22, 773, 778, 5, 76},
  {cont__compiler__body__to_c_305, &frame__compiler__body__to_c_22, 779, 779, 5, 35},
  {cont__compiler__body__to_c_306, &frame__compiler__body__to_c_22, 805, 805, 36, 36},
  {cont__compiler__body__to_c_307, &frame__compiler__body__to_c_22, 805, 805, 5, 78},
  {cont__compiler__body__to_c_309, &frame__compiler__body__to_c_22, 807, 807, 7, 26},
  {cont__compiler__body__to_c_310, &frame__compiler__body__to_c_22, 806, 932, 5, 28},
  {cont__compiler__body__to_c_402, &frame__compiler__body__to_c_22, 933, 933, 5, 17},
  {cont__compiler__body__to_c_403, &frame__compiler__body__to_c_22, 934, 934, 5, 20},
  {cont__compiler__body__to_c_404, &frame__compiler__body__to_c_22, 935, 935, 8, 40},
  {cont__compiler__body__to_c_405, &frame__compiler__body__to_c_22, 935, 935, 8, 75},
  {cont__compiler__body__to_c_409, &frame__compiler__body__to_c_22, 935, 966, 5, 10},
  {cont__compiler__body__to_c_424, &frame__compiler__body__to_c_22, 966, 966, 10, 10},
  {entry__compiler__body__to_c_428, NULL, 967, 967, 46, 66},
  {cont__compiler__body__to_c_429, &frame__compiler__body__to_c_428, 967, 967, 39, 76},
  {entry__compiler__body__to_c_433, NULL, 970, 973, 24, 27},
  {cont__compiler__body__to_c_436, &frame__compiler__body__to_c_433, 970, 973, 7, 27},
  {cont__compiler__body__to_c_437, &frame__compiler__body__to_c_433, 974, 974, 14, 33},
  {cont__compiler__body__to_c_438, &frame__compiler__body__to_c_433, 974, 974, 7, 33},
  {entry__compiler__body__to_c_439, NULL, 976, 976, 14, 64},
  {cont__compiler__body__to_c_441, &frame__compiler__body__to_c_439, 976, 976, 7, 64},
  {entry__compiler__body___to_c, NULL, 540, 540, 3, 42},
  {cont__compiler__body___to_c_3, &frame__compiler__body___to_c, 544, 544, 3, 26},
  {cont__compiler__body___to_c_4, &frame__compiler__body___to_c, 548, 548, 7, 26},
  {cont__compiler__body___to_c_5, &frame__compiler__body___to_c, 546, 550, 3, 36},
  {cont__compiler__body___to_c_11, &frame__compiler__body___to_c, 552, 552, 6, 24},
  {cont__compiler__body___to_c_12, &frame__compiler__body___to_c, 552, 552, 3, 53},
  {cont__compiler__body___to_c_16, &frame__compiler__body___to_c, 553, 553, 3, 12},
  {cont__compiler__body___to_c_17, &frame__compiler__body___to_c, 557, 557, 7, 26},
  {cont__compiler__body___to_c_18, &frame__compiler__body___to_c, 555, 559, 3, 16},
  {cont__compiler__body___to_c_21, &frame__compiler__body___to_c, 562, 966, 3, 11},
  {cont__compiler__body___to_c_425, &frame__compiler__body___to_c, 967, 967, 6, 31},
  {cont__compiler__body___to_c_426, &frame__compiler__body___to_c, 967, 967, 6, 36},
  {cont__compiler__body___to_c_427, &frame__compiler__body___to_c, 967, 967, 3, 76},
  {cont__compiler__body___to_c_430, &frame__compiler__body___to_c, 969, 969, 5, 28},
  {cont__compiler__body___to_c_431, &frame__compiler__body___to_c, 969, 969, 5, 37},
  {cont__compiler__body___to_c_432, &frame__compiler__body___to_c, 968, 976, 3, 65},
  {cont__compiler__body___to_c_442, &frame__compiler__body___to_c, 976, 976, 65, 65},
  {entry__compiler__definition__to_c_7, NULL, 991, 991, 25, 43},
  {cont__compiler__definition__to_c_8, &frame__compiler__definition__to_c_7, 991, 991, 9, 44},
  {cont__compiler__definition__to_c_9, &frame__compiler__definition__to_c_7, 993, 993, 25, 42},
  {cont__compiler__definition__to_c_10, &frame__compiler__definition__to_c_7, 993, 993, 9, 43},
  {cont__compiler__definition__to_c_11, &frame__compiler__definition__to_c_7, },
  {cont__compiler__definition__to_c_12, &frame__compiler__definition__to_c_7, 988, 993, 5, 44},
  {entry__compiler__definition___to_c, NULL, 986, 986, 3, 48},
  {cont__compiler__definition___to_c_3, &frame__compiler__definition___to_c, 987, 987, 6, 28},
  {cont__compiler__definition___to_c_4, &frame__compiler__definition___to_c, 987, 987, 6, 36},
  {cont__compiler__definition___to_c_5, &frame__compiler__definition___to_c, 987, 987, 6, 36},
  {cont__compiler__definition___to_c_6, &frame__compiler__definition___to_c, 987, 993, 3, 45},
  {cont__compiler__definition___to_c_13, &frame__compiler__definition___to_c, 994, 994, 6, 24},
  {cont__compiler__definition___to_c_14, &frame__compiler__definition___to_c, 994, 994, 6, 29},
  {cont__compiler__definition___to_c_15, &frame__compiler__definition___to_c, 994, 994, 3, 29},
  {entry__compiler__numeric_literal___to_c, NULL, 1000, 1000, 3, 53},
  {cont__compiler__numeric_literal___to_c_3, &frame__compiler__numeric_literal___to_c, 1001, 1001, 20, 40},
  {cont__compiler__numeric_literal___to_c_4, &frame__compiler__numeric_literal___to_c, 1001, 1001, 3, 42},
  {cont__compiler__numeric_literal___to_c_6, &frame__compiler__numeric_literal___to_c, 1002, 1002, 3, 23},
  {cont__compiler__numeric_literal___to_c_7, &frame__compiler__numeric_literal___to_c, 1003, 1003, 3, 9},
  {entry__compiler__character_literal___to_c, NULL, 1009, 1009, 3, 55},
  {cont__compiler__character_literal___to_c_3, &frame__compiler__character_literal___to_c, 1010, 1010, 23, 42},
  {cont__compiler__character_literal___to_c_4, &frame__compiler__character_literal___to_c, 1010, 1010, 23, 53},
  {cont__compiler__character_literal___to_c_5, &frame__compiler__character_literal___to_c, 1010, 1010, 3, 55},
  {cont__compiler__character_literal___to_c_7, &frame__compiler__character_literal___to_c, 1011, 1011, 3, 23},
  {cont__compiler__character_literal___to_c_8, &frame__compiler__character_literal___to_c, 1012, 1012, 3, 9},
  {entry__to_c_string_8, NULL, 1021, 1021, 53, 62},
  {cont__to_c_string_9, &frame__to_c_string_8, 1021, 1021, 53, 62},
  {entry__to_c_string_6, NULL, 1021, 1021, 34, 48},
  {cont__to_c_string_7, &frame__to_c_string_6, 1021, 1021, 34, 62},
  {cont__to_c_string_10, &frame__to_c_string_6, 1021, 1021, 34, 62},
  {entry__to_c_string_4, NULL, 1021, 1021, 21, 29},
  {cont__to_c_string_5, &frame__to_c_string_4, 1021, 1021, 21, 62},
  {cont__to_c_string_11, &frame__to_c_string_4, 1021, 1021, 21, 62},
  {entry__to_c_string_13, NULL, 1022, 1022, 31, 35},
  {cont__to_c_string_14, &frame__to_c_string_13, 1022, 1022, 19, 36},
  {cont__to_c_string_15, &frame__to_c_string_13, 1022, 1022, 7, 36},
  {cont__to_c_string_16, &frame__to_c_string_13, 1023, 1023, 38, 51},
  {cont__to_c_string_17, &frame__to_c_string_13, 1023, 1023, 34, 52},
  {cont__to_c_string_18, &frame__to_c_string_13, 1023, 1023, 25, 59},
  {cont__to_c_string_20, &frame__to_c_string_13, 1023, 1023, 7, 59},
  {cont__to_c_string_22, &frame__to_c_string_13, 1024, 1024, 7, 14},
  {cont__to_c_string_23, &frame__to_c_string_13, 1024, 1024, 14, 14},
  {entry__to_c_string_2, NULL, 1021, 1021, 8, 16},
  {cont__to_c_string_3, &frame__to_c_string_2, 1021, 1021, 8, 62},
  {cont__to_c_string_12, &frame__to_c_string_2, 1021, 1024, 5, 14},
  {entry__to_c_string_28, NULL, 1025, 1025, 52, 52},
  {cont__to_c_string_29, &frame__to_c_string_28, 1025, 1025, 39, 53},
  {cont__to_c_string_30, &frame__to_c_string_28, 1025, 1025, 27, 53},
  {cont__to_c_string_31, &frame__to_c_string_28, 1025, 1025, 53, 53},
  {entry__to_c_string, NULL, 1020, 1024, 3, 15},
  {cont__to_c_string_24, &frame__to_c_string, 1025, 1025, 11, 24},
  {cont__to_c_string_25, &frame__to_c_string, 1025, 1025, 6, 24},
  {cont__to_c_string_26, &frame__to_c_string, 1025, 1025, 6, 24},
  {cont__to_c_string_27, &frame__to_c_string, 1025, 1025, 3, 53},
  {cont__to_c_string_32, &frame__to_c_string, 1026, 1026, 3, 8},
  {entry__register_string_15, NULL, 1045, 1045, 15, 34},
  {cont__register_string_16, &frame__register_string_15, 1045, 1045, 34, 34},
  {entry__register_string_23, NULL, 1053, 1053, 31, 50},
  {cont__register_string_24, &frame__register_string_23, 1053, 1053, 50, 50},
  {entry__register_string_21, NULL, 1053, 1053, 22, 28},
  {cont__register_string_22, &frame__register_string_21, 1053, 1053, 19, 50},
  {cont__register_string_25, &frame__register_string_21, 1054, 1054, 19, 23},
  {entry__register_string_19, NULL, 1050, 1050, 20, 36},
  {cont__register_string_20, &frame__register_string_19, 1050, 1054, 17, 23},
  {entry__register_string_18, NULL, 1049, 1054, 15, 24},
  {cont__register_string_26, &frame__register_string_18, 1058, 1058, 15, 30},
  {cont__register_string_27, &frame__register_string_18, 1059, 1059, 15, 36},
  {cont__register_string_28, &frame__register_string_18, 1060, 1060, 32, 48},
  {cont__register_string_29, &frame__register_string_18, 1060, 1060, 15, 78},
  {cont__register_string_30, &frame__register_string_18, 1060, 1060, 78, 78},
  {entry__register_string_13, NULL, 1042, 1042, 16, 33},
  {cont__register_string_14, &frame__register_string_13, 1042, 1045, 13, 34},
  {cont__register_string_17, &frame__register_string_13, 1046, 1060, 13, 78},
  {entry__register_string_10, NULL, 1039, 1039, 14, 26},
  {cont__register_string_11, &frame__register_string_10, 1039, 1039, 14, 26},
  {cont__register_string_12, &frame__register_string_10, 1039, 1060, 11, 79},
  {entry__register_string_31, NULL, 1062, 1062, 11, 32},
  {cont__register_string_32, &frame__register_string_31, 1062, 1062, 36, 36},
  {entry__register_string_46, NULL, 1070, 1070, 29, 35},
  {cont__register_string_47, &frame__register_string_46, 1070, 1070, 29, 35},
  {entry__register_string_50, NULL, 1078, 1078, 21, 37},
  {cont__register_string_51, &frame__register_string_50, 1073, 1078, 19, 37},
  {entry__register_string_53, NULL, 1080, 1080, 19, 45},
  {entry__register_string_59, NULL, 1083, 1083, 19, 45},
  {entry__register_string_60, NULL, 1085, 1085, 19, 43},
  {entry__register_string_49, NULL, 1071, 1080, 15, 46},
  {cont__register_string_55, &frame__register_string_49, 1082, 1082, 22, 22},
  {cont__register_string_56, &frame__register_string_49, 1082, 1082, 17, 23},
  {cont__register_string_57, &frame__register_string_49, 1082, 1082, 17, 33},
  {cont__register_string_58, &frame__register_string_49, 1081, 1085, 15, 44},
  {cont__register_string_61, &frame__register_string_49, 1086, 1088, 32, 32},
  {cont__register_string_63, &frame__register_string_49, 1086, 1088, 15, 32},
  {entry__register_string_64, NULL, 1090, 1090, 41, 56},
  {cont__register_string_65, &frame__register_string_64, 1090, 1090, 32, 78},
  {cont__register_string_67, &frame__register_string_64, 1090, 1090, 15, 78},
  {entry__register_string_40, NULL, 1067, 1067, 28, 61},
  {cont__register_string_42, &frame__register_string_40, 1067, 1067, 11, 61},
  {cont__register_string_43, &frame__register_string_40, 1068, 1068, 11, 41},
  {cont__register_string_44, &frame__register_string_40, 1070, 1070, 13, 24},
  {cont__register_string_45, &frame__register_string_40, 1070, 1070, 13, 35},
  {cont__register_string_48, &frame__register_string_40, 1069, 1090, 11, 79},
  {entry__register_string_86, NULL, 1102, 1102, 21, 30},
  {cont__register_string_87, &frame__register_string_86, 1102, 1102, 21, 30},
  {cont__register_string_88, &frame__register_string_86, 1102, 1102, 21, 30},
  {entry__register_string_83, NULL, 1101, 1101, 21, 35},
  {cont__register_string_84, &frame__register_string_83, 1101, 1101, 21, 35},
  {cont__register_string_85, &frame__register_string_83, 1102, 1102, 21, 30},
  {cont__register_string_89, &frame__register_string_83, },
  {entry__register_string_80, NULL, 1100, 1100, 21, 35},
  {cont__register_string_81, &frame__register_string_80, 1100, 1100, 21, 35},
  {cont__register_string_82, &frame__register_string_80, },
  {cont__register_string_90, &frame__register_string_80, },
  {entry__register_string_77, NULL, 1099, 1099, 21, 30},
  {cont__register_string_78, &frame__register_string_77, 1099, 1099, 21, 30},
  {cont__register_string_79, &frame__register_string_77, },
  {cont__register_string_91, &frame__register_string_77, },
  {entry__register_string_96, NULL, 1103, 1103, 38, 47},
  {cont__register_string_97, &frame__register_string_96, 1103, 1103, 38, 47},
  {cont__register_string_98, &frame__register_string_96, 1103, 1103, 38, 47},
  {entry__register_string_93, NULL, 1103, 1103, 19, 33},
  {cont__register_string_94, &frame__register_string_93, 1103, 1103, 19, 33},
  {cont__register_string_95, &frame__register_string_93, 1103, 1103, 19, 47},
  {cont__register_string_99, &frame__register_string_93, 1103, 1103, 19, 47},
  {entry__register_string_101, NULL, 1105, 1105, 19, 56},
  {entry__register_string_102, NULL, 1107, 1107, 45, 58},
  {cont__register_string_103, &frame__register_string_102, 1107, 1107, 41, 59},
  {cont__register_string_104, &frame__register_string_102, 1107, 1107, 19, 59},
  {entry__register_string_74, NULL, 1098, 1098, 21, 30},
  {cont__register_string_75, &frame__register_string_74, 1098, 1098, 21, 30},
  {cont__register_string_76, &frame__register_string_74, },
  {cont__register_string_92, &frame__register_string_74, 1096, 1103, 17, 47},
  {cont__register_string_100, &frame__register_string_74, 1095, 1107, 15, 60},
  {entry__register_string_106, NULL, 1109, 1109, 15, 35},
  {entry__register_string_68, NULL, 1092, 1092, 28, 67},
  {cont__register_string_72, &frame__register_string_68, 1092, 1092, 11, 67},
  {cont__register_string_73, &frame__register_string_68, 1093, 1109, 11, 36},
  {cont__register_string_107, &frame__register_string_68, 1110, 1110, 11, 35},
  {cont__register_string_109, &frame__register_string_68, 1112, 1112, 13, 74},
  {cont__register_string_112, &frame__register_string_68, 1111, 1112, 11, 74},
  {entry__register_string_4, NULL, 1034, 1034, 7, 16},
  {cont__register_string_5, &frame__register_string_4, 1035, 1035, 14, 23},
  {cont__register_string_6, &frame__register_string_4, 1035, 1035, 7, 27},
  {cont__register_string_7, &frame__register_string_4, 1036, 1036, 7, 36},
  {cont__register_string_8, &frame__register_string_4, 1038, 1038, 9, 25},
  {cont__register_string_9, &frame__register_string_4, 1037, 1062, 7, 37},
  {cont__register_string_33, &frame__register_string_4, 1063, 1063, 7, 58},
  {cont__register_string_35, &frame__register_string_4, 1064, 1064, 29, 55},
  {cont__register_string_37, &frame__register_string_4, 1064, 1064, 7, 55},
  {cont__register_string_38, &frame__register_string_4, 1066, 1066, 9, 31},
  {cont__register_string_39, &frame__register_string_4, 1065, 1112, 7, 76},
  {cont__register_string_113, &frame__register_string_4, 1113, 1113, 7, 13},
  {entry__register_string_114, NULL, 1032, 1032, 5, 21},
  {entry__register_string, NULL, 1029, 1029, 3, 21},
  {cont__register_string_2, &frame__register_string, 1031, 1031, 5, 12},
  {cont__register_string_3, &frame__register_string, 1030, 1113, 3, 14},
  {entry__compiler__string_literal__to_c_7, NULL, 1121, 1121, 5, 14},
  {entry__compiler__string_literal__to_c_8, NULL, 1123, 1123, 7, 40},
  {cont__compiler__string_literal__to_c_9, &frame__compiler__string_literal__to_c_8, 1124, 1124, 7, 33},
  {cont__compiler__string_literal__to_c_10, &frame__compiler__string_literal__to_c_8, 1125, 1125, 7, 20},
  {entry__compiler__string_literal___to_c, NULL, 1116, 1116, 3, 52},
  {cont__compiler__string_literal___to_c_3, &frame__compiler__string_literal___to_c, 1117, 1117, 3, 27},
  {cont__compiler__string_literal___to_c_4, &frame__compiler__string_literal___to_c, 1118, 1118, 3, 37},
  {cont__compiler__string_literal___to_c_5, &frame__compiler__string_literal___to_c, 1120, 1120, 5, 22},
  {cont__compiler__string_literal___to_c_6, &frame__compiler__string_literal___to_c, 1119, 1125, 3, 21},
  {entry__compiler__unique_item__to_c_6, NULL, 1138, 1138, 12, 24},
  {cont__compiler__unique_item__to_c_7, &frame__compiler__unique_item__to_c_6, 1138, 1138, 9, 24},
  {entry__compiler__unique_item__to_c_8, NULL, 1140, 1140, 11, 32},
  {cont__compiler__unique_item__to_c_9, &frame__compiler__unique_item__to_c_8, 1141, 1141, 11, 30},
  {entry__compiler__unique_item__to_c_15, NULL, 1146, 1146, 10, 22},
  {cont__compiler__unique_item__to_c_16, &frame__compiler__unique_item__to_c_15, 1146, 1146, 7, 22},
  {entry__compiler__unique_item__to_c_17, NULL, 1147, 1147, 7, 13},
  {entry__compiler__unique_item__to_c_20, NULL, 1150, 1150, 5, 28},
  {cont__compiler__unique_item__to_c_21, &frame__compiler__unique_item__to_c_20, 1151, 1151, 27, 53},
  {cont__compiler__unique_item__to_c_22, &frame__compiler__unique_item__to_c_20, 1151, 1151, 5, 53},
  {cont__compiler__unique_item__to_c_23, &frame__compiler__unique_item__to_c_20, 1152, 1154, 22, 56},
  {cont__compiler__unique_item__to_c_26, &frame__compiler__unique_item__to_c_20, 1152, 1154, 5, 56},
  {entry__compiler__unique_item___to_c, NULL, 1131, 1131, 3, 49},
  {cont__compiler__unique_item___to_c_3, &frame__compiler__unique_item___to_c, 1137, 1137, 9, 21},
  {cont__compiler__unique_item___to_c_4, &frame__compiler__unique_item___to_c, 1137, 1137, 9, 32},
  {cont__compiler__unique_item___to_c_5, &frame__compiler__unique_item___to_c, 1138, 1138, 9, 24},
  {cont__compiler__unique_item___to_c_10, &frame__compiler__unique_item___to_c, 1133, 1141, 3, 33},
  {cont__compiler__unique_item___to_c_12, &frame__compiler__unique_item___to_c, 1145, 1145, 7, 19},
  {cont__compiler__unique_item___to_c_13, &frame__compiler__unique_item___to_c, 1145, 1145, 7, 30},
  {cont__compiler__unique_item___to_c_14, &frame__compiler__unique_item___to_c, 1143, 1147, 3, 14},
  {cont__compiler__unique_item___to_c_18, &frame__compiler__unique_item___to_c, 1149, 1149, 10, 32},
  {cont__compiler__unique_item___to_c_19, &frame__compiler__unique_item___to_c, 1149, 1154, 3, 57},
  {cont__compiler__unique_item___to_c_27, &frame__compiler__unique_item___to_c, 1155, 1155, 3, 9},
  {entry__compiler__identifier__to_c_9, NULL, 1167, 1167, 33, 49},
  {cont__compiler__identifier__to_c_10, &frame__compiler__identifier__to_c_9, 1167, 1167, 33, 60},
  {cont__compiler__identifier__to_c_11, &frame__compiler__identifier__to_c_9, 1167, 1167, 16, 60},
  {cont__compiler__identifier__to_c_12, &frame__compiler__identifier__to_c_9, 1167, 1167, 11, 62},
  {cont__compiler__identifier__to_c_13, &frame__compiler__identifier__to_c_9, 1168, 1168, 14, 49},
  {cont__compiler__identifier__to_c_15, &frame__compiler__identifier__to_c_9, 1168, 1168, 11, 49},
  {entry__compiler__identifier__to_c_16, NULL, 1169, 1169, 9, 15},
  {entry__compiler__identifier__to_c_7, NULL, 1166, 1166, 9, 35},
  {cont__compiler__identifier__to_c_8, &frame__compiler__identifier__to_c_7, 1169, 1169, 9, 15},
  {cont__compiler__identifier__to_c_17, &frame__compiler__identifier__to_c_7, 1164, 1169, 28, 16},
  {entry__compiler__identifier__to_c_5, NULL, 1164, 1164, 8, 26},
  {cont__compiler__identifier__to_c_6, &frame__compiler__identifier__to_c_5, 1164, 1169, 5, 16},
  {entry__compiler__identifier__to_c_23, NULL, 1174, 1174, 35, 54},
  {cont__compiler__identifier__to_c_24, &frame__compiler__identifier__to_c_23, 1173, 1175, 12, 13},
  {cont__compiler__identifier__to_c_27, &frame__compiler__identifier__to_c_23, 1173, 1175, 9, 13},
  {entry__compiler__identifier__to_c_28, NULL, 1176, 1176, 28, 47},
  {cont__compiler__identifier__to_c_29, &frame__compiler__identifier__to_c_28, 1176, 1176, 12, 64},
  {cont__compiler__identifier__to_c_30, &frame__compiler__identifier__to_c_28, 1176, 1176, 9, 64},
  {entry__compiler__identifier__to_c_21, NULL, 1172, 1172, 9, 30},
  {cont__compiler__identifier__to_c_22, &frame__compiler__identifier__to_c_21, 1176, 1176, 9, 64},
  {cont__compiler__identifier__to_c_31, &frame__compiler__identifier__to_c_21, 1170, 1176, 40, 65},
  {entry__compiler__identifier__to_c_18, NULL, 1170, 1170, 8, 27},
  {cont__compiler__identifier__to_c_19, &frame__compiler__identifier__to_c_18, 1170, 1170, 8, 38},
  {cont__compiler__identifier__to_c_20, &frame__compiler__identifier__to_c_18, 1170, 1176, 5, 65},
  {entry__compiler__identifier__to_c_35, NULL, 1177, 1177, 41, 56},
  {cont__compiler__identifier__to_c_37, &frame__compiler__identifier__to_c_35, 1177, 1177, 38, 56},
  {entry__compiler__identifier__to_c_32, NULL, 1177, 1177, 8, 25},
  {cont__compiler__identifier__to_c_33, &frame__compiler__identifier__to_c_32, 1177, 1177, 8, 36},
  {cont__compiler__identifier__to_c_34, &frame__compiler__identifier__to_c_32, 1177, 1177, 5, 56},
  {entry__compiler__identifier__to_c_42, NULL, 1182, 1182, 61, 78},
  {cont__compiler__identifier__to_c_43, &frame__compiler__identifier__to_c_42, 1182, 1182, 46, 58},
  {cont__compiler__identifier__to_c_44, &frame__compiler__identifier__to_c_42, 1182, 1182, 31, 59},
  {cont__compiler__identifier__to_c_45, &frame__compiler__identifier__to_c_42, 1182, 1182, 31, 79},
  {cont__compiler__identifier__to_c_46, &frame__compiler__identifier__to_c_42, 1182, 1182, 14, 80},
  {cont__compiler__identifier__to_c_47, &frame__compiler__identifier__to_c_42, 1182, 1182, 11, 80},
  {entry__compiler__identifier__to_c_48, NULL, 1183, 1183, 31, 48},
  {cont__compiler__identifier__to_c_49, &frame__compiler__identifier__to_c_48, 1183, 1183, 14, 49},
  {cont__compiler__identifier__to_c_50, &frame__compiler__identifier__to_c_48, 1183, 1183, 11, 49},
  {entry__compiler__identifier__to_c_53, NULL, 1189, 1189, 14, 29},
  {cont__compiler__identifier__to_c_54, &frame__compiler__identifier__to_c_53, 1189, 1189, 11, 29},
  {entry__compiler__identifier__to_c_55, NULL, 1190, 1190, 14, 28},
  {cont__compiler__identifier__to_c_56, &frame__compiler__identifier__to_c_55, 1190, 1190, 11, 28},
  {entry__compiler__identifier__to_c_39, NULL, 1181, 1181, 11, 28},
  {cont__compiler__identifier__to_c_40, &frame__compiler__identifier__to_c_39, 1181, 1181, 11, 39},
  {cont__compiler__identifier__to_c_41, &frame__compiler__identifier__to_c_39, 1179, 1183, 7, 50},
  {cont__compiler__identifier__to_c_51, &frame__compiler__identifier__to_c_39, 1188, 1188, 11, 39},
  {cont__compiler__identifier__to_c_52, &frame__compiler__identifier__to_c_39, 1190, 1190, 11, 28},
  {cont__compiler__identifier__to_c_57, &frame__compiler__identifier__to_c_39, 1185, 1190, 7, 29},
  {entry__compiler__identifier__to_c_38, NULL, 1178, 1190, 5, 30},
  {entry__compiler__identifier___to_c, NULL, 1161, 1161, 3, 54},
  {cont__compiler__identifier___to_c_3, &frame__compiler__identifier___to_c, 1162, 1162, 3, 29},
  {cont__compiler__identifier___to_c_4, &frame__compiler__identifier___to_c, 1163, 1190, 3, 31},
  {entry__compiler__c_body__to_c_8, NULL, 1201, 1201, 5, 52},
  {cont__compiler__c_body__to_c_9, &frame__compiler__c_body__to_c_8, 1201, 1201, 52, 52},
  {entry__compiler__c_body__to_c_15, NULL, 1206, 1206, 20, 34},
  {cont__compiler__c_body__to_c_16, &frame__compiler__c_body__to_c_15, 1206, 1206, 12, 43},
  {cont__compiler__c_body__to_c_17, &frame__compiler__c_body__to_c_15, 1206, 1206, 9, 43},
  {entry__compiler__c_body__to_c_18, NULL, 1207, 1207, 13, 13},
  {cont__compiler__c_body__to_c_19, &frame__compiler__c_body__to_c_18, 1207, 1207, 9, 13},
  {entry__compiler__c_body__to_c_26, NULL, 1214, 1214, 9, 66},
  {cont__compiler__c_body__to_c_29, &frame__compiler__c_body__to_c_26, 1213, 1214, 7, 66},
  {entry__compiler__c_body__to_c_11, NULL, 1205, 1205, 9, 23},
  {cont__compiler__c_body__to_c_12, &frame__compiler__c_body__to_c_11, 1205, 1205, 9, 54},
  {cont__compiler__c_body__to_c_14, &frame__compiler__c_body__to_c_11, 1203, 1207, 5, 14},
  {cont__compiler__c_body__to_c_20, &frame__compiler__c_body__to_c_11, 1209, 1211, 27, 38},
  {cont__compiler__c_body__to_c_23, &frame__compiler__c_body__to_c_11, 1209, 1211, 5, 38},
  {cont__compiler__c_body__to_c_24, &frame__compiler__c_body__to_c_11, 1212, 1212, 8, 35},
  {cont__compiler__c_body__to_c_25, &frame__compiler__c_body__to_c_11, 1212, 1214, 5, 67},
  {cont__compiler__c_body__to_c_30, &frame__compiler__c_body__to_c_11, 1217, 1217, 20, 34},
  {cont__compiler__c_body__to_c_31, &frame__compiler__c_body__to_c_11, 1217, 1217, 20, 44},
  {cont__compiler__c_body__to_c_32, &frame__compiler__c_body__to_c_11, 1217, 1217, 9, 45},
  {cont__compiler__c_body__to_c_33, &frame__compiler__c_body__to_c_11, 1215, 1217, 11, 51},
  {cont__compiler__c_body__to_c_35, &frame__compiler__c_body__to_c_11, 1215, 1217, 5, 51},
  {cont__compiler__c_body__to_c_36, &frame__compiler__c_body__to_c_11, 1218, 1221, 22, 13},
  {cont__compiler__c_body__to_c_37, &frame__compiler__c_body__to_c_11, 1218, 1221, 5, 13},
  {entry__compiler__c_body___to_c, NULL, 1196, 1196, 3, 44},
  {cont__compiler__c_body___to_c_3, &frame__compiler__c_body___to_c, 1197, 1197, 3, 12},
  {cont__compiler__c_body___to_c_4, &frame__compiler__c_body___to_c, 1198, 1198, 3, 39},
  {cont__compiler__c_body___to_c_5, &frame__compiler__c_body___to_c, 1200, 1200, 6, 26},
  {cont__compiler__c_body___to_c_6, &frame__compiler__c_body___to_c, 1200, 1200, 6, 37},
  {cont__compiler__c_body___to_c_7, &frame__compiler__c_body___to_c, 1200, 1201, 3, 52},
  {cont__compiler__c_body___to_c_10, &frame__compiler__c_body___to_c, 1202, 1221, 3, 14},
  {cont__compiler__c_body___to_c_38, &frame__compiler__c_body___to_c, 1222, 1222, 6, 25},
  {cont__compiler__c_body___to_c_39, &frame__compiler__c_body___to_c, 1222, 1222, 3, 25},
  {entry__extract_destination, NULL, 1227, 1227, 3, 40},
  {cont__extract_destination_2, &frame__extract_destination, 1228, 1228, 6, 29},
  {cont__extract_destination_3, &frame__extract_destination, 1228, 1228, 31, 49},
  {cont__extract_destination_4, &frame__extract_destination, 1228, 1228, 51, 77},
  {cont__extract_destination_5, &frame__extract_destination, 1228, 1228, 3, 77},
  {entry__compiler__is_single_assign_3, NULL, 1235, 1235, 39, 57},
  {cont__compiler__is_single_assign_4, &frame__compiler__is_single_assign_3, 1235, 1235, 35, 58},
  {cont__compiler__is_single_assign_5, &frame__compiler__is_single_assign_3, 1235, 1235, 35, 58},
  {entry__compiler__is_single_assign_7, NULL, 1235, 1235, 61, 72},
  {entry__compiler__is_single_assign_15, NULL, 1244, 1244, 27, 44},
  {cont__compiler__is_single_assign_16, &frame__compiler__is_single_assign_15, 1244, 1244, 16, 45},
  {cont__compiler__is_single_assign_17, &frame__compiler__is_single_assign_15, 1244, 1244, 13, 45},
  {entry__compiler__is_single_assign_18, NULL, 1245, 1245, 13, 24},
  {entry__compiler__is_single_assign_11, NULL, 1240, 1240, 36, 48},
  {cont__compiler__is_single_assign_12, &frame__compiler__is_single_assign_11, 1240, 1240, 9, 49},
  {cont__compiler__is_single_assign_13, &frame__compiler__is_single_assign_11, 1243, 1243, 13, 33},
  {cont__compiler__is_single_assign_14, &frame__compiler__is_single_assign_11, 1244, 1244, 13, 45},
  {cont__compiler__is_single_assign_19, &frame__compiler__is_single_assign_11, 1241, 1245, 9, 25},
  {entry__compiler__is_single_assign_20, NULL, 1246, 1246, 23, 35},
  {cont__compiler__is_single_assign_21, &frame__compiler__is_single_assign_20, 1246, 1246, 10, 36},
  {cont__compiler__is_single_assign_22, &frame__compiler__is_single_assign_20, 1246, 1246, 7, 36},
  {entry__compiler__is_single_assign_25, NULL, 1248, 1248, 25, 58},
  {cont__compiler__is_single_assign_26, &frame__compiler__is_single_assign_25, 1248, 1248, 25, 58},
  {entry__compiler__is_single_assign, NULL, 1235, 1235, 10, 30},
  {cont__compiler__is_single_assign_2, &frame__compiler__is_single_assign, 1235, 1235, 10, 58},
  {cont__compiler__is_single_assign_6, &frame__compiler__is_single_assign, 1235, 1235, 3, 72},
  {cont__compiler__is_single_assign_8, &frame__compiler__is_single_assign, 1239, 1239, 7, 24},
  {cont__compiler__is_single_assign_9, &frame__compiler__is_single_assign, 1239, 1239, 7, 35},
  {cont__compiler__is_single_assign_10, &frame__compiler__is_single_assign, 1237, 1246, 3, 37},
  {cont__compiler__is_single_assign_23, &frame__compiler__is_single_assign, 1248, 1248, 6, 20},
  {cont__compiler__is_single_assign_24, &frame__compiler__is_single_assign, 1248, 1248, 6, 58},
  {cont__compiler__is_single_assign_27, &frame__compiler__is_single_assign, 1248, 1248, 3, 58},
  {entry__compiler__might_be_constant_3, NULL, 1255, 1255, 39, 57},
  {cont__compiler__might_be_constant_4, &frame__compiler__might_be_constant_3, 1255, 1255, 35, 58},
  {cont__compiler__might_be_constant_5, &frame__compiler__might_be_constant_3, 1255, 1255, 35, 58},
  {entry__compiler__might_be_constant_7, NULL, 1255, 1255, 61, 72},
  {entry__compiler__might_be_constant_15, NULL, 1264, 1264, 27, 44},
  {cont__compiler__might_be_constant_16, &frame__compiler__might_be_constant_15, 1264, 1264, 16, 45},
  {cont__compiler__might_be_constant_17, &frame__compiler__might_be_constant_15, 1264, 1264, 13, 45},
  {entry__compiler__might_be_constant_18, NULL, 1265, 1265, 13, 24},
  {entry__compiler__might_be_constant_11, NULL, 1260, 1260, 36, 48},
  {cont__compiler__might_be_constant_12, &frame__compiler__might_be_constant_11, 1260, 1260, 9, 49},
  {cont__compiler__might_be_constant_13, &frame__compiler__might_be_constant_11, 1263, 1263, 13, 33},
  {cont__compiler__might_be_constant_14, &frame__compiler__might_be_constant_11, 1264, 1264, 13, 45},
  {cont__compiler__might_be_constant_19, &frame__compiler__might_be_constant_11, 1261, 1265, 9, 25},
  {entry__compiler__might_be_constant_20, NULL, 1266, 1266, 23, 35},
  {cont__compiler__might_be_constant_21, &frame__compiler__might_be_constant_20, 1266, 1266, 10, 36},
  {cont__compiler__might_be_constant_22, &frame__compiler__might_be_constant_20, 1266, 1266, 7, 36},
  {entry__compiler__might_be_constant, NULL, 1255, 1255, 10, 30},
  {cont__compiler__might_be_constant_2, &frame__compiler__might_be_constant, 1255, 1255, 10, 58},
  {cont__compiler__might_be_constant_6, &frame__compiler__might_be_constant, 1255, 1255, 3, 72},
  {cont__compiler__might_be_constant_8, &frame__compiler__might_be_constant, 1259, 1259, 7, 24},
  {cont__compiler__might_be_constant_9, &frame__compiler__might_be_constant, 1259, 1259, 7, 35},
  {cont__compiler__might_be_constant_10, &frame__compiler__might_be_constant, 1257, 1266, 3, 37},
  {cont__compiler__might_be_constant_23, &frame__compiler__might_be_constant, 1268, 1268, 6, 22},
  {cont__compiler__might_be_constant_24, &frame__compiler__might_be_constant, 1268, 1268, 3, 22},
  {entry__assign_6, NULL, 1273, 1273, 24, 66},
  {cont__assign_9, &frame__assign_6, 1273, 1273, 7, 66},
  {entry__assign_2, NULL, 1272, 1272, 25, 44},
  {cont__assign_4, &frame__assign_2, 1272, 1272, 8, 44},
  {cont__assign_5, &frame__assign_2, 1272, 1273, 5, 66},
  {entry__assign_12, NULL, 1277, 1277, 24, 62},
  {cont__assign_14, &frame__assign_12, 1277, 1277, 7, 62},
  {entry__assign_10, NULL, 1274, 1274, 8, 34},
  {cont__assign_11, &frame__assign_10, 1274, 1277, 5, 62},
  {entry__assign_15, NULL, 1279, 1279, 24, 62},
  {cont__assign_16, &frame__assign_15, 1279, 1279, 7, 62},
  {entry__assign, NULL, 1271, 1279, 3, 63},
  {entry__compiler__define_variable_4, NULL, 1286, 1286, 13, 35},
  {cont__compiler__define_variable_5, &frame__compiler__define_variable_4, 1286, 1286, 55, 77},
  {cont__compiler__define_variable_6, &frame__compiler__define_variable_4, 1284, 1287, 36, 13},
  {cont__compiler__define_variable_8, &frame__compiler__define_variable_4, 1284, 1287, 5, 13},
  {entry__compiler__define_variable_12, NULL, 1289, 1289, 27, 47},
  {cont__compiler__define_variable_13, &frame__compiler__define_variable_12, 1289, 1289, 27, 47},
  {entry__compiler__define_variable_16, NULL, 1294, 1294, 17, 39},
  {cont__compiler__define_variable_17, &frame__compiler__define_variable_16, 1292, 1294, 26, 59},
  {cont__compiler__define_variable_19, &frame__compiler__define_variable_16, 1292, 1294, 9, 59},
  {cont__compiler__define_variable_20, &frame__compiler__define_variable_16, 1296, 1296, 34, 56},
  {cont__compiler__define_variable_21, &frame__compiler__define_variable_16, 1296, 1296, 62, 72},
  {cont__compiler__define_variable_22, &frame__compiler__define_variable_16, 1296, 1296, 11, 80},
  {cont__compiler__define_variable_24, &frame__compiler__define_variable_16, 1295, 1296, 9, 80},
  {entry__compiler__define_variable_25, NULL, 1298, 1298, 16, 38},
  {cont__compiler__define_variable_26, &frame__compiler__define_variable_25, 1298, 1298, 40, 50},
  {cont__compiler__define_variable_27, &frame__compiler__define_variable_25, 1298, 1298, 9, 50},
  {entry__compiler__define_variable_15, NULL, 1290, 1298, 5, 51},
  {entry__compiler__define_variable_31, NULL, 1322, 1322, 13, 51},
  {cont__compiler__define_variable_33, &frame__compiler__define_variable_31, 1321, 1322, 11, 51},
  {cont__compiler__define_variable_34, &frame__compiler__define_variable_31, 1323, 1326, 33, 13},
  {cont__compiler__define_variable_37, &frame__compiler__define_variable_31, 1323, 1326, 11, 13},
  {cont__compiler__define_variable_38, &frame__compiler__define_variable_31, 1330, 1330, 38, 60},
  {cont__compiler__define_variable_39, &frame__compiler__define_variable_31, 1327, 1330, 28, 63},
  {cont__compiler__define_variable_43, &frame__compiler__define_variable_31, 1327, 1330, 11, 63},
  {entry__compiler__define_variable_44, NULL, 1333, 1333, 13, 51},
  {cont__compiler__define_variable_45, &frame__compiler__define_variable_44, 1332, 1333, 11, 51},
  {cont__compiler__define_variable_46, &frame__compiler__define_variable_44, 1334, 1340, 33, 13},
  {cont__compiler__define_variable_50, &frame__compiler__define_variable_44, 1334, 1340, 11, 13},
  {cont__compiler__define_variable_51, &frame__compiler__define_variable_44, 1341, 1344, 28, 56},
  {cont__compiler__define_variable_54, &frame__compiler__define_variable_44, 1341, 1344, 11, 56},
  {entry__compiler__define_variable_55, NULL, 1346, 1353, 33, 13},
  {cont__compiler__define_variable_62, &frame__compiler__define_variable_55, 1346, 1353, 11, 13},
  {cont__compiler__define_variable_63, &frame__compiler__define_variable_55, 1354, 1358, 28, 40},
  {cont__compiler__define_variable_67, &frame__compiler__define_variable_55, 1354, 1358, 11, 40},
  {entry__compiler__define_variable_68, NULL, 1360, 1370, 33, 13},
  {cont__compiler__define_variable_74, &frame__compiler__define_variable_68, 1360, 1370, 11, 13},
  {cont__compiler__define_variable_75, &frame__compiler__define_variable_68, 1371, 1376, 28, 51},
  {cont__compiler__define_variable_79, &frame__compiler__define_variable_68, 1371, 1376, 11, 51},
  {entry__compiler__define_variable_30, NULL, 1319, 1376, 7, 53},
  {entry__compiler__define_variable_90, NULL, 1386, 1386, 21, 35},
  {cont__compiler__define_variable_91, &frame__compiler__define_variable_90, 1384, 1386, 30, 55},
  {cont__compiler__define_variable_92, &frame__compiler__define_variable_90, 1384, 1386, 13, 55},
  {entry__compiler__define_variable_81, NULL, 1380, 1380, 45, 80},
  {cont__compiler__define_variable_84, &frame__compiler__define_variable_81, 1380, 1380, 11, 80},
  {cont__compiler__define_variable_85, &frame__compiler__define_variable_81, 1382, 1382, 31, 52},
  {cont__compiler__define_variable_86, &frame__compiler__define_variable_81, 1382, 1382, 13, 61},
  {cont__compiler__define_variable_87, &frame__compiler__define_variable_81, 1381, 1382, 11, 61},
  {cont__compiler__define_variable_88, &frame__compiler__define_variable_81, 1383, 1383, 18, 34},
  {cont__compiler__define_variable_89, &frame__compiler__define_variable_81, 1383, 1386, 11, 56},
  {entry__compiler__define_variable_93, NULL, 1388, 1388, 45, 80},
  {cont__compiler__define_variable_94, &frame__compiler__define_variable_93, 1388, 1388, 11, 80},
  {cont__compiler__define_variable_95, &frame__compiler__define_variable_93, 1390, 1390, 31, 52},
  {cont__compiler__define_variable_96, &frame__compiler__define_variable_93, 1390, 1390, 13, 61},
  {cont__compiler__define_variable_97, &frame__compiler__define_variable_93, 1389, 1390, 11, 61},
  {entry__compiler__define_variable_105, NULL, 1402, 1404, 30, 51},
  {cont__compiler__define_variable_108, &frame__compiler__define_variable_105, 1402, 1404, 13, 51},
  {entry__compiler__define_variable_98, NULL, 1392, 1399, 33, 13},
  {cont__compiler__define_variable_99, &frame__compiler__define_variable_98, 1392, 1399, 11, 13},
  {cont__compiler__define_variable_100, &frame__compiler__define_variable_98, 1400, 1400, 28, 72},
  {cont__compiler__define_variable_102, &frame__compiler__define_variable_98, 1400, 1400, 11, 72},
  {cont__compiler__define_variable_103, &frame__compiler__define_variable_98, 1401, 1401, 18, 34},
  {cont__compiler__define_variable_104, &frame__compiler__define_variable_98, 1401, 1404, 11, 52},
  {entry__compiler__define_variable_109, NULL, 1406, 1416, 33, 13},
  {cont__compiler__define_variable_110, &frame__compiler__define_variable_109, 1406, 1416, 11, 13},
  {cont__compiler__define_variable_111, &frame__compiler__define_variable_109, 1417, 1420, 28, 43},
  {cont__compiler__define_variable_112, &frame__compiler__define_variable_109, 1417, 1420, 11, 43},
  {entry__compiler__define_variable_80, NULL, 1378, 1420, 7, 45},
  {entry__compiler__define_variable_115, NULL, 1421, 1421, 27, 48},
  {cont__compiler__define_variable_116, &frame__compiler__define_variable_115, 1421, 1421, 27, 48},
  {entry__compiler__define_variable_120, NULL, 1424, 1424, 55, 65},
  {cont__compiler__define_variable_121, &frame__compiler__define_variable_120, 1424, 1424, 26, 73},
  {cont__compiler__define_variable_122, &frame__compiler__define_variable_120, 1424, 1424, 9, 73},
  {entry__compiler__define_variable_129, NULL, 1435, 1435, 19, 29},
  {cont__compiler__define_variable_130, &frame__compiler__define_variable_129, 1432, 1435, 32, 37},
  {cont__compiler__define_variable_133, &frame__compiler__define_variable_129, 1432, 1435, 15, 37},
  {entry__compiler__define_variable_134, NULL, 1439, 1439, 65, 75},
  {cont__compiler__define_variable_135, &frame__compiler__define_variable_134, 1437, 1440, 32, 23},
  {cont__compiler__define_variable_137, &frame__compiler__define_variable_134, 1437, 1440, 15, 23},
  {entry__compiler__define_variable_125, NULL, 1427, 1429, 28, 57},
  {cont__compiler__define_variable_126, &frame__compiler__define_variable_125, 1427, 1429, 11, 57},
  {cont__compiler__define_variable_127, &frame__compiler__define_variable_125, 1431, 1431, 13, 36},
  {cont__compiler__define_variable_128, &frame__compiler__define_variable_125, 1430, 1440, 11, 25},
  {entry__compiler__define_variable_123, NULL, 1426, 1426, 12, 34},
  {cont__compiler__define_variable_124, &frame__compiler__define_variable_123, 1426, 1440, 9, 26},
  {entry__compiler__define_variable_118, NULL, 1423, 1423, 7, 26},
  {cont__compiler__define_variable_119, &frame__compiler__define_variable_118, 1422, 1440, 5, 28},
  {entry__compiler__define_variable, NULL, 1282, 1282, 3, 63},
  {cont__compiler__define_variable_2, &frame__compiler__define_variable, 1283, 1283, 6, 38},
  {cont__compiler__define_variable_3, &frame__compiler__define_variable, 1283, 1287, 3, 14},
  {cont__compiler__define_variable_9, &frame__compiler__define_variable, 1288, 1288, 3, 36},
  {cont__compiler__define_variable_10, &frame__compiler__define_variable, 1289, 1289, 6, 22},
  {cont__compiler__define_variable_11, &frame__compiler__define_variable, 1289, 1289, 6, 47},
  {cont__compiler__define_variable_14, &frame__compiler__define_variable, 1289, 1316, 3, 93},
  {cont__compiler__define_variable_28, &frame__compiler__define_variable, 1318, 1318, 5, 24},
  {cont__compiler__define_variable_29, &frame__compiler__define_variable, 1317, 1420, 3, 47},
  {cont__compiler__define_variable_113, &frame__compiler__define_variable, 1421, 1421, 6, 22},
  {cont__compiler__define_variable_114, &frame__compiler__define_variable, 1421, 1421, 6, 48},
  {cont__compiler__define_variable_117, &frame__compiler__define_variable, 1421, 1440, 3, 29},
  {entry__namespace_argument_3, NULL, 1445, 1445, 8, 33},
  {cont__namespace_argument_4, &frame__namespace_argument_3, 1445, 1445, 5, 33},
  {entry__namespace_argument_5, NULL, 1446, 1446, 5, 13},
  {entry__namespace_argument, NULL, 1444, 1444, 5, 24},
  {cont__namespace_argument_2, &frame__namespace_argument, 1443, 1446, 3, 13},
  {entry__compiler__define_attribute_6, NULL, 1454, 1454, 7, 22},
  {cont__compiler__define_attribute_7, &frame__compiler__define_attribute_6, 1454, 1454, 22, 22},
  {entry__compiler__define_attribute_8, NULL, 1456, 1456, 7, 59},
  {cont__compiler__define_attribute_10, &frame__compiler__define_attribute_8, 1457, 1457, 29, 54},
  {cont__compiler__define_attribute_11, &frame__compiler__define_attribute_8, 1457, 1457, 7, 54},
  {entry__compiler__define_attribute_14, NULL, 1463, 1463, 29, 46},
  {cont__compiler__define_attribute_15, &frame__compiler__define_attribute_14, 1463, 1463, 29, 57},
  {cont__compiler__define_attribute_16, &frame__compiler__define_attribute_14, 1463, 1463, 29, 57},
  {entry__compiler__define_attribute_18, NULL, 1466, 1466, 32, 60},
  {cont__compiler__define_attribute_19, &frame__compiler__define_attribute_18, 1464, 1467, 24, 45},
  {cont__compiler__define_attribute_23, &frame__compiler__define_attribute_18, 1464, 1467, 7, 45},
  {entry__compiler__define_attribute_24, NULL, 1472, 1472, 30, 44},
  {cont__compiler__define_attribute_25, &frame__compiler__define_attribute_24, 1469, 1473, 24, 38},
  {cont__compiler__define_attribute_26, &frame__compiler__define_attribute_24, 1469, 1473, 7, 38},
  {entry__compiler__define_attribute, NULL, 1449, 1449, 3, 63},
  {cont__compiler__define_attribute_2, &frame__compiler__define_attribute, 1450, 1450, 35, 58},
  {cont__compiler__define_attribute_3, &frame__compiler__define_attribute, 1450, 1450, 3, 59},
  {cont__compiler__define_attribute_4, &frame__compiler__define_attribute, 1453, 1453, 5, 21},
  {cont__compiler__define_attribute_5, &frame__compiler__define_attribute, 1452, 1461, 3, 39},
  {cont__compiler__define_attribute_12, &frame__compiler__define_attribute, 1463, 1463, 5, 24},
  {cont__compiler__define_attribute_13, &frame__compiler__define_attribute, 1463, 1463, 5, 57},
  {cont__compiler__define_attribute_17, &frame__compiler__define_attribute, 1462, 1473, 3, 40},
  {entry__compiler__define_method_6, NULL, 1481, 1481, 7, 22},
  {cont__compiler__define_method_7, &frame__compiler__define_method_6, 1481, 1481, 22, 22},
  {entry__compiler__define_method_8, NULL, 1483, 1483, 7, 59},
  {cont__compiler__define_method_9, &frame__compiler__define_method_8, 1484, 1484, 29, 54},
  {cont__compiler__define_method_10, &frame__compiler__define_method_8, 1484, 1484, 7, 54},
  {entry__compiler__define_method_13, NULL, 1490, 1490, 29, 46},
  {cont__compiler__define_method_14, &frame__compiler__define_method_13, 1490, 1490, 29, 57},
  {cont__compiler__define_method_15, &frame__compiler__define_method_13, 1490, 1490, 29, 57},
  {entry__compiler__define_method_17, NULL, 1493, 1493, 29, 57},
  {cont__compiler__define_method_18, &frame__compiler__define_method_17, 1491, 1494, 24, 45},
  {cont__compiler__define_method_20, &frame__compiler__define_method_17, 1491, 1494, 7, 45},
  {entry__compiler__define_method_21, NULL, 1499, 1499, 30, 44},
  {cont__compiler__define_method_22, &frame__compiler__define_method_21, 1496, 1500, 24, 16},
  {cont__compiler__define_method_23, &frame__compiler__define_method_21, 1496, 1500, 7, 16},
  {entry__compiler__define_method, NULL, 1476, 1476, 3, 63},
  {cont__compiler__define_method_2, &frame__compiler__define_method, 1477, 1477, 35, 58},
  {cont__compiler__define_method_3, &frame__compiler__define_method, 1477, 1477, 3, 59},
  {cont__compiler__define_method_4, &frame__compiler__define_method, 1480, 1480, 5, 21},
  {cont__compiler__define_method_5, &frame__compiler__define_method, 1479, 1488, 3, 39},
  {cont__compiler__define_method_11, &frame__compiler__define_method, 1490, 1490, 5, 24},
  {cont__compiler__define_method_12, &frame__compiler__define_method, 1490, 1490, 5, 57},
  {cont__compiler__define_method_16, &frame__compiler__define_method, 1489, 1500, 3, 18},
  {entry__compiler__define_type_function_5, NULL, 1506, 1506, 29, 46},
  {cont__compiler__define_type_function_6, &frame__compiler__define_type_function_5, 1506, 1506, 29, 57},
  {cont__compiler__define_type_function_7, &frame__compiler__define_type_function_5, 1506, 1506, 29, 57},
  {entry__compiler__define_type_function_9, NULL, 1509, 1509, 36, 64},
  {cont__compiler__define_type_function_10, &frame__compiler__define_type_function_9, 1507, 1510, 24, 45},
  {cont__compiler__define_type_function_12, &frame__compiler__define_type_function_9, 1507, 1510, 7, 45},
  {entry__compiler__define_type_function_13, NULL, 1515, 1515, 30, 44},
  {cont__compiler__define_type_function_14, &frame__compiler__define_type_function_13, 1512, 1515, 24, 61},
  {cont__compiler__define_type_function_15, &frame__compiler__define_type_function_13, 1512, 1515, 7, 61},
  {entry__compiler__define_type_function, NULL, 1503, 1503, 3, 64},
  {cont__compiler__define_type_function_2, &frame__compiler__define_type_function, 1504, 1504, 3, 31},
  {cont__compiler__define_type_function_3, &frame__compiler__define_type_function, 1506, 1506, 5, 24},
  {cont__compiler__define_type_function_4, &frame__compiler__define_type_function, 1506, 1506, 5, 57},
  {cont__compiler__define_type_function_8, &frame__compiler__define_type_function, 1505, 1515, 3, 63},
  {entry__compiler__define_polymorphic_function_3, NULL, 1521, 1521, 7, 23},
  {entry__compiler__define_polymorphic_function_5, NULL, 1522, 1522, 7, 11},
  {entry__compiler__define_polymorphic_function_2, NULL, 1519, 1522, 5, 11},
  {entry__compiler__define_polymorphic_function_8, NULL, 1528, 1528, 9, 47},
  {cont__compiler__define_polymorphic_function_9, &frame__compiler__define_polymorphic_function_8, 1527, 1528, 7, 47},
  {entry__compiler__define_polymorphic_function_10, NULL, 1530, 1530, 41, 76},
  {cont__compiler__define_polymorphic_function_11, &frame__compiler__define_polymorphic_function_10, 1530, 1530, 7, 76},
  {cont__compiler__define_polymorphic_function_12, &frame__compiler__define_polymorphic_function_10, 1532, 1532, 27, 48},
  {cont__compiler__define_polymorphic_function_13, &frame__compiler__define_polymorphic_function_10, 1532, 1532, 9, 57},
  {cont__compiler__define_polymorphic_function_14, &frame__compiler__define_polymorphic_function_10, 1531, 1532, 7, 57},
  {entry__compiler__define_polymorphic_function_18, NULL, 1536, 1536, 28, 37},
  {cont__compiler__define_polymorphic_function_19, &frame__compiler__define_polymorphic_function_18, 1536, 1536, 25, 37},
  {entry__compiler__define_polymorphic_function_20, NULL, 1536, 1536, 40, 44},
  {entry__compiler__define_polymorphic_function_45, NULL, 1559, 1559, 48, 70},
  {cont__compiler__define_polymorphic_function_46, &frame__compiler__define_polymorphic_function_45, 1556, 1559, 28, 73},
  {cont__compiler__define_polymorphic_function_48, &frame__compiler__define_polymorphic_function_45, 1556, 1559, 11, 73},
  {entry__compiler__define_polymorphic_function_49, NULL, 1563, 1563, 46, 58},
  {cont__compiler__define_polymorphic_function_50, &frame__compiler__define_polymorphic_function_49, 1565, 1565, 16, 38},
  {cont__compiler__define_polymorphic_function_51, &frame__compiler__define_polymorphic_function_49, 1561, 1565, 28, 41},
  {cont__compiler__define_polymorphic_function_55, &frame__compiler__define_polymorphic_function_49, 1561, 1565, 11, 41},
  {entry__compiler__define_polymorphic_function_41, NULL, 1550, 1553, 29, 9},
  {cont__compiler__define_polymorphic_function_42, &frame__compiler__define_polymorphic_function_41, 1550, 1553, 7, 9},
  {cont__compiler__define_polymorphic_function_43, &frame__compiler__define_polymorphic_function_41, 1555, 1555, 9, 21},
  {cont__compiler__define_polymorphic_function_44, &frame__compiler__define_polymorphic_function_41, 1554, 1565, 7, 43},
  {entry__compiler__define_polymorphic_function_56, NULL, 1569, 1569, 44, 56},
  {cont__compiler__define_polymorphic_function_57, &frame__compiler__define_polymorphic_function_56, 1567, 1570, 24, 40},
  {cont__compiler__define_polymorphic_function_62, &frame__compiler__define_polymorphic_function_56, 1567, 1570, 7, 40},
  {entry__compiler__define_polymorphic_function, NULL, 1524, 1524, 3, 63},
  {cont__compiler__define_polymorphic_function_6, &frame__compiler__define_polymorphic_function, 1526, 1526, 5, 24},
  {cont__compiler__define_polymorphic_function_7, &frame__compiler__define_polymorphic_function, 1525, 1532, 3, 59},
  {cont__compiler__define_polymorphic_function_15, &frame__compiler__define_polymorphic_function, 1533, 1533, 3, 52},
  {cont__compiler__define_polymorphic_function_16, &frame__compiler__define_polymorphic_function, 1536, 1536, 10, 22},
  {cont__compiler__define_polymorphic_function_17, &frame__compiler__define_polymorphic_function, 1536, 1536, 7, 45},
  {cont__compiler__define_polymorphic_function_21, &frame__compiler__define_polymorphic_function, 1534, 1536, 25, 52},
  {cont__compiler__define_polymorphic_function_23, &frame__compiler__define_polymorphic_function, 1534, 1536, 3, 52},
  {cont__compiler__define_polymorphic_function_24, &frame__compiler__define_polymorphic_function, 1539, 1539, 11, 33},
  {cont__compiler__define_polymorphic_function_25, &frame__compiler__define_polymorphic_function, 1539, 1539, 53, 75},
  {cont__compiler__define_polymorphic_function_26, &frame__compiler__define_polymorphic_function, 1537, 1540, 34, 11},
  {cont__compiler__define_polymorphic_function_27, &frame__compiler__define_polymorphic_function, 1537, 1540, 3, 11},
  {cont__compiler__define_polymorphic_function_28, &frame__compiler__define_polymorphic_function, 1541, 1541, 34, 58},
  {cont__compiler__define_polymorphic_function_29, &frame__compiler__define_polymorphic_function, 1541, 1541, 3, 58},
  {cont__compiler__define_polymorphic_function_30, &frame__compiler__define_polymorphic_function, 1542, 1542, 31, 77},
  {cont__compiler__define_polymorphic_function_32, &frame__compiler__define_polymorphic_function, 1542, 1542, 3, 77},
  {cont__compiler__define_polymorphic_function_33, &frame__compiler__define_polymorphic_function, 1543, 1543, 3, 43},
  {cont__compiler__define_polymorphic_function_34, &frame__compiler__define_polymorphic_function, 1546, 1546, 25, 47},
  {cont__compiler__define_polymorphic_function_35, &frame__compiler__define_polymorphic_function, 1544, 1547, 20, 48},
  {cont__compiler__define_polymorphic_function_38, &frame__compiler__define_polymorphic_function, 1544, 1547, 3, 48},
  {cont__compiler__define_polymorphic_function_39, &frame__compiler__define_polymorphic_function, 1549, 1549, 5, 24},
  {cont__compiler__define_polymorphic_function_40, &frame__compiler__define_polymorphic_function, 1548, 1570, 3, 42},
  {entry__compiler__define_c_code_7, NULL, 1623, 1623, 11, 38},
  {cont__compiler__define_c_code_8, &frame__compiler__define_c_code_7, 1623, 1623, 38, 38},
  {entry__compiler__define_c_code_9, NULL, 1625, 1625, 11, 32},
  {cont__compiler__define_c_code_10, &frame__compiler__define_c_code_9, 1625, 1625, 32, 32},
  {entry__compiler__define_c_code_13, NULL, 1629, 1629, 13, 51},
  {cont__compiler__define_c_code_14, &frame__compiler__define_c_code_13, 1628, 1629, 11, 51},
  {entry__compiler__define_c_code_15, NULL, 1631, 1631, 45, 80},
  {cont__compiler__define_c_code_16, &frame__compiler__define_c_code_15, 1631, 1631, 11, 80},
  {cont__compiler__define_c_code_17, &frame__compiler__define_c_code_15, 1633, 1633, 31, 52},
  {cont__compiler__define_c_code_18, &frame__compiler__define_c_code_15, 1633, 1633, 13, 61},
  {cont__compiler__define_c_code_19, &frame__compiler__define_c_code_15, 1632, 1633, 11, 61},
  {entry__compiler__define_c_code_25, NULL, 1642, 1642, 19, 41},
  {cont__compiler__define_c_code_26, &frame__compiler__define_c_code_25, 1640, 1643, 28, 76},
  {cont__compiler__define_c_code_28, &frame__compiler__define_c_code_25, 1640, 1643, 11, 76},
  {entry__compiler__define_c_code_29, NULL, 1647, 1647, 19, 41},
  {cont__compiler__define_c_code_30, &frame__compiler__define_c_code_29, 1645, 1648, 28, 19},
  {cont__compiler__define_c_code_32, &frame__compiler__define_c_code_29, 1645, 1648, 11, 19},
  {entry__compiler__define_c_code_35, NULL, 1652, 1652, 24, 46},
  {cont__compiler__define_c_code_36, &frame__compiler__define_c_code_35, 1650, 1653, 31, 11},
  {cont__compiler__define_c_code_38, &frame__compiler__define_c_code_35, 1650, 1653, 9, 11},
  {entry__compiler__define_c_code_5, NULL, 1622, 1622, 9, 26},
  {cont__compiler__define_c_code_6, &frame__compiler__define_c_code_5, 1621, 1625, 7, 33},
  {cont__compiler__define_c_code_11, &frame__compiler__define_c_code_5, 1627, 1627, 9, 36},
  {cont__compiler__define_c_code_12, &frame__compiler__define_c_code_5, 1626, 1633, 7, 63},
  {cont__compiler__define_c_code_20, &frame__compiler__define_c_code_5, 1636, 1636, 15, 37},
  {cont__compiler__define_c_code_21, &frame__compiler__define_c_code_5, 1636, 1636, 57, 79},
  {cont__compiler__define_c_code_22, &frame__compiler__define_c_code_5, 1634, 1637, 38, 15},
  {cont__compiler__define_c_code_23, &frame__compiler__define_c_code_5, 1634, 1637, 7, 15},
  {cont__compiler__define_c_code_24, &frame__compiler__define_c_code_5, 1638, 1648, 7, 21},
  {cont__compiler__define_c_code_33, &frame__compiler__define_c_code_5, 1649, 1649, 10, 29},
  {cont__compiler__define_c_code_34, &frame__compiler__define_c_code_5, 1649, 1653, 7, 12},
  {entry__compiler__define_c_code_43, NULL, 1582, 1582, 9, 13},
  {entry__compiler__define_c_code_45, NULL, 1584, 1584, 9, 13},
  {entry__compiler__define_c_code_47, NULL, 1586, 1586, 9, 20},
  {entry__compiler__define_c_code_49, NULL, 1587, 1587, 9, 20},
  {entry__compiler__define_c_code_54, NULL, 1594, 1594, 12, 35},
  {cont__compiler__define_c_code_55, &frame__compiler__define_c_code_54, 1594, 1594, 9, 35},
  {entry__compiler__define_c_code_56, NULL, 1595, 1595, 9, 20},
  {entry__compiler__define_c_code_59, NULL, 1600, 1600, 12, 30},
  {cont__compiler__define_c_code_60, &frame__compiler__define_c_code_59, 1600, 1600, 9, 30},
  {entry__compiler__define_c_code_61, NULL, 1601, 1601, 9, 20},
  {entry__compiler__define_c_code_64, NULL, 1606, 1606, 28, 46},
  {cont__compiler__define_c_code_65, &frame__compiler__define_c_code_64, 1606, 1606, 12, 47},
  {cont__compiler__define_c_code_66, &frame__compiler__define_c_code_64, 1606, 1606, 9, 47},
  {entry__compiler__define_c_code_67, NULL, 1607, 1607, 9, 20},
  {entry__compiler__define_c_code_71, NULL, 1612, 1612, 28, 46},
  {cont__compiler__define_c_code_72, &frame__compiler__define_c_code_71, 1612, 1612, 12, 47},
  {cont__compiler__define_c_code_73, &frame__compiler__define_c_code_71, 1612, 1612, 9, 47},
  {entry__compiler__define_c_code_74, NULL, 1613, 1613, 9, 20},
  {entry__compiler__define_c_code_76, NULL, 1661, 1661, 41, 58},
  {cont__compiler__define_c_code_77, &frame__compiler__define_c_code_76, 1658, 1662, 31, 12},
  {cont__compiler__define_c_code_82, &frame__compiler__define_c_code_76, 1658, 1662, 9, 12},
  {entry__compiler__define_c_code_116, NULL, 1688, 1688, 72, 72},
  {cont__compiler__define_c_code_117, &frame__compiler__define_c_code_116, 1688, 1688, 52, 73},
  {cont__compiler__define_c_code_118, &frame__compiler__define_c_code_116, 1688, 1688, 49, 73},
  {entry__compiler__define_c_code_113, NULL, 1688, 1688, 20, 47},
  {cont__compiler__define_c_code_115, &frame__compiler__define_c_code_113, 1688, 1688, 17, 73},
  {entry__compiler__define_c_code_121, NULL, 1689, 1689, 71, 71},
  {cont__compiler__define_c_code_122, &frame__compiler__define_c_code_121, 1689, 1689, 51, 72},
  {cont__compiler__define_c_code_123, &frame__compiler__define_c_code_121, 1689, 1689, 48, 72},
  {entry__compiler__define_c_code_119, NULL, 1689, 1689, 20, 46},
  {cont__compiler__define_c_code_120, &frame__compiler__define_c_code_119, 1689, 1689, 17, 72},
  {entry__compiler__define_c_code_125, NULL, 1690, 1690, 25, 36},
  {entry__compiler__define_c_code_124, NULL, 1690, 1690, 17, 36},
  {entry__compiler__define_c_code_128, NULL, 1693, 1693, 39, 64},
  {cont__compiler__define_c_code_129, &frame__compiler__define_c_code_128, 1693, 1693, 39, 64},
  {entry__compiler__define_c_code_131, NULL, 1697, 1697, 29, 51},
  {cont__compiler__define_c_code_132, &frame__compiler__define_c_code_131, 1694, 1697, 23, 79},
  {cont__compiler__define_c_code_136, &frame__compiler__define_c_code_131, 1694, 1697, 17, 79},
  {entry__compiler__define_c_code_137, NULL, 1699, 1699, 23, 76},
  {cont__compiler__define_c_code_139, &frame__compiler__define_c_code_137, 1699, 1699, 17, 76},
  {entry__compiler__define_c_code_100, NULL, 1679, 1679, 13, 36},
  {cont__compiler__define_c_code_102, &frame__compiler__define_c_code_100, 1680, 1680, 13, 27},
  {cont__compiler__define_c_code_103, &frame__compiler__define_c_code_100, 1681, 1681, 51, 62},
  {cont__compiler__define_c_code_104, &frame__compiler__define_c_code_100, 1681, 1681, 65, 65},
  {cont__compiler__define_c_code_105, &frame__compiler__define_c_code_100, 1681, 1681, 30, 66},
  {cont__compiler__define_c_code_106, &frame__compiler__define_c_code_100, 1681, 1681, 13, 67},
  {cont__compiler__define_c_code_107, &frame__compiler__define_c_code_100, 1684, 1684, 40, 51},
  {cont__compiler__define_c_code_108, &frame__compiler__define_c_code_100, 1684, 1684, 54, 54},
  {cont__compiler__define_c_code_109, &frame__compiler__define_c_code_100, 1684, 1684, 20, 55},
  {cont__compiler__define_c_code_110, &frame__compiler__define_c_code_100, 1684, 1684, 20, 76},
  {cont__compiler__define_c_code_111, &frame__compiler__define_c_code_100, 1683, 1684, 13, 77},
  {cont__compiler__define_c_code_112, &frame__compiler__define_c_code_100, 1686, 1690, 13, 37},
  {cont__compiler__define_c_code_126, &frame__compiler__define_c_code_100, 1693, 1693, 15, 34},
  {cont__compiler__define_c_code_127, &frame__compiler__define_c_code_100, 1693, 1693, 15, 64},
  {cont__compiler__define_c_code_130, &frame__compiler__define_c_code_100, 1692, 1699, 13, 77},
  {entry__compiler__define_c_code_93, NULL, 1672, 1677, 17, 76},
  {cont__compiler__define_c_code_98, &frame__compiler__define_c_code_93, 1672, 1677, 11, 76},
  {cont__compiler__define_c_code_99, &frame__compiler__define_c_code_93, 1678, 1699, 11, 78},
  {cont__compiler__define_c_code_140, &frame__compiler__define_c_code_93, 1700, 1702, 11, 13},
  {entry__compiler__define_c_code_83, NULL, 1669, 1669, 13, 30},
  {cont__compiler__define_c_code_84, &frame__compiler__define_c_code_83, 1664, 1669, 31, 53},
  {cont__compiler__define_c_code_87, &frame__compiler__define_c_code_83, 1664, 1669, 9, 53},
  {cont__compiler__define_c_code_88, &frame__compiler__define_c_code_83, 1670, 1670, 36, 61},
  {cont__compiler__define_c_code_89, &frame__compiler__define_c_code_83, 1670, 1670, 9, 63},
  {cont__compiler__define_c_code_91, &frame__compiler__define_c_code_83, 1671, 1671, 16, 48},
  {cont__compiler__define_c_code_92, &frame__compiler__define_c_code_83, 1671, 1702, 9, 14},
  {entry__compiler__define_c_code_146, NULL, 1707, 1708, 17, 69},
  {cont__compiler__define_c_code_149, &frame__compiler__define_c_code_146, 1707, 1708, 11, 69},
  {entry__compiler__define_c_code_153, NULL, 1711, 1711, 13, 47},
  {cont__compiler__define_c_code_154, &frame__compiler__define_c_code_153, 1712, 1712, 20, 42},
  {cont__compiler__define_c_code_155, &frame__compiler__define_c_code_153, 1712, 1712, 44, 56},
  {cont__compiler__define_c_code_156, &frame__compiler__define_c_code_153, 1712, 1712, 44, 61},
  {cont__compiler__define_c_code_157, &frame__compiler__define_c_code_153, 1712, 1712, 13, 61},
  {entry__compiler__define_c_code_158, NULL, 1714, 1714, 13, 42},
  {entry__compiler__define_c_code_161, NULL, 1719, 1719, 38, 60},
  {cont__compiler__define_c_code_162, &frame__compiler__define_c_code_161, 1716, 1719, 28, 63},
  {cont__compiler__define_c_code_163, &frame__compiler__define_c_code_161, 1716, 1719, 11, 63},
  {entry__compiler__define_c_code_180, NULL, 1732, 1732, 49, 67},
  {cont__compiler__define_c_code_181, &frame__compiler__define_c_code_180, 1732, 1732, 67, 67},
  {entry__compiler__define_c_code_166, NULL, 1724, 1724, 13, 36},
  {cont__compiler__define_c_code_167, &frame__compiler__define_c_code_166, 1725, 1725, 13, 27},
  {cont__compiler__define_c_code_168, &frame__compiler__define_c_code_166, 1726, 1726, 51, 62},
  {cont__compiler__define_c_code_169, &frame__compiler__define_c_code_166, 1726, 1726, 65, 65},
  {cont__compiler__define_c_code_170, &frame__compiler__define_c_code_166, 1726, 1726, 30, 66},
  {cont__compiler__define_c_code_171, &frame__compiler__define_c_code_166, 1726, 1726, 13, 67},
  {cont__compiler__define_c_code_172, &frame__compiler__define_c_code_166, 1729, 1729, 40, 51},
  {cont__compiler__define_c_code_173, &frame__compiler__define_c_code_166, 1729, 1729, 54, 54},
  {cont__compiler__define_c_code_174, &frame__compiler__define_c_code_166, 1729, 1729, 20, 55},
  {cont__compiler__define_c_code_175, &frame__compiler__define_c_code_166, 1729, 1729, 20, 76},
  {cont__compiler__define_c_code_176, &frame__compiler__define_c_code_166, 1728, 1729, 13, 77},
  {cont__compiler__define_c_code_177, &frame__compiler__define_c_code_166, 1731, 1731, 13, 40},
  {cont__compiler__define_c_code_178, &frame__compiler__define_c_code_166, 1732, 1732, 20, 46},
  {cont__compiler__define_c_code_179, &frame__compiler__define_c_code_166, 1732, 1732, 13, 67},
  {cont__compiler__define_c_code_182, &frame__compiler__define_c_code_166, 1733, 1733, 13, 40},
  {cont__compiler__define_c_code_183, &frame__compiler__define_c_code_166, 1736, 1736, 27, 49},
  {cont__compiler__define_c_code_184, &frame__compiler__define_c_code_166, 1734, 1737, 36, 20},
  {cont__compiler__define_c_code_187, &frame__compiler__define_c_code_166, 1734, 1737, 13, 20},
  {cont__compiler__define_c_code_188, &frame__compiler__define_c_code_166, 1737, 1737, 21, 21},
  {entry__compiler__define_c_code_189, NULL, 1739, 1739, 13, 34},
  {cont__compiler__define_c_code_190, &frame__compiler__define_c_code_189, 1739, 1739, 34, 34},
  {entry__compiler__define_c_code_202, NULL, 1753, 1753, 22, 37},
  {cont__compiler__define_c_code_203, &frame__compiler__define_c_code_202, 1753, 1753, 19, 37},
  {entry__compiler__define_c_code_204, NULL, 1754, 1754, 19, 23},
  {entry__compiler__define_c_code_208, NULL, 1761, 1765, 17, 23},
  {cont__compiler__define_c_code_211, &frame__compiler__define_c_code_208, 1765, 1765, 24, 24},
  {entry__compiler__define_c_code_212, NULL, 1767, 1767, 17, 75},
  {cont__compiler__define_c_code_214, &frame__compiler__define_c_code_212, 1767, 1767, 75, 75},
  {entry__compiler__define_c_code_200, NULL, 1752, 1752, 19, 38},
  {cont__compiler__define_c_code_201, &frame__compiler__define_c_code_200, 1753, 1753, 19, 37},
  {cont__compiler__define_c_code_205, &frame__compiler__define_c_code_200, 1749, 1757, 13, 22},
  {cont__compiler__define_c_code_206, &frame__compiler__define_c_code_200, 1760, 1760, 15, 42},
  {cont__compiler__define_c_code_207, &frame__compiler__define_c_code_200, 1759, 1767, 13, 76},
  {entry__compiler__define_c_code_215, NULL, 1769, 1769, 13, 50},
  {cont__compiler__define_c_code_216, &frame__compiler__define_c_code_215, 1769, 1769, 50, 50},
  {entry__compiler__define_c_code_221, NULL, 1775, 1785, 13, 16},
  {cont__compiler__define_c_code_223, &frame__compiler__define_c_code_221, 1785, 1785, 17, 17},
  {entry__compiler__define_c_code_224, NULL, 1787, 1797, 44, 16},
  {cont__compiler__define_c_code_228, &frame__compiler__define_c_code_224, 1787, 1797, 13, 16},
  {cont__compiler__define_c_code_229, &frame__compiler__define_c_code_224, 1797, 1797, 17, 17},
  {entry__compiler__define_c_code_249, NULL, 1810, 1819, 21, 17},
  {cont__compiler__define_c_code_256, &frame__compiler__define_c_code_249, 1810, 1819, 15, 17},
  {entry__compiler__define_c_code_257, NULL, 1821, 1827, 21, 17},
  {cont__compiler__define_c_code_262, &frame__compiler__define_c_code_257, 1821, 1827, 15, 17},
  {entry__compiler__define_c_code_243, NULL, 1807, 1807, 13, 66},
  {cont__compiler__define_c_code_245, &frame__compiler__define_c_code_243, 1806, 1807, 11, 66},
  {cont__compiler__define_c_code_246, &frame__compiler__define_c_code_243, 1809, 1809, 13, 38},
  {cont__compiler__define_c_code_248, &frame__compiler__define_c_code_243, 1808, 1827, 11, 19},
  {entry__compiler__define_c_code_142, NULL, 1704, 1704, 9, 32},
  {cont__compiler__define_c_code_143, &frame__compiler__define_c_code_142, 1705, 1705, 9, 38},
  {cont__compiler__define_c_code_144, &frame__compiler__define_c_code_142, 1706, 1706, 16, 30},
  {cont__compiler__define_c_code_145, &frame__compiler__define_c_code_142, 1706, 1708, 9, 70},
  {cont__compiler__define_c_code_150, &frame__compiler__define_c_code_142, 1710, 1710, 11, 23},
  {cont__compiler__define_c_code_151, &frame__compiler__define_c_code_142, 1710, 1710, 11, 34},
  {cont__compiler__define_c_code_152, &frame__compiler__define_c_code_142, 1709, 1714, 9, 43},
  {cont__compiler__define_c_code_159, &frame__compiler__define_c_code_142, 1715, 1715, 12, 31},
  {cont__compiler__define_c_code_160, &frame__compiler__define_c_code_142, 1715, 1719, 9, 64},
  {cont__compiler__define_c_code_164, &frame__compiler__define_c_code_142, 1723, 1723, 11, 25},
  {cont__compiler__define_c_code_165, &frame__compiler__define_c_code_142, 1722, 1739, 9, 35},
  {cont__compiler__define_c_code_191, &frame__compiler__define_c_code_142, 1744, 1744, 24, 36},
  {cont__compiler__define_c_code_192, &frame__compiler__define_c_code_142, 1745, 1745, 39, 51},
  {cont__compiler__define_c_code_193, &frame__compiler__define_c_code_142, 1745, 1745, 39, 65},
  {cont__compiler__define_c_code_194, &frame__compiler__define_c_code_142, 1741, 1745, 9, 67},
  {cont__compiler__define_c_code_199, &frame__compiler__define_c_code_142, 1747, 1769, 9, 51},
  {cont__compiler__define_c_code_217, &frame__compiler__define_c_code_142, 1770, 1772, 9, 12},
  {cont__compiler__define_c_code_218, &frame__compiler__define_c_code_142, 1774, 1774, 11, 44},
  {cont__compiler__define_c_code_220, &frame__compiler__define_c_code_142, 1773, 1797, 9, 18},
  {cont__compiler__define_c_code_230, &frame__compiler__define_c_code_142, 1798, 1798, 9, 36},
  {cont__compiler__define_c_code_231, &frame__compiler__define_c_code_142, 1800, 1800, 11, 74},
  {cont__compiler__define_c_code_233, &frame__compiler__define_c_code_142, 1799, 1800, 9, 74},
  {cont__compiler__define_c_code_234, &frame__compiler__define_c_code_142, 1803, 1803, 24, 39},
  {cont__compiler__define_c_code_235, &frame__compiler__define_c_code_142, 1803, 1803, 13, 40},
  {cont__compiler__define_c_code_236, &frame__compiler__define_c_code_142, 1801, 1803, 15, 46},
  {cont__compiler__define_c_code_238, &frame__compiler__define_c_code_142, 1801, 1803, 9, 46},
  {cont__compiler__define_c_code_239, &frame__compiler__define_c_code_142, 1804, 1804, 9, 51},
  {cont__compiler__define_c_code_241, &frame__compiler__define_c_code_142, 1805, 1805, 16, 50},
  {cont__compiler__define_c_code_242, &frame__compiler__define_c_code_142, 1805, 1827, 9, 20},
  {entry__compiler__define_c_code_266, NULL, 1834, 1834, 38, 60},
  {cont__compiler__define_c_code_267, &frame__compiler__define_c_code_266, 1831, 1834, 28, 63},
  {cont__compiler__define_c_code_268, &frame__compiler__define_c_code_266, 1831, 1834, 11, 63},
  {entry__compiler__define_c_code_263, NULL, 1829, 1829, 9, 30},
  {cont__compiler__define_c_code_264, &frame__compiler__define_c_code_263, 1830, 1830, 12, 31},
  {cont__compiler__define_c_code_265, &frame__compiler__define_c_code_263, 1830, 1834, 9, 64},
  {entry__compiler__define_c_code_277, NULL, 1843, 1843, 16, 48},
  {cont__compiler__define_c_code_279, &frame__compiler__define_c_code_277, 1843, 1843, 13, 48},
  {entry__compiler__define_c_code_280, NULL, 1844, 1844, 13, 28},
  {entry__compiler__define_c_code_288, NULL, 1854, 1854, 15, 25},
  {entry__compiler__define_c_code_289, NULL, 1855, 1855, 15, 19},
  {entry__compiler__define_c_code_297, NULL, 1861, 1864, 30, 40},
  {cont__compiler__define_c_code_299, &frame__compiler__define_c_code_297, 1861, 1864, 13, 40},
  {entry__compiler__define_c_code_300, NULL, 1866, 1866, 35, 67},
  {cont__compiler__define_c_code_301, &frame__compiler__define_c_code_300, 1866, 1866, 13, 67},
  {entry__compiler__define_c_code_269, NULL, 1836, 1836, 9, 43},
  {cont__compiler__define_c_code_270, &frame__compiler__define_c_code_269, 1837, 1837, 9, 51},
  {cont__compiler__define_c_code_271, &frame__compiler__define_c_code_269, 1838, 1838, 45, 56},
  {cont__compiler__define_c_code_272, &frame__compiler__define_c_code_269, 1838, 1838, 59, 59},
  {cont__compiler__define_c_code_273, &frame__compiler__define_c_code_269, 1838, 1838, 9, 60},
  {cont__compiler__define_c_code_274, &frame__compiler__define_c_code_269, 1842, 1842, 13, 26},
  {cont__compiler__define_c_code_275, &frame__compiler__define_c_code_269, 1842, 1842, 13, 39},
  {cont__compiler__define_c_code_276, &frame__compiler__define_c_code_269, 1840, 1844, 9, 29},
  {cont__compiler__define_c_code_281, &frame__compiler__define_c_code_269, 1846, 1846, 47, 70},
  {cont__compiler__define_c_code_282, &frame__compiler__define_c_code_269, 1846, 1846, 47, 70},
  {cont__compiler__define_c_code_283, &frame__compiler__define_c_code_269, 1846, 1846, 47, 72},
  {cont__compiler__define_c_code_284, &frame__compiler__define_c_code_269, 1846, 1846, 9, 73},
  {cont__compiler__define_c_code_285, &frame__compiler__define_c_code_269, 1847, 1847, 9, 45},
  {cont__compiler__define_c_code_286, &frame__compiler__define_c_code_269, 1853, 1853, 15, 43},
  {cont__compiler__define_c_code_287, &frame__compiler__define_c_code_269, },
  {cont__compiler__define_c_code_290, &frame__compiler__define_c_code_269, 1856, 1856, 47, 57},
  {cont__compiler__define_c_code_291, &frame__compiler__define_c_code_269, 1856, 1856, 59, 69},
  {cont__compiler__define_c_code_292, &frame__compiler__define_c_code_269, 1856, 1856, 13, 70},
  {cont__compiler__define_c_code_293, &frame__compiler__define_c_code_269, 1849, 1857, 9, 22},
  {cont__compiler__define_c_code_294, &frame__compiler__define_c_code_269, 1860, 1860, 11, 24},
  {cont__compiler__define_c_code_295, &frame__compiler__define_c_code_269, 1860, 1860, 11, 37},
  {cont__compiler__define_c_code_296, &frame__compiler__define_c_code_269, 1859, 1866, 9, 68},
  {cont__compiler__define_c_code_302, &frame__compiler__define_c_code_269, 1867, 1867, 45, 63},
  {cont__compiler__define_c_code_303, &frame__compiler__define_c_code_269, 1867, 1867, 45, 74},
  {cont__compiler__define_c_code_304, &frame__compiler__define_c_code_269, 1867, 1867, 15, 80},
  {cont__compiler__define_c_code_305, &frame__compiler__define_c_code_269, 1867, 1867, 9, 80},
  {entry__compiler__define_c_code_310, NULL, 1871, 1871, 39, 45},
  {cont__compiler__define_c_code_311, &frame__compiler__define_c_code_310, 1871, 1871, 39, 51},
  {cont__compiler__define_c_code_312, &frame__compiler__define_c_code_310, 1871, 1871, 39, 51},
  {entry__compiler__define_c_code_318, NULL, 1873, 1873, 15, 41},
  {entry__compiler__define_c_code_314, NULL, 1872, 1872, 38, 75},
  {cont__compiler__define_c_code_316, &frame__compiler__define_c_code_314, 1872, 1872, 20, 75},
  {cont__compiler__define_c_code_317, &frame__compiler__define_c_code_314, 1872, 1873, 13, 41},
  {entry__compiler__define_c_code_308, NULL, 1871, 1871, 14, 34},
  {cont__compiler__define_c_code_309, &frame__compiler__define_c_code_308, 1871, 1871, 14, 51},
  {cont__compiler__define_c_code_313, &frame__compiler__define_c_code_308, 1871, 1873, 11, 42},
  {cont__compiler__define_c_code_319, &frame__compiler__define_c_code_308, 1874, 1874, 33, 46},
  {cont__compiler__define_c_code_320, &frame__compiler__define_c_code_308, 1874, 1874, 11, 53},
  {entry__compiler__define_c_code_306, NULL, 1869, 1869, 9, 36},
  {cont__compiler__define_c_code_307, &frame__compiler__define_c_code_306, 1870, 1874, 9, 53},
  {entry__compiler__define_c_code_321, NULL, 1876, 1877, 15, 58},
  {cont__compiler__define_c_code_324, &frame__compiler__define_c_code_321, 1876, 1877, 9, 58},
  {entry__compiler__define_c_code_4, NULL, 1575, 1575, 5, 23},
  {cont__compiler__define_c_code_39, &frame__compiler__define_c_code_4, 1576, 1576, 5, 27},
  {cont__compiler__define_c_code_40, &frame__compiler__define_c_code_4, 1580, 1580, 9, 22},
  {cont__compiler__define_c_code_41, &frame__compiler__define_c_code_4, 1578, 1587, 5, 21},
  {cont__compiler__define_c_code_51, &frame__compiler__define_c_code_4, 1589, 1589, 5, 35},
  {cont__compiler__define_c_code_52, &frame__compiler__define_c_code_4, 1593, 1593, 9, 29},
  {cont__compiler__define_c_code_53, &frame__compiler__define_c_code_4, 1591, 1595, 5, 21},
  {cont__compiler__define_c_code_57, &frame__compiler__define_c_code_4, 1599, 1599, 9, 29},
  {cont__compiler__define_c_code_58, &frame__compiler__define_c_code_4, 1597, 1601, 5, 21},
  {cont__compiler__define_c_code_62, &frame__compiler__define_c_code_4, 1605, 1605, 9, 29},
  {cont__compiler__define_c_code_63, &frame__compiler__define_c_code_4, 1603, 1607, 5, 21},
  {cont__compiler__define_c_code_68, &frame__compiler__define_c_code_4, 1611, 1611, 9, 27},
  {cont__compiler__define_c_code_69, &frame__compiler__define_c_code_4, 1611, 1611, 9, 38},
  {cont__compiler__define_c_code_70, &frame__compiler__define_c_code_4, 1609, 1613, 5, 21},
  {cont__compiler__define_c_code_75, &frame__compiler__define_c_code_4, 1655, 1877, 5, 60},
  {entry__compiler__define_c_code, NULL, 1573, 1573, 3, 42},
  {cont__compiler__define_c_code_3, &frame__compiler__define_c_code, 1574, 1877, 3, 61},
  {entry__assign_attributes_15, NULL, 1893, 1893, 13, 17},
  {entry__assign_attributes_16, NULL, 1894, 1894, 13, 23},
  {entry__assign_attributes_13, NULL, 1892, 1892, 13, 51},
  {cont__assign_attributes_14, &frame__assign_attributes_13, 1890, 1894, 9, 24},
  {cont__assign_attributes_18, &frame__assign_attributes_13, 1899, 1899, 23, 49},
  {cont__assign_attributes_19, &frame__assign_attributes_13, 1896, 1899, 15, 67},
  {cont__assign_attributes_22, &frame__assign_attributes_13, 1896, 1899, 9, 67},
  {entry__assign_attributes_23, NULL, 1901, 1903, 15, 46},
  {cont__assign_attributes_26, &frame__assign_attributes_23, 1901, 1903, 9, 46},
  {entry__assign_attributes_7, NULL, 1886, 1886, 5, 40},
  {cont__assign_attributes_8, &frame__assign_attributes_7, 1887, 1887, 12, 34},
  {cont__assign_attributes_9, &frame__assign_attributes_7, 1887, 1887, 12, 37},
  {cont__assign_attributes_10, &frame__assign_attributes_7, 1887, 1887, 5, 42},
  {cont__assign_attributes_11, &frame__assign_attributes_7, 1889, 1889, 7, 27},
  {cont__assign_attributes_12, &frame__assign_attributes_7, 1888, 1903, 5, 48},
  {entry__assign_attributes, NULL, 1883, 1883, 56, 66},
  {cont__assign_attributes_2, &frame__assign_attributes, 1880, 1884, 9, 36},
  {cont__assign_attributes_5, &frame__assign_attributes, 1880, 1884, 3, 36},
  {cont__assign_attributes_6, &frame__assign_attributes, 1885, 1903, 3, 49},
  {cont__assign_attributes_27, &frame__assign_attributes, 1904, 1904, 3, 43},
  {cont__assign_attributes_29, &frame__assign_attributes, 1905, 1908, 9, 9},
  {cont__assign_attributes_31, &frame__assign_attributes, 1905, 1908, 3, 9},
  {entry__compiler__generate_statement_5, NULL, 1915, 1915, 41, 74},
  {entry__compiler__generate_statement_3, NULL, 1915, 1915, 10, 38},
  {cont__compiler__generate_statement_4, &frame__compiler__generate_statement_3, 1915, 1915, 7, 74},
  {entry__compiler__generate_statement_9, NULL, 1916, 1916, 38, 67},
  {entry__compiler__generate_statement_7, NULL, 1916, 1916, 10, 35},
  {cont__compiler__generate_statement_8, &frame__compiler__generate_statement_7, 1916, 1916, 7, 67},
  {entry__compiler__generate_statement_11, NULL, 1918, 1918, 9, 45},
  {entry__compiler__generate_statement_2, NULL, 1914, 1918, 5, 46},
  {entry__compiler__generate_statement_22, NULL, 1927, 1927, 50, 79},
  {cont__compiler__generate_statement_23, &frame__compiler__generate_statement_22, 1927, 1927, 79, 79},
  {entry__compiler__generate_statement_19, NULL, 1926, 1926, 9, 39},
  {cont__compiler__generate_statement_20, &frame__compiler__generate_statement_19, 1927, 1927, 12, 47},
  {cont__compiler__generate_statement_21, &frame__compiler__generate_statement_19, 1927, 1927, 9, 79},
  {entry__compiler__generate_statement_24, NULL, 1929, 1929, 9, 38},
  {cont__compiler__generate_statement_25, &frame__compiler__generate_statement_24, 1929, 1929, 38, 38},
  {entry__compiler__generate_statement_17, NULL, 1925, 1925, 7, 31},
  {cont__compiler__generate_statement_18, &frame__compiler__generate_statement_17, 1924, 1929, 5, 39},
  {entry__compiler__generate_statement_30, NULL, 1933, 1933, 24, 24},
  {cont__compiler__generate_statement_31, &frame__compiler__generate_statement_30, 1933, 1933, 7, 25},
  {cont__compiler__generate_statement_32, &frame__compiler__generate_statement_30, 1933, 1933, 7, 52},
  {cont__compiler__generate_statement_33, &frame__compiler__generate_statement_30, 1933, 1933, 7, 52},
  {entry__compiler__generate_statement_38, NULL, 1940, 1940, 11, 20},
  {entry__compiler__generate_statement_39, NULL, 1941, 1941, 11, 24},
  {entry__compiler__generate_statement_35, NULL, 1935, 1935, 7, 38},
  {cont__compiler__generate_statement_36, &frame__compiler__generate_statement_35, 1939, 1939, 11, 28},
  {cont__compiler__generate_statement_37, &frame__compiler__generate_statement_35, 1937, 1941, 7, 25},
  {cont__compiler__generate_statement_40, &frame__compiler__generate_statement_35, 1943, 1943, 7, 58},
  {entry__compiler__generate_statement_48, NULL, 1951, 1951, 44, 69},
  {cont__compiler__generate_statement_49, &frame__compiler__generate_statement_48, 1951, 1951, 44, 74},
  {cont__compiler__generate_statement_50, &frame__compiler__generate_statement_48, 1951, 1951, 17, 78},
  {cont__compiler__generate_statement_53, &frame__compiler__generate_statement_48, 1950, 1951, 15, 78},
  {entry__compiler__generate_statement_45, NULL, 1949, 1949, 16, 41},
  {cont__compiler__generate_statement_46, &frame__compiler__generate_statement_45, 1949, 1949, 16, 52},
  {cont__compiler__generate_statement_47, &frame__compiler__generate_statement_45, 1949, 1951, 13, 79},
  {entry__compiler__generate_statement_57, NULL, 1955, 1957, 15, 70},
  {entry__compiler__generate_statement_54, NULL, 1952, 1952, 16, 41},
  {cont__compiler__generate_statement_55, &frame__compiler__generate_statement_54, 1952, 1952, 16, 52},
  {cont__compiler__generate_statement_56, &frame__compiler__generate_statement_54, 1952, 1957, 13, 71},
  {entry__compiler__generate_statement_61, NULL, 1965, 1965, 27, 61},
  {cont__compiler__generate_statement_64, &frame__compiler__generate_statement_61, 1965, 1965, 19, 61},
  {entry__compiler__generate_statement_65, NULL, 1963, 1963, 19, 48},
  {entry__compiler__generate_statement_59, NULL, 1959, 1959, 15, 61},
  {cont__compiler__generate_statement_60, &frame__compiler__generate_statement_59, 1960, 1965, 15, 62},
  {entry__compiler__generate_statement_70, NULL, 1971, 1971, 15, 28},
  {entry__compiler__generate_statement_71, NULL, 1972, 1972, 15, 23},
  {entry__compiler__generate_statement_43, NULL, 1947, 1947, 11, 46},
  {cont__compiler__generate_statement_44, &frame__compiler__generate_statement_43, 1948, 1965, 11, 64},
  {cont__compiler__generate_statement_67, &frame__compiler__generate_statement_43, 1966, 1966, 11, 20},
  {cont__compiler__generate_statement_68, &frame__compiler__generate_statement_43, 1970, 1970, 15, 36},
  {cont__compiler__generate_statement_69, &frame__compiler__generate_statement_43, 1968, 1972, 11, 24},
  {cont__compiler__generate_statement_72, &frame__compiler__generate_statement_43, 1974, 1974, 39, 59},
  {cont__compiler__generate_statement_73, &frame__compiler__generate_statement_43, 1974, 1974, 11, 59},
  {cont__compiler__generate_statement_74, &frame__compiler__generate_statement_43, 1975, 1975, 11, 23},
  {cont__compiler__generate_statement_75, &frame__compiler__generate_statement_43, 1976, 1976, 29, 49},
  {cont__compiler__generate_statement_76, &frame__compiler__generate_statement_43, 1976, 1976, 11, 49},
  {cont__compiler__generate_statement_77, &frame__compiler__generate_statement_43, 1977, 1977, 11, 44},
  {entry__compiler__generate_statement_82, NULL, 1984, 1984, 15, 38},
  {cont__compiler__generate_statement_83, &frame__compiler__generate_statement_82, 1984, 1984, 15, 38},
  {entry__compiler__generate_statement_85, NULL, 1988, 1988, 47, 62},
  {cont__compiler__generate_statement_86, &frame__compiler__generate_statement_85, 1988, 1988, 68, 78},
  {cont__compiler__generate_statement_87, &frame__compiler__generate_statement_85, 1986, 1989, 21, 23},
  {cont__compiler__generate_statement_89, &frame__compiler__generate_statement_85, 1986, 1989, 15, 23},
  {entry__compiler__generate_statement_90, NULL, 1991, 1991, 49, 59},
  {cont__compiler__generate_statement_91, &frame__compiler__generate_statement_90, 1991, 1991, 21, 60},
  {cont__compiler__generate_statement_92, &frame__compiler__generate_statement_90, 1991, 1991, 15, 60},
  {entry__compiler__generate_statement_78, NULL, 1979, 1979, 11, 42},
  {cont__compiler__generate_statement_79, &frame__compiler__generate_statement_78, 1980, 1980, 11, 36},
  {cont__compiler__generate_statement_80, &frame__compiler__generate_statement_78, 1983, 1983, 15, 55},
  {cont__compiler__generate_statement_81, &frame__compiler__generate_statement_78, 1982, 1984, 13, 38},
  {cont__compiler__generate_statement_84, &frame__compiler__generate_statement_78, 1981, 1991, 11, 61},
  {entry__compiler__generate_statement_41, NULL, 1946, 1946, 9, 26},
  {cont__compiler__generate_statement_42, &frame__compiler__generate_statement_41, 1945, 1991, 7, 63},
  {entry__compiler__generate_statement, NULL, 1913, 1918, 3, 47},
  {cont__compiler__generate_statement_13, &frame__compiler__generate_statement, 1919, 1919, 3, 34},
  {cont__compiler__generate_statement_14, &frame__compiler__generate_statement, 1920, 1920, 3, 32},
  {cont__compiler__generate_statement_15, &frame__compiler__generate_statement, 1923, 1923, 12, 34},
  {cont__compiler__generate_statement_16, &frame__compiler__generate_statement, 1923, 1929, 3, 40},
  {cont__compiler__generate_statement_26, &frame__compiler__generate_statement, 1932, 1932, 7, 32},
  {cont__compiler__generate_statement_27, &frame__compiler__generate_statement, 1932, 1932, 7, 37},
  {cont__compiler__generate_statement_28, &frame__compiler__generate_statement, 1932, 1932, 7, 37},
  {cont__compiler__generate_statement_29, &frame__compiler__generate_statement, 1931, 1933, 5, 52},
  {cont__compiler__generate_statement_34, &frame__compiler__generate_statement, 1930, 1991, 3, 65}
};

union NODE {
  struct {
    FUNC type;
    ATTRIBUTES *attributes;
  };
  CONTINUATION continuation;
  CLOSURE closure;
};
static void type__compiler__to_c(void) {
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  myself = get_attribute(arguments->slots[0], poly_idx__compiler__to_c);
  if (CONTAINS_AN_ATTRIBUTE_VALUE(myself)) {
    if (argument_count != 1) {
      if (argument_count != 2) invalid_arguments_error();
      NODE *attr = arguments->slots[1];
      NODE *temp = clone_object_and_attributes(arguments->slots[0]);
      update_start_p = node_p;
      set_attribute_value(temp->attributes, poly_idx__compiler__to_c, attr);
      arguments = node_p;
      argument_count = 1;
      arguments->slots[0] = temp;
    } else {
      arguments = node_p;
      arguments->slots[0] = RETRIEVE_ATTRIBUTE_VALUE(myself);
    }
    func = frame->cont;
    frame->cont = invalid_continuation;
  } else {
    func = myself->type;
  }
}
static NODE *character__92;
static NODE *character__47;
static NODE *character__160;
static NODE *character__10;
static NODE *number__0;
static NODE *number__3;
static NODE *character__126;
static NODE *character__95;
static NODE *character__40;
static NODE *character__34;
static NODE *character__255;
static NODE *number__5;
static NODE *character__39;
static NODE *character__32;
static NODE *number__9;
static NODE *character__125;
static NODE *character__41;
static NODE *character__59;
static NODE *number__1;
static NODE *number__2;
static NODE *character__42;

static const char *used_namespaces[] = {
  "std",
  "compiler",
  "node",
  NULL
};

static MODULE_INFO module_info = {
  NULL,
  "c_code_generator",
  continuation_info,
  sizeof(continuation_info)/sizeof(CONTINUATION_INFO),
  (NODE **)&var,
  var_names,
  sizeof(var_names)/sizeof(const char *),
  used_namespaces,
  {DEBUG_FILENAME("c_code_generator.sim")}
};

/******
C O D E
******/

static int already_run = false;

EXPORT void run__c_code_generator(void) {
  if (already_run) {
    func = frame->cont;
    frame->cont = invalid_continuation;
    return;
  }
  already_run = true;
  allocate_initialized_frame_gc(0, 0);
  // 34: %compiler::suffix undefined
  initialize_maybe_future(get__compiler__suffix(), get__undefined());
  // 36: %cont_suffix undefined
  initialize_maybe_future(get__cont_suffix(), get__undefined());
  // 37: %current_locals empty_table
  initialize_maybe_future(get__current_locals(), get__empty_table());
  // 38: %current_frame undefined
  initialize_maybe_future(get__current_frame(), get__undefined());
  // 39: %is_a_shared_local empty_set
  initialize_maybe_future(get__is_a_shared_local(), get__empty_set());
  // 41: %%compiler::delayed_code undefined
  set__compiler__delayed_code(get__undefined());
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__var_name_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 46: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__var_name_5(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 47: ... string('_' name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__95;
  arguments->slots[1] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__var_name_6;
}
static void cont__var_name_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 47: -> string('_' name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__var_name(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 45: name .contains. "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__2d7981f4e5f02b9a;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__var_name_3;
}
static void cont__var_name_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 46: -> name
  frame->slots[2] /* temp__2 */ = create_closure(entry__var_name_4, 0);
  // 47: -> string('_' name)
  frame->slots[3] /* temp__3 */ = create_closure(entry__var_name_5, 0);
  // 44: if
  // 45:   name .contains. "__"
  // 46:   -> name
  // 47:   -> string('_' name)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__var_entry_3(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 52: ... string("var." name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2e0ae90b5df07d17;
  arguments->slots[1] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__var_entry_5;
}
static void cont__var_entry_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 52: -> string("var." name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__var_entry_6(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 53: ... string("var._" name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__485aef83e8b97008;
  arguments->slots[1] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__var_entry_8;
}
static void cont__var_entry_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 53: -> string("var._" name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__var_entry(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 51: name .contains. "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__2d7981f4e5f02b9a;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__var_entry_2;
}
static void cont__var_entry_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 52: -> string("var." name)
  frame->slots[2] /* temp__2 */ = create_closure(entry__var_entry_3, 0);
  // 53: -> string("var._" name)
  frame->slots[3] /* temp__3 */ = create_closure(entry__var_entry_6, 0);
  // 50: if
  // 51:   name .contains. "__"
  // 52:   -> string("var." name)
  // 53:   -> string("var._" name)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__insert_delayed(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 56: write delayed_code
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__delayed_code();
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__insert_delayed_2;
}
static void cont__insert_delayed_2(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 57: !delayed_code ""
  set__delayed_code(empty_string);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__delayed(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // body: 0
  // cont_tab_entries: 1
  frame->slots[1] /* cont_tab_entries */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 60: $$cont_tab_entries ""
  ((CELL *)frame->slots[1])->contents /* cont_tab_entries */ = empty_string;
  // 61: ... :
  // 62:   %%compiler::current_continuation_info undefined
  // 63:   
  // 64:   %write_to_continuation_table: (args*) write_to &cont_tab_entries args*
  // 65:   
  // 66:   collect_output $output body
  // 67:   append &delayed_code output
  frame->slots[2] /* temp__1 */ = create_closure(entry__delayed_2, 0);
  // 61: do:
  // 62:   %%compiler::current_continuation_info undefined
  // 63:   
  // 64:   %write_to_continuation_table: (args*) write_to &cont_tab_entries args*
  // 65:   
  // 66:   collect_output $output body
  // 67:   append &delayed_code output
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__delayed_7;
}
static void entry__delayed_2(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // return__1: 0
  // cont_tab_entries: 1
  // body: 2
  // output: 3
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* cont_tab_entries */
  frame->slots[2] = myself->closure.frame->slots[0]; /* body */
  define__compiler__current_continuation_info(undefined);
  define__write_to_continuation_table(create_future());
  frame->slots[3] /* output */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 62: %%compiler::current_continuation_info undefined
  set__compiler__current_continuation_info(get__undefined());
  // 64: ... : (args*) write_to &cont_tab_entries args*
  frame->slots[4] /* temp__1 */ = create_closure(entry__delayed_3, -1);
  // 64: %write_to_continuation_table: (args*) write_to &cont_tab_entries args*
  initialize_future(get__write_to_continuation_table(), frame->slots[4] /* temp__1 */);
  // 66: collect_output $output body
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* body */;
  result_count = 1;
  myself = get__collect_output();
  func = myself->type;
  frame->cont = cont__delayed_5;
}
static void entry__delayed_3(void) {
  allocate_arguments();
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // args: 0
  // cont_tab_entries: 1
  frame->slots[1] = myself->closure.frame->slots[1]; /* cont_tab_entries */
  frame->slots[0] /* args */ = from_arguments(0, argument_count-0);
  // 64: ... write_to &cont_tab_entries args*
  argument_count = 0;
  arguments = node_p;
  arguments->slots[argument_count++] = ((CELL *)frame->slots[1])->contents /* cont_tab_entries */;
  unfold(frame->slots[0] /* args */);
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__delayed_4;
}
static void cont__delayed_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* cont_tab_entries */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__delayed_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* output */, arguments->slots[0]);
  // 67: append &delayed_code output
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__delayed_code();
  arguments->slots[1] = frame->slots[3] /* output */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__delayed_6;
}
static void cont__delayed_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__delayed_code(arguments->slots[0]);
  argument_count = 0;
  arguments = node_p;
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__delayed_7(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 68: write_to_delayed_continuation_table cont_tab_entries
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* cont_tab_entries */;
  result_count = frame->caller_result_count;
  myself = get__write_to_delayed_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__begin_continuation(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 71: ... "
  // 72:   static void @(name)(void);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__94d1722d4e0367ec;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__66ccbf91860d092a;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_4;
}
static void cont__compiler__begin_continuation_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 71: write_to_declarations "
  // 72:   static void @(name)(void);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_5;
}
static void cont__compiler__begin_continuation_5(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 73: insert_delayed
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = func__insert_delayed;
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_6;
}
static void cont__compiler__begin_continuation_6(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 74: ... "
  // 75:   static void @(name)(void) {
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__94d1722d4e0367ec;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__fc8c36a84adb366f;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_8;
}
static void cont__compiler__begin_continuation_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 74: write "
  // 75:   static void @(name)(void) {
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_9;
}
static void cont__compiler__begin_continuation_9(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 76: ... "  {@(name), "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__fa730415f296bb7;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__2d7981f4e6682be5;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_12;
}
static void cont__compiler__begin_continuation_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 76: write_to_continuation_table "  {@(name), "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_13;
}
static void cont__compiler__begin_continuation_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 79: current_frame.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__current_frame();
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_14;
}
static void cont__compiler__begin_continuation_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = func__compiler__begin_continuation_15;
  arguments->slots[2] = func__compiler__begin_continuation_18;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_20;
}
static void entry__compiler__begin_continuation_15(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 80: ... "&@(current_frame), "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc7;
  arguments->slots[1] = get__current_frame();
  arguments->slots[2] = string__2d7981f4e6682be5;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__begin_continuation_17;
}
static void cont__compiler__begin_continuation_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 80: -> "&@(current_frame), "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__begin_continuation_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 81: -> "NULL, "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__1f5d5783d902f7;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__begin_continuation_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 77: write_to_continuation_table
  // 78:   if
  // 79:     current_frame.is_defined
  // 80:     -> "&@(current_frame), "
  // 81:     -> "NULL, "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__end_continuation_3(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 86: ... "@(current_continuation_info)},@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__current_continuation_info();
  arguments->slots[1] = string__fa727015f496bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__end_continuation_5;
}
static void cont__compiler__end_continuation_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 86: write_to_continuation_table "@(current_continuation_info)},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame->cont = cont__compiler__end_continuation_6;
}
static void cont__compiler__end_continuation_6(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 87: !current_continuation_info undefined
  set__current_continuation_info(get__undefined());
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__end_continuation_7(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 89: write_to_continuation_table "},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__fa727015f496bc6;
  result_count = frame->caller_result_count;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__end_continuation(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 85: current_continuation_info.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__current_continuation_info();
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__end_continuation_2;
}
static void cont__compiler__end_continuation_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 84: if
  // 85:   current_continuation_info.is_defined:
  // 86:     write_to_continuation_table "@(current_continuation_info)},@nl;"
  // 87:     !current_continuation_info undefined
  // 88:   :
  // 89:     write_to_continuation_table "},@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  arguments->slots[1] = func__compiler__end_continuation_3;
  arguments->slots[2] = func__compiler__end_continuation_7;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__next_continuation(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 92: end_continuation
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = get__end_continuation();
  func = myself->type;
  frame->cont = cont__compiler__next_continuation_2;
}
static void cont__compiler__next_continuation_2(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 93: begin_continuation name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = frame->caller_result_count;
  myself = get__begin_continuation();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__count_arguments(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // arguments: 0
  // return: 1
  // inputs_count: 2
  frame->slots[1] /* return */ = create_continuation();
  frame->slots[2] /* inputs_count */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 100: $$inputs_count 0
  ((CELL *)frame->slots[2])->contents /* inputs_count */ = number__0;
  // 101: ... : (argument)
  // 102:   if
  // 103:     argument.is_an_expanded_item || argument.is_an_optional_item:
  // 104:       return undefined
  // 105:     :
  // 106:       inc &inputs_count
  frame->slots[3] /* temp__1 */ = create_closure(entry__count_arguments_2, 1);
  // 101: for_each arguments: (argument)
  // 102:   if
  // 103:     argument.is_an_expanded_item || argument.is_an_optional_item:
  // 104:       return undefined
  // 105:     :
  // 106:       inc &inputs_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__count_arguments_10;
}
static void entry__count_arguments_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 104: return undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__count_arguments_8(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 106: inc &inputs_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* inputs_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__count_arguments_9;
}
static void cont__count_arguments_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* inputs_count */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__count_arguments_2(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // argument: 0
  // return: 1
  // inputs_count: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 103: argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__count_arguments_3;
}
static void cont__count_arguments_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 103: ... argument.is_an_optional_item
  frame->slots[5] /* temp__3 */ = create_closure(entry__count_arguments_4, 0);
  // 103: argument.is_an_expanded_item || argument.is_an_optional_item
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__count_arguments_6;
}
static void entry__count_arguments_4(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 103: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__count_arguments_5;
}
static void cont__count_arguments_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 103: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__count_arguments_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 103: ... :
  // 104:   return undefined
  frame->slots[6] /* temp__4 */ = create_closure(entry__count_arguments_7, 0);
  // 105: :
  // 106:   inc &inputs_count
  frame->slots[7] /* temp__5 */ = create_closure(entry__count_arguments_8, 0);
  // 102: if
  // 103:   argument.is_an_expanded_item || argument.is_an_optional_item:
  // 104:     return undefined
  // 105:   :
  // 106:     inc &inputs_count
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__count_arguments_10(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 107: -> inputs_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* inputs_count */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__generate_c_arguments_25(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // src: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 129: ... "  unfold(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__70e425abc2231c8d;
  arguments->slots[1] = frame->slots[0] /* src */;
  arguments->slots[2] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_27;
}
static void cont__generate_c_arguments_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 129: ... write "  unfold(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__generate_c_arguments_19(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // src: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 128: ... "  optional_item(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__7834b5f7cd2908a7;
  arguments->slots[1] = frame->slots[0] /* src */;
  arguments->slots[2] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_22;
}
static void cont__generate_c_arguments_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 128: ... write "  optional_item(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__generate_c_arguments_17(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 128: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_18;
}
static void cont__generate_c_arguments_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 128: ... : write "  optional_item(@(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__generate_c_arguments_19, 0);
  // 128: -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__generate_c_arguments_23(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 129: ... argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_24;
}
static void cont__generate_c_arguments_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 129: ... : write "  unfold(@(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__generate_c_arguments_25, 0);
  // 129: -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__generate_c_arguments_28(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // inputs_count: 0
  // idx: 1
  // src: 2
  // slot_idx: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* inputs_count */
  frame->slots[1] = myself->closure.frame->slots[2]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[3]; /* src */
  frame->slots[3] /* slot_idx */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 133: inputs_count.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* inputs_count */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_29;
}
static void cont__generate_c_arguments_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 134: -> idx
  frame->slots[5] /* temp__2 */ = create_closure(entry__generate_c_arguments_30, 0);
  // 131: $slot_idx
  // 132:   if
  // 133:     inputs_count.is_defined
  // 134:     -> idx
  // 135:     -> "argument_count++"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = func__generate_c_arguments_31;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_33;
}
static void entry__generate_c_arguments_30(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // idx: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 134: -> idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* idx */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__generate_c_arguments_31(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 135: -> "argument_count++"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__4808b9f7f52b8767;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__generate_c_arguments_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* slot_idx */, arguments->slots[0]);
  // 137: ... "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__fd6b440801406c9;
  arguments->slots[1] = frame->slots[3] /* slot_idx */;
  arguments->slots[2] = string__780af94b5f887d19;
  arguments->slots[3] = frame->slots[2] /* src */;
  arguments->slots[4] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_36;
}
static void cont__generate_c_arguments_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 137: write "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_37;
}
static void cont__generate_c_arguments_37(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 138: inc &idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_38;
}
static void cont__generate_c_arguments_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__generate_c_arguments_15(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // argument: 0
  // inputs_count: 1
  // idx: 2
  // src: 3
  frame->slots[1] = myself->closure.frame->slots[2]; /* inputs_count */
  frame->slots[2] = myself->closure.frame->slots[3]; /* idx */
  frame->slots[3] /* src */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 126: $src argument.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_16;
}
static void cont__generate_c_arguments_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 128: -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  frame->slots[4] /* temp__1 */ = create_closure(entry__generate_c_arguments_17, 0);
  // 129: -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__generate_c_arguments_23, 0);
  // 130: :
  // 131:   $slot_idx
  // 132:     if
  // 133:       inputs_count.is_defined
  // 134:       -> idx
  // 135:       -> "argument_count++"
  // 136:   
  // 137:   write "  arguments->slots[@(slot_idx)] = @(src);@nl;"
  // 138:   inc &idx
  frame->slots[6] /* temp__3 */ = create_closure(entry__generate_c_arguments_28, 0);
  // 127: cond
  // 128:   -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  // 129:   -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  // 130:   :
  // 131:     $slot_idx
  // 132:       if
  // 133:         inputs_count.is_defined
  // 134:         -> idx
  // 135:         -> "argument_count++"
  // 136:     
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__generate_c_arguments(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // arguments: 0
  // within_exit_function: 1
  // inputs_count: 2
  // idx: 3
  frame->slots[2] /* inputs_count */ = create_future();
  frame->slots[3] /* idx */ = create_cell();
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 2) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[1] /* within_exit_function */ = arguments->slots[1];
    case 1:;
  }
  switch(argument_count) {
    case 1: frame->slots[1] /* within_exit_function */ = get__false();
  }
  // 114: $inputs_count count_arguments(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  result_count = 1;
  myself = func__count_arguments;
  func = myself->type;
  frame->cont = cont__generate_c_arguments_2;
}
static void cont__generate_c_arguments_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* inputs_count */, arguments->slots[0]);
  // 116: ... :
  // 117:   if inputs_count.is_defined:
  // 118:     write "  argument_count += @(inputs_count);@nl;"
  frame->slots[4] /* temp__1 */ = create_closure(entry__generate_c_arguments_3, 0);
  // 119: :
  // 120:   write "
  // 121:     @
  // 122:       argument_count = @(default_value(inputs_count 0));
  // 123:       arguments = node_p;
  frame->slots[5] /* temp__2 */ = create_closure(entry__generate_c_arguments_9, 0);
  // 115: if
  // 116:   within_exit_function:
  // 117:     if inputs_count.is_defined:
  // 118:       write "  argument_count += @(inputs_count);@nl;"
  // 119:   :
  // 120:     write "
  // 121:       @
  // 122:         argument_count = @(default_value(inputs_count 0));
  // 123:         arguments = node_p;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* within_exit_function */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_14;
}
static void entry__generate_c_arguments_5(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 118: ... "  argument_count += @(inputs_count);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__a1d76a17b79c4b5;
  arguments->slots[1] = frame->slots[0] /* inputs_count */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_8;
}
static void cont__generate_c_arguments_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 118: write "  argument_count += @(inputs_count);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__generate_c_arguments_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 117: ... inputs_count.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* inputs_count */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_4;
}
static void cont__generate_c_arguments_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 117: ... :
  // 118:   write "  argument_count += @(inputs_count);@nl;"
  frame->slots[2] /* temp__2 */ = create_closure(entry__generate_c_arguments_5, 0);
  // 117: if inputs_count.is_defined:
  // 118:   write "  argument_count += @(inputs_count);@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__generate_c_arguments_9(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // inputs_count: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* inputs_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 122: ... default_value(inputs_count 0)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* inputs_count */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__default_value();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_10;
}
static void cont__generate_c_arguments_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 120: ... "
  // 121:   @
  // 122:     argument_count = @(default_value(inputs_count 0));
  // 123:     arguments = node_p;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__3892a143ae642f72;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__13889e43284fcd2b;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__generate_c_arguments_13;
}
static void cont__generate_c_arguments_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 120: write "
  // 121:   @
  // 122:     argument_count = @(default_value(inputs_count 0));
  // 123:     arguments = node_p;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__generate_c_arguments_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 124: $$idx 0
  ((CELL *)frame->slots[3])->contents /* idx */ = number__0;
  // 125: ... : (argument)
  // 126:   $src argument.to_c
  // 127:   cond
  // 128:     -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  // 129:     -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  // 130:     :
  // 131:       $slot_idx
  // 132:         if
  // 133:           inputs_count.is_defined
  // 134:           -> idx
  // ...
  frame->slots[4] /* temp__1 */ = create_closure(entry__generate_c_arguments_15, 1);
  // 125: for_each arguments: (argument)
  // 126:   $src argument.to_c
  // 127:   cond
  // 128:     -> argument.is_an_optional_item: write "  optional_item(@(src));@nl;"
  // 129:     -> argument.is_an_expanded_item: write "  unfold(@(src));@nl;"
  // 130:     :
  // 131:       $slot_idx
  // 132:         if
  // 133:           inputs_count.is_defined
  // 134:           -> idx
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_func_and_myself_18(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // cont: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* cont */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 151: ... "  frame->cont = @(cont);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__7c88f48f8c83734e;
  arguments->slots[1] = frame->slots[0] /* cont */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_20;
}
static void cont__get_func_and_myself_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 151: ... write "  frame->cont = @(cont);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_func_and_myself(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // functor: 0
  // cont: 1
  // insertion_line: 2
  // insertion: 3
  frame->slots[3] /* insertion */ = create_future();
  if (argument_count < 2) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[2] /* insertion_line */ = arguments->slots[2];
    case 2:;
  }
  switch(argument_count) {
    case 2: frame->slots[2] /* insertion_line */ = undefined;
  }
  // 141: ... : (indent)
  // 142:   if
  // 143:     insertion_line.is_defined
  // 144:     -> indented(indent string('@nl;' insertion_line))
  // 145:     -> ""
  frame->slots[4] /* temp__1 */ = create_closure(entry__get_func_and_myself_2, 1);
  // 141: $insertion: (indent)
  // 142:   if
  // 143:     insertion_line.is_defined
  // 144:     -> indented(indent string('@nl;' insertion_line))
  // 145:     -> ""
  initialize_future(frame->slots[3] /* insertion */, frame->slots[4] /* temp__1 */);
  // 149: ... functor.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_8;
}
static void entry__get_func_and_myself_4(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // indent: 0
  // insertion_line: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[1]; /* insertion_line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 144: ... string('@nl;' insertion_line)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* insertion_line */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_5;
}
static void cont__get_func_and_myself_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 144: ... indented(indent string('@nl;' insertion_line))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_6;
}
static void cont__get_func_and_myself_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 144: -> indented(indent string('@nl;' insertion_line))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_func_and_myself_7(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 145: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_func_and_myself_2(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // indent: 0
  // insertion_line: 1
  frame->slots[1] = myself->closure.frame->slots[2]; /* insertion_line */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 143: insertion_line.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* insertion_line */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_3;
}
static void cont__get_func_and_myself_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 144: -> indented(indent string('@nl;' insertion_line))
  frame->slots[3] /* temp__2 */ = create_closure(entry__get_func_and_myself_4, 0);
  // 142: if
  // 143:   insertion_line.is_defined
  // 144:   -> indented(indent string('@nl;' insertion_line))
  // 145:   -> ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = func__get_func_and_myself_7;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__get_func_and_myself_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 150: ... insertion(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[3] /* insertion */;
  func = myself->type;
  frame->cont = cont__get_func_and_myself_9;
}
static void cont__get_func_and_myself_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 147: ... "
  // 148:   @
  // 149:     myself = @(functor.to_c);
  // 150:     func = myself->type;@(insertion(2))
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__8c93215920e16830;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__b99451f7c76bbc46;
  arguments->slots[3] = frame->slots[6] /* temp__3 */;
  arguments->slots[4] = string__578a5af303e9ceb;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_13;
}
static void cont__get_func_and_myself_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 147: write "
  // 148:   @
  // 149:     myself = @(functor.to_c);
  // 150:     func = myself->type;@(insertion(2))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_14;
}
static void cont__get_func_and_myself_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 151: ... cont != "frame->cont"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* cont */;
  arguments->slots[1] = string__6c9a2bd2e7c4af5;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_16;
}
static void cont__get_func_and_myself_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 151: ... cont != "frame->cont"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__get_func_and_myself_17;
}
static void cont__get_func_and_myself_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 151: ... : write "  frame->cont = @(cont);@nl;"
  frame->slots[6] /* temp__3 */ = create_closure(entry__get_func_and_myself_18, 0);
  // 151: if cont != "frame->cont": write "  frame->cont = @(cont);@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // prefix: 0
  // destination: 1
  // src: 2
  // return: 3
  // dest: 4
  frame->slots[3] /* return */ = create_continuation();
  frame->slots[4] /* dest */ = create_future();
  if (argument_count < 2) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  frame->slots[2] /* src */ = arguments->slots[argument_count-1];
  frame->slots[1] /* destination */ = arguments->slots[argument_count-2];
  switch(argument_count) {
    default: frame->slots[0] /* prefix */ = arguments->slots[0];
    case 2:;
  }
  switch(argument_count) {
    case 2: frame->slots[0] /* prefix */ = string__2d7981f4e6082be5;
  }
  // 160: ... destination.is_a_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  result_count = 1;
  myself = get__is_a_definition();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_3;
}
static void cont__compiler__assignment_to_c_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 160: ... :
  // 161:   case variable_kind_of(destination)
  // 162:     STATIC_SINGLE:
  // 163:       if
  // 164:         destination.is_an_initialization:
  // 165:           return
  // 166:             "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 167:         :
  // 168:           return "@(prefix)@(destination.to_c) = @(src);@nl;"
  // 169:     DYNAMIC_SINGLE:
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__assignment_to_c_4, 0);
  // 160: if destination.is_a_definition:
  // 161:   case variable_kind_of(destination)
  // 162:     STATIC_SINGLE:
  // 163:       if
  // 164:         destination.is_an_initialization:
  // 165:           return
  // 166:             "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 167:         :
  // 168:           return "@(prefix)@(destination.to_c) = @(src);@nl;"
  // 169:     DYNAMIC_SINGLE:
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_36;
}
static void entry__compiler__assignment_to_c_31(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // return: 0
  // prefix: 1
  // mangled_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 181: ... "@(prefix)set__@(mangled_name)(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__405aee03eb312008;
  arguments->slots[2] = frame->slots[2] /* mangled_name */;
  arguments->slots[3] = string__578a5af303e9cc9;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_33;
}
static void cont__compiler__assignment_to_c_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 181: return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_34(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // return: 0
  // prefix: 1
  // mangled_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 183: ... "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__7280ac95052d00ff;
  arguments->slots[2] = frame->slots[2] /* mangled_name */;
  arguments->slots[3] = string__578a5af303e9cc9;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_35;
}
static void cont__compiler__assignment_to_c_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 183: return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_18(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // return: 0
  // prefix: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 173: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_19;
}
static void cont__compiler__assignment_to_c_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 173: "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__b4b0e7de47027f92;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = string__2d7981f4e6682be5;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_20;
}
static void cont__compiler__assignment_to_c_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 172: return
  // 173:   "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_21(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  // mangled_name: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  frame->slots[4] /* mangled_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 175: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_22;
}
static void cont__compiler__assignment_to_c_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 175: $mangled_name mangled_name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_23;
}
static void cont__compiler__assignment_to_c_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* mangled_name */, arguments->slots[0]);
  // 176: ... "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* prefix */;
  arguments->slots[1] = string__7280ac95052d00ff;
  arguments->slots[2] = frame->slots[4] /* mangled_name */;
  arguments->slots[3] = string__578a5af303e9cc9;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_26;
}
static void cont__compiler__assignment_to_c_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 176: return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_8(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // return: 0
  // prefix: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 166: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_9;
}
static void cont__compiler__assignment_to_c_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 166: "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__b4b0e7de47027f92;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = string__2d7981f4e6682be5;
  arguments->slots[4] = frame->slots[3] /* src */;
  arguments->slots[5] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_11;
}
static void cont__compiler__assignment_to_c_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 165: return
  // 166:   "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_12(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // return: 0
  // prefix: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 168: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_13;
}
static void cont__compiler__assignment_to_c_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 168: ... "@(prefix)@(destination.to_c) = @(src);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__fa730415fc16bec;
  arguments->slots[3] = frame->slots[3] /* src */;
  arguments->slots[4] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_15;
}
static void cont__compiler__assignment_to_c_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 168: return "@(prefix)@(destination.to_c) = @(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_6(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 164: destination.is_an_initialization
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__is_an_initialization();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_7;
}
static void cont__compiler__assignment_to_c_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 164: ... :
  // 165:   return
  // 166:     "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__assignment_to_c_8, 0);
  // 167: :
  // 168:   return "@(prefix)@(destination.to_c) = @(src);@nl;"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__assignment_to_c_12, 0);
  // 163: if
  // 164:   destination.is_an_initialization:
  // 165:     return
  // 166:       "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 167:   :
  // 168:     return "@(prefix)@(destination.to_c) = @(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_16(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 171: destination.is_an_initialization
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__is_an_initialization();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_17;
}
static void cont__compiler__assignment_to_c_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 171: ... :
  // 172:   return
  // 173:     "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__assignment_to_c_18, 0);
  // 174: :
  // 175:   $mangled_name mangled_name_of(identifier_of(destination))
  // 176:   return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__assignment_to_c_21, 0);
  // 170: if
  // 171:   destination.is_an_initialization:
  // 172:     return
  // 173:       "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 174:   :
  // 175:     $mangled_name mangled_name_of(identifier_of(destination))
  // 176:     return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_27(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  // mangled_name: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] = myself->closure.frame->slots[2]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[3]; /* src */
  frame->slots[4] /* mangled_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 178: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_28;
}
static void cont__compiler__assignment_to_c_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 178: $mangled_name mangled_name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_29;
}
static void cont__compiler__assignment_to_c_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* mangled_name */, arguments->slots[0]);
  // 180: destination.is_an_initialization
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__is_an_initialization();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_30;
}
static void cont__compiler__assignment_to_c_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 180: ... :
  // 181:   return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__assignment_to_c_31, 0);
  // 182: :
  // 183:   return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__assignment_to_c_34, 0);
  // 179: if
  // 180:   destination.is_an_initialization:
  // 181:     return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  // 182:   :
  // 183:     return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__assignment_to_c_4(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // destination: 0
  // return: 1
  // prefix: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* return */
  frame->slots[2] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[2]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 161: ... variable_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_5;
}
static void cont__compiler__assignment_to_c_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 162: ... :
  // 163:   if
  // 164:     destination.is_an_initialization:
  // 165:       return
  // 166:         "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 167:     :
  // 168:       return "@(prefix)@(destination.to_c) = @(src);@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__assignment_to_c_6, 0);
  // 169: ... :
  // 170:   if
  // 171:     destination.is_an_initialization:
  // 172:       return
  // 173:         "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 174:     :
  // 175:       $mangled_name mangled_name_of(identifier_of(destination))
  // 176:       return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__assignment_to_c_16, 0);
  // 177: ... :
  // 178:   $mangled_name mangled_name_of(identifier_of(destination))
  // 179:   if
  // 180:     destination.is_an_initialization:
  // 181:       return "@(prefix)set__@(mangled_name)(@(src));@nl;"
  // 182:     :
  // 183:       return "@(prefix)define__@(mangled_name)(@(src));@nl;"
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__assignment_to_c_27, 0);
  // 161: case variable_kind_of(destination)
  // 162:   STATIC_SINGLE:
  // 163:     if
  // 164:       destination.is_an_initialization:
  // 165:         return
  // 166:           "@(prefix)initialize_future(@(destination.to_c), @(src));@nl;"
  // 167:       :
  // 168:         return "@(prefix)@(destination.to_c) = @(src);@nl;"
  // 169:   DYNAMIC_SINGLE:
  // 170:     if
  // ...
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = get__DYNAMIC_SINGLE();
  arguments->slots[4] = frame->slots[6] /* temp__3 */;
  arguments->slots[5] = get__DYNAMIC_MULTI();
  arguments->slots[6] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__assignment_to_c_36(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 184: $dest destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_37;
}
static void cont__compiler__assignment_to_c_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* dest */, arguments->slots[0]);
  // 186: dest .has_prefix. "get_"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* dest */;
  arguments->slots[1] = string__c0ae80b5dc07d66;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_39;
}
static void cont__compiler__assignment_to_c_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 187: -> "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__assignment_to_c_40, 0);
  // 188: -> "@(prefix)@(dest) = @(src);@nl;"
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__assignment_to_c_45, 0);
  // 185: if
  // 186:   dest .has_prefix. "get_"
  // 187:   -> "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  // 188:   -> "@(prefix)@(dest) = @(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_47;
}
static void entry__compiler__assignment_to_c_40(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // prefix: 0
  // dest: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[4]; /* dest */
  frame->slots[2] = myself->closure.frame->slots[2]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 187: ... 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__3;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_41;
}
static void cont__compiler__assignment_to_c_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 187: ... range(dest 5 -3)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* dest */;
  arguments->slots[1] = number__5;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_42;
}
static void cont__compiler__assignment_to_c_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 187: ... "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  arguments->slots[1] = string__240ae80b5dc07d66;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  arguments->slots[3] = string__578a5af303e9cc9;
  arguments->slots[4] = frame->slots[2] /* src */;
  arguments->slots[5] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_44;
}
static void cont__compiler__assignment_to_c_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 187: -> "@(prefix)set_@(range(dest 5 -3))(@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__assignment_to_c_45(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // prefix: 0
  // dest: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[4]; /* dest */
  frame->slots[2] = myself->closure.frame->slots[2]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 188: ... "@(prefix)@(dest) = @(src);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  arguments->slots[1] = frame->slots[1] /* dest */;
  arguments->slots[2] = string__fa730415fc16bec;
  arguments->slots[3] = frame->slots[2] /* src */;
  arguments->slots[4] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__assignment_to_c_46;
}
static void cont__compiler__assignment_to_c_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 188: -> "@(prefix)@(dest) = @(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__assignment_to_c_47(void) {
  myself = frame->slots[3] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__assign_argument_or_result_7(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // prefix: 1
  // src: 2
  // name: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[2] = myself->closure.frame->slots[3]; /* src */
  frame->slots[3] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 199: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_8;
}
static void cont__assign_argument_or_result_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 199: $name name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_9;
}
static void cont__assign_argument_or_result_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* name */, arguments->slots[0]);
  // 201: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_10;
}
static void cont__assign_argument_or_result_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 200: ... "
  // 201:   @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 202:   create_cell_with_contents(@(src));@nl;@
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = string__9d12bd49b1f09f10;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = string__ca5af8c3e89bc077;
  arguments->slots[4] = frame->slots[3] /* name */;
  arguments->slots[5] = string__64bada731157029;
  arguments->slots[6] = frame->slots[2] /* src */;
  arguments->slots[7] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_14;
}
static void cont__assign_argument_or_result_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 200: write "
  // 201:   @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 202:   create_cell_with_contents(@(src));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign_argument_or_result_15(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // prefix: 0
  // destination: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[2] = myself->closure.frame->slots[3]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 204: ... assignment_to_c(prefix destination src)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  arguments->slots[1] = frame->slots[1] /* destination */;
  arguments->slots[2] = frame->slots[2] /* src */;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_16;
}
static void cont__assign_argument_or_result_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 204: write assignment_to_c(prefix destination src)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign_argument_or_result(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // prefix: 0
  // kind: 1
  // destination: 2
  // src: 3
  if (argument_count < 3) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 4) {
    too_many_arguments_error();
    return;
  }
  frame->slots[3] /* src */ = arguments->slots[argument_count-1];
  frame->slots[2] /* destination */ = arguments->slots[argument_count-2];
  frame->slots[1] /* kind */ = arguments->slots[argument_count-3];
  switch(argument_count) {
    default: frame->slots[0] /* prefix */ = arguments->slots[0];
    case 3:;
  }
  switch(argument_count) {
    case 3: frame->slots[0] /* prefix */ = string__2d7981f4e6082be5;
  }
  // 198: destination.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_2;
}
static void cont__assign_argument_or_result_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 198: ... kind == "arguments"
  frame->slots[6] /* temp__3 */ = create_closure(entry__assign_argument_or_result_3, 0);
  // 198: destination.is_a_multi_assign_definition && kind == "arguments"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_6;
}
static void entry__assign_argument_or_result_3(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 198: ... kind == "arguments"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = string__64ac252603a3a696;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__assign_argument_or_result_5;
}
static void cont__assign_argument_or_result_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 198: ... kind == "arguments"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__assign_argument_or_result_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 198: ... :
  // 199:   $name name_of(identifier_of(destination))
  // 200:   write "
  // 201:     @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 202:     create_cell_with_contents(@(src));@nl;@
  frame->slots[7] /* temp__4 */ = create_closure(entry__assign_argument_or_result_7, 0);
  // 203: :
  // 204:   write assignment_to_c(prefix destination src)
  frame->slots[8] /* temp__5 */ = create_closure(entry__assign_argument_or_result_15, 0);
  // 197: if
  // 198:   destination.is_a_multi_assign_definition && kind == "arguments":
  // 199:     $name name_of(identifier_of(destination))
  // 200:     write "
  // 201:       @(prefix)frame->slots[@(current_locals(name))] /* @(name) */ = @
  // 202:       create_cell_with_contents(@(src));@nl;@
  // 203:   :
  // 204:     write assignment_to_c(prefix destination src)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_137(void) {
  allocate_initialized_frame_gc(5, 11);
  // slot allocations:
  // idx: 0
  // outputs: 1
  // kind: 2
  // indices: 3
  // right_count: 4
  // output: 5
  // default_value: 6
  // cont_idx: 7
  frame->slots[1] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[5]; /* kind */
  frame->slots[3] = myself->closure.frame->slots[3]; /* indices */
  frame->slots[4] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[5] /* output */ = create_future();
  frame->slots[6] /* default_value */ = create_future();
  frame->slots[7] /* cont_idx */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 329: $output outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__extract_138;
}
static void cont__extract_138(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* output */, arguments->slots[0]);
  // 330: $default_value default_value_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* output */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__extract_139;
}
static void cont__extract_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* default_value */, arguments->slots[0]);
  // 332: default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__extract_140;
}
static void cont__extract_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 332: ... :
  // 333:   if
  // 334:     default_value.is_a_function_call:
  // 335:       for_each statements_of(output): (statement)
  // 336:         generate_statement statement
  // 337:     :
  // 338:       assign_argument_or_result kind output default_value.to_c
  frame->slots[9] /* temp__2 */ = create_closure(entry__extract_141, 0);
  // 339: :
  // 340:   assign_argument_or_result kind output "undefined"
  frame->slots[10] /* temp__3 */ = create_closure(entry__extract_148, 0);
  // 331: if
  // 332:   default_value.is_defined:
  // 333:     if
  // 334:       default_value.is_a_function_call:
  // 335:         for_each statements_of(output): (statement)
  // 336:           generate_statement statement
  // 337:       :
  // 338:         assign_argument_or_result kind output default_value.to_c
  // 339:   :
  // 340:     assign_argument_or_result kind output "undefined"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_150;
}
static void entry__extract_145(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // statement: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 336: generate_statement statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = frame->caller_result_count;
  myself = get__generate_statement();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_143(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // output: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* output */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 335: ... statements_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__extract_144;
}
static void cont__extract_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 335: for_each statements_of(output): (statement)
  // 336:   generate_statement statement
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__extract_145;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_146(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // kind: 0
  // output: 1
  // default_value: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output */
  frame->slots[2] = myself->closure.frame->slots[0]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 338: ... default_value.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* default_value */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__extract_147;
}
static void cont__extract_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 338: assign_argument_or_result kind output default_value.to_c
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[1] /* output */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_141(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // default_value: 0
  // output: 1
  // kind: 2
  frame->slots[0] = myself->closure.frame->slots[6]; /* default_value */
  frame->slots[1] = myself->closure.frame->slots[5]; /* output */
  frame->slots[2] = myself->closure.frame->slots[2]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 334: default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__extract_142;
}
static void cont__extract_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 334: ... :
  // 335:   for_each statements_of(output): (statement)
  // 336:     generate_statement statement
  frame->slots[4] /* temp__2 */ = create_closure(entry__extract_143, 0);
  // 337: :
  // 338:   assign_argument_or_result kind output default_value.to_c
  frame->slots[5] /* temp__3 */ = create_closure(entry__extract_146, 0);
  // 333: if
  // 334:   default_value.is_a_function_call:
  // 335:     for_each statements_of(output): (statement)
  // 336:       generate_statement statement
  // 337:   :
  // 338:     assign_argument_or_result kind output default_value.to_c
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_148(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // kind: 0
  // output: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[5]; /* output */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 340: assign_argument_or_result kind output "undefined"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[1] /* output */;
  arguments->slots[2] = string__7ca0252e172b1501;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_150(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 341: ... idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[4])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_151;
}
static void cont__extract_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 341: $cont_idx indices(idx+right_count)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* indices */;
  func = myself->type;
  frame->cont = cont__extract_152;
}
static void cont__extract_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* cont_idx */, arguments->slots[0]);
  // 342: ... "
  // 343:     func = cont@(suffix)_@(cont_idx);
  // 344:   }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__456a7fcebab856fe;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = frame->slots[7] /* cont_idx */;
  arguments->slots[4] = string__b40af3cb5d887d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_155;
}
static void cont__extract_155(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 342: write "
  // 343:     func = cont@(suffix)_@(cont_idx);
  // 344:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__extract_156;
}
static void cont__extract_156(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 345: ... "cont@(suffix)_@(cont_idx)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40aea8b5d107d4d;
  arguments->slots[1] = get__suffix();
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = frame->slots[7] /* cont_idx */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_158;
}
static void cont__extract_158(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 345: next_continuation "cont@(suffix)_@(cont_idx)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__next_continuation();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_113(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // total_count: 0
  // right_count: 1
  // fixed_count: 2
  // indices: 3
  // outputs: 4
  // kind: 5
  frame->slots[0] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[3] = myself->closure.frame->slots[6]; /* indices */
  frame->slots[4] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[5] = myself->closure.frame->slots[3]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 308: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_114;
}
static void cont__extract_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 308: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_115;
}
static void cont__extract_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 308: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_116;
}
static void cont__extract_116(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 308: ... : (idx)
  // 309:   $n idx+right_count
  // 310:   
  // 311:   $cnt
  // 312:     if
  // 313:       n == total_count
  // 314:       -> "default"
  // 315:       -> "case @(n)"
  // 316:   
  // 317:   inc &index
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__extract_117, 1);
  // 308: from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 309:   $n idx+right_count
  // 310:   
  // 311:   $cnt
  // 312:     if
  // 313:       n == total_count
  // 314:       -> "default"
  // 315:       -> "case @(n)"
  // 316:   
  // 317:   inc &index
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = 0;
  myself = get__from_down_to();
  func = myself->type;
  frame->cont = cont__extract_130;
}
static void entry__extract_117(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // idx: 0
  // right_count: 1
  // total_count: 2
  // indices: 3
  // n: 4
  // cnt: 5
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[3]; /* indices */
  frame->slots[4] /* n */ = create_future();
  frame->slots[5] /* cnt */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 309: $n idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_118;
}
static void cont__extract_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* n */, arguments->slots[0]);
  // 313: n == total_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* n */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_count */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__extract_119;
}
static void cont__extract_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 315: -> "case @(n)"
  frame->slots[7] /* temp__2 */ = create_closure(entry__extract_120, 0);
  // 311: $cnt
  // 312:   if
  // 313:     n == total_count
  // 314:     -> "default"
  // 315:     -> "case @(n)"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = func__extract_122;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_123;
}
static void entry__extract_120(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // n: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 315: ... "case @(n)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__485aefc3eae02077;
  arguments->slots[1] = frame->slots[0] /* n */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_121;
}
static void cont__extract_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 315: -> "case @(n)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_122(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 314: -> "default"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b014089015daa08e;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_123(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* cnt */, arguments->slots[0]);
  // 317: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__extract_124;
}
static void cont__extract_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 318: !indices(n)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* n */;
  arguments->slots[1] = get__index();
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* indices */;
  func = myself->type;
  frame->cont = cont__extract_125;
}
static void cont__extract_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* indices */ = arguments->slots[0];
  // 319: ... "
  // 320:   @
  // 321:       @(cnt):
  // 322:         func = cont@(suffix)_@(index);
  // 323:         return;
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__820af94b5f607d19;
  arguments->slots[1] = frame->slots[5] /* cnt */;
  arguments->slots[2] = string__3d6fbe7ddbf3d274;
  arguments->slots[3] = get__suffix();
  arguments->slots[4] = string__578a5af303e9cbe;
  arguments->slots[5] = get__index();
  arguments->slots[6] = string__1392ca21613062f7;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_129;
}
static void cont__extract_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 319: write "
  // 320:   @
  // 321:       @(cnt):
  // 322:         func = cont@(suffix)_@(index);
  // 323:         return;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_130(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 324: ... "
  // 325:   @
  // 326:       case @(fixed_count):;
  // 327:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__6db0224cc22b4c85;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[2] = string__336c1dff155460f0;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_132;
}
static void cont__extract_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 324: write "
  // 325:   @
  // 326:       case @(fixed_count):;
  // 327:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__extract_133;
}
static void cont__extract_133(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 328: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_134;
}
static void cont__extract_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 328: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_135;
}
static void cont__extract_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 328: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_136;
}
static void cont__extract_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 328: ... : (idx)
  // 329:   $output outputs(idx)
  // 330:   $default_value default_value_of(output)
  // 331:   if
  // 332:     default_value.is_defined:
  // 333:       if
  // 334:         default_value.is_a_function_call:
  // 335:           for_each statements_of(output): (statement)
  // 336:             generate_statement statement
  // 337:         :
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__extract_137, 1);
  // 328: from_to fixed_count-right_count+1 total_count-right_count: (idx)
  // 329:   $output outputs(idx)
  // 330:   $default_value default_value_of(output)
  // 331:   if
  // 332:     default_value.is_defined:
  // 333:       if
  // 334:         default_value.is_a_function_call:
  // 335:           for_each statements_of(output): (statement)
  // 336:             generate_statement statement
  // 337:         :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__from_to();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_159(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // fixed_count: 0
  // right_count: 1
  // total_count: 2
  // outputs: 3
  // kind: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[4] = myself->closure.frame->slots[3]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 347: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_160;
}
static void cont__extract_160(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 347: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_161;
}
static void cont__extract_161(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 347: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_162;
}
static void cont__extract_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 347: ... : (idx)
  // 348:   $output outputs(idx)
  // 349:   $default_value default_value_of(output)
  // 350:   
  // 351:   $value
  // 352:     if
  // 353:       default_value.is_defined
  // 354:       -> default_value.to_c
  // 355:       -> "undefined"
  // 356:   
  // ...
  frame->slots[8] /* temp__4 */ = create_closure(entry__extract_163, 1);
  // 347: from_to fixed_count-right_count+1 total_count-right_count: (idx)
  // 348:   $output outputs(idx)
  // 349:   $default_value default_value_of(output)
  // 350:   
  // 351:   $value
  // 352:     if
  // 353:       default_value.is_defined
  // 354:       -> default_value.to_c
  // 355:       -> "undefined"
  // 356:   
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  arguments->slots[2] = frame->slots[8] /* temp__4 */;
  result_count = 0;
  myself = get__from_to();
  func = myself->type;
  frame->cont = cont__extract_174;
}
static void entry__extract_163(void) {
  allocate_initialized_frame_gc(4, 10);
  // slot allocations:
  // idx: 0
  // outputs: 1
  // right_count: 2
  // kind: 3
  // output: 4
  // default_value: 5
  // value: 6
  frame->slots[1] = myself->closure.frame->slots[3]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[3] = myself->closure.frame->slots[4]; /* kind */
  frame->slots[4] /* output */ = create_future();
  frame->slots[5] /* default_value */ = create_future();
  frame->slots[6] /* value */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 348: $output outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__extract_164;
}
static void cont__extract_164(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* output */, arguments->slots[0]);
  // 349: $default_value default_value_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* output */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__extract_165;
}
static void cont__extract_165(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* default_value */, arguments->slots[0]);
  // 353: default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__extract_166;
}
static void cont__extract_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 354: -> default_value.to_c
  frame->slots[8] /* temp__2 */ = create_closure(entry__extract_167, 0);
  // 351: $value
  // 352:   if
  // 353:     default_value.is_defined
  // 354:     -> default_value.to_c
  // 355:     -> "undefined"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = func__extract_169;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_170;
}
static void entry__extract_167(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // default_value: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 354: ... default_value.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__extract_168;
}
static void cont__extract_168(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 354: -> default_value.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_169(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 355: -> "undefined"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__7ca0252e172b1501;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_170(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* value */, arguments->slots[0]);
  // 358: ... idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_171;
}
static void cont__extract_171(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 358: ... idx+right_count-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_172;
}
static void cont__extract_172(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 358: "    case @(idx+right_count-1): "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__6db0224cc22b4c85;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6d82be5;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_173;
}
static void cont__extract_173(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 357: assign_argument_or_result
  // 358:   "    case @(idx+right_count-1): "
  // 359:   kind
  // 360:   output
  // 361:   value
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* kind */;
  arguments->slots[2] = frame->slots[4] /* output */;
  arguments->slots[3] = frame->slots[6] /* value */;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_174(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 362: write "
  // 363:   @
  // 364:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__820af94b5d887d33;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_87(void) {
  allocate_initialized_frame_gc(6, 11);
  // slot allocations:
  // total_count: 0
  // right_count: 1
  // fixed_count: 2
  // kind: 3
  // outputs: 4
  // has_complex_default_values: 5
  // indices: 6
  frame->slots[0] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[4]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[3] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[4] = myself->closure.frame->slots[1]; /* outputs */
  frame->slots[5] = myself->closure.frame->slots[6]; /* has_complex_default_values */
  frame->slots[6] /* indices */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 283: write "
  // 284:   @
  // 285:     switch(argument_count) {
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__fcf46690a35325f6;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__extract_89;
}
static void cont__extract_89(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 286: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_90;
}
static void cont__extract_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 286: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_91;
}
static void cont__extract_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 286: ... fixed_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_92;
}
static void cont__extract_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 286: ... : (idx)
  // 287:   $n idx+right_count
  // 288:   
  // 289:   $cnt
  // 290:     if
  // 291:       n == total_count
  // 292:       -> "default"
  // 293:       -> "case @(n)"
  // 294:   
  // 295:   assign_argument_or_result
  // ...
  frame->slots[10] /* temp__4 */ = create_closure(entry__extract_93, 1);
  // 286: from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 287:   $n idx+right_count
  // 288:   
  // 289:   $cnt
  // 290:     if
  // 291:       n == total_count
  // 292:       -> "default"
  // 293:       -> "case @(n)"
  // 294:   
  // 295:   assign_argument_or_result
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__from_down_to();
  func = myself->type;
  frame->cont = cont__extract_108;
}
static void entry__extract_93(void) {
  allocate_initialized_frame_gc(5, 11);
  // slot allocations:
  // idx: 0
  // right_count: 1
  // total_count: 2
  // kind: 3
  // outputs: 4
  // n: 5
  // cnt: 6
  frame->slots[1] = myself->closure.frame->slots[1]; /* right_count */
  frame->slots[2] = myself->closure.frame->slots[0]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[3]; /* kind */
  frame->slots[4] = myself->closure.frame->slots[4]; /* outputs */
  frame->slots[5] /* n */ = create_future();
  frame->slots[6] /* cnt */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 287: $n idx+right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* right_count */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_94;
}
static void cont__extract_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* n */, arguments->slots[0]);
  // 291: n == total_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* n */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_count */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__extract_95;
}
static void cont__extract_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 293: -> "case @(n)"
  frame->slots[8] /* temp__2 */ = create_closure(entry__extract_96, 0);
  // 289: $cnt
  // 290:   if
  // 291:     n == total_count
  // 292:     -> "default"
  // 293:     -> "case @(n)"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__extract_99;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_101;
}
static void entry__extract_96(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // n: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 293: ... "case @(n)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__485aefc3eae02077;
  arguments->slots[1] = frame->slots[0] /* n */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_98;
}
static void cont__extract_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 293: -> "case @(n)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_99(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 292: -> "default"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b014089015daa08e;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* cnt */, arguments->slots[0]);
  // 296: "    @(cnt): "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__820af94b5f607d19;
  arguments->slots[1] = frame->slots[6] /* cnt */;
  arguments->slots[2] = string__2d7981f4e6d82be5;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_104;
}
static void cont__extract_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 298: outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[4] /* outputs */;
  func = myself->type;
  frame->cont = cont__extract_105;
}
static void cont__extract_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 299: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_106;
}
static void cont__extract_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__4 */ = arguments->slots[0];
  // 299: "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__f8fbbe9f15fa69de;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = string__578a5af303e9cbc;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_107;
}
static void cont__extract_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 295: assign_argument_or_result
  // 296:   "    @(cnt): "
  // 297:   kind
  // 298:   outputs(idx)
  // 299:   "arguments->slots[@(idx-1)]"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* kind */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  arguments->slots[3] = frame->slots[9] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_108(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 300: ... "
  // 301:   @
  // 302:       case @(fixed_count):;
  // 303:     }
  // 304:     switch(argument_count) {
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__6db0224cc22b4c85;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[2] = string__3d141c30a0902819;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_111;
}
static void cont__extract_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 300: write "
  // 301:   @
  // 302:       case @(fixed_count):;
  // 303:     }
  // 304:     switch(argument_count) {
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__extract_112;
}
static void cont__extract_112(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 305: $$indices empty_table
  ((CELL *)frame->slots[6])->contents /* indices */ = get__empty_table();
  // 307: ... :
  // 308:   from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 309:     $n idx+right_count
  // 310:     
  // 311:     $cnt
  // 312:       if
  // 313:         n == total_count
  // 314:         -> "default"
  // 315:         -> "case @(n)"
  // 316:     
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__extract_113, 0);
  // 346: :
  // 347:   from_to fixed_count-right_count+1 total_count-right_count: (idx)
  // 348:     $output outputs(idx)
  // 349:     $default_value default_value_of(output)
  // 350:     
  // 351:     $value
  // 352:       if
  // 353:         default_value.is_defined
  // 354:         -> default_value.to_c
  // 355:         -> "undefined"
  // ...
  frame->slots[8] /* temp__2 */ = create_closure(entry__extract_159, 0);
  // 306: if
  // 307:   has_complex_default_values:
  // 308:     from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 309:       $n idx+right_count
  // 310:       
  // 311:       $cnt
  // 312:         if
  // 313:           n == total_count
  // 314:           -> "default"
  // 315:           -> "case @(n)"
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* has_complex_default_values */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract(void) {
  allocate_initialized_frame_gc(2, 11);
  // slot allocations:
  // kind: 0
  // outputs: 1
  // fixed_count: 2
  // total_count: 3
  // right_count: 4
  // unlimited: 5
  // has_complex_default_values: 6
  frame->slots[2] /* fixed_count */ = create_cell();
  frame->slots[3] /* total_count */ = create_cell();
  frame->slots[4] /* right_count */ = create_cell();
  frame->slots[5] /* unlimited */ = create_cell();
  frame->slots[6] /* has_complex_default_values */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 211: $$fixed_count 0
  ((CELL *)frame->slots[2])->contents /* fixed_count */ = number__0;
  // 212: $$total_count 0
  ((CELL *)frame->slots[3])->contents /* total_count */ = number__0;
  // 213: $$right_count 0
  ((CELL *)frame->slots[4])->contents /* right_count */ = number__0;
  // 214: $$unlimited false
  ((CELL *)frame->slots[5])->contents /* unlimited */ = get__false();
  // 215: $$has_complex_default_values false
  ((CELL *)frame->slots[6])->contents /* has_complex_default_values */ = get__false();
  // 216: ... : (output)
  // 217:   cond
  // 218:     -> output.is_an_optional_item:
  // 219:       inc &total_count
  // 220:       $default_value default_value_of(output)
  // 221:       if default_value.is_defined && default_value.is_a_function_call:
  // 222:         !has_complex_default_values true
  // 223:     -> output.is_an_expanded_item: !unlimited true
  // 224:     :
  // 225:       inc &fixed_count
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__extract_2, 1);
  // 216: for_each outputs: (output)
  // 217:   cond
  // 218:     -> output.is_an_optional_item:
  // 219:       inc &total_count
  // 220:       $default_value default_value_of(output)
  // 221:       if default_value.is_defined && default_value.is_a_function_call:
  // 222:         !has_complex_default_values true
  // 223:     -> output.is_an_expanded_item: !unlimited true
  // 224:     :
  // 225:       inc &fixed_count
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* outputs */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__extract_24;
}
static void entry__extract_22(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // right_count: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* right_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 227: ... inc &right_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__extract_23;
}
static void cont__extract_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right_count */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_15(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // unlimited: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* unlimited */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 223: ... !unlimited true
  ((CELL *)frame->slots[0])->contents /* unlimited */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_12(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 222: !has_complex_default_values true
  ((CELL *)frame->slots[0])->contents /* has_complex_default_values */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_5(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // total_count: 0
  // output: 1
  // has_complex_default_values: 2
  // default_value: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[0]; /* output */
  frame->slots[2] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  frame->slots[3] /* default_value */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 219: inc &total_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__extract_6;
}
static void cont__extract_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_count */ = arguments->slots[0];
  // 220: $default_value default_value_of(output)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* output */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__extract_7;
}
static void cont__extract_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* default_value */, arguments->slots[0]);
  // 221: ... default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__extract_8;
}
static void cont__extract_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 221: ... default_value.is_a_function_call
  frame->slots[6] /* temp__3 */ = create_closure(entry__extract_9, 0);
  // 221: ... default_value.is_defined && default_value.is_a_function_call
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__extract_11;
}
static void entry__extract_9(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // default_value: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 221: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__extract_10;
}
static void cont__extract_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 221: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 221: ... :
  // 222:   !has_complex_default_values true
  frame->slots[7] /* temp__4 */ = create_closure(entry__extract_12, 0);
  // 221: if default_value.is_defined && default_value.is_a_function_call:
  // 222:   !has_complex_default_values true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_3(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // output: 0
  // total_count: 1
  // has_complex_default_values: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* output */
  frame->slots[1] = myself->closure.frame->slots[1]; /* total_count */
  frame->slots[2] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 218: ... output.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__extract_4;
}
static void cont__extract_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 218: ... :
  // 219:   inc &total_count
  // 220:   $default_value default_value_of(output)
  // 221:   if default_value.is_defined && default_value.is_a_function_call:
  // 222:     !has_complex_default_values true
  frame->slots[4] /* temp__2 */ = create_closure(entry__extract_5, 0);
  // 218: -> output.is_an_optional_item:
  // 219:   inc &total_count
  // 220:   $default_value default_value_of(output)
  // 221:   if default_value.is_defined && default_value.is_a_function_call:
  // 222:     !has_complex_default_values true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_13(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // output: 0
  // unlimited: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* output */
  frame->slots[1] = myself->closure.frame->slots[3]; /* unlimited */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 223: ... output.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__extract_14;
}
static void cont__extract_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 223: ... : !unlimited true
  frame->slots[3] /* temp__2 */ = create_closure(entry__extract_15, 0);
  // 223: -> output.is_an_expanded_item: !unlimited true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_16(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // fixed_count: 0
  // total_count: 1
  // unlimited: 2
  // right_count: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* total_count */
  frame->slots[2] = myself->closure.frame->slots[3]; /* unlimited */
  frame->slots[3] = myself->closure.frame->slots[5]; /* right_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 225: inc &fixed_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__extract_17;
}
static void cont__extract_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* fixed_count */ = arguments->slots[0];
  // 226: inc &total_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* total_count */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__extract_18;
}
static void cont__extract_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* total_count */ = arguments->slots[0];
  // 227: ... total_count > fixed_count
  frame->slots[5] /* temp__2 */ = create_closure(entry__extract_19, 0);
  // 227: ... unlimited || total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__extract_21;
}
static void entry__extract_19(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // total_count: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* total_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 227: ... total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* total_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__extract_20;
}
static void cont__extract_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 227: ... total_count > fixed_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 227: ... : inc &right_count
  frame->slots[6] /* temp__3 */ = create_closure(entry__extract_22, 0);
  // 227: if unlimited || total_count > fixed_count: inc &right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_2(void) {
  allocate_initialized_frame_gc(6, 9);
  // slot allocations:
  // output: 0
  // total_count: 1
  // has_complex_default_values: 2
  // unlimited: 3
  // fixed_count: 4
  // right_count: 5
  frame->slots[1] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[2] = myself->closure.frame->slots[6]; /* has_complex_default_values */
  frame->slots[3] = myself->closure.frame->slots[5]; /* unlimited */
  frame->slots[4] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[5] = myself->closure.frame->slots[4]; /* right_count */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 218: -> output.is_an_optional_item:
  // 219:   inc &total_count
  // 220:   $default_value default_value_of(output)
  // 221:   if default_value.is_defined && default_value.is_a_function_call:
  // 222:     !has_complex_default_values true
  frame->slots[6] /* temp__1 */ = create_closure(entry__extract_3, 0);
  // 223: -> output.is_an_expanded_item: !unlimited true
  frame->slots[7] /* temp__2 */ = create_closure(entry__extract_13, 0);
  // 224: :
  // 225:   inc &fixed_count
  // 226:   inc &total_count
  // 227:   if unlimited || total_count > fixed_count: inc &right_count
  frame->slots[8] /* temp__3 */ = create_closure(entry__extract_16, 0);
  // 217: cond
  // 218:   -> output.is_an_optional_item:
  // 219:     inc &total_count
  // 220:     $default_value default_value_of(output)
  // 221:     if default_value.is_defined && default_value.is_a_function_call:
  // 222:       !has_complex_default_values true
  // 223:   -> output.is_an_expanded_item: !unlimited true
  // 224:   :
  // 225:     inc &fixed_count
  // 226:     inc &total_count
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_24(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 229: ... total_count > fixed_count
  frame->slots[8] /* temp__2 */ = create_closure(entry__extract_25, 0);
  // 229: unlimited || total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__extract_27;
}
static void entry__extract_25(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // total_count: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[3]; /* total_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 229: ... total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* total_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__extract_26;
}
static void cont__extract_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 229: ... total_count > fixed_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 229: ... :
  // 230:   if fixed_count > 0:
  // 231:     write "
  // 232:       @
  // 233:         if (argument_count < @(fixed_count)) {
  // 234:           too_few_@(kind)_error();
  // 235:           return;
  // 236:         }
  // 237:   unless unlimited:
  // 238:     write "
  // ...
  frame->slots[9] /* temp__3 */ = create_closure(entry__extract_28, 0);
  // 244: :
  // 245:   write "
  // 246:     @
  // 247:       if (argument_count != @(fixed_count)) {
  // 248:         invalid_@(kind)_error();
  // 249:         return;
  // 250:       }
  frame->slots[10] /* temp__4 */ = create_closure(entry__extract_40, 0);
  // 228: if
  // 229:   unlimited || total_count > fixed_count:
  // 230:     if fixed_count > 0:
  // 231:       write "
  // 232:         @
  // 233:           if (argument_count < @(fixed_count)) {
  // 234:             too_few_@(kind)_error();
  // 235:             return;
  // 236:           }
  // 237:     unless unlimited:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_44;
}
static void entry__extract_36(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // total_count: 0
  // kind: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 238: ... "
  // 239:   @
  // 240:     if (argument_count > @(total_count)) {
  // 241:       too_many_@(kind)_error();
  // 242:       return;
  // 243:     }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__3a411e083cfe7a1;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* total_count */;
  arguments->slots[2] = string__5a751cd352200189;
  arguments->slots[3] = frame->slots[1] /* kind */;
  arguments->slots[4] = string__46700f340c500fa1;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_39;
}
static void cont__extract_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 238: write "
  // 239:   @
  // 240:     if (argument_count > @(total_count)) {
  // 241:       too_many_@(kind)_error();
  // 242:       return;
  // 243:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_28(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // fixed_count: 0
  // kind: 1
  // unlimited: 2
  // total_count: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[2] = myself->closure.frame->slots[5]; /* unlimited */
  frame->slots[3] = myself->closure.frame->slots[3]; /* total_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 230: ... fixed_count > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__extract_29;
}
static void cont__extract_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 230: ... :
  // 231:   write "
  // 232:     @
  // 233:       if (argument_count < @(fixed_count)) {
  // 234:         too_few_@(kind)_error();
  // 235:         return;
  // 236:       }
  frame->slots[5] /* temp__2 */ = create_closure(entry__extract_30, 0);
  // 230: if fixed_count > 0:
  // 231:   write "
  // 232:     @
  // 233:       if (argument_count < @(fixed_count)) {
  // 234:         too_few_@(kind)_error();
  // 235:         return;
  // 236:       }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_35;
}
static void entry__extract_30(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // kind: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 231: ... "
  // 232:   @
  // 233:     if (argument_count < @(fixed_count)) {
  // 234:       too_few_@(kind)_error();
  // 235:       return;
  // 236:     }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__3a411e083dfe7a1;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[2] = string__163aca4ea3526a62;
  arguments->slots[3] = frame->slots[1] /* kind */;
  arguments->slots[4] = string__46700f340c500fa1;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_34;
}
static void cont__extract_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 231: write "
  // 232:   @
  // 233:     if (argument_count < @(fixed_count)) {
  // 234:       too_few_@(kind)_error();
  // 235:       return;
  // 236:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_35(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 237: ... :
  // 238:   write "
  // 239:     @
  // 240:       if (argument_count > @(total_count)) {
  // 241:         too_many_@(kind)_error();
  // 242:         return;
  // 243:       }
  frame->slots[4] /* temp__1 */ = create_closure(entry__extract_36, 0);
  // 237: unless unlimited:
  // 238:   write "
  // 239:     @
  // 240:       if (argument_count > @(total_count)) {
  // 241:         too_many_@(kind)_error();
  // 242:         return;
  // 243:       }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_40(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // fixed_count: 0
  // kind: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* fixed_count */
  frame->slots[1] = myself->closure.frame->slots[0]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 245: ... "
  // 246:   @
  // 247:     if (argument_count != @(fixed_count)) {
  // 248:       invalid_@(kind)_error();
  // 249:       return;
  // 250:     }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__8f0419bf3de01d00;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* fixed_count */;
  arguments->slots[2] = string__23ec94223c989c2;
  arguments->slots[3] = frame->slots[1] /* kind */;
  arguments->slots[4] = string__46700f340c500fa1;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_43;
}
static void cont__extract_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 245: write "
  // 246:   @
  // 247:     if (argument_count != @(fixed_count)) {
  // 248:       invalid_@(kind)_error();
  // 249:       return;
  // 250:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_44(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 251: ... kind == "results"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = string__984c0ed0151bf089;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__extract_46;
}
static void cont__extract_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 251: ... unlimited
  frame->slots[9] /* temp__3 */ = create_closure(entry__extract_47, 0);
  // 251: ... kind == "results" && unlimited
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__extract_48;
}
static void entry__extract_47(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // unlimited: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* unlimited */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 251: ... unlimited
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* unlimited */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 251: if kind == "results" && unlimited: writeln "  allocate_arguments();"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__extract_49;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_51;
}
static void entry__extract_49(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 251: ... writeln "  allocate_arguments();"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__858e9ccf5a7e0845;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_51(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 255: ... fixed_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[4])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_52;
}
static void cont__extract_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 255: ... : (idx)
  // 256:   $output outputs(idx)
  // 257:   if
  // 258:     ||
  // 259:       kind == "results"
  // 260:       output.is_a_multi_assign_definition
  // 261:       unlimited
  // 262:       has_complex_default_values
  // 263:     :
  // 264:       assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  frame->slots[8] /* temp__2 */ = create_closure(entry__extract_53, 1);
  // 255: from_to 1 fixed_count-right_count: (idx)
  // 256:   $output outputs(idx)
  // 257:   if
  // 258:     ||
  // 259:       kind == "results"
  // 260:       output.is_a_multi_assign_definition
  // 261:       unlimited
  // 262:       has_complex_default_values
  // 263:     :
  // 264:       assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__from_to();
  func = myself->type;
  frame->cont = cont__extract_68;
}
static void entry__extract_63(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // kind: 0
  // output: 1
  // idx: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[5]; /* output */
  frame->slots[2] = myself->closure.frame->slots[0]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 264: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_64;
}
static void cont__extract_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 264: ... "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__f8fbbe9f15fa69de;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cbc;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_67;
}
static void cont__extract_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 264: assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[1] /* output */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__extract_53(void) {
  allocate_initialized_frame_gc(5, 10);
  // slot allocations:
  // idx: 0
  // outputs: 1
  // kind: 2
  // unlimited: 3
  // has_complex_default_values: 4
  // output: 5
  frame->slots[1] = myself->closure.frame->slots[1]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[3] = myself->closure.frame->slots[5]; /* unlimited */
  frame->slots[4] = myself->closure.frame->slots[6]; /* has_complex_default_values */
  frame->slots[5] /* output */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 256: $output outputs(idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__extract_54;
}
static void cont__extract_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* output */, arguments->slots[0]);
  // 259: kind == "results"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* kind */;
  arguments->slots[1] = string__984c0ed0151bf089;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__extract_55;
}
static void cont__extract_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  frame->slots[8] /* temp__3 */ = create_closure(entry__extract_56, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__extract_62;
}
static void entry__extract_56(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // output: 0
  // unlimited: 1
  // has_complex_default_values: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* output */
  frame->slots[1] = myself->closure.frame->slots[3]; /* unlimited */
  frame->slots[2] = myself->closure.frame->slots[4]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 260: output.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* output */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__extract_57;
}
static void cont__extract_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__3 */ = create_closure(entry__extract_58, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__extract_61;
}
static void entry__extract_58(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // unlimited: 0
  // has_complex_default_values: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* unlimited */
  frame->slots[1] = myself->closure.frame->slots[2]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 262: has_complex_default_values
  frame->slots[3] /* temp__2 */ = create_closure(entry__extract_59, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__extract_60;
}
static void entry__extract_59(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 262: has_complex_default_values
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* has_complex_default_values */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__extract_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 263: :
  // 264:   assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  frame->slots[9] /* temp__4 */ = create_closure(entry__extract_63, 0);
  // 257: if
  // 258:   ||
  // 259:     kind == "results"
  // 260:     output.is_a_multi_assign_definition
  // 261:     unlimited
  // 262:     has_complex_default_values
  // 263:   :
  // 264:     assign_argument_or_result kind output "arguments->slots[@(idx-1)]"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_68(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 268: ... : (idx)
  // 269:   assign_argument_or_result
  // 270:     kind
  // 271:     outputs(-idx)
  // 272:     "arguments->slots[argument_count@(-idx)]"
  frame->slots[7] /* temp__1 */ = create_closure(entry__extract_69, 1);
  // 268: from_to 1 right_count: (idx)
  // 269:   assign_argument_or_result
  // 270:     kind
  // 271:     outputs(-idx)
  // 272:     "arguments->slots[argument_count@(-idx)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = ((CELL *)frame->slots[4])->contents /* right_count */;
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__from_to();
  func = myself->type;
  frame->cont = cont__extract_75;
}
static void entry__extract_69(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // idx: 0
  // kind: 1
  // outputs: 2
  frame->slots[1] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[2] = myself->closure.frame->slots[1]; /* outputs */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 271: ... idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__extract_70;
}
static void cont__extract_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 271: outputs(-idx)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[2] /* outputs */;
  func = myself->type;
  frame->cont = cont__extract_71;
}
static void cont__extract_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 272: ... idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__extract_72;
}
static void cont__extract_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 272: "arguments->slots[argument_count@(-idx)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__41a90e180f1f464a;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = string__578a5af303e9cbc;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_74;
}
static void cont__extract_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 269: assign_argument_or_result
  // 270:   kind
  // 271:   outputs(-idx)
  // 272:   "arguments->slots[argument_count@(-idx)]"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* kind */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_75(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 276: ... :
  // 277:   assign_argument_or_result kind outputs(total_count-right_count+1) "
  // 278:     from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  frame->slots[7] /* temp__1 */ = create_closure(entry__extract_76, 0);
  // 276: if unlimited:
  // 277:   assign_argument_or_result kind outputs(total_count-right_count+1) "
  // 278:     from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* unlimited */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__extract_85;
}
static void entry__extract_76(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // kind: 0
  // outputs: 1
  // total_count: 2
  // right_count: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[1]; /* outputs */
  frame->slots[2] = myself->closure.frame->slots[3]; /* total_count */
  frame->slots[3] = myself->closure.frame->slots[4]; /* right_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 277: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_77;
}
static void cont__extract_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 277: ... total_count-right_count+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__extract_78;
}
static void cont__extract_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 277: ... outputs(total_count-right_count+1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[1] /* outputs */;
  func = myself->type;
  frame->cont = cont__extract_79;
}
static void cont__extract_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 278: ... total_count-right_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* right_count */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__extract_80;
}
static void cont__extract_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__5 */ = arguments->slots[0];
  // 277: ... "
  // 278:   from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__c641af060b3640ca;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  arguments->slots[2] = string__eb230bd48e24a88;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* total_count */;
  arguments->slots[4] = string__578a5af303e9cc8;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__extract_84;
}
static void cont__extract_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 277: assign_argument_or_result kind outputs(total_count-right_count+1) "
  // 278:   from_arguments(@(total_count-right_count), argument_count-@(total_count))@
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__extract_85(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 282: ... total_count > fixed_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* fixed_count */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* total_count */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__extract_86;
}
static void cont__extract_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 282: ... :
  // 283:   write "
  // 284:     @
  // 285:       switch(argument_count) {
  // 286:   from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 287:     $n idx+right_count
  // 288:     
  // 289:     $cnt
  // 290:       if
  // 291:         n == total_count
  // ...
  frame->slots[8] /* temp__2 */ = create_closure(entry__extract_87, 0);
  // 282: if total_count > fixed_count:
  // 283:   write "
  // 284:     @
  // 285:       switch(argument_count) {
  // 286:   from_down_to total_count-right_count fixed_count-right_count+1: (idx)
  // 287:     $n idx+right_count
  // 288:     
  // 289:     $cnt
  // 290:       if
  // 291:         n == total_count
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__write_as_remark(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 371: =
  // 372:   '@nl;'
  // 373:   "
  // 374:     @
  // 375:     
  // 376:       // @
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = string__d81f45b583c652f7;
  result_count = 1;
  myself = get__std__key_value_pair();
  func = myself->type;
  frame->cont = cont__write_as_remark_3;
}
static void cont__write_as_remark_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__replace_all();
  func = myself->type;
  frame->cont = cont__write_as_remark_4;
}
static void cont__write_as_remark_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 367: writeln
  // 368:   "  // "
  // 369:   replace_all
  // 370:     str
  // 371:     =
  // 372:       '@nl;'
  // 373:       "
  // 374:         @
  // 375:         
  // 376:           // @
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__ca5af8c3e8b41077;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compute_column_no(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  // i: 1
  frame->slots[1] /* i */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 379: $$i -1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_column_no_2;
}
static void cont__compute_column_no_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* i */ = arguments->slots[0];
  // 380: ... -> str(i) != newline && str(i) != indent_marker: dec &i
  frame->slots[2] /* temp__1 */ = create_closure(entry__compute_column_no_3, 0);
  // 380: while -> str(i) != newline && str(i) != indent_marker: dec &i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__compute_column_no_14;
}
static void entry__compute_column_no_12(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // i: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* i */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 380: ... dec &i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* i */;
  result_count = 1;
  myself = get__dec();
  func = myself->type;
  frame->cont = cont__compute_column_no_13;
}
static void cont__compute_column_no_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* i */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compute_column_no_3(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // str: 0
  // i: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* i */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 380: ... str(i)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* i */;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__compute_column_no_4;
}
static void cont__compute_column_no_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 380: ... str(i) != newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compute_column_no_5;
}
static void cont__compute_column_no_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 380: ... str(i) != newline
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compute_column_no_6;
}
static void cont__compute_column_no_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 380: ... str(i) != indent_marker
  frame->slots[6] /* temp__5 */ = create_closure(entry__compute_column_no_7, 0);
  // 380: ... str(i) != newline && str(i) != indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compute_column_no_11;
}
static void entry__compute_column_no_7(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // str: 0
  // i: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* i */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 380: ... str(i)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* i */;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__compute_column_no_8;
}
static void cont__compute_column_no_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 380: ... str(i) != indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compute_column_no_9;
}
static void cont__compute_column_no_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 380: ... str(i) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compute_column_no_10;
}
static void cont__compute_column_no_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 380: ... str(i) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_column_no_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 380: ... : dec &i
  frame->slots[7] /* temp__6 */ = create_closure(entry__compute_column_no_12, 0);
  // 380: ... -> str(i) != newline && str(i) != indent_marker: dec &i
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__6 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_column_no_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 381: ... i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* i */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_column_no_15;
}
static void cont__compute_column_no_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 381: -> -i
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compute_source_text_info(void) {
  allocate_initialized_frame_gc(3, 21);
  // slot allocations:
  // node: 0
  // print_remark: 1
  // is_an_exit: 2
  // fragment: 3
  // fragment_source: 4
  // offset: 5
  // pos: 6
  // prefix: 7
  // fragment_line_no: 8
  // indents: 9
  // line_no: 10
  // column_no: 11
  // source: 12
  // last_line_no: 13
  // last_column_no: 14
  // submodule_no: 15
  // continuation_info: 16
  frame->slots[3] /* fragment */ = create_future();
  frame->slots[4] /* fragment_source */ = create_future();
  frame->slots[5] /* offset */ = create_future();
  frame->slots[6] /* pos */ = create_future();
  frame->slots[7] /* prefix */ = create_future();
  frame->slots[8] /* fragment_line_no */ = create_future();
  frame->slots[9] /* indents */ = create_future();
  frame->slots[10] /* line_no */ = create_cell();
  frame->slots[11] /* column_no */ = create_cell();
  frame->slots[12] /* source */ = create_cell();
  frame->slots[13] /* last_line_no */ = create_cell();
  frame->slots[14] /* last_column_no */ = create_future();
  frame->slots[15] /* submodule_no */ = create_future();
  frame->slots[16] /* continuation_info */ = create_future();
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[2] /* is_an_exit */ = arguments->slots[2];
    case 2: frame->slots[1] /* print_remark */ = arguments->slots[1];
    case 1:;
  }
  switch(argument_count) {
    case 1: frame->slots[1] /* print_remark */ = get__false();
    case 2: frame->slots[2] /* is_an_exit */ = get__false();
  }
  // 389: $fragment fragment_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__fragment_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_2;
}
static void cont__compute_source_text_info_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* fragment */, arguments->slots[0]);
  // 390: $fragment_source source_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_3;
}
static void cont__compute_source_text_info_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* fragment_source */, arguments->slots[0]);
  // 391: $offset source_position_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__source_position_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_4;
}
static void cont__compute_source_text_info_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* offset */, arguments->slots[0]);
  // 392: ... length_of(fragment_source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* fragment_source */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_5;
}
static void cont__compute_source_text_info_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 392: ... length_of(fragment_source)-offset
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* offset */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_6;
}
static void cont__compute_source_text_info_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 392: $pos length_of(fragment_source)-offset+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_7;
}
static void cont__compute_source_text_info_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* pos */, arguments->slots[0]);
  // 393: ... pos-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* pos */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_8;
}
static void cont__compute_source_text_info_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 393: $prefix range(fragment_source 1 pos-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* fragment_source */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[17] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_9;
}
static void cont__compute_source_text_info_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* prefix */, arguments->slots[0]);
  // 394: $fragment_line_no line_no_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__line_no_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_10;
}
static void cont__compute_source_text_info_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* fragment_line_no */, arguments->slots[0]);
  // 395: $indents indents_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__indents_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_11;
}
static void cont__compute_source_text_info_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[9] /* indents */, arguments->slots[0]);
  // 399: count_character_occurrences(prefix newline)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* prefix */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_12;
}
static void cont__compute_source_text_info_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 400: count_character_occurrences(prefix indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* prefix */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_13;
}
static void cont__compute_source_text_info_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 397: $$line_no
  // 398:   +
  // 399:     count_character_occurrences(prefix newline)
  // 400:     count_character_occurrences(prefix indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_14;
}
static void cont__compute_source_text_info_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[10])->contents /* line_no */ = arguments->slots[0];
  // 404: line_no > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = ((CELL *)frame->slots[10])->contents /* line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_15;
}
static void cont__compute_source_text_info_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 405: -> compute_column_no(prefix)+indents(line_no)
  frame->slots[18] /* temp__2 */ = create_closure(entry__compute_source_text_info_16, 0);
  // 406: -> length_of(prefix)+1
  frame->slots[19] /* temp__3 */ = create_closure(entry__compute_source_text_info_20, 0);
  // 402: $$column_no
  // 403:   if
  // 404:     line_no > 0
  // 405:     -> compute_column_no(prefix)+indents(line_no)
  // 406:     -> length_of(prefix)+1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = frame->slots[18] /* temp__2 */;
  arguments->slots[2] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_23;
}
static void entry__compute_source_text_info_16(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // prefix: 0
  // indents: 1
  // line_no: 2
  frame->slots[0] = myself->closure.frame->slots[7]; /* prefix */
  frame->slots[1] = myself->closure.frame->slots[9]; /* indents */
  frame->slots[2] = myself->closure.frame->slots[10]; /* line_no */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 405: ... compute_column_no(prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  result_count = 1;
  myself = func__compute_column_no;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_17;
}
static void cont__compute_source_text_info_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 405: ... indents(line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* line_no */;
  result_count = 1;
  myself = frame->slots[1] /* indents */;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_18;
}
static void cont__compute_source_text_info_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 405: ... compute_column_no(prefix)+indents(line_no)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_19;
}
static void cont__compute_source_text_info_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 405: -> compute_column_no(prefix)+indents(line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compute_source_text_info_20(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // prefix: 0
  frame->slots[0] = myself->closure.frame->slots[7]; /* prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 406: ... length_of(prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_21;
}
static void cont__compute_source_text_info_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 406: ... length_of(prefix)+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_22;
}
static void cont__compute_source_text_info_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 406: -> length_of(prefix)+1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[11])->contents /* column_no */ = arguments->slots[0];
  // 408: ... offset
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* offset */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_24;
}
static void cont__compute_source_text_info_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 408: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_25;
}
static void cont__compute_source_text_info_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 408: $$source range(fragment_source -offset -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* fragment_source */;
  arguments->slots[1] = frame->slots[17] /* temp__1 */;
  arguments->slots[2] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_26;
}
static void cont__compute_source_text_info_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[12])->contents /* source */ = arguments->slots[0];
  // 409: ... end_position_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__end_position_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_27;
}
static void cont__compute_source_text_info_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[19] /* temp__3 */ = arguments->slots[0];
  // 409: ... 1+end_position_of(node)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_28;
}
static void cont__compute_source_text_info_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 409: ... 1+end_position_of(node))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_29;
}
static void cont__compute_source_text_info_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 409: range &source 1 -(1+end_position_of(node))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* source */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[17] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_30;
}
static void cont__compute_source_text_info_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[12])->contents /* source */ = arguments->slots[0];
  // 414: count_character_occurrences(source newline)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* source */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_31;
}
static void cont__compute_source_text_info_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = frame->slots[18] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_32;
}
static void cont__compute_source_text_info_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 415: count_character_occurrences(source indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* source */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__count_character_occurrences();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_33;
}
static void cont__compute_source_text_info_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[19] /* temp__3 */ = arguments->slots[0];
  // 411: $$last_line_no
  // 412:   +
  // 413:     line_no
  // 414:     count_character_occurrences(source newline)
  // 415:     count_character_occurrences(source indent_marker)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_34;
}
static void cont__compute_source_text_info_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[13])->contents /* last_line_no */ = arguments->slots[0];
  // 420: last_line_no > line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = ((CELL *)frame->slots[13])->contents /* last_line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_35;
}
static void cont__compute_source_text_info_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 421: -> compute_column_no(source)+indents(last_line_no)-1
  frame->slots[19] /* temp__3 */ = create_closure(entry__compute_source_text_info_36, 0);
  // 422: -> column_no+length_of(source)
  frame->slots[20] /* temp__4 */ = create_closure(entry__compute_source_text_info_41, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  arguments->slots[1] = frame->slots[19] /* temp__3 */;
  arguments->slots[2] = frame->slots[20] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_44;
}
static void entry__compute_source_text_info_36(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // source: 0
  // indents: 1
  // last_line_no: 2
  frame->slots[0] = myself->closure.frame->slots[12]; /* source */
  frame->slots[1] = myself->closure.frame->slots[9]; /* indents */
  frame->slots[2] = myself->closure.frame->slots[13]; /* last_line_no */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 421: ... compute_column_no(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* source */;
  result_count = 1;
  myself = func__compute_column_no;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_37;
}
static void cont__compute_source_text_info_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 421: ... indents(last_line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* last_line_no */;
  result_count = 1;
  myself = frame->slots[1] /* indents */;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_38;
}
static void cont__compute_source_text_info_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 421: ... compute_column_no(source)+indents(last_line_no)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_39;
}
static void cont__compute_source_text_info_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 421: ... compute_column_no(source)+indents(last_line_no)-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_40;
}
static void cont__compute_source_text_info_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 421: -> compute_column_no(source)+indents(last_line_no)-1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compute_source_text_info_41(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // column_no: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[11]; /* column_no */
  frame->slots[1] = myself->closure.frame->slots[12]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 422: ... length_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* source */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_42;
}
static void cont__compute_source_text_info_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 422: ... column_no+length_of(source)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* column_no */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_43;
}
static void cont__compute_source_text_info_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 422: -> column_no+length_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 417: $last_column_no
  // 418:   -
  // 419:     if
  // 420:       last_line_no > line_no
  // 421:       -> compute_column_no(source)+indents(last_line_no)-1
  // 422:       -> column_no+length_of(source)
  // 423:     1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[17] /* temp__1 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_45;
}
static void cont__compute_source_text_info_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[14] /* last_column_no */, arguments->slots[0]);
  // 425: plus &line_no fragment_line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = frame->slots[8] /* fragment_line_no */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_46;
}
static void cont__compute_source_text_info_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[10])->contents /* line_no */ = arguments->slots[0];
  // 426: plus &last_line_no fragment_line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[13])->contents /* last_line_no */;
  arguments->slots[1] = frame->slots[8] /* fragment_line_no */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_47;
}
static void cont__compute_source_text_info_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[13])->contents /* last_line_no */ = arguments->slots[0];
  // 427: $submodule_no submodule_no_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* fragment */;
  result_count = 1;
  myself = get__submodule_no_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_48;
}
static void cont__compute_source_text_info_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[15] /* submodule_no */, arguments->slots[0]);
  // 428: ... :
  // 429:   !line_no last_line_no
  // 430:   !column_no last_column_no
  frame->slots[17] /* temp__1 */ = create_closure(entry__compute_source_text_info_49, 0);
  // 428: if is_an_exit:
  // 429:   !line_no last_line_no
  // 430:   !column_no last_column_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* is_an_exit */;
  arguments->slots[1] = frame->slots[17] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_50;
}
static void entry__compute_source_text_info_49(void) {
  allocate_initialized_frame_gc(4, 4);
  // slot allocations:
  // line_no: 0
  // last_line_no: 1
  // column_no: 2
  // last_column_no: 3
  frame->slots[0] = myself->closure.frame->slots[10]; /* line_no */
  frame->slots[1] = myself->closure.frame->slots[13]; /* last_line_no */
  frame->slots[2] = myself->closure.frame->slots[11]; /* column_no */
  frame->slots[3] = myself->closure.frame->slots[14]; /* last_column_no */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 429: !line_no last_line_no
  ((CELL *)frame->slots[0])->contents /* line_no */ = ((CELL *)frame->slots[1])->contents /* last_line_no */;
  // 430: !column_no last_column_no
  ((CELL *)frame->slots[2])->contents /* column_no */ = frame->slots[3] /* last_column_no */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_50(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 434: ... submodule_no != 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* submodule_no */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_51;
}
static void cont__compute_source_text_info_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[19] /* temp__3 */ = arguments->slots[0];
  // 434: ... submodule_no != 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[19] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_52;
}
static void cont__compute_source_text_info_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[18] /* temp__2 */ = arguments->slots[0];
  // 434: ... -> ", @(submodule_no_of(fragment))"
  frame->slots[20] /* temp__4 */ = create_closure(entry__compute_source_text_info_53, 0);
  // 434: ... if(submodule_no != 0 (-> ", @(submodule_no_of(fragment))") -> "")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[18] /* temp__2 */;
  arguments->slots[1] = frame->slots[20] /* temp__4 */;
  arguments->slots[2] = func__compute_source_text_info_56;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_57;
}
static void entry__compute_source_text_info_53(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // fragment: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* fragment */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 434: ... submodule_no_of(fragment)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* fragment */;
  result_count = 1;
  myself = get__submodule_no_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_54;
}
static void cont__compute_source_text_info_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 434: ... ", @(submodule_no_of(fragment))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6682be5;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_55;
}
static void cont__compute_source_text_info_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 434: ... -> ", @(submodule_no_of(fragment))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compute_source_text_info_56(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 434: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__1 */ = arguments->slots[0];
  // 432: $continuation_info "
  // 433:   @(line_no), @(last_line_no), @(column_no), @(last_column_no)@
  // 434:   @(if(submodule_no != 0 (-> ", @(submodule_no_of(fragment))") -> ""))@
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* line_no */;
  arguments->slots[1] = string__2d7981f4e6682be5;
  arguments->slots[2] = ((CELL *)frame->slots[13])->contents /* last_line_no */;
  arguments->slots[3] = string__2d7981f4e6682be5;
  arguments->slots[4] = ((CELL *)frame->slots[11])->contents /* column_no */;
  arguments->slots[5] = string__2d7981f4e6682be5;
  arguments->slots[6] = frame->slots[14] /* last_column_no */;
  arguments->slots[7] = frame->slots[17] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_58;
}
static void cont__compute_source_text_info_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[16] /* continuation_info */, arguments->slots[0]);
  // 436: ... :
  // 437:   $$indent 0
  // 438:   $$do_print_dots false
  // 439:   if last_line_no > line_no+9:
  // 440:     !last_line_no line_no+9
  // 441:     !do_print_dots true
  // 442:   $width length_of(to_string(last_line_no))
  // 443:   if
  // 444:     &&
  // 445:       length_of(prefix) > 0
  // ...
  frame->slots[17] /* temp__1 */ = create_closure(entry__compute_source_text_info_59, 0);
  // 436: if print_remark:
  // 437:   $$indent 0
  // 438:   $$do_print_dots false
  // 439:   if last_line_no > line_no+9:
  // 440:     !last_line_no line_no+9
  // 441:     !do_print_dots true
  // 442:   $width length_of(to_string(last_line_no))
  // 443:   if
  // 444:     &&
  // 445:       length_of(prefix) > 0
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* print_remark */;
  arguments->slots[1] = frame->slots[17] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_118;
}
static void entry__compute_source_text_info_99(void) {
  allocate_initialized_frame_gc(7, 8);
  // slot allocations:
  // break: 0
  // source: 1
  // indent: 2
  // last_line_no: 3
  // line_no: 4
  // write_line_start: 5
  // do_print_dots: 6
  frame->slots[0] /* break */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[3]; /* source */
  frame->slots[2] = myself->closure.frame->slots[4]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[1]; /* last_line_no */
  frame->slots[4] = myself->closure.frame->slots[0]; /* line_no */
  frame->slots[5] = myself->closure.frame->slots[7]; /* write_line_start */
  frame->slots[6] = myself->closure.frame->slots[5]; /* do_print_dots */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 458: ... : (_idx chr)
  // 459:   case chr
  // 460:     newline, indent_marker:
  // 461:       if chr == indent_marker: inc &indent
  // 462:       writeln
  // 463:       if
  // 464:         line_no <= last_line_no:
  // 465:           write_line_start
  // 466:         :
  // 467:           if do_print_dots: writeln "  // ..."
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__compute_source_text_info_100, 2);
  // 458: for_each source: (_idx chr)
  // 459:   case chr
  // 460:     newline, indent_marker:
  // 461:       if chr == indent_marker: inc &indent
  // 462:       writeln
  // 463:       if
  // 464:         line_no <= last_line_no:
  // 465:           write_line_start
  // 466:         :
  // 467:           if do_print_dots: writeln "  // ..."
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* source */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_117;
}
static void entry__compute_source_text_info_110(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // do_print_dots: 0
  // break: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* do_print_dots */
  frame->slots[1] = myself->closure.frame->slots[6]; /* break */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 467: if do_print_dots: writeln "  // ..."
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* do_print_dots */;
  arguments->slots[1] = func__compute_source_text_info_111;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_113;
}
static void entry__compute_source_text_info_111(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 467: ... writeln "  // ..."
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__ef94be7186a1680e;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compute_source_text_info_113(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 468: break
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* break */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compute_source_text_info_102(void) {
  allocate_initialized_frame_gc(7, 10);
  // slot allocations:
  // chr: 0
  // indent: 1
  // last_line_no: 2
  // line_no: 3
  // write_line_start: 4
  // do_print_dots: 5
  // break: 6
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* last_line_no */
  frame->slots[3] = myself->closure.frame->slots[4]; /* line_no */
  frame->slots[4] = myself->closure.frame->slots[5]; /* write_line_start */
  frame->slots[5] = myself->closure.frame->slots[6]; /* do_print_dots */
  frame->slots[6] = myself->closure.frame->slots[7]; /* break */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 461: ... chr == indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_103;
}
static void cont__compute_source_text_info_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 461: ... : inc &indent
  frame->slots[8] /* temp__2 */ = create_closure(entry__compute_source_text_info_104, 0);
  // 461: if chr == indent_marker: inc &indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_106;
}
static void entry__compute_source_text_info_104(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 461: ... inc &indent
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_105;
}
static void cont__compute_source_text_info_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_106(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 462: writeln
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = get__writeln();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_107;
}
static void cont__compute_source_text_info_107(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 464: line_no <= last_line_no
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* last_line_no */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_108;
}
static void cont__compute_source_text_info_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 464: line_no <= last_line_no
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_109;
}
static void cont__compute_source_text_info_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 466: :
  // 467:   if do_print_dots: writeln "  // ..."
  // 468:   break
  frame->slots[9] /* temp__3 */ = create_closure(entry__compute_source_text_info_110, 0);
  // 463: if
  // 464:   line_no <= last_line_no:
  // 465:     write_line_start
  // 466:   :
  // 467:     if do_print_dots: writeln "  // ..."
  // 468:     break
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* write_line_start */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compute_source_text_info_114(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 470: dec &indent
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__dec();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_115;
}
static void cont__compute_source_text_info_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compute_source_text_info_116(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 472: write chr
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compute_source_text_info_100(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // idx: 0
  // chr: 1
  // indent: 2
  // last_line_no: 3
  // line_no: 4
  // write_line_start: 5
  // do_print_dots: 6
  // break: 7
  frame->slots[2] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[3]; /* last_line_no */
  frame->slots[4] = myself->closure.frame->slots[4]; /* line_no */
  frame->slots[5] = myself->closure.frame->slots[5]; /* write_line_start */
  frame->slots[6] = myself->closure.frame->slots[6]; /* do_print_dots */
  frame->slots[7] = myself->closure.frame->slots[0]; /* break */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 460: newline, indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__newline();
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_101;
}
static void cont__compute_source_text_info_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 460: ... :
  // 461:   if chr == indent_marker: inc &indent
  // 462:   writeln
  // 463:   if
  // 464:     line_no <= last_line_no:
  // 465:       write_line_start
  // 466:     :
  // 467:       if do_print_dots: writeln "  // ..."
  // 468:       break
  frame->slots[9] /* temp__2 */ = create_closure(entry__compute_source_text_info_102, 0);
  // 469: ... :
  // 470:   dec &indent
  frame->slots[10] /* temp__3 */ = create_closure(entry__compute_source_text_info_114, 0);
  // 471: :
  // 472:   write chr
  frame->slots[11] /* temp__4 */ = create_closure(entry__compute_source_text_info_116, 0);
  // 459: case chr
  // 460:   newline, indent_marker:
  // 461:     if chr == indent_marker: inc &indent
  // 462:     writeln
  // 463:     if
  // 464:       line_no <= last_line_no:
  // 465:         write_line_start
  // 466:       :
  // 467:         if do_print_dots: writeln "  // ..."
  // 468:         break
  // ...
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = frame->slots[8] /* temp__1 */;
  arguments->slots[2] = frame->slots[9] /* temp__2 */;
  arguments->slots[3] = get__outdent_marker();
  arguments->slots[4] = frame->slots[10] /* temp__3 */;
  arguments->slots[5] = frame->slots[11] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compute_source_text_info_117(void) {
  myself = frame->slots[0] /* break */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compute_source_text_info_59(void) {
  allocate_initialized_frame_gc(4, 13);
  // slot allocations:
  // line_no: 0
  // last_line_no: 1
  // prefix: 2
  // source: 3
  // indent: 4
  // do_print_dots: 5
  // width: 6
  // write_line_start: 7
  frame->slots[0] = myself->closure.frame->slots[10]; /* line_no */
  frame->slots[1] = myself->closure.frame->slots[13]; /* last_line_no */
  frame->slots[2] = myself->closure.frame->slots[7]; /* prefix */
  frame->slots[3] = myself->closure.frame->slots[12]; /* source */
  frame->slots[7] /* write_line_start */ = create_future();
  frame->slots[4] /* indent */ = create_cell();
  frame->slots[5] /* do_print_dots */ = create_cell();
  frame->slots[6] /* width */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 452: ... :
  // 453:   write "  // @(pad_left(line_no width)): " dup("  " max(indent 0))
  // 454:   inc &line_no
  frame->slots[8] /* temp__1 */ = create_closure(entry__compute_source_text_info_60, 0);
  // 452: $write_line_start:
  // 453:   write "  // @(pad_left(line_no width)): " dup("  " max(indent 0))
  // 454:   inc &line_no
  initialize_future(frame->slots[7] /* write_line_start */, frame->slots[8] /* temp__1 */);
  // 437: $$indent 0
  ((CELL *)frame->slots[4])->contents /* indent */ = number__0;
  // 438: $$do_print_dots false
  ((CELL *)frame->slots[5])->contents /* do_print_dots */ = get__false();
  // 439: ... line_no+9
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line_no */;
  arguments->slots[1] = number__9;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_67;
}
static void entry__compute_source_text_info_60(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // line_no: 0
  // width: 1
  // indent: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* line_no */
  frame->slots[1] = myself->closure.frame->slots[6]; /* width */
  frame->slots[2] = myself->closure.frame->slots[4]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 453: ... pad_left(line_no width)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line_no */;
  arguments->slots[1] = frame->slots[1] /* width */;
  result_count = 1;
  myself = get__pad_left();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_61;
}
static void cont__compute_source_text_info_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 453: ... "  // @(pad_left(line_no width)): "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__ca5af8c3e8b41077;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6d82be5;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_62;
}
static void cont__compute_source_text_info_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 453: ... max(indent 0)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* indent */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__max();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_63;
}
static void cont__compute_source_text_info_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 453: ... dup("  " max(indent 0))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__dup();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_64;
}
static void cont__compute_source_text_info_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 453: write "  // @(pad_left(line_no width)): " dup("  " max(indent 0))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_65;
}
static void cont__compute_source_text_info_65(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 454: inc &line_no
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line_no */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_66;
}
static void cont__compute_source_text_info_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line_no */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 439: ... last_line_no > line_no+9
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* last_line_no */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_68;
}
static void cont__compute_source_text_info_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 439: ... :
  // 440:   !last_line_no line_no+9
  // 441:   !do_print_dots true
  frame->slots[10] /* temp__3 */ = create_closure(entry__compute_source_text_info_69, 0);
  // 439: if last_line_no > line_no+9:
  // 440:   !last_line_no line_no+9
  // 441:   !do_print_dots true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_71;
}
static void entry__compute_source_text_info_69(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // last_line_no: 0
  // line_no: 1
  // do_print_dots: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* last_line_no */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line_no */
  frame->slots[2] = myself->closure.frame->slots[5]; /* do_print_dots */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 440: !last_line_no line_no+9
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* line_no */;
  arguments->slots[1] = number__9;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_70;
}
static void cont__compute_source_text_info_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* last_line_no */ = arguments->slots[0];
  // 441: !do_print_dots true
  ((CELL *)frame->slots[2])->contents /* do_print_dots */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_71(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 442: ... to_string(last_line_no)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* last_line_no */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_72;
}
static void cont__compute_source_text_info_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 442: $width length_of(to_string(last_line_no))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_73;
}
static void cont__compute_source_text_info_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* width */, arguments->slots[0]);
  // 445: length_of(prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_74;
}
static void cont__compute_source_text_info_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 445: length_of(prefix) > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_75;
}
static void cont__compute_source_text_info_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  frame->slots[11] /* temp__4 */ = create_closure(entry__compute_source_text_info_76, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_87;
}
static void entry__compute_source_text_info_76(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // prefix: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 446: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_77;
}
static void cont__compute_source_text_info_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 446: prefix(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = frame->slots[0] /* prefix */;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_78;
}
static void cont__compute_source_text_info_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 446: prefix(-1) != newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_79;
}
static void cont__compute_source_text_info_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 446: prefix(-1) != newline
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_80;
}
static void cont__compute_source_text_info_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 447: prefix(-1) != indent_marker
  frame->slots[6] /* temp__6 */ = create_closure(entry__compute_source_text_info_81, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_86;
}
static void entry__compute_source_text_info_81(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // prefix: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 447: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_82;
}
static void cont__compute_source_text_info_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 447: prefix(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = frame->slots[0] /* prefix */;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_83;
}
static void cont__compute_source_text_info_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 447: prefix(-1) != indent_marker
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__indent_marker();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_84;
}
static void cont__compute_source_text_info_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 447: prefix(-1) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_85;
}
static void cont__compute_source_text_info_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 447: prefix(-1) != indent_marker
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 448: :
  // 449:   append "... " &source
  frame->slots[12] /* temp__5 */ = create_closure(entry__compute_source_text_info_88, 0);
  // 443: if
  // 444:   &&
  // 445:     length_of(prefix) > 0
  // 446:     prefix(-1) != newline
  // 447:     prefix(-1) != indent_marker
  // 448:   :
  // 449:     append "... " &source
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_91;
}
static void entry__compute_source_text_info_88(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 449: append "... " &source
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__9e0afacb5f107d19;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* source */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_90;
}
static void cont__compute_source_text_info_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* source */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_91(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 450: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_92;
}
static void cont__compute_source_text_info_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 450: ... source(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* source */;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_93;
}
static void cont__compute_source_text_info_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 450: ... source(-1) == newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_94;
}
static void cont__compute_source_text_info_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 450: ... : push &source newline
  frame->slots[11] /* temp__4 */ = create_closure(entry__compute_source_text_info_95, 0);
  // 450: unless source(-1) == newline: push &source newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_97;
}
static void entry__compute_source_text_info_95(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 450: ... push &source newline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* source */;
  arguments->slots[1] = get__newline();
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compute_source_text_info_96;
}
static void cont__compute_source_text_info_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* source */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compute_source_text_info_97(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 456: write_line_start
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[7] /* write_line_start */;
  func = myself->type;
  frame->cont = cont__compute_source_text_info_98;
}
static void cont__compute_source_text_info_98(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 457: ... : (-> break)
  // 458:   for_each source: (_idx chr)
  // 459:     case chr
  // 460:       newline, indent_marker:
  // 461:         if chr == indent_marker: inc &indent
  // 462:         writeln
  // 463:         if
  // 464:           line_no <= last_line_no:
  // 465:             write_line_start
  // 466:           :
  // ...
  frame->slots[8] /* temp__1 */ = create_closure(entry__compute_source_text_info_99, 0);
  // 457: do: (-> break)
  // 458:   for_each source: (_idx chr)
  // 459:     case chr
  // 460:       newline, indent_marker:
  // 461:         if chr == indent_marker: inc &indent
  // 462:         writeln
  // 463:         if
  // 464:           line_no <= last_line_no:
  // 465:             write_line_start
  // 466:           :
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compute_source_text_info_118(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 473: -> continuation_info
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* continuation_info */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__write_source_as_remark_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // node: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* node */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 477: compute_source_text_info !current_continuation_info node true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  arguments->slots[1] = get__true();
  result_count = 1;
  myself = func__compute_source_text_info;
  func = myself->type;
  frame->cont = cont__compiler__write_source_as_remark_5;
}
static void cont__compiler__write_source_as_remark_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__current_continuation_info(arguments->slots[0]);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__write_source_as_remark(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // node: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 476: ... end_position_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* node */;
  result_count = 1;
  myself = get__end_position_of();
  func = myself->type;
  frame->cont = cont__compiler__write_source_as_remark_2;
}
static void cont__compiler__write_source_as_remark_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 476: ... end_position_of(node).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__write_source_as_remark_3;
}
static void cont__compiler__write_source_as_remark_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 476: ... :
  // 477:   compute_source_text_info !current_continuation_info node true
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__write_source_as_remark_4, 0);
  // 476: if end_position_of(node).is_defined:
  // 477:   compute_source_text_info !current_continuation_info node true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // source: 0
  // return: 1
  frame->slots[1] /* return */ = create_continuation();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 489: -> source.is_a_constant: return EARLY
  frame->slots[2] /* temp__1 */ = create_closure(entry__get_kind_2, 0);
  // 490: -> source.is_a_temporary: return STANDARD
  frame->slots[3] /* temp__2 */ = create_closure(entry__get_kind_5, 0);
  // 491: :
  // 492:   $name mangled_name_of(source)
  // 493:   cond
  // 494:     -> current_locals(name).is_defined:
  // 495:       return
  // 496:         if
  // 497:           name.is_a_shared_local
  // 498:           -> STANDARD
  // 499:           -> EARLY
  // 500:     -> needed_names(name).is_defined:
  // ...
  frame->slots[4] /* temp__3 */ = create_closure(entry__get_kind_8, 0);
  // 488: cond
  // 489:   -> source.is_a_constant: return EARLY
  // 490:   -> source.is_a_temporary: return STANDARD
  // 491:   :
  // 492:     $name mangled_name_of(source)
  // 493:     cond
  // 494:       -> current_locals(name).is_defined:
  // 495:         return
  // 496:           if
  // 497:             name.is_a_shared_local
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__get_kind_44;
}
static void entry__get_kind_42(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 520: return STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__STANDARD;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_43(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 522: return EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__EARLY;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_26(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 505: return EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__EARLY;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_27(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 507: return STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__STANDARD;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_21(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // name: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 501: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__get_kind_22;
}
static void cont__get_kind_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 501: ... variable_kind_of(needed_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__get_kind_23;
}
static void cont__get_kind_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 502: ... :
  // 503:   return UNKNOWN
  frame->slots[4] /* temp__3 */ = create_closure(entry__get_kind_24, 0);
  // 504: POLYMORPHIC, DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__POLYMORPHIC();
  arguments->slots[1] = get__DYNAMIC_SINGLE();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__get_kind_25;
}
static void entry__get_kind_24(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 503: return UNKNOWN
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__UNKNOWN;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__get_kind_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 504: ... :
  // 505:   return EARLY
  frame->slots[6] /* temp__5 */ = create_closure(entry__get_kind_26, 0);
  // 506: :
  // 507:   return STANDARD
  frame->slots[7] /* temp__6 */ = create_closure(entry__get_kind_27, 0);
  // 501: case variable_kind_of(needed_names(name))
  // 502:   STATIC_SINGLE:
  // 503:     return UNKNOWN
  // 504:   POLYMORPHIC, DYNAMIC_SINGLE:
  // 505:     return EARLY
  // 506:   :
  // 507:     return STANDARD
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  arguments->slots[3] = frame->slots[5] /* temp__4 */;
  arguments->slots[4] = frame->slots[6] /* temp__5 */;
  arguments->slots[5] = frame->slots[7] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_13(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // return: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 497: name.is_a_shared_local
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  result_count = 1;
  myself = get__is_a_shared_local();
  func = myself->type;
  frame->cont = cont__get_kind_14;
}
static void cont__get_kind_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = func__get_kind_15;
  arguments->slots[2] = func__get_kind_16;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__get_kind_17;
}
static void entry__get_kind_15(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 498: -> STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__STANDARD;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_kind_16(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 499: -> EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__EARLY;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__get_kind_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 495: return
  // 496:   if
  // 497:     name.is_a_shared_local
  // 498:     -> STANDARD
  // 499:     -> EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_10(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // name: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 494: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__get_kind_11;
}
static void cont__get_kind_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 494: ... current_locals(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__get_kind_12;
}
static void cont__get_kind_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 494: ... :
  // 495:   return
  // 496:     if
  // 497:       name.is_a_shared_local
  // 498:       -> STANDARD
  // 499:       -> EARLY
  frame->slots[4] /* temp__3 */ = create_closure(entry__get_kind_13, 0);
  // 494: -> current_locals(name).is_defined:
  // 495:   return
  // 496:     if
  // 497:       name.is_a_shared_local
  // 498:       -> STANDARD
  // 499:       -> EARLY
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_kind_18(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // name: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 500: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__get_kind_19;
}
static void cont__get_kind_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 500: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__get_kind_20;
}
static void cont__get_kind_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 500: ... :
  // 501:   case variable_kind_of(needed_names(name))
  // 502:     STATIC_SINGLE:
  // 503:       return UNKNOWN
  // 504:     POLYMORPHIC, DYNAMIC_SINGLE:
  // 505:       return EARLY
  // 506:     :
  // 507:       return STANDARD
  frame->slots[4] /* temp__3 */ = create_closure(entry__get_kind_21, 0);
  // 500: -> needed_names(name).is_defined:
  // 501:   case variable_kind_of(needed_names(name))
  // 502:     STATIC_SINGLE:
  // 503:       return UNKNOWN
  // 504:     POLYMORPHIC, DYNAMIC_SINGLE:
  // 505:       return EARLY
  // 506:     :
  // 507:       return STANDARD
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_kind_28(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // source: 0
  // name: 1
  // return: 2
  // variable_kind: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[2]; /* name */
  frame->slots[2] = myself->closure.frame->slots[1]; /* return */
  frame->slots[3] /* variable_kind */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 511: namespace_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__get_kind_29;
}
static void cont__get_kind_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 511: namespace_of(source).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__get_kind_30;
}
static void cont__get_kind_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 512: ->
  // 513:   variable_kind_of
  // 514:     exported_names(name_of(source))(namespace_of(source))
  frame->slots[6] /* temp__3 */ = create_closure(entry__get_kind_31, 0);
  // 515: -> variable_kind_of(global_names(name))
  frame->slots[7] /* temp__4 */ = create_closure(entry__get_kind_37, 0);
  // 509: $variable_kind
  // 510:   if
  // 511:     namespace_of(source).is_defined
  // 512:     ->
  // 513:       variable_kind_of
  // 514:         exported_names(name_of(source))(namespace_of(source))
  // 515:     -> variable_kind_of(global_names(name))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__get_kind_40;
}
static void entry__get_kind_31(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 514: ... namespace_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__get_kind_32;
}
static void cont__get_kind_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 514: ... name_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__get_kind_33;
}
static void cont__get_kind_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 514: exported_names(name_of(source))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__get_kind_34;
}
static void cont__get_kind_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 514: exported_names(name_of(source))(namespace_of(source))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = frame->slots[4] /* temp__4 */;
  func = myself->type;
  frame->cont = cont__get_kind_35;
}
static void cont__get_kind_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__get_kind_36;
}
static void cont__get_kind_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 512: ->
  // 513:   variable_kind_of
  // 514:     exported_names(name_of(source))(namespace_of(source))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_kind_37(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 515: ... global_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__get_kind_38;
}
static void cont__get_kind_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 515: ... variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__get_kind_39;
}
static void cont__get_kind_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 515: -> variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__get_kind_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* variable_kind */, arguments->slots[0]);
  // 519: STATIC_MULTI, DYNAMIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__STATIC_MULTI();
  arguments->slots[1] = get__DYNAMIC_MULTI();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__get_kind_41;
}
static void cont__get_kind_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 519: ... :
  // 520:   return STANDARD
  frame->slots[5] /* temp__2 */ = create_closure(entry__get_kind_42, 0);
  // 521: :
  // 522:   return EARLY
  frame->slots[6] /* temp__3 */ = create_closure(entry__get_kind_43, 0);
  // 517: case
  // 518:   variable_kind
  // 519:   STATIC_MULTI, DYNAMIC_MULTI:
  // 520:     return STANDARD
  // 521:   :
  // 522:     return EARLY
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* variable_kind */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  arguments->slots[3] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 490: ... return STANDARD
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__STANDARD;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 489: ... return EARLY
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__EARLY;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__get_kind_2(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // source: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 489: ... source.is_a_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_constant();
  func = myself->type;
  frame->cont = cont__get_kind_3;
}
static void cont__get_kind_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 489: ... : return EARLY
  frame->slots[3] /* temp__2 */ = create_closure(entry__get_kind_4, 0);
  // 489: -> source.is_a_constant: return EARLY
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_kind_5(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // source: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 490: ... source.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__get_kind_6;
}
static void cont__get_kind_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 490: ... : return STANDARD
  frame->slots[3] /* temp__2 */ = create_closure(entry__get_kind_7, 0);
  // 490: -> source.is_a_temporary: return STANDARD
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__get_kind_8(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // source: 0
  // return: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 492: $name mangled_name_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__get_kind_9;
}
static void cont__get_kind_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 494: -> current_locals(name).is_defined:
  // 495:   return
  // 496:     if
  // 497:       name.is_a_shared_local
  // 498:       -> STANDARD
  // 499:       -> EARLY
  frame->slots[3] /* temp__1 */ = create_closure(entry__get_kind_10, 0);
  // 500: -> needed_names(name).is_defined:
  // 501:   case variable_kind_of(needed_names(name))
  // 502:     STATIC_SINGLE:
  // 503:       return UNKNOWN
  // 504:     POLYMORPHIC, DYNAMIC_SINGLE:
  // 505:       return EARLY
  // 506:     :
  // 507:       return STANDARD
  frame->slots[4] /* temp__2 */ = create_closure(entry__get_kind_18, 0);
  // 508: :
  // 509:   $variable_kind
  // 510:     if
  // 511:       namespace_of(source).is_defined
  // 512:       ->
  // 513:         variable_kind_of
  // 514:           exported_names(name_of(source))(namespace_of(source))
  // 515:       -> variable_kind_of(global_names(name))
  // 516:   
  // 517:   case
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__get_kind_28, 0);
  // 493: cond
  // 494:   -> current_locals(name).is_defined:
  // 495:     return
  // 496:       if
  // 497:         name.is_a_shared_local
  // 498:         -> STANDARD
  // 499:         -> EARLY
  // 500:   -> needed_names(name).is_defined:
  // 501:     case variable_kind_of(needed_names(name))
  // 502:       STATIC_SINGLE:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__get_kind_44(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 523: -> UNKNOWN
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = unique__UNKNOWN;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__types__grammar_node___to_c(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 529: show_compiler_debug_info "generate expression"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__bce93a997a35ab67;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__types__grammar_node___to_c_3;
}
static void cont__types__grammar_node___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 530: -> "???"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__fa737815fd16bf3;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body___to_c(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // self: 0
  // return: 1
  // outer_level: 2
  // parent_locals: 3
  // is_an_inherited_shared_local: 4
  // body_name: 5
  // body_suffix: 6
  // par_count: 7
  frame->slots[1] /* return */ = create_continuation();
  // _define $outer_level level
  frame->slots[2] /* outer_level */ = get__level();
  // _define $parent_locals current_locals
  frame->slots[3] /* parent_locals */ = get__current_locals();
  // _define $is_an_inherited_shared_local is_a_shared_local
  frame->slots[4] /* is_an_inherited_shared_local */ = get__is_a_shared_local();
  frame->slots[5] /* body_name */ = create_future();
  frame->slots[6] /* body_suffix */ = create_future();
  define__cont_suffix(create_future());
  frame->slots[7] /* par_count */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 540: show_compiler_debug_info "generate body"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__463afb92a66256b1;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_3;
}
static void cont__compiler__body___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 544: $body_name name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_4;
}
static void cont__compiler__body___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* body_name */, arguments->slots[0]);
  // 548: body_name.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* body_name */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_5;
}
static void cont__compiler__body___to_c_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 549: -> string("__" body_name)
  frame->slots[9] /* temp__2 */ = create_closure(entry__compiler__body__to_c_6, 0);
  // 546: $body_suffix
  // 547:   if
  // 548:     body_name.is_defined
  // 549:     -> string("__" body_name)
  // 550:     -> string(suffix '_' index+1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = func__compiler__body__to_c_8;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_11;
}
static void entry__compiler__body__to_c_6(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // body_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* body_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 549: ... string("__" body_name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e5f02b9a;
  arguments->slots[1] = frame->slots[0] /* body_name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_7;
}
static void cont__compiler__body__to_c_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 549: -> string("__" body_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_8(void) {
  allocate_initialized_frame_gc(0, 2);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 550: ... index+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__index();
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_9;
}
static void cont__compiler__body__to_c_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__2 */ = arguments->slots[0];
  // 550: ... string(suffix '_' index+1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__suffix();
  arguments->slots[1] = character__95;
  arguments->slots[2] = frame->slots[1] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_10;
}
static void cont__compiler__body__to_c_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 550: -> string(suffix '_' index+1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body___to_c_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* body_suffix */, arguments->slots[0]);
  // 552: ... self.is_a_reference
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_reference();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_12;
}
static void cont__compiler__body___to_c_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 552: ... : return "func@(body_suffix)"
  frame->slots[9] /* temp__2 */ = create_closure(entry__compiler__body__to_c_13, 0);
  // 552: if self.is_a_reference: return "func@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_16;
}
static void entry__compiler__body__to_c_13(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // return: 0
  // body_suffix: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[6]; /* body_suffix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 552: ... "func@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__e0aec0b5d107d5a;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_15;
}
static void cont__compiler__body__to_c_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 552: ... return "func@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body___to_c_16(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 553: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_17;
}
static void cont__compiler__body___to_c_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 557: body_name.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* body_name */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_18;
}
static void cont__compiler__body___to_c_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 558: -> body_suffix
  frame->slots[9] /* temp__2 */ = create_closure(entry__compiler__body__to_c_19, 0);
  // 555: %cont_suffix
  // 556:   if
  // 557:     body_name.is_defined
  // 558:     -> body_suffix
  // 559:     -> suffix
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = func__compiler__body__to_c_20;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_21;
}
static void entry__compiler__body__to_c_19(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // body_suffix: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* body_suffix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 558: -> body_suffix
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* body_suffix */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_20(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 559: -> suffix
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__suffix();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body___to_c_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__cont_suffix(), arguments->slots[0]);
  // 561: $$par_count undefined
  ((CELL *)frame->slots[7])->contents /* par_count */ = get__undefined();
  // 562: ... :
  // 563:   %level outer_level+1
  // 564:   $$slot_idx 0
  // 565:   $$locals empty_insert_order_table
  // 566:   $$is_shared empty_set
  // 567:   $$min_par_cnt 0
  // 568:   $$max_par_cnt 0
  // 569:   $$right_par_cnt 0
  // 570:   $$has_rest_parameter false
  // 571:   $$has_complex_default_values false
  // ...
  frame->slots[8] /* temp__1 */ = create_closure(entry__compiler__body__to_c_22, 0);
  // 562: delayed:
  // 563:   %level outer_level+1
  // 564:   $$slot_idx 0
  // 565:   $$locals empty_insert_order_table
  // 566:   $$is_shared empty_set
  // 567:   $$min_par_cnt 0
  // 568:   $$max_par_cnt 0
  // 569:   $$right_par_cnt 0
  // 570:   $$has_rest_parameter false
  // 571:   $$has_complex_default_values false
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = func__delayed;
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_425;
}
static void entry__compiler__body__to_c_22(void) {
  allocate_initialized_frame_gc(7, 30);
  // slot allocations:
  // return__2: 0
  // outer_level: 1
  // self: 2
  // par_count: 3
  // is_an_inherited_shared_local: 4
  // body_suffix: 5
  // parent_locals: 6
  // slot_idx: 7
  // locals: 8
  // is_shared: 9
  // min_par_cnt: 10
  // max_par_cnt: 11
  // right_par_cnt: 12
  // has_rest_parameter: 13
  // has_complex_default_values: 14
  // myself_parameter: 15
  // continuation_parameter: 16
  // input_parameters: 17
  // output_parameters: 18
  // implicit_parameters: 19
  // locals_idx: 20
  // total_slots: 21
  // extract_destination_and_source: 22
  // extract_source_or_create_future: 23
  // statements: 24
  // generate_exit: 25
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* outer_level */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[7]; /* par_count */
  frame->slots[4] = myself->closure.frame->slots[4]; /* is_an_inherited_shared_local */
  frame->slots[5] = myself->closure.frame->slots[6]; /* body_suffix */
  frame->slots[6] = myself->closure.frame->slots[3]; /* parent_locals */
  // _define $extract_destination_and_source 
  // : (definition)
  //   is_a_key_value_pair !temp__1 definition
  // 
  //   !temp__2:
  //     key_of !temp__1 definition
  //     -> temp__1
  // 
  //   !temp__3 -> definition
  // 
  //   if $destination temp__1 temp__2 temp__3
  //   is_a_key_value_pair !temp__1 definition
  // 
  //   !temp__2:
  //     std::value_of !temp__1 definition
  //     -> temp__1
  // 
  //   if $source temp__1 temp__2 -> undefined
  //   -> destination source
  frame->slots[22] /* extract_destination_and_source */ = func__compiler__body__to_c_23;
  // _define $extract_source_or_create_future 
  // : (source)
  //   is_undefined !temp__1 source
  // 
  //   !temp__2:
  //     get_kind !temp__1 source
  // 
  //     !temp__2:
  //       mangled_name_of !temp__2 source
  //       std::string !temp__1 "get_value_or_future__" temp__2 "()"
  //       -> temp__1
  // 
  //     !temp__3:
  //       to_c !temp__1 source
  //       -> temp__1
  // 
  //     case
  //       temp__1
  //       .
  //       temp__2
  //       .
  //       -> "create_future()"
  //       temp__3
  // 
  //   if
  //     temp__1
  //     -> "create_future()"
  //     temp__2
  frame->slots[23] /* extract_source_or_create_future */ = func__compiler__body__to_c_34;
  frame->slots[25] /* generate_exit */ = create_future();
  define__level(create_future());
  frame->slots[7] /* slot_idx */ = create_cell();
  frame->slots[8] /* locals */ = create_cell();
  frame->slots[9] /* is_shared */ = create_cell();
  frame->slots[10] /* min_par_cnt */ = create_cell();
  frame->slots[11] /* max_par_cnt */ = create_cell();
  frame->slots[12] /* right_par_cnt */ = create_cell();
  frame->slots[13] /* has_rest_parameter */ = create_cell();
  frame->slots[14] /* has_complex_default_values */ = create_cell();
  frame->slots[15] /* myself_parameter */ = create_cell();
  frame->slots[16] /* continuation_parameter */ = create_cell();
  frame->slots[17] /* input_parameters */ = create_cell();
  frame->slots[18] /* output_parameters */ = create_cell();
  frame->slots[19] /* implicit_parameters */ = create_cell();
  // _define $locals_idx slot_idx
  frame->slots[20] /* locals_idx */ = create_future();
  frame->slots[21] /* total_slots */ = create_future();
  // _define %current_locals locals
  define__current_locals(create_future());
  // _define %is_a_shared_local is_shared
  define__is_a_shared_local(create_future());
  // _define %temporary_offset slot_idx
  define__temporary_offset(create_future());
  define__current_frame(create_future());
  frame->slots[24] /* statements */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 781: ... :
  // 782:   if
  // 783:     ||
  // 784:       self.defines_a_dynamic
  // 785:       &&
  // 786:         continuation_parameter.is_defined
  // 787:         variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 788:     :
  // 789:       write "
  // 790:         @
  // ...
  frame->slots[26] /* temp__1 */ = create_closure(entry__compiler__body__to_c_48, 0);
  // 781: $generate_exit:
  // 782:   if
  // 783:     ||
  // 784:       self.defines_a_dynamic
  // 785:       &&
  // 786:         continuation_parameter.is_defined
  // 787:         variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 788:     :
  // 789:       write "
  // 790:         @
  // ...
  initialize_future(frame->slots[25] /* generate_exit */, frame->slots[26] /* temp__1 */);
  // 563: %level outer_level+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* outer_level */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_66;
}
static void entry__compiler__body__to_c_57(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 793: ... continuation_parameter.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_58;
}
static void cont__compiler__body__to_c_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 789: ... "
  // 790:   @
  // 791:     argument_count = 0;
  // 792:     arguments = node_p;
  // 793:     myself = @(continuation_parameter.to_c);
  // 794:     func = myself->type;
  // 795:     frame->cont = invalid_continuation;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__ed9510e8330beabe;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__53a8ae7fafe9c367;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_61;
}
static void cont__compiler__body__to_c_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 789: write "
  // 790:   @
  // 791:     argument_count = 0;
  // 792:     arguments = node_p;
  // 793:     myself = @(continuation_parameter.to_c);
  // 794:     func = myself->type;
  // 795:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_62(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // self: 0
  // output_parameters: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 797: compute_source_text_info self false true !current_continuation_info
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = get__false();
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = func__compute_source_text_info;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_63;
}
static void cont__compiler__body__to_c_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__current_continuation_info(arguments->slots[0]);
  // 798: generate_c_arguments output_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 0;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_64;
}
static void cont__compiler__body__to_c_64(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 799: write "
  // 800:   @
  // 801:     frame = frame->caller_frame;
  // 802:     func = frame->cont;
  // 803:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b30064368698509a;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_38(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 708: ... mangled_name_of(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_39;
}
static void cont__compiler__body__to_c_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 708: ... "get_value_or_future__@(mangled_name_of(source))()"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__7f76cf7c934307b4;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6482bec;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_42;
}
static void cont__compiler__body__to_c_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 708: -> "get_value_or_future__@(mangled_name_of(source))()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_43(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 711: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_44;
}
static void cont__compiler__body__to_c_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 711: -> source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_45(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 710: -> "create_future()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__3e418beaa4f754e1;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_36(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 706: ... get_kind(source)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = func__get_kind;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_37;
}
static void cont__compiler__body__to_c_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 708: -> "get_value_or_future__@(mangled_name_of(source))()"
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__body__to_c_38, 0);
  // 711: -> source.to_c
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__body__to_c_43, 0);
  // 706: case get_kind(source)
  // 707:   UNKNOWN
  // 708:   -> "get_value_or_future__@(mangled_name_of(source))()"
  // 709:   STANDARD
  // 710:   -> "create_future()"
  // 711:   -> source.to_c
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = unique__UNKNOWN;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  arguments->slots[3] = unique__STANDARD;
  arguments->slots[4] = func__compiler__body__to_c_45;
  arguments->slots[5] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_47(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 704: -> "create_future()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__3e418beaa4f754e1;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_23(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // definition: 0
  // destination: 1
  // source: 2
  frame->slots[1] /* destination */ = create_future();
  frame->slots[2] /* source */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 689: definition.is_a_key_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_a_key_value_pair();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_24;
}
static void cont__compiler__body__to_c_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 690: -> key_of(definition)
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_25, 0);
  // 691: -> definition
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_27, 0);
  // 687: $destination
  // 688:   if
  // 689:     definition.is_a_key_value_pair
  // 690:     -> key_of(definition)
  // 691:     -> definition
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_28;
}
static void entry__compiler__body__to_c_25(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 690: ... key_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__key_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_26;
}
static void cont__compiler__body__to_c_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 690: -> key_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_27(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 691: -> definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* destination */, arguments->slots[0]);
  // 695: definition.is_a_key_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_a_key_value_pair();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_29;
}
static void cont__compiler__body__to_c_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 696: -> std::value_of(definition)
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_30, 0);
  // 693: $source
  // 694:   if
  // 695:     definition.is_a_key_value_pair
  // 696:     -> std::value_of(definition)
  // 697:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = func__compiler__body__to_c_32;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_33;
}
static void entry__compiler__body__to_c_30(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 696: ... std::value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__std__value_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_31;
}
static void cont__compiler__body__to_c_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 696: -> std::value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_32(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 697: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* source */, arguments->slots[0]);
  // 699: -> destination source
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  arguments->slots[1] = frame->slots[2] /* source */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_34(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // source: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 703: source.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_35;
}
static void cont__compiler__body__to_c_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 705: :
  // 706:   case get_kind(source)
  // 707:     UNKNOWN
  // 708:     -> "get_value_or_future__@(mangled_name_of(source))()"
  // 709:     STANDARD
  // 710:     -> "create_future()"
  // 711:     -> source.to_c
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__body__to_c_36, 0);
  // 702: if
  // 703:   source.is_undefined
  // 704:   -> "create_future()"
  // 705:   :
  // 706:     case get_kind(source)
  // 707:       UNKNOWN
  // 708:       -> "get_value_or_future__@(mangled_name_of(source))()"
  // 709:       STANDARD
  // 710:       -> "create_future()"
  // 711:       -> source.to_c
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__body__to_c_47;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_48(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // self: 0
  // continuation_parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* self */
  frame->slots[1] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[18]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 784: self.defines_a_dynamic
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__defines_a_dynamic();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_49;
}
static void cont__compiler__body__to_c_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 785: &&
  // 786:   continuation_parameter.is_defined
  // 787:   variable_kind_of(continuation_parameter) == STATIC_MULTI
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_50, 0);
  // 783: ||
  // 784:   self.defines_a_dynamic
  // 785:   &&
  // 786:     continuation_parameter.is_defined
  // 787:     variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_56;
}
static void entry__compiler__body__to_c_50(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 786: continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_51;
}
static void cont__compiler__body__to_c_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 787: variable_kind_of(continuation_parameter) == STATIC_MULTI
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__body__to_c_52, 0);
  // 785: &&
  // 786:   continuation_parameter.is_defined
  // 787:   variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_55;
}
static void entry__compiler__body__to_c_52(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 787: variable_kind_of(continuation_parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_53;
}
static void cont__compiler__body__to_c_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 787: variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = get__STATIC_MULTI();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_54;
}
static void cont__compiler__body__to_c_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 787: variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 785: &&
  // 786:   continuation_parameter.is_defined
  // 787:   variable_kind_of(continuation_parameter) == STATIC_MULTI
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 788: :
  // 789:   write "
  // 790:     @
  // 791:       argument_count = 0;
  // 792:       arguments = node_p;
  // 793:       myself = @(continuation_parameter.to_c);
  // 794:       func = myself->type;
  // 795:       frame->cont = invalid_continuation;
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__body__to_c_57, 0);
  // 796: :
  // 797:   compute_source_text_info self false true !current_continuation_info
  // 798:   generate_c_arguments output_parameters
  // 799:   write "
  // 800:     @
  // 801:       frame = frame->caller_frame;
  // 802:       func = frame->cont;
  // 803:       frame->cont = invalid_continuation;
  frame->slots[7] /* temp__5 */ = create_closure(entry__compiler__body__to_c_62, 0);
  // 782: if
  // 783:   ||
  // 784:     self.defines_a_dynamic
  // 785:     &&
  // 786:       continuation_parameter.is_defined
  // 787:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 788:   :
  // 789:     write "
  // 790:       @
  // 791:         argument_count = 0;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__level(), arguments->slots[0]);
  // 564: $$slot_idx 0
  ((CELL *)frame->slots[7])->contents /* slot_idx */ = number__0;
  // 565: $$locals empty_insert_order_table
  ((CELL *)frame->slots[8])->contents /* locals */ = get__empty_insert_order_table();
  // 566: $$is_shared empty_set
  ((CELL *)frame->slots[9])->contents /* is_shared */ = get__empty_set();
  // 567: $$min_par_cnt 0
  ((CELL *)frame->slots[10])->contents /* min_par_cnt */ = number__0;
  // 568: $$max_par_cnt 0
  ((CELL *)frame->slots[11])->contents /* max_par_cnt */ = number__0;
  // 569: $$right_par_cnt 0
  ((CELL *)frame->slots[12])->contents /* right_par_cnt */ = number__0;
  // 570: $$has_rest_parameter false
  ((CELL *)frame->slots[13])->contents /* has_rest_parameter */ = get__false();
  // 571: $$has_complex_default_values false
  ((CELL *)frame->slots[14])->contents /* has_complex_default_values */ = get__false();
  // 572: $$myself_parameter undefined
  ((CELL *)frame->slots[15])->contents /* myself_parameter */ = get__undefined();
  // 573: $$continuation_parameter undefined
  ((CELL *)frame->slots[16])->contents /* continuation_parameter */ = get__undefined();
  // 574: $$input_parameters empty_list
  ((CELL *)frame->slots[17])->contents /* input_parameters */ = get__empty_list();
  // 575: $$output_parameters empty_list
  ((CELL *)frame->slots[18])->contents /* output_parameters */ = get__empty_list();
  // 576: $$implicit_parameters empty_list
  ((CELL *)frame->slots[19])->contents /* implicit_parameters */ = get__empty_list();
  // 577: ... parameters_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__parameters_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_67;
}
static void cont__compiler__body__to_c_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 577: ... : (parameter)
  // 578:   $kind parameter_kind_of(parameter)
  // 579:   $default_value default_value_of(parameter)
  // 580:   if default_value.is_defined && default_value.is_a_function_call:
  // 581:     !has_complex_default_values true
  // 582:   case kind
  // 583:     OUT_PARAMETER:
  // 584:       push &output_parameters parameter
  // 585:     IN_OUT_PARAMETER:
  // 586:       push &input_parameters parameter
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_68, 1);
  // 577: for_each parameters_of(self): (parameter)
  // 578:   $kind parameter_kind_of(parameter)
  // 579:   $default_value default_value_of(parameter)
  // 580:   if default_value.is_defined && default_value.is_a_function_call:
  // 581:     !has_complex_default_values true
  // 582:   case kind
  // 583:     OUT_PARAMETER:
  // 584:       push &output_parameters parameter
  // 585:     IN_OUT_PARAMETER:
  // 586:       push &input_parameters parameter
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_87;
}
static void entry__compiler__body__to_c_83(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // implicit_parameters: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* implicit_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 589: push &implicit_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* implicit_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_84;
}
static void cont__compiler__body__to_c_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* implicit_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_85(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // input_parameters: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* input_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 591: push &input_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* input_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_86;
}
static void cont__compiler__body__to_c_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* input_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_68(void) {
  allocate_initialized_frame_gc(5, 12);
  // slot allocations:
  // parameter: 0
  // has_complex_default_values: 1
  // output_parameters: 2
  // input_parameters: 3
  // implicit_parameters: 4
  // kind: 5
  // default_value: 6
  frame->slots[1] = myself->closure.frame->slots[14]; /* has_complex_default_values */
  frame->slots[2] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[3] = myself->closure.frame->slots[17]; /* input_parameters */
  frame->slots[4] = myself->closure.frame->slots[19]; /* implicit_parameters */
  frame->slots[5] /* kind */ = create_future();
  frame->slots[6] /* default_value */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 578: $kind parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_69;
}
static void cont__compiler__body__to_c_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* kind */, arguments->slots[0]);
  // 579: $default_value default_value_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_70;
}
static void cont__compiler__body__to_c_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* default_value */, arguments->slots[0]);
  // 580: ... default_value.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* default_value */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_71;
}
static void cont__compiler__body__to_c_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 580: ... default_value.is_a_function_call
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__body__to_c_72, 0);
  // 580: ... default_value.is_defined && default_value.is_a_function_call
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_74;
}
static void entry__compiler__body__to_c_72(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // default_value: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* default_value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 580: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* default_value */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_73;
}
static void cont__compiler__body__to_c_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 580: ... default_value.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 580: ... :
  // 581:   !has_complex_default_values true
  frame->slots[10] /* temp__4 */ = create_closure(entry__compiler__body__to_c_75, 0);
  // 580: if default_value.is_defined && default_value.is_a_function_call:
  // 581:   !has_complex_default_values true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_76;
}
static void entry__compiler__body__to_c_75(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 581: !has_complex_default_values true
  ((CELL *)frame->slots[0])->contents /* has_complex_default_values */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_76(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 583: ... :
  // 584:   push &output_parameters parameter
  frame->slots[7] /* temp__1 */ = create_closure(entry__compiler__body__to_c_77, 0);
  // 585: ... :
  // 586:   push &input_parameters parameter
  // 587:   push &output_parameters parameter
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__body__to_c_79, 0);
  // 588: MYSELF_PARAMETER, CONTINUATION_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__MYSELF_PARAMETER();
  arguments->slots[1] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_82;
}
static void entry__compiler__body__to_c_77(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // output_parameters: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* output_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 584: push &output_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_78;
}
static void cont__compiler__body__to_c_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* output_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_79(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // input_parameters: 0
  // parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* input_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[2] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 586: push &input_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* input_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_80;
}
static void cont__compiler__body__to_c_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* input_parameters */ = arguments->slots[0];
  // 587: push &output_parameters parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[1] /* parameter */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_81;
}
static void cont__compiler__body__to_c_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* output_parameters */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 588: ... :
  // 589:   push &implicit_parameters parameter
  frame->slots[10] /* temp__4 */ = create_closure(entry__compiler__body__to_c_83, 0);
  // 590: :
  // 591:   push &input_parameters parameter
  frame->slots[11] /* temp__5 */ = create_closure(entry__compiler__body__to_c_85, 0);
  // 582: case kind
  // 583:   OUT_PARAMETER:
  // 584:     push &output_parameters parameter
  // 585:   IN_OUT_PARAMETER:
  // 586:     push &input_parameters parameter
  // 587:     push &output_parameters parameter
  // 588:   MYSELF_PARAMETER, CONTINUATION_PARAMETER:
  // 589:     push &implicit_parameters parameter
  // 590:   :
  // 591:     push &input_parameters parameter
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* kind */;
  arguments->slots[1] = get__OUT_PARAMETER();
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  arguments->slots[3] = get__IN_OUT_PARAMETER();
  arguments->slots[4] = frame->slots[8] /* temp__2 */;
  arguments->slots[5] = frame->slots[9] /* temp__3 */;
  arguments->slots[6] = frame->slots[10] /* temp__4 */;
  arguments->slots[7] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_87(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 595: ... : (parameter)
  // 596:   $name name_of(identifier_of(parameter))
  // 597:   cond
  // 598:     -> parameter.is_an_optional_item: inc &max_par_cnt
  // 599:     -> parameter.is_an_expanded_item: !has_rest_parameter true
  // 600:     :
  // 601:       inc &min_par_cnt
  // 602:       inc &max_par_cnt
  // 603:       if max_par_cnt > min_par_cnt: inc &right_par_cnt
  // 604:   !locals(name) slot_idx
  // ...
  frame->slots[26] /* temp__1 */ = create_closure(entry__compiler__body__to_c_88, 1);
  // 595: for_each input_parameters: (parameter)
  // 596:   $name name_of(identifier_of(parameter))
  // 597:   cond
  // 598:     -> parameter.is_an_optional_item: inc &max_par_cnt
  // 599:     -> parameter.is_an_expanded_item: !has_rest_parameter true
  // 600:     :
  // 601:       inc &min_par_cnt
  // 602:       inc &max_par_cnt
  // 603:       if max_par_cnt > min_par_cnt: inc &right_par_cnt
  // 604:   !locals(name) slot_idx
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[17])->contents /* input_parameters */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_109;
}
static void entry__compiler__body__to_c_88(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // parameter: 0
  // max_par_cnt: 1
  // has_rest_parameter: 2
  // min_par_cnt: 3
  // right_par_cnt: 4
  // locals: 5
  // slot_idx: 6
  // is_shared: 7
  // name: 8
  frame->slots[1] = myself->closure.frame->slots[11]; /* max_par_cnt */
  frame->slots[2] = myself->closure.frame->slots[13]; /* has_rest_parameter */
  frame->slots[3] = myself->closure.frame->slots[10]; /* min_par_cnt */
  frame->slots[4] = myself->closure.frame->slots[12]; /* right_par_cnt */
  frame->slots[5] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[6] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[7] = myself->closure.frame->slots[9]; /* is_shared */
  frame->slots[8] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 596: ... identifier_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_89;
}
static void cont__compiler__body__to_c_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 596: $name name_of(identifier_of(parameter))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_90;
}
static void cont__compiler__body__to_c_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* name */, arguments->slots[0]);
  // 598: -> parameter.is_an_optional_item: inc &max_par_cnt
  frame->slots[9] /* temp__1 */ = create_closure(entry__compiler__body__to_c_91, 0);
  // 599: -> parameter.is_an_expanded_item: !has_rest_parameter true
  frame->slots[10] /* temp__2 */ = create_closure(entry__compiler__body__to_c_95, 0);
  // 600: :
  // 601:   inc &min_par_cnt
  // 602:   inc &max_par_cnt
  // 603:   if max_par_cnt > min_par_cnt: inc &right_par_cnt
  frame->slots[11] /* temp__3 */ = create_closure(entry__compiler__body__to_c_98, 0);
  // 597: cond
  // 598:   -> parameter.is_an_optional_item: inc &max_par_cnt
  // 599:   -> parameter.is_an_expanded_item: !has_rest_parameter true
  // 600:   :
  // 601:     inc &min_par_cnt
  // 602:     inc &max_par_cnt
  // 603:     if max_par_cnt > min_par_cnt: inc &right_par_cnt
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__2 */;
  arguments->slots[2] = frame->slots[11] /* temp__3 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_104;
}
static void entry__compiler__body__to_c_102(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // right_par_cnt: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* right_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 603: ... inc &right_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_103;
}
static void cont__compiler__body__to_c_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right_par_cnt */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_97(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_rest_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_rest_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 599: ... !has_rest_parameter true
  ((CELL *)frame->slots[0])->contents /* has_rest_parameter */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_93(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // max_par_cnt: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* max_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 598: ... inc &max_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* max_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_94;
}
static void cont__compiler__body__to_c_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* max_par_cnt */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_91(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // parameter: 0
  // max_par_cnt: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[1] = myself->closure.frame->slots[1]; /* max_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 598: ... parameter.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_92;
}
static void cont__compiler__body__to_c_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 598: ... : inc &max_par_cnt
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__body__to_c_93, 0);
  // 598: -> parameter.is_an_optional_item: inc &max_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_95(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // parameter: 0
  // has_rest_parameter: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[1] = myself->closure.frame->slots[2]; /* has_rest_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 599: ... parameter.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_96;
}
static void cont__compiler__body__to_c_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 599: ... : !has_rest_parameter true
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__body__to_c_97, 0);
  // 599: -> parameter.is_an_expanded_item: !has_rest_parameter true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_98(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // min_par_cnt: 0
  // max_par_cnt: 1
  // right_par_cnt: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* min_par_cnt */
  frame->slots[1] = myself->closure.frame->slots[1]; /* max_par_cnt */
  frame->slots[2] = myself->closure.frame->slots[4]; /* right_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 601: inc &min_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* min_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_99;
}
static void cont__compiler__body__to_c_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* min_par_cnt */ = arguments->slots[0];
  // 602: inc &max_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* max_par_cnt */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_100;
}
static void cont__compiler__body__to_c_100(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* max_par_cnt */ = arguments->slots[0];
  // 603: ... max_par_cnt > min_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* min_par_cnt */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* max_par_cnt */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_101;
}
static void cont__compiler__body__to_c_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 603: ... : inc &right_par_cnt
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_102, 0);
  // 603: if max_par_cnt > min_par_cnt: inc &right_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_104(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 604: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* name */;
  arguments->slots[1] = ((CELL *)frame->slots[6])->contents /* slot_idx */;
  result_count = 1;
  myself = ((CELL *)frame->slots[5])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_105;
}
static void cont__compiler__body__to_c_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* locals */ = arguments->slots[0];
  // 605: !is_shared(name) parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_106;
}
static void cont__compiler__body__to_c_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 605: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* name */;
  arguments->slots[1] = frame->slots[9] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[7])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_107;
}
static void cont__compiler__body__to_c_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[7])->contents /* is_shared */ = arguments->slots[0];
  // 606: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_108;
}
static void cont__compiler__body__to_c_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_109(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 607: ... : (parameter)
  // 608:   $name name_of(identifier_of(parameter))
  // 609:   case parameter_kind_of(parameter)
  // 610:     MYSELF_PARAMETER:
  // 611:       !myself_parameter parameter
  // 612:     CONTINUATION_PARAMETER:
  // 613:       !continuation_parameter parameter
  // 614:   !locals(name) slot_idx
  // 615:   !is_shared(name) parameter.is_a_multi_assign_definition
  // 616:   inc &slot_idx
  frame->slots[26] /* temp__1 */ = create_closure(entry__compiler__body__to_c_110, 1);
  // 607: for_each implicit_parameters: (parameter)
  // 608:   $name name_of(identifier_of(parameter))
  // 609:   case parameter_kind_of(parameter)
  // 610:     MYSELF_PARAMETER:
  // 611:       !myself_parameter parameter
  // 612:     CONTINUATION_PARAMETER:
  // 613:       !continuation_parameter parameter
  // 614:   !locals(name) slot_idx
  // 615:   !is_shared(name) parameter.is_a_multi_assign_definition
  // 616:   inc &slot_idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[19])->contents /* implicit_parameters */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_121;
}
static void entry__compiler__body__to_c_110(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // parameter: 0
  // myself_parameter: 1
  // continuation_parameter: 2
  // locals: 3
  // slot_idx: 4
  // is_shared: 5
  // name: 6
  frame->slots[1] = myself->closure.frame->slots[15]; /* myself_parameter */
  frame->slots[2] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[3] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[4] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[5] = myself->closure.frame->slots[9]; /* is_shared */
  frame->slots[6] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 608: ... identifier_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_111;
}
static void cont__compiler__body__to_c_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 608: $name name_of(identifier_of(parameter))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_112;
}
static void cont__compiler__body__to_c_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* name */, arguments->slots[0]);
  // 609: ... parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_113;
}
static void cont__compiler__body__to_c_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 610: ... :
  // 611:   !myself_parameter parameter
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__body__to_c_114, 0);
  // 612: ... :
  // 613:   !continuation_parameter parameter
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__body__to_c_115, 0);
  // 609: case parameter_kind_of(parameter)
  // 610:   MYSELF_PARAMETER:
  // 611:     !myself_parameter parameter
  // 612:   CONTINUATION_PARAMETER:
  // 613:     !continuation_parameter parameter
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = get__MYSELF_PARAMETER();
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  arguments->slots[3] = get__CONTINUATION_PARAMETER();
  arguments->slots[4] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_116;
}
static void entry__compiler__body__to_c_114(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // myself_parameter: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* myself_parameter */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 611: !myself_parameter parameter
  ((CELL *)frame->slots[0])->contents /* myself_parameter */ = frame->slots[1] /* parameter */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_115(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // continuation_parameter: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* continuation_parameter */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 613: !continuation_parameter parameter
  ((CELL *)frame->slots[0])->contents /* continuation_parameter */ = frame->slots[1] /* parameter */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_116(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 614: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* name */;
  arguments->slots[1] = ((CELL *)frame->slots[4])->contents /* slot_idx */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_117;
}
static void cont__compiler__body__to_c_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* locals */ = arguments->slots[0];
  // 615: !is_shared(name) parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_118;
}
static void cont__compiler__body__to_c_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 615: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* name */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[5])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_119;
}
static void cont__compiler__body__to_c_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* is_shared */ = arguments->slots[0];
  // 616: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_120;
}
static void cont__compiler__body__to_c_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_121(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 619: ... max_par_cnt != min_par_cnt
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_122, 0);
  // 619: has_rest_parameter || max_par_cnt != min_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[13])->contents /* has_rest_parameter */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_125;
}
static void entry__compiler__body__to_c_122(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // max_par_cnt: 0
  // min_par_cnt: 1
  frame->slots[0] = myself->closure.frame->slots[11]; /* max_par_cnt */
  frame->slots[1] = myself->closure.frame->slots[10]; /* min_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 619: ... max_par_cnt != min_par_cnt
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* max_par_cnt */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* min_par_cnt */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_123;
}
static void cont__compiler__body__to_c_123(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 619: ... max_par_cnt != min_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_124;
}
static void cont__compiler__body__to_c_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 619: ... max_par_cnt != min_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 621: -> max_par_cnt
  frame->slots[28] /* temp__3 */ = create_closure(entry__compiler__body__to_c_126, 0);
  // 617: !par_count
  // 618:   if
  // 619:     has_rest_parameter || max_par_cnt != min_par_cnt
  // 620:     -> -1
  // 621:     -> max_par_cnt
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = func__compiler__body__to_c_127;
  arguments->slots[2] = frame->slots[28] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_129;
}
static void entry__compiler__body__to_c_126(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // max_par_cnt: 0
  frame->slots[0] = myself->closure.frame->slots[11]; /* max_par_cnt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 621: -> max_par_cnt
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* max_par_cnt */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_127(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 620: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_128;
}
static void cont__compiler__body__to_c_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 620: -> -1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* par_count */ = arguments->slots[0];
  // 625: ... inherited_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__inherited_names_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_130;
}
static void cont__compiler__body__to_c_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 625: ... : (name _info)
  // 626:   !locals(name) slot_idx
  // 627:   !is_shared(name) is_an_inherited_shared_local(name)
  // 628:   inc &slot_idx
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_131, 2);
  // 625: for_each inherited_names_of(self): (name _info)
  // 626:   !locals(name) slot_idx
  // 627:   !is_shared(name) is_an_inherited_shared_local(name)
  // 628:   inc &slot_idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_136;
}
static void entry__compiler__body__to_c_131(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // name: 0
  // info: 1
  // locals: 2
  // slot_idx: 3
  // is_shared: 4
  // is_an_inherited_shared_local: 5
  frame->slots[2] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[3] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[4] = myself->closure.frame->slots[9]; /* is_shared */
  frame->slots[5] = myself->closure.frame->slots[4]; /* is_an_inherited_shared_local */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 626: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* slot_idx */;
  result_count = 1;
  myself = ((CELL *)frame->slots[2])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_132;
}
static void cont__compiler__body__to_c_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* locals */ = arguments->slots[0];
  // 627: !is_shared(name) is_an_inherited_shared_local(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = frame->slots[5] /* is_an_inherited_shared_local */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_133;
}
static void cont__compiler__body__to_c_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 627: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[4])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_134;
}
static void cont__compiler__body__to_c_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* is_shared */ = arguments->slots[0];
  // 628: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_135;
}
static void cont__compiler__body__to_c_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_136(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 629: $locals_idx slot_idx
  initialize_maybe_future(frame->slots[20] /* locals_idx */, ((CELL *)frame->slots[7])->contents /* slot_idx */);
  // 633: ... defined_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__defined_names_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_137;
}
static void cont__compiler__body__to_c_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 633: ... : (name info)
  // 634:   unless info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER:
  // 635:     !locals(name) slot_idx
  // 636:     !is_shared(name) info.is_a_multi_assign_definition
  // 637:     inc &slot_idx
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_138, 2);
  // 633: for_each defined_names_of(self): (name info)
  // 634:   unless info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER:
  // 635:     !locals(name) slot_idx
  // 636:     !is_shared(name) info.is_a_multi_assign_definition
  // 637:     inc &slot_idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_150;
}
static void entry__compiler__body__to_c_145(void) {
  allocate_initialized_frame_gc(5, 6);
  // slot allocations:
  // locals: 0
  // name: 1
  // slot_idx: 2
  // is_shared: 3
  // info: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* locals */
  frame->slots[1] = myself->closure.frame->slots[0]; /* name */
  frame->slots[2] = myself->closure.frame->slots[3]; /* slot_idx */
  frame->slots[3] = myself->closure.frame->slots[4]; /* is_shared */
  frame->slots[4] = myself->closure.frame->slots[1]; /* info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 635: !locals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* slot_idx */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_146;
}
static void cont__compiler__body__to_c_146(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* locals */ = arguments->slots[0];
  // 636: !is_shared(name) info.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* info */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_147;
}
static void cont__compiler__body__to_c_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 636: !is_shared(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* is_shared */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_148;
}
static void cont__compiler__body__to_c_148(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* is_shared */ = arguments->slots[0];
  // 637: inc &slot_idx
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* slot_idx */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_149;
}
static void cont__compiler__body__to_c_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* slot_idx */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_138(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // name: 0
  // info: 1
  // locals: 2
  // slot_idx: 3
  // is_shared: 4
  frame->slots[2] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[3] = myself->closure.frame->slots[7]; /* slot_idx */
  frame->slots[4] = myself->closure.frame->slots[9]; /* is_shared */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 634: ... info.is_a_parameter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* info */;
  result_count = 1;
  myself = get__is_a_parameter();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_139;
}
static void cont__compiler__body__to_c_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 634: ... parameter_kind_of(info) != OUT_PARAMETER
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__body__to_c_140, 0);
  // 634: ... info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_144;
}
static void entry__compiler__body__to_c_140(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // info: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 634: ... parameter_kind_of(info)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* info */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_141;
}
static void cont__compiler__body__to_c_141(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 634: ... parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__OUT_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_142;
}
static void cont__compiler__body__to_c_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 634: ... parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_143;
}
static void cont__compiler__body__to_c_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 634: ... parameter_kind_of(info) != OUT_PARAMETER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 634: ... :
  // 635:   !locals(name) slot_idx
  // 636:   !is_shared(name) info.is_a_multi_assign_definition
  // 637:   inc &slot_idx
  frame->slots[8] /* temp__4 */ = create_closure(entry__compiler__body__to_c_145, 0);
  // 634: unless info.is_a_parameter && parameter_kind_of(info) != OUT_PARAMETER:
  // 635:   !locals(name) slot_idx
  // 636:   !is_shared(name) info.is_a_multi_assign_definition
  // 637:   inc &slot_idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_150(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 638: ... temporary_count_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__temporary_count_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_151;
}
static void cont__compiler__body__to_c_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 638: $total_slots slot_idx+temporary_count_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[7])->contents /* slot_idx */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_152;
}
static void cont__compiler__body__to_c_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[21] /* total_slots */, arguments->slots[0]);
  // 639: %current_locals locals
  initialize_maybe_future(get__current_locals(), ((CELL *)frame->slots[8])->contents /* locals */);
  // 640: %is_a_shared_local is_shared
  initialize_maybe_future(get__is_a_shared_local(), ((CELL *)frame->slots[9])->contents /* is_shared */);
  // 641: %temporary_offset slot_idx
  initialize_maybe_future(get__temporary_offset(), ((CELL *)frame->slots[7])->contents /* slot_idx */);
  // 642: ... "static NODE *func@(body_suffix);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__6b846eb6691a1cd5;
  arguments->slots[1] = frame->slots[5] /* body_suffix */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_154;
}
static void cont__compiler__body__to_c_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 642: write_to_declarations "static NODE *func@(body_suffix);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_155;
}
static void cont__compiler__body__to_c_155(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 643: ... :
  // 644:   %current_frame undefined
  // 645:   begin_continuation "entry@(body_suffix)"
  frame->slots[26] /* temp__1 */ = create_closure(entry__compiler__body__to_c_156, 0);
  // 643: do:
  // 644:   %current_frame undefined
  // 645:   begin_continuation "entry@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_160;
}
static void entry__compiler__body__to_c_156(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // return__1: 0
  // body_suffix: 1
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[5]; /* body_suffix */
  // _define %current_frame undefined
  define__current_frame(get_value_or_future__undefined());
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 644: %current_frame undefined
  initialize_maybe_future(get__current_frame(), get__undefined());
  // 645: ... "entry@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__565aee03ea58402e;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_158;
}
static void cont__compiler__body__to_c_158(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 645: begin_continuation "entry@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__begin_continuation();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_159;
}
static void cont__compiler__body__to_c_159(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_160(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 646: ... has_complex_default_values
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_161, 0);
  // 646: ... has_rest_parameter || has_complex_default_values
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[13])->contents /* has_rest_parameter */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_162;
}
static void entry__compiler__body__to_c_161(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_complex_default_values: 0
  frame->slots[0] = myself->closure.frame->slots[14]; /* has_complex_default_values */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 646: ... has_complex_default_values
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* has_complex_default_values */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 646: if has_rest_parameter || has_complex_default_values:
  // 647:   write "
  // 648:     @
  // 649:       allocate_arguments();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = func__compiler__body__to_c_163;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_165;
}
static void entry__compiler__body__to_c_163(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 647: write "
  // 648:   @
  // 649:     allocate_arguments();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__e67ad3f0422c2c7e;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_165(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 652: continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[16])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_166;
}
static void cont__compiler__body__to_c_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[27] /* temp__2 */ = arguments->slots[0];
  // 653: continuation_parameter.is_a_multi_assign_definition
  frame->slots[28] /* temp__3 */ = create_closure(entry__compiler__body__to_c_167, 0);
  // 651: &&
  // 652:   continuation_parameter.is_defined
  // 653:   continuation_parameter.is_a_multi_assign_definition
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[27] /* temp__2 */;
  arguments->slots[1] = frame->slots[28] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_169;
}
static void entry__compiler__body__to_c_167(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // continuation_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[16]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 653: continuation_parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_a_multi_assign_definition();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_168;
}
static void cont__compiler__body__to_c_168(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 653: continuation_parameter.is_a_multi_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_169(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 650: if
  // 651:   &&
  // 652:     continuation_parameter.is_defined
  // 653:     continuation_parameter.is_a_multi_assign_definition
  // 654:   :
  // 655:     write "
  // 656:       @
  // 657:         caller_frame = frame;
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = func__compiler__body__to_c_170;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_172;
}
static void entry__compiler__body__to_c_170(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 655: write "
  // 656:   @
  // 657:     caller_frame = frame;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2acb68f672d208ee;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_172(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 658: ... "  allocate_initialized_frame_gc(@(locals_idx), @(total_slots));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__81412d4a12e22ca0;
  arguments->slots[1] = frame->slots[20] /* locals_idx */;
  arguments->slots[2] = string__2d7981f4e6682be5;
  arguments->slots[3] = frame->slots[21] /* total_slots */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_174;
}
static void cont__compiler__body__to_c_174(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 658: write "  allocate_initialized_frame_gc(@(locals_idx), @(total_slots));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_175;
}
static void cont__compiler__body__to_c_175(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 659: writeln "  // slot allocations:"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b723bfa8a9fda3ff;
  result_count = 0;
  myself = get__writeln();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_177;
}
static void cont__compiler__body__to_c_177(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 661: ... length_of(current_locals)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__current_locals();
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_178;
}
static void cont__compiler__body__to_c_178(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[27] /* temp__2 */ = arguments->slots[0];
  // 661: "static FRAME_INFO frame@(body_suffix) = {@(length_of(current_locals)), {"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__d564cec0827db510;
  arguments->slots[1] = frame->slots[5] /* body_suffix */;
  arguments->slots[2] = string__820afe0b5f607d42;
  arguments->slots[3] = frame->slots[27] /* temp__2 */;
  arguments->slots[4] = string__fa733415f296bb7;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_182;
}
static void cont__compiler__body__to_c_182(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 660: write_to_declarations
  // 661:   "static FRAME_INFO frame@(body_suffix) = {@(length_of(current_locals)), {"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_183;
}
static void cont__compiler__body__to_c_183(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 662: for_each current_locals: (name slot)
  // 663:   writeln "  // @(name): @(slot)"
  // 664:   if slot != 0: write_to_declarations ", "
  // 665:   write_to_declarations "@quot;@(name)@quot;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__current_locals();
  arguments->slots[1] = func__compiler__body__to_c_184;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_193;
}
static void entry__compiler__body__to_c_184(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // name: 0
  // slot: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 663: ... "  // @(name): @(slot)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__ca5af8c3e8b41077;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__2d7981f4e6d82be5;
  arguments->slots[3] = frame->slots[1] /* slot */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_185;
}
static void cont__compiler__body__to_c_185(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 663: writeln "  // @(name): @(slot)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__writeln();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_186;
}
static void cont__compiler__body__to_c_186(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 664: ... slot != 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* slot */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_187;
}
static void cont__compiler__body__to_c_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 664: ... slot != 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_188;
}
static void cont__compiler__body__to_c_188(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 664: if slot != 0: write_to_declarations ", "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = func__compiler__body__to_c_189;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_190;
}
static void entry__compiler__body__to_c_189(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 664: ... write_to_declarations ", "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6682be5;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_190(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 665: ... "@quot;@(name)@quot;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc3;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__578a5af303e9cc3;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_192;
}
static void cont__compiler__body__to_c_192(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 665: write_to_declarations "@quot;@(name)@quot;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_193(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 666: write_to_declarations "
  // 667:   }};
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__380aee0b5fb87d33;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_195;
}
static void cont__compiler__body__to_c_195(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 668: %current_frame "frame@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__6e5aeb43eaa07032;
  arguments->slots[1] = frame->slots[5] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_197;
}
static void cont__compiler__body__to_c_197(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__current_frame(), arguments->slots[0]);
  // 669: ... continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[16])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_198;
}
static void cont__compiler__body__to_c_198(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 669: ... :
  // 670:   assign_argument_or_result
  // 671:     "arguments"
  // 672:     continuation_parameter
  // 673:     if
  // 674:       output_parameters.is_empty
  // 675:       -> "create_continuation()"
  // 676:       :
  // 677:         write_to_declarations "
  // 678:           static void exit@(body_suffix)(void);
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_199, 0);
  // 669: if continuation_parameter.is_defined:
  // 670:   assign_argument_or_result
  // 671:     "arguments"
  // 672:     continuation_parameter
  // 673:     if
  // 674:       output_parameters.is_empty
  // 675:       -> "create_continuation()"
  // 676:       :
  // 677:         write_to_declarations "
  // 678:           static void exit@(body_suffix)(void);
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_210;
}
static void entry__compiler__body__to_c_199(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // continuation_parameter: 0
  // output_parameters: 1
  // body_suffix: 2
  frame->slots[0] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[1] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[2] = myself->closure.frame->slots[5]; /* body_suffix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 674: output_parameters.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_200;
}
static void cont__compiler__body__to_c_200(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 676: :
  // 677:   write_to_declarations "
  // 678:     static void exit@(body_suffix)(void);
  // 679:   -> "create_continuation_with_exit(exit@(body_suffix))"
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_201, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = func__compiler__body__to_c_207;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_209;
}
static void entry__compiler__body__to_c_201(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // body_suffix: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* body_suffix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 677: ... "
  // 678:   static void exit@(body_suffix)(void);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__dd22cae03536c939;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__66ccbf91860d092a;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_203;
}
static void cont__compiler__body__to_c_203(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 677: write_to_declarations "
  // 678:   static void exit@(body_suffix)(void);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_204;
}
static void cont__compiler__body__to_c_204(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 679: ... "create_continuation_with_exit(exit@(body_suffix))"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__cec1f2b7e8b1bf6a;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__578a5af303e9cc8;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_206;
}
static void cont__compiler__body__to_c_206(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 679: -> "create_continuation_with_exit(exit@(body_suffix))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_207(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 675: -> "create_continuation()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__ce243b1c25d80854;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_209(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 670: assign_argument_or_result
  // 671:   "arguments"
  // 672:   continuation_parameter
  // 673:   if
  // 674:     output_parameters.is_empty
  // 675:     -> "create_continuation()"
  // 676:     :
  // 677:       write_to_declarations "
  // 678:         static void exit@(body_suffix)(void);
  // 679:       -> "create_continuation_with_exit(exit@(body_suffix))"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__64ac252603a3a696;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_210(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 680: ... inherited_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__inherited_names_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_211;
}
static void cont__compiler__body__to_c_211(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 680: ... : (name _info)
  // 681:   write "
  // 682:     @
  // 683:       frame->slots[@(current_locals(name))] = @
  // 684:     myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_212, 2);
  // 680: for_each inherited_names_of(self): (name _info)
  // 681:   write "
  // 682:     @
  // 683:       frame->slots[@(current_locals(name))] = @
  // 684:     myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_220;
}
static void entry__compiler__body__to_c_212(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // name: 0
  // info: 1
  // parent_locals: 2
  frame->slots[2] = myself->closure.frame->slots[6]; /* parent_locals */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 683: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_213;
}
static void cont__compiler__body__to_c_213(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 684: ... parent_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = frame->slots[2] /* parent_locals */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_214;
}
static void cont__compiler__body__to_c_214(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 681: ... "
  // 682:   @
  // 683:     frame->slots[@(current_locals(name))] = @
  // 684:   myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__6c6dcf991c09c1f6;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__716ce75c96089b20;
  arguments->slots[3] = frame->slots[5] /* temp__3 */;
  arguments->slots[4] = string__d81f459e03efe2f7;
  arguments->slots[5] = frame->slots[0] /* name */;
  arguments->slots[6] = string__820afbcb5f187d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_219;
}
static void cont__compiler__body__to_c_219(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 681: write "
  // 682:   @
  // 683:     frame->slots[@(current_locals(name))] = @
  // 684:   myself->closure.frame->slots[@(parent_locals(name))]; /* @(name) */
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_220(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 713: ... definitions_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__definitions_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_221;
}
static void cont__compiler__body__to_c_221(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 713: ... : (definition)
  // 714:   extract_destination_and_source $destination $source definition
  // 715:   if source.is_defined:
  // 716:     write_as_remark
  // 717:       "_define @(key_of(definition)) @(std::value_of(definition))"
  // 718:   case variable_kind_of(destination)
  // 719:     STATIC_SINGLE, DYNAMIC_SINGLE:
  // 720:       if attribute_kind_of(destination) == NONE:
  // 721:         extract_source_or_create_future $src source
  // 722:         write assignment_to_c(destination src)
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_222, 1);
  // 713: for_each definitions_of(self): (definition)
  // 714:   extract_destination_and_source $destination $source definition
  // 715:   if source.is_defined:
  // 716:     write_as_remark
  // 717:       "_define @(key_of(definition)) @(std::value_of(definition))"
  // 718:   case variable_kind_of(destination)
  // 719:     STATIC_SINGLE, DYNAMIC_SINGLE:
  // 720:       if attribute_kind_of(destination) == NONE:
  // 721:         extract_source_or_create_future $src source
  // 722:         write assignment_to_c(destination src)
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_248;
}
static void entry__compiler__body__to_c_237(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // extract_source_or_create_future: 0
  // source: 1
  // destination: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] /* src */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 721: extract_source_or_create_future $src source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = frame->slots[0] /* extract_source_or_create_future */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_238;
}
static void cont__compiler__body__to_c_238(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 722: ... assignment_to_c(destination src)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  arguments->slots[1] = frame->slots[3] /* src */;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_239;
}
static void cont__compiler__body__to_c_239(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 722: write assignment_to_c(destination src)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_234(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // extract_source_or_create_future: 1
  // source: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[2]; /* extract_source_or_create_future */
  frame->slots[2] = myself->closure.frame->slots[5]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 720: ... attribute_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_235;
}
static void cont__compiler__body__to_c_235(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 720: ... attribute_kind_of(destination) == NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__NONE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_236;
}
static void cont__compiler__body__to_c_236(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 720: ... :
  // 721:   extract_source_or_create_future $src source
  // 722:   write assignment_to_c(destination src)
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_237, 0);
  // 720: if attribute_kind_of(destination) == NONE:
  // 721:   extract_source_or_create_future $src source
  // 722:   write assignment_to_c(destination src)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_240(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // destination: 0
  // locals: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* locals */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 724: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_241;
}
static void cont__compiler__body__to_c_241(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 724: $name name_of(identifier_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_242;
}
static void cont__compiler__body__to_c_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 727: ... locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* name */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_243;
}
static void cont__compiler__body__to_c_243(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 725: ... "
  // 726:   @
  // 727:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__6c6dcf991c09c1f6;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__ca5af8c3e89bc077;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__78fdfa78a6dea8bb;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_245;
}
static void cont__compiler__body__to_c_245(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 725: write "
  // 726:   @
  // 727:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_246(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // destination: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* destination */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 729: ... assignment_to_c(destination "undefined")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  arguments->slots[1] = string__7ca0252e172b1501;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_247;
}
static void cont__compiler__body__to_c_247(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 729: write assignment_to_c(destination "undefined")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_222(void) {
  allocate_initialized_frame_gc(4, 11);
  // slot allocations:
  // definition: 0
  // extract_destination_and_source: 1
  // extract_source_or_create_future: 2
  // locals: 3
  // destination: 4
  // source: 5
  frame->slots[1] = myself->closure.frame->slots[22]; /* extract_destination_and_source */
  frame->slots[2] = myself->closure.frame->slots[23]; /* extract_source_or_create_future */
  frame->slots[3] = myself->closure.frame->slots[8]; /* locals */
  frame->slots[4] /* destination */ = create_future();
  frame->slots[5] /* source */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 714: extract_destination_and_source $destination $source definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 2;
  myself = frame->slots[1] /* extract_destination_and_source */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_223;
}
static void cont__compiler__body__to_c_223(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* destination */, arguments->slots[0]);
  initialize_future(frame->slots[5] /* source */, arguments->slots[1]);
  // 715: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_224;
}
static void cont__compiler__body__to_c_224(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 715: ... :
  // 716:   write_as_remark
  // 717:     "_define @(key_of(definition)) @(std::value_of(definition))"
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__body__to_c_225, 0);
  // 715: if source.is_defined:
  // 716:   write_as_remark
  // 717:     "_define @(key_of(definition)) @(std::value_of(definition))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_231;
}
static void entry__compiler__body__to_c_225(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // definition: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 717: ... key_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__key_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_226;
}
static void cont__compiler__body__to_c_226(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 717: ... std::value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__std__value_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_227;
}
static void cont__compiler__body__to_c_227(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 717: "_define @(key_of(definition)) @(std::value_of(definition))"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__7c84ae5484fdf7e0;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cc1;
  arguments->slots[3] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_230;
}
static void cont__compiler__body__to_c_230(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 716: write_as_remark
  // 717:   "_define @(key_of(definition)) @(std::value_of(definition))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = func__write_as_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_231(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 718: ... variable_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* destination */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_232;
}
static void cont__compiler__body__to_c_232(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 719: STATIC_SINGLE, DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__STATIC_SINGLE();
  arguments->slots[1] = get__DYNAMIC_SINGLE();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_233;
}
static void cont__compiler__body__to_c_233(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 719: ... :
  // 720:   if attribute_kind_of(destination) == NONE:
  // 721:     extract_source_or_create_future $src source
  // 722:     write assignment_to_c(destination src)
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__body__to_c_234, 0);
  // 723: ... :
  // 724:   $name name_of(identifier_of(destination))
  // 725:   write "
  // 726:     @
  // 727:       frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  frame->slots[9] /* temp__4 */ = create_closure(entry__compiler__body__to_c_240, 0);
  // 728: ... :
  // 729:   write assignment_to_c(destination "undefined")
  frame->slots[10] /* temp__5 */ = create_closure(entry__compiler__body__to_c_246, 0);
  // 718: case variable_kind_of(destination)
  // 719:   STATIC_SINGLE, DYNAMIC_SINGLE:
  // 720:     if attribute_kind_of(destination) == NONE:
  // 721:       extract_source_or_create_future $src source
  // 722:       write assignment_to_c(destination src)
  // 723:   STATIC_MULTI:
  // 724:     $name name_of(identifier_of(destination))
  // 725:     write "
  // 726:       @
  // 727:         frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  // ...
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  arguments->slots[3] = get__STATIC_MULTI();
  arguments->slots[4] = frame->slots[9] /* temp__4 */;
  arguments->slots[5] = get__DYNAMIC_MULTI();
  arguments->slots[6] = frame->slots[10] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_248(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 730: ... definitions_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__definitions_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_249;
}
static void cont__compiler__body__to_c_249(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 730: ... : (definition)
  // 731:   extract_destination_and_source $destination $source definition
  // 732:   if
  // 733:     &&
  // 734:       variable_kind_of(destination) == STATIC_SINGLE
  // 735:       attribute_kind_of(destination) != NONE
  // 736:     :
  // 737:       case attribute_kind_of(destination)
  // 738:         ATTRIBUTE_KIND:
  // 739:           extract_source_or_create_future $src source
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_250, 1);
  // 730: for_each definitions_of(self): (definition)
  // 731:   extract_destination_and_source $destination $source definition
  // 732:   if
  // 733:     &&
  // 734:       variable_kind_of(destination) == STATIC_SINGLE
  // 735:       attribute_kind_of(destination) != NONE
  // 736:     :
  // 737:       case attribute_kind_of(destination)
  // 738:         ATTRIBUTE_KIND:
  // 739:           extract_source_or_create_future $src source
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_288;
}
static void entry__compiler__body__to_c_275(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // extract_source_or_create_future: 0
  // source: 1
  // destination: 2
  // src: 3
  // attribute_name: 4
  // dest: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] /* src */ = create_future();
  frame->slots[4] /* attribute_name */ = create_future();
  frame->slots[5] /* dest */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 750: extract_source_or_create_future $src source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = frame->slots[0] /* extract_source_or_create_future */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_276;
}
static void cont__compiler__body__to_c_276(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 751: ... attribute_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_277;
}
static void cont__compiler__body__to_c_277(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 751: $attribute_name mangled_name_of(attribute_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_278;
}
static void cont__compiler__body__to_c_278(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* attribute_name */, arguments->slots[0]);
  // 752: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_279;
}
static void cont__compiler__body__to_c_279(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 752: $dest identifier_of(destination).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_280;
}
static void cont__compiler__body__to_c_280(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* dest */, arguments->slots[0]);
  // 753: ... "
  // 754:   @
  // 755:     update_start_p = node_p;
  // 756:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 757:   @(src));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__fccc671c88ddb4ed;
  arguments->slots[1] = frame->slots[5] /* dest */;
  arguments->slots[2] = string__82b9fe52d4649726;
  arguments->slots[3] = frame->slots[4] /* attribute_name */;
  arguments->slots[4] = string__2d7981f4e6682be5;
  arguments->slots[5] = frame->slots[3] /* src */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_281;
}
static void cont__compiler__body__to_c_281(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 753: write "
  // 754:   @
  // 755:     update_start_p = node_p;
  // 756:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 757:   @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_282(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // source: 0
  // destination: 1
  // entry: 2
  // fun_par_count: 3
  // dest: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[2] /* entry */ = create_future();
  frame->slots[3] /* fun_par_count */ = create_future();
  frame->slots[4] /* dest */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 759: to_c $entry $_fun_par_count source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 2;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_283;
}
static void cont__compiler__body__to_c_283(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* entry */, arguments->slots[0]);
  initialize_future(frame->slots[3] /* fun_par_count */, arguments->slots[1]);
  // 763: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_284;
}
static void cont__compiler__body__to_c_284(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 763: $dest identifier_of(destination).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_285;
}
static void cont__compiler__body__to_c_285(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* dest */, arguments->slots[0]);
  // 764: ... "
  // 765:   @
  // 766:     update_start_p = node_p;
  // 767:     def_attribute(&@(dest), -1, @(entry));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__fccc671c88ddb4ed;
  arguments->slots[1] = frame->slots[4] /* dest */;
  arguments->slots[2] = string__c21f422683de52f7;
  arguments->slots[3] = frame->slots[2] /* entry */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_287;
}
static void cont__compiler__body__to_c_287(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 764: write "
  // 765:   @
  // 766:     update_start_p = node_p;
  // 767:     def_attribute(&@(dest), -1, @(entry));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_261(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // extract_source_or_create_future: 0
  // source: 1
  // destination: 2
  // src: 3
  // attribute_name: 4
  // dest: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[3] /* src */ = create_future();
  frame->slots[4] /* attribute_name */ = create_future();
  frame->slots[5] /* dest */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 739: extract_source_or_create_future $src source
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = frame->slots[0] /* extract_source_or_create_future */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_262;
}
static void cont__compiler__body__to_c_262(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* src */, arguments->slots[0]);
  // 740: ... attribute_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_263;
}
static void cont__compiler__body__to_c_263(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 740: $attribute_name mangled_name_of(attribute_of(destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_264;
}
static void cont__compiler__body__to_c_264(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* attribute_name */, arguments->slots[0]);
  // 741: ... identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_265;
}
static void cont__compiler__body__to_c_265(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 741: $dest identifier_of(destination).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_266;
}
static void cont__compiler__body__to_c_266(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* dest */, arguments->slots[0]);
  // 742: ... "
  // 743:   @
  // 744:     update_start_p = node_p;
  // 745:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 746:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__fccc671c88ddb4ed;
  arguments->slots[1] = frame->slots[5] /* dest */;
  arguments->slots[2] = string__82b9fe52d4649726;
  arguments->slots[3] = frame->slots[4] /* attribute_name */;
  arguments->slots[4] = string__23db4977718ddc08;
  arguments->slots[5] = frame->slots[3] /* src */;
  arguments->slots[6] = string__900afb0b5fb87d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_271;
}
static void cont__compiler__body__to_c_271(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 742: write "
  // 743:   @
  // 744:     update_start_p = node_p;
  // 745:     def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 746:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_272(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // destination: 0
  // extract_source_or_create_future: 1
  // source: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[1]; /* extract_source_or_create_future */
  frame->slots[2] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 749: attribute_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_273;
}
static void cont__compiler__body__to_c_273(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 749: attribute_of(destination).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_274;
}
static void cont__compiler__body__to_c_274(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 749: ... :
  // 750:   extract_source_or_create_future $src source
  // 751:   $attribute_name mangled_name_of(attribute_of(destination))
  // 752:   $dest identifier_of(destination).to_c
  // 753:   write "
  // 754:     @
  // 755:       update_start_p = node_p;
  // 756:       def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 757:     @(src));
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_275, 0);
  // 758: :
  // 759:   to_c $entry $_fun_par_count source
  // 760:   
  // 761:   #ewriteln name "/:"
  // 762:   
  // 763:   $dest identifier_of(destination).to_c
  // 764:   write "
  // 765:     @
  // 766:       update_start_p = node_p;
  // 767:       def_attribute(&@(dest), -1, @(entry));
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__body__to_c_282, 0);
  // 748: if
  // 749:   attribute_of(destination).is_defined:
  // 750:     extract_source_or_create_future $src source
  // 751:     $attribute_name mangled_name_of(attribute_of(destination))
  // 752:     $dest identifier_of(destination).to_c
  // 753:     write "
  // 754:       @
  // 755:         update_start_p = node_p;
  // 756:         def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 757:       @(src));
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_259(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // extract_source_or_create_future: 1
  // source: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[2]; /* extract_source_or_create_future */
  frame->slots[2] = myself->closure.frame->slots[4]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 737: ... attribute_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_260;
}
static void cont__compiler__body__to_c_260(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 738: ... :
  // 739:   extract_source_or_create_future $src source
  // 740:   $attribute_name mangled_name_of(attribute_of(destination))
  // 741:   $dest identifier_of(destination).to_c
  // 742:   write "
  // 743:     @
  // 744:       update_start_p = node_p;
  // 745:       def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 746:     MAKE_ATTRIBUTE_VALUE(@(src)));
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_261, 0);
  // 747: ... :
  // 748:   if
  // 749:     attribute_of(destination).is_defined:
  // 750:       extract_source_or_create_future $src source
  // 751:       $attribute_name mangled_name_of(attribute_of(destination))
  // 752:       $dest identifier_of(destination).to_c
  // 753:       write "
  // 754:         @
  // 755:           update_start_p = node_p;
  // 756:           def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_272, 0);
  // 737: case attribute_kind_of(destination)
  // 738:   ATTRIBUTE_KIND:
  // 739:     extract_source_or_create_future $src source
  // 740:     $attribute_name mangled_name_of(attribute_of(destination))
  // 741:     $dest identifier_of(destination).to_c
  // 742:     write "
  // 743:       @
  // 744:         update_start_p = node_p;
  // 745:         def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // 746:       MAKE_ATTRIBUTE_VALUE(@(src)));
  // ...
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = get__ATTRIBUTE_KIND();
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  arguments->slots[3] = get__METHOD_KIND();
  arguments->slots[4] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_250(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // definition: 0
  // extract_destination_and_source: 1
  // extract_source_or_create_future: 2
  // destination: 3
  // source: 4
  frame->slots[1] = myself->closure.frame->slots[22]; /* extract_destination_and_source */
  frame->slots[2] = myself->closure.frame->slots[23]; /* extract_source_or_create_future */
  frame->slots[3] /* destination */ = create_future();
  frame->slots[4] /* source */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 731: extract_destination_and_source $destination $source definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 2;
  myself = frame->slots[1] /* extract_destination_and_source */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_251;
}
static void cont__compiler__body__to_c_251(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* destination */, arguments->slots[0]);
  initialize_future(frame->slots[4] /* source */, arguments->slots[1]);
  // 734: variable_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* destination */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_252;
}
static void cont__compiler__body__to_c_252(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 734: variable_kind_of(destination) == STATIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  arguments->slots[1] = get__STATIC_SINGLE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_253;
}
static void cont__compiler__body__to_c_253(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 735: attribute_kind_of(destination) != NONE
  frame->slots[8] /* temp__4 */ = create_closure(entry__compiler__body__to_c_254, 0);
  // 733: &&
  // 734:   variable_kind_of(destination) == STATIC_SINGLE
  // 735:   attribute_kind_of(destination) != NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_258;
}
static void entry__compiler__body__to_c_254(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // destination: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* destination */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 735: attribute_kind_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_255;
}
static void cont__compiler__body__to_c_255(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 735: attribute_kind_of(destination) != NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__NONE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_256;
}
static void cont__compiler__body__to_c_256(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 735: attribute_kind_of(destination) != NONE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_257;
}
static void cont__compiler__body__to_c_257(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 735: attribute_kind_of(destination) != NONE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_258(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 736: :
  // 737:   case attribute_kind_of(destination)
  // 738:     ATTRIBUTE_KIND:
  // 739:       extract_source_or_create_future $src source
  // 740:       $attribute_name mangled_name_of(attribute_of(destination))
  // 741:       $dest identifier_of(destination).to_c
  // 742:       write "
  // 743:         @
  // 744:           update_start_p = node_p;
  // 745:           def_attribute(&@(dest), poly_idx__@(attribute_name), @
  // ...
  frame->slots[9] /* temp__5 */ = create_closure(entry__compiler__body__to_c_259, 0);
  // 732: if
  // 733:   &&
  // 734:     variable_kind_of(destination) == STATIC_SINGLE
  // 735:     attribute_kind_of(destination) != NONE
  // 736:   :
  // 737:     case attribute_kind_of(destination)
  // 738:       ATTRIBUTE_KIND:
  // 739:         extract_source_or_create_future $src source
  // 740:         $attribute_name mangled_name_of(attribute_of(destination))
  // 741:         $dest identifier_of(destination).to_c
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_288(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 768: ... :
  // 769:   collect_output $code: extract "arguments" input_parameters
  // 770:   write code
  frame->slots[26] /* temp__1 */ = create_closure(entry__compiler__body__to_c_289, 0);
  // 768: do:
  // 769:   collect_output $code: extract "arguments" input_parameters
  // 770:   write code
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_292;
}
static void entry__compiler__body__to_c_289(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // input_parameters: 0
  // code: 1
  frame->slots[0] = myself->closure.frame->slots[17]; /* input_parameters */
  frame->slots[1] /* code */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 769: ... : extract "arguments" input_parameters
  frame->slots[2] /* temp__1 */ = create_closure(entry__compiler__body__to_c_290, 0);
  // 769: collect_output $code: extract "arguments" input_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__collect_output();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_291;
}
static void entry__compiler__body__to_c_290(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // input_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* input_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 769: ... extract "arguments" input_parameters
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__64ac252603a3a696;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* input_parameters */;
  result_count = frame->caller_result_count;
  myself = func__extract;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_291(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* code */, arguments->slots[0]);
  // 770: write code
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* code */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_292(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 771: ... myself_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[15])->contents /* myself_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_293;
}
static void cont__compiler__body__to_c_293(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 771: ... :
  // 772:   assign_argument_or_result "arguments" myself_parameter "myself"
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_294, 0);
  // 771: if myself_parameter.is_defined:
  // 772:   assign_argument_or_result "arguments" myself_parameter "myself"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_296;
}
static void entry__compiler__body__to_c_294(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // myself_parameter: 0
  frame->slots[0] = myself->closure.frame->slots[15]; /* myself_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 772: assign_argument_or_result "arguments" myself_parameter "myself"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__64ac252603a3a696;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* myself_parameter */;
  arguments->slots[2] = string__7e1f570601dbc2b1;
  result_count = frame->caller_result_count;
  myself = func__assign_argument_or_result;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_296(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 773: ... : (parameter)
  // 774:   unless parameter_kind_of(parameter) == IN_OUT_PARAMETER:
  // 775:     $name name_of(identifier_of(parameter))
  // 776:     write "
  // 777:       @
  // 778:         frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  frame->slots[26] /* temp__1 */ = create_closure(entry__compiler__body__to_c_297, 1);
  // 773: for_each output_parameters: (parameter)
  // 774:   unless parameter_kind_of(parameter) == IN_OUT_PARAMETER:
  // 775:     $name name_of(identifier_of(parameter))
  // 776:     write "
  // 777:       @
  // 778:         frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[18])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[26] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_305;
}
static void entry__compiler__body__to_c_300(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // parameter: 0
  // locals: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  frame->slots[1] = myself->closure.frame->slots[1]; /* locals */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 775: ... identifier_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_301;
}
static void cont__compiler__body__to_c_301(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 775: $name name_of(identifier_of(parameter))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_302;
}
static void cont__compiler__body__to_c_302(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 778: ... locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* name */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* locals */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_303;
}
static void cont__compiler__body__to_c_303(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 776: ... "
  // 777:   @
  // 778:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__6c6dcf991c09c1f6;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__ca5af8c3e89bc077;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__78fdfa78a6dea8bb;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_304;
}
static void cont__compiler__body__to_c_304(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 776: write "
  // 777:   @
  // 778:     frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_297(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // parameter: 0
  // locals: 1
  frame->slots[1] = myself->closure.frame->slots[8]; /* locals */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 774: ... parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_298;
}
static void cont__compiler__body__to_c_298(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 774: ... parameter_kind_of(parameter) == IN_OUT_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__IN_OUT_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_299;
}
static void cont__compiler__body__to_c_299(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 774: ... :
  // 775:   $name name_of(identifier_of(parameter))
  // 776:   write "
  // 777:     @
  // 778:       frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__body__to_c_300, 0);
  // 774: unless parameter_kind_of(parameter) == IN_OUT_PARAMETER:
  // 775:   $name name_of(identifier_of(parameter))
  // 776:   write "
  // 777:     @
  // 778:       frame->slots[@(locals(name))] /* @(name) */ = create_cell();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_305(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 779: $statements statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_306;
}
static void cont__compiler__body__to_c_306(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[24] /* statements */, arguments->slots[0]);
  // 805: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_307;
}
static void cont__compiler__body__to_c_307(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 805: for_each_from_to statements 1 -2: (statement) generate_statement statement
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[24] /* statements */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[26] /* temp__1 */;
  arguments->slots[3] = func__compiler__body__to_c_308;
  result_count = 0;
  myself = get__for_each_from_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_309;
}
static void entry__compiler__body__to_c_308(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // statement: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 805: ... generate_statement statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = frame->caller_result_count;
  myself = get__generate_statement();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_309(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 807: is_empty(statements)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[24] /* statements */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_310;
}
static void cont__compiler__body__to_c_310(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 809: :
  // 810:   $statement statements(-1)
  // 811:   cond
  // 812:     -> statement.is_a_return:
  // 813:       write_source_as_remark statement
  // 814:       
  // 815:       #if
  // 816:         continuation_parameter.is_defined &&
  // 817:         (
  // 818:           not(output_parameters.is_empty) ||
  // ...
  frame->slots[27] /* temp__2 */ = create_closure(entry__compiler__body__to_c_311, 0);
  // 806: if
  // 807:   is_empty(statements):
  // 808:     generate_exit
  // 809:   :
  // 810:     $statement statements(-1)
  // 811:     cond
  // 812:       -> statement.is_a_return:
  // 813:         write_source_as_remark statement
  // 814:         
  // 815:         #if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[25] /* generate_exit */;
  arguments->slots[2] = frame->slots[27] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_402;
}
static void entry__compiler__body__to_c_378(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // output_parameters: 1
  // n: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[0]; /* output_parameters */
  frame->slots[2] /* n */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 892: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_379;
}
static void cont__compiler__body__to_c_379(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 893: ... "cont@(cont_suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40aea8b5d107d4d;
  arguments->slots[1] = get__cont_suffix();
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_380;
}
static void cont__compiler__body__to_c_380(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 893: get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = func__get_func_and_myself;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_381;
}
static void cont__compiler__body__to_c_381(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 894: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e4e02bcf;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_382;
}
static void cont__compiler__body__to_c_382(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 895: ... "cont@(cont_suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40aea8b5d107d4d;
  arguments->slots[1] = get__cont_suffix();
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_383;
}
static void cont__compiler__body__to_c_383(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 895: next_continuation "cont@(cont_suffix)_@(index)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__next_continuation();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_384;
}
static void cont__compiler__body__to_c_384(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 896: $n count_arguments(output_parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = func__count_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_385;
}
static void cont__compiler__body__to_c_385(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* n */, arguments->slots[0]);
  // 898: n.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* n */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_386;
}
static void cont__compiler__body__to_c_386(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 898: ... :
  // 899:   write "
  // 900:     @
  // 901:       int i = argument_count;
  // 902:       while (--i >= 0) {
  // 903:         arguments->slots[i+@(n)] = arguments->slots[i];
  // 904:       }
  // 905:   generate_c_arguments output_parameters true
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_387, 0);
  // 906: :
  // 907:   write "
  // 908:     @
  // 909:       int i;
  // 910:       int n = argument_count;
  // 911:       FRAME *return_arguments = arguments;
  // 912:       allocate_arguments();
  // 913:   generate_c_arguments output_parameters
  // 914:   write "
  // 915:     @
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_392, 0);
  // 897: if
  // 898:   n.is_defined:
  // 899:     write "
  // 900:       @
  // 901:         int i = argument_count;
  // 902:         while (--i >= 0) {
  // 903:           arguments->slots[i+@(n)] = arguments->slots[i];
  // 904:         }
  // 905:     generate_c_arguments output_parameters true
  // 906:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_397;
}
static void entry__compiler__body__to_c_387(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // n: 0
  // output_parameters: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* n */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 899: ... "
  // 900:   @
  // 901:     int i = argument_count;
  // 902:     while (--i >= 0) {
  // 903:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 904:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__add2b8040716429a;
  arguments->slots[1] = frame->slots[0] /* n */;
  arguments->slots[2] = string__fc381eaca84ce05b;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_390;
}
static void cont__compiler__body__to_c_390(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 899: write "
  // 900:   @
  // 901:     int i = argument_count;
  // 902:     while (--i >= 0) {
  // 903:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 904:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_391;
}
static void cont__compiler__body__to_c_391(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 905: generate_c_arguments output_parameters true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  arguments->slots[1] = get__true();
  result_count = frame->caller_result_count;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_392(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // output_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 907: write "
  // 908:   @
  // 909:     int i;
  // 910:     int n = argument_count;
  // 911:     FRAME *return_arguments = arguments;
  // 912:     allocate_arguments();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__ba62772f4c1bf545;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_394;
}
static void cont__compiler__body__to_c_394(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 913: generate_c_arguments output_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 0;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_395;
}
static void cont__compiler__body__to_c_395(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 914: write "
  // 915:   @
  // 916:     for (i = 0; i < n; ++i) {
  // 917:       arguments->slots[argument_count++] = @
  // 918:   return_arguments->slots[i];
  // 919:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__7b93af9dc5bb91ae;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_397(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 920: write "
  // 921:   @
  // 922:     frame = frame->caller_frame;
  // 923:     func = frame->cont;
  // 924:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b30064368698509a;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_364(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // functor: 0
  // statement: 1
  // continuation_parameter: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[2]; /* statement */
  frame->slots[2] = myself->closure.frame->slots[0]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 877: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_365;
}
static void cont__compiler__body__to_c_365(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 878: ... "cont@(cont_suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40aea8b5d107d4d;
  arguments->slots[1] = get__cont_suffix();
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_366;
}
static void cont__compiler__body__to_c_366(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 878: get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = func__get_func_and_myself;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_367;
}
static void cont__compiler__body__to_c_367(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 879: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e4e02bcf;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_369;
}
static void cont__compiler__body__to_c_369(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 880: ... "cont@(cont_suffix)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40aea8b5d107d4d;
  arguments->slots[1] = get__cont_suffix();
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_370;
}
static void cont__compiler__body__to_c_370(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 880: next_continuation "cont@(cont_suffix)_@(index)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__next_continuation();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_371;
}
static void cont__compiler__body__to_c_371(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 881: compute_source_text_info
  // 882:   statement
  // 883:   false
  // 884:   true
  // 885:   !current_continuation_info
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  arguments->slots[1] = get__false();
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = func__compute_source_text_info;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_372;
}
static void cont__compiler__body__to_c_372(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__current_continuation_info(arguments->slots[0]);
  // 888: ... continuation_parameter.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_373;
}
static void cont__compiler__body__to_c_373(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 886: ... "
  // 887:   @
  // 888:     myself = @(continuation_parameter.to_c);
  // 889:     func = myself->type;
  // 890:     frame->cont = invalid_continuation;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__8c93215920e16830;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__53a8ae7fafe9c367;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_374;
}
static void cont__compiler__body__to_c_374(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 886: write "
  // 887:   @
  // 888:     myself = @(continuation_parameter.to_c);
  // 889:     func = myself->type;
  // 890:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_362(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // continuation_parameter: 0
  // functor: 1
  // statement: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* continuation_parameter */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[2] = myself->closure.frame->slots[3]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 876: ... continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_363;
}
static void cont__compiler__body__to_c_363(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 876: ... :
  // 877:   inc &index
  // 878:   get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  // 879:   write "}@nl;"
  // 880:   next_continuation "cont@(cont_suffix)_@(index)"
  // 881:   compute_source_text_info
  // 882:     statement
  // 883:     false
  // 884:     true
  // 885:     !current_continuation_info
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_364, 0);
  // 876: -> continuation_parameter.is_defined:
  // 877:   inc &index
  // 878:   get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  // 879:   write "}@nl;"
  // 880:   next_continuation "cont@(cont_suffix)_@(index)"
  // 881:   compute_source_text_info
  // 882:     statement
  // 883:     false
  // 884:     true
  // 885:     !current_continuation_info
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_375(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // output_parameters: 0
  // functor: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* output_parameters */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 891: ... output_parameters.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_376;
}
static void cont__compiler__body__to_c_376(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 891: ... not(output_parameters.is_empty)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_377;
}
static void cont__compiler__body__to_c_377(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 891: ... :
  // 892:   inc &index
  // 893:   get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  // 894:   write "}@nl;"
  // 895:   next_continuation "cont@(cont_suffix)_@(index)"
  // 896:   $n count_arguments(output_parameters)
  // 897:   if
  // 898:     n.is_defined:
  // 899:       write "
  // 900:         @
  // ...
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__body__to_c_378, 0);
  // 891: -> not(output_parameters.is_empty):
  // 892:   inc &index
  // 893:   get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  // 894:   write "}@nl;"
  // 895:   next_continuation "cont@(cont_suffix)_@(index)"
  // 896:   $n count_arguments(output_parameters)
  // 897:   if
  // 898:     n.is_defined:
  // 899:       write "
  // 900:         @
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_398(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 926: get_func_and_myself
  // 927:   functor
  // 928:   "frame->cont"
  // 929:   "frame = frame->caller_frame;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = string__6c9a2bd2e7c4af5;
  arguments->slots[2] = string__da5f7a92b20e4d64;
  result_count = frame->caller_result_count;
  myself = func__get_func_and_myself;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_343(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // functor: 0
  // statement: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 850: get_func_and_myself functor "continuation_trampoline"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  arguments->slots[1] = string__db8268c5e3e3998;
  result_count = 0;
  myself = func__get_func_and_myself;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_345;
}
static void cont__compiler__body__to_c_345(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 853: ... continuation_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  result_count = 1;
  myself = get__continuation_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_346;
}
static void cont__compiler__body__to_c_346(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 853: ... continuation_of(statement).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_347;
}
static void cont__compiler__body__to_c_347(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 851: ... "
  // 852:   @
  // 853:     frame->slots[0] = @(continuation_of(statement).to_c);
  // 854:     if (frame->slots[0]->type != continuation_type_function)
  // 855:       invalid_continuation_error();
  // 856:     frame->slot_count = 1;
  // 857:     frame->caller_frame = NULL;
  // 858:     result_count = frame->slots[0]->continuation.result_count;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__3404e8fb37dde7ec;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__6b3b62c960789ef;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_350;
}
static void cont__compiler__body__to_c_350(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 851: write "
  // 852:   @
  // 853:     frame->slots[0] = @(continuation_of(statement).to_c);
  // 854:     if (frame->slots[0]->type != continuation_type_function)
  // 855:       invalid_continuation_error();
  // 856:     frame->slot_count = 1;
  // 857:     frame->caller_frame = NULL;
  // 858:     result_count = frame->slots[0]->continuation.result_count;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_351(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // result_count: 0
  // continuation_parameter: 1
  // functor: 2
  // statement: 3
  // output_parameters: 4
  frame->slots[0] = myself->closure.frame->slots[5]; /* result_count */
  frame->slots[1] = myself->closure.frame->slots[2]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor */
  frame->slots[3] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[4] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 869: :
  // 870:   write "
  // 871:     @
  // 872:       result_count =
  // 873:         frame->caller_result_count >= @(result_count) ?
  // 874:         frame->caller_result_count-@(result_count) : -1;
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__body__to_c_352, 0);
  // 860: case result_count
  // 861:   undefined:
  // 862:     write "
  // 863:       @
  // 864:         result_count = -1;
  // 865:   0:
  // 866:     write "
  // 867:       @
  // 868:         result_count = frame->caller_result_count;
  // 869:   :
  // ...
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* result_count */;
  arguments->slots[1] = get__undefined();
  arguments->slots[2] = func__compiler__body__to_c_357;
  arguments->slots[3] = number__0;
  arguments->slots[4] = func__compiler__body__to_c_359;
  arguments->slots[5] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_361;
}
static void entry__compiler__body__to_c_352(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // result_count: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* result_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 870: ... "
  // 871:   @
  // 872:     result_count =
  // 873:       frame->caller_result_count >= @(result_count) ?
  // 874:       frame->caller_result_count-@(result_count) : -1;
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__c178c7d8fee76458;
  arguments->slots[1] = frame->slots[0] /* result_count */;
  arguments->slots[2] = string__8f22c8f0e8431566;
  arguments->slots[3] = frame->slots[0] /* result_count */;
  arguments->slots[4] = string__290419bf9766c0f0;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_356;
}
static void cont__compiler__body__to_c_356(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 870: write "
  // 871:   @
  // 872:     result_count =
  // 873:       frame->caller_result_count >= @(result_count) ?
  // 874:       frame->caller_result_count-@(result_count) : -1;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_357(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 862: write "
  // 863:   @
  // 864:     result_count = -1;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b0a76bfaa09e5475;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_359(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 866: write "
  // 867:   @
  // 868:     result_count = frame->caller_result_count;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__3f31837fe07336b7;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_361(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 876: -> continuation_parameter.is_defined:
  // 877:   inc &index
  // 878:   get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  // 879:   write "}@nl;"
  // 880:   next_continuation "cont@(cont_suffix)_@(index)"
  // 881:   compute_source_text_info
  // 882:     statement
  // 883:     false
  // 884:     true
  // 885:     !current_continuation_info
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__body__to_c_362, 0);
  // 891: -> not(output_parameters.is_empty):
  // 892:   inc &index
  // 893:   get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  // 894:   write "}@nl;"
  // 895:   next_continuation "cont@(cont_suffix)_@(index)"
  // 896:   $n count_arguments(output_parameters)
  // 897:   if
  // 898:     n.is_defined:
  // 899:       write "
  // 900:         @
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__body__to_c_375, 0);
  // 925: :
  // 926:   get_func_and_myself
  // 927:     functor
  // 928:     "frame->cont"
  // 929:     "frame = frame->caller_frame;"
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__body__to_c_398, 0);
  // 875: cond
  // 876:   -> continuation_parameter.is_defined:
  // 877:     inc &index
  // 878:     get_func_and_myself functor "cont@(cont_suffix)_@(index)"
  // 879:     write "}@nl;"
  // 880:     next_continuation "cont@(cont_suffix)_@(index)"
  // 881:     compute_source_text_info
  // 882:       statement
  // 883:       false
  // 884:       true
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_335(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // statement: 0
  // output_parameters: 1
  // continuation_parameter: 2
  // functor: 3
  // input_arguments: 4
  // result_count: 5
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output_parameters */
  frame->slots[2] = myself->closure.frame->slots[2]; /* continuation_parameter */
  frame->slots[3] /* functor */ = create_future();
  frame->slots[4] /* input_arguments */ = create_future();
  frame->slots[5] /* result_count */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 843: write_source_as_remark statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__write_source_as_remark();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_336;
}
static void cont__compiler__body__to_c_336(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 844: $functor functor_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_337;
}
static void cont__compiler__body__to_c_337(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* functor */, arguments->slots[0]);
  // 845: $input_arguments arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_338;
}
static void cont__compiler__body__to_c_338(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* input_arguments */, arguments->slots[0]);
  // 846: $result_count count_arguments(output_parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = func__count_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_339;
}
static void cont__compiler__body__to_c_339(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* result_count */, arguments->slots[0]);
  // 847: generate_c_arguments input_arguments
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* input_arguments */;
  result_count = 0;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_340;
}
static void cont__compiler__body__to_c_340(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 849: continuation_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__continuation_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_341;
}
static void cont__compiler__body__to_c_341(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 849: continuation_of(statement).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_342;
}
static void cont__compiler__body__to_c_342(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 849: ... :
  // 850:   get_func_and_myself functor "continuation_trampoline"
  // 851:   write "
  // 852:     @
  // 853:       frame->slots[0] = @(continuation_of(statement).to_c);
  // 854:       if (frame->slots[0]->type != continuation_type_function)
  // 855:         invalid_continuation_error();
  // 856:       frame->slot_count = 1;
  // 857:       frame->caller_frame = NULL;
  // 858:       result_count = frame->slots[0]->continuation.result_count;
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__body__to_c_343, 0);
  // 859: :
  // 860:   case result_count
  // 861:     undefined:
  // 862:       write "
  // 863:         @
  // 864:           result_count = -1;
  // 865:     0:
  // 866:       write "
  // 867:         @
  // 868:           result_count = frame->caller_result_count;
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__compiler__body__to_c_351, 0);
  // 848: if
  // 849:   continuation_of(statement).is_defined:
  // 850:     get_func_and_myself functor "continuation_trampoline"
  // 851:     write "
  // 852:       @
  // 853:         frame->slots[0] = @(continuation_of(statement).to_c);
  // 854:         if (frame->slots[0]->type != continuation_type_function)
  // 855:           invalid_continuation_error();
  // 856:         frame->slot_count = 1;
  // 857:         frame->caller_frame = NULL;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_319(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // statement: 0
  // continuation_parameter: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 824: ... arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_320;
}
static void cont__compiler__body__to_c_320(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 824: generate_c_arguments arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_321;
}
static void cont__compiler__body__to_c_321(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 827: ... continuation_parameter.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_322;
}
static void cont__compiler__body__to_c_322(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 825: ... "
  // 826:   @
  // 827:     myself = @(continuation_parameter.to_c);
  // 828:     func = myself->type;
  // 829:     frame->cont = invalid_continuation;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__8c93215920e16830;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__53a8ae7fafe9c367;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_323;
}
static void cont__compiler__body__to_c_323(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 825: write "
  // 826:   @
  // 827:     myself = @(continuation_parameter.to_c);
  // 828:     func = myself->type;
  // 829:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_324(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // output_parameters: 0
  // statement: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* output_parameters */
  frame->slots[1] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 832: ... arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_325;
}
static void cont__compiler__body__to_c_325(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 832: append(output_parameters arguments_of(statement))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_326;
}
static void cont__compiler__body__to_c_326(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 831: generate_c_arguments
  // 832:   append(output_parameters arguments_of(statement))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_327;
}
static void cont__compiler__body__to_c_327(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 833: write "
  // 834:   @
  // 835:     frame = frame->caller_frame;
  // 836:     func = frame->cont;
  // 837:     frame->cont = invalid_continuation;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b30064368698509a;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_316(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // statement: 0
  // continuation_parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 813: write_source_as_remark statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__write_source_as_remark();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_317;
}
static void cont__compiler__body__to_c_317(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 823: continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_318;
}
static void cont__compiler__body__to_c_318(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 823: ... :
  // 824:   generate_c_arguments arguments_of(statement)
  // 825:   write "
  // 826:     @
  // 827:       myself = @(continuation_parameter.to_c);
  // 828:       func = myself->type;
  // 829:       frame->cont = invalid_continuation;
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_319, 0);
  // 830: :
  // 831:   generate_c_arguments
  // 832:     append(output_parameters arguments_of(statement))
  // 833:   write "
  // 834:     @
  // 835:       frame = frame->caller_frame;
  // 836:       func = frame->cont;
  // 837:       frame->cont = invalid_continuation;
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_324, 0);
  // 822: if
  // 823:   continuation_parameter.is_defined:
  // 824:     generate_c_arguments arguments_of(statement)
  // 825:     write "
  // 826:       @
  // 827:         myself = @(continuation_parameter.to_c);
  // 828:         func = myself->type;
  // 829:         frame->cont = invalid_continuation;
  // 830:   :
  // 831:     generate_c_arguments
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_314(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // statement: 0
  // continuation_parameter: 1
  // output_parameters: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[1]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[2]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 812: ... statement.is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_a_return();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_315;
}
static void cont__compiler__body__to_c_315(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 812: ... :
  // 813:   write_source_as_remark statement
  // 814:   
  // 815:   #if
  // 816:     continuation_parameter.is_defined &&
  // 817:     (
  // 818:       not(output_parameters.is_empty) ||
  // 819:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 820:     ):
  // 821:   
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_316, 0);
  // 812: -> statement.is_a_return:
  // 813:   write_source_as_remark statement
  // 814:   
  // 815:   #if
  // 816:     continuation_parameter.is_defined &&
  // 817:     (
  // 818:       not(output_parameters.is_empty) ||
  // 819:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 820:     ):
  // 821:   
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_328(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // statement: 0
  // output_parameters: 1
  // continuation_parameter: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[2]; /* output_parameters */
  frame->slots[2] = myself->closure.frame->slots[1]; /* continuation_parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 840: statement.is_a_procedure_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_a_procedure_call();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_329;
}
static void cont__compiler__body__to_c_329(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 841: not(any_of(arguments_of(statement) is_a_destination))
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_330, 0);
  // 839: &&
  // 840:   statement.is_a_procedure_call
  // 841:   not(any_of(arguments_of(statement) is_a_destination))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_334;
}
static void entry__compiler__body__to_c_330(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 841: ... arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_331;
}
static void cont__compiler__body__to_c_331(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 841: ... any_of(arguments_of(statement) is_a_destination)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__is_a_destination();
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_332;
}
static void cont__compiler__body__to_c_332(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 841: not(any_of(arguments_of(statement) is_a_destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_333;
}
static void cont__compiler__body__to_c_333(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 841: not(any_of(arguments_of(statement) is_a_destination))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_334(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 842: :
  // 843:   write_source_as_remark statement
  // 844:   $functor functor_of(statement)
  // 845:   $input_arguments arguments_of(statement)
  // 846:   $result_count count_arguments(output_parameters)
  // 847:   generate_c_arguments input_arguments
  // 848:   if
  // 849:     continuation_of(statement).is_defined:
  // 850:       get_func_and_myself functor "continuation_trampoline"
  // 851:       write "
  // ...
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__body__to_c_335, 0);
  // 838: ->
  // 839:   &&
  // 840:     statement.is_a_procedure_call
  // 841:     not(any_of(arguments_of(statement) is_a_destination))
  // 842:   :
  // 843:     write_source_as_remark statement
  // 844:     $functor functor_of(statement)
  // 845:     $input_arguments arguments_of(statement)
  // 846:     $result_count count_arguments(output_parameters)
  // 847:     generate_c_arguments input_arguments
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_c_400(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // statement: 0
  // generate_exit: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* statement */
  frame->slots[1] = myself->closure.frame->slots[3]; /* generate_exit */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 931: generate_statement statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__generate_statement();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_401;
}
static void cont__compiler__body__to_c_401(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 932: generate_exit
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* generate_exit */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_311(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // statements: 0
  // continuation_parameter: 1
  // output_parameters: 2
  // generate_exit: 3
  // statement: 4
  frame->slots[0] = myself->closure.frame->slots[24]; /* statements */
  frame->slots[1] = myself->closure.frame->slots[16]; /* continuation_parameter */
  frame->slots[2] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[3] = myself->closure.frame->slots[25]; /* generate_exit */
  frame->slots[4] /* statement */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 810: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_312;
}
static void cont__compiler__body__to_c_312(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 810: $statement statements(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = frame->slots[0] /* statements */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_313;
}
static void cont__compiler__body__to_c_313(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* statement */, arguments->slots[0]);
  // 812: -> statement.is_a_return:
  // 813:   write_source_as_remark statement
  // 814:   
  // 815:   #if
  // 816:     continuation_parameter.is_defined &&
  // 817:     (
  // 818:       not(output_parameters.is_empty) ||
  // 819:       variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 820:     ):
  // 821:   
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__body__to_c_314, 0);
  // 838: ->
  // 839:   &&
  // 840:     statement.is_a_procedure_call
  // 841:     not(any_of(arguments_of(statement) is_a_destination))
  // 842:   :
  // 843:     write_source_as_remark statement
  // 844:     $functor functor_of(statement)
  // 845:     $input_arguments arguments_of(statement)
  // 846:     $result_count count_arguments(output_parameters)
  // 847:     generate_c_arguments input_arguments
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__body__to_c_328, 0);
  // 930: :
  // 931:   generate_statement statement
  // 932:   generate_exit
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__body__to_c_400, 0);
  // 811: cond
  // 812:   -> statement.is_a_return:
  // 813:     write_source_as_remark statement
  // 814:     
  // 815:     #if
  // 816:       continuation_parameter.is_defined &&
  // 817:       (
  // 818:         not(output_parameters.is_empty) ||
  // 819:         variable_kind_of(continuation_parameter) == STATIC_MULTI
  // 820:       ):
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_402(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 933: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e4e02bcf;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_403;
}
static void cont__compiler__body__to_c_403(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 934: end_continuation
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = get__end_continuation();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_404;
}
static void cont__compiler__body__to_c_404(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 935: ... continuation_parameter.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[16])->contents /* continuation_parameter */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_405;
}
static void cont__compiler__body__to_c_405(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[27] /* temp__2 */ = arguments->slots[0];
  // 935: ... not(output_parameters.is_empty)
  frame->slots[28] /* temp__3 */ = create_closure(entry__compiler__body__to_c_406, 0);
  // 935: ... continuation_parameter.is_defined && not(output_parameters.is_empty)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[27] /* temp__2 */;
  arguments->slots[1] = frame->slots[28] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_409;
}
static void entry__compiler__body__to_c_406(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // output_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[18]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 935: ... output_parameters.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_407;
}
static void cont__compiler__body__to_c_407(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 935: ... not(output_parameters.is_empty)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_408;
}
static void cont__compiler__body__to_c_408(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 935: ... not(output_parameters.is_empty)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_c_409(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[26] /* temp__1 */ = arguments->slots[0];
  // 935: ... :
  // 936:   # create an exit-function as a helper for the continuation parameter
  // 937:   
  // 938:   write "
  // 939:     static void exit@(body_suffix)(void) {
  // 940:       frame = ((CONTINUATION *)myself)->exit_frame;
  // 941:   $n count_arguments(output_parameters)
  // 942:   if
  // 943:     n.is_defined:
  // 944:       write "
  // ...
  frame->slots[29] /* temp__4 */ = create_closure(entry__compiler__body__to_c_410, 0);
  // 935: if continuation_parameter.is_defined && not(output_parameters.is_empty):
  // 936:   # create an exit-function as a helper for the continuation parameter
  // 937:   
  // 938:   write "
  // 939:     static void exit@(body_suffix)(void) {
  // 940:       frame = ((CONTINUATION *)myself)->exit_frame;
  // 941:   $n count_arguments(output_parameters)
  // 942:   if
  // 943:     n.is_defined:
  // 944:       write "
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[26] /* temp__1 */;
  arguments->slots[1] = frame->slots[29] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_424;
}
static void entry__compiler__body__to_c_410(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // body_suffix: 0
  // output_parameters: 1
  // n: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* body_suffix */
  frame->slots[1] = myself->closure.frame->slots[18]; /* output_parameters */
  frame->slots[2] /* n */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 938: ... "
  // 939:   static void exit@(body_suffix)(void) {
  // 940:     frame = ((CONTINUATION *)myself)->exit_frame;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__dd22cae03536c939;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__357d878b1635920f;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_412;
}
static void cont__compiler__body__to_c_412(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 938: write "
  // 939:   static void exit@(body_suffix)(void) {
  // 940:     frame = ((CONTINUATION *)myself)->exit_frame;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_413;
}
static void cont__compiler__body__to_c_413(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 941: $n count_arguments(output_parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  result_count = 1;
  myself = func__count_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_414;
}
static void cont__compiler__body__to_c_414(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* n */, arguments->slots[0]);
  // 943: n.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* n */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_415;
}
static void cont__compiler__body__to_c_415(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 943: ... :
  // 944:   write "
  // 945:     @
  // 946:       int i = argument_count;
  // 947:       while (--i >= 0) {
  // 948:         arguments->slots[i+@(n)] = arguments->slots[i];
  // 949:       }
  // 950:   generate_c_arguments output_parameters true
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__body__to_c_416, 0);
  // 951: :
  // 952:   write "
  // 953:     @
  // 954:       int i;
  // 955:       int n = argument_count;
  // 956:       FRAME *return_arguments = arguments;
  // 957:       allocate_arguments();
  // 958:   generate_c_arguments output_parameters
  // 959:   write "
  // 960:     @
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_c_419, 0);
  // 942: if
  // 943:   n.is_defined:
  // 944:     write "
  // 945:       @
  // 946:         int i = argument_count;
  // 947:         while (--i >= 0) {
  // 948:           arguments->slots[i+@(n)] = arguments->slots[i];
  // 949:         }
  // 950:     generate_c_arguments output_parameters true
  // 951:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_422;
}
static void entry__compiler__body__to_c_416(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // n: 0
  // output_parameters: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* n */
  frame->slots[1] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 944: ... "
  // 945:   @
  // 946:     int i = argument_count;
  // 947:     while (--i >= 0) {
  // 948:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 949:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__add2b8040716429a;
  arguments->slots[1] = frame->slots[0] /* n */;
  arguments->slots[2] = string__fc381eaca84ce05b;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_417;
}
static void cont__compiler__body__to_c_417(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 944: write "
  // 945:   @
  // 946:     int i = argument_count;
  // 947:     while (--i >= 0) {
  // 948:       arguments->slots[i+@(n)] = arguments->slots[i];
  // 949:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_418;
}
static void cont__compiler__body__to_c_418(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 950: generate_c_arguments output_parameters true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* output_parameters */;
  arguments->slots[1] = get__true();
  result_count = frame->caller_result_count;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_419(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // output_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* output_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 952: write "
  // 953:   @
  // 954:     int i;
  // 955:     int n = argument_count;
  // 956:     FRAME *return_arguments = arguments;
  // 957:     allocate_arguments();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__ba62772f4c1bf545;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_420;
}
static void cont__compiler__body__to_c_420(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 958: generate_c_arguments output_parameters
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_parameters */;
  result_count = 0;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_421;
}
static void cont__compiler__body__to_c_421(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 959: write "
  // 960:   @
  // 961:     for (i = 0; i < n; ++i) {
  // 962:       arguments->slots[argument_count++] = return_arguments->slots[i];
  // 963:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__7b93af9dc5bb91ae;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_422(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 964: write "
  // 965:     func = continuation_type_function;
  // 966:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__8e4c39950c6aecc7;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_c_424(void) {
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body___to_c_425(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 967: ... parameter_count_of(return)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* return */;
  result_count = 1;
  myself = get__parameter_count_of();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_426;
}
static void cont__compiler__body___to_c_426(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 967: ... parameter_count_of(return) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_427;
}
static void cont__compiler__body___to_c_427(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 967: ... : return "entry@(body_suffix)" par_count
  frame->slots[10] /* temp__3 */ = create_closure(entry__compiler__body__to_c_428, 0);
  // 967: if parameter_count_of(return) == 2: return "entry@(body_suffix)" par_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_430;
}
static void entry__compiler__body__to_c_428(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // return: 0
  // body_suffix: 1
  // par_count: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[6]; /* body_suffix */
  frame->slots[2] = myself->closure.frame->slots[7]; /* par_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 967: ... "entry@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__565aee03ea58402e;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_429;
}
static void cont__compiler__body__to_c_429(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 967: ... return "entry@(body_suffix)" par_count
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* par_count */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body___to_c_430(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 969: inherited_names_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__inherited_names_of();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_431;
}
static void cont__compiler__body___to_c_431(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 969: inherited_names_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_432;
}
static void cont__compiler__body___to_c_432(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 969: ... :
  // 970:   write_to_phase_2 "
  // 971:     @
  // 972:       func@(body_suffix) = create_function(entry@(body_suffix), @
  // 973:     @(par_count));@nl;@
  // 974:   return "func@(body_suffix)"
  frame->slots[10] /* temp__3 */ = create_closure(entry__compiler__body__to_c_433, 0);
  // 975: :
  // 976:   return "create_closure(entry@(body_suffix), @(par_count))"
  frame->slots[11] /* temp__4 */ = create_closure(entry__compiler__body__to_c_439, 0);
  // 968: if
  // 969:   inherited_names_of(self).is_empty:
  // 970:     write_to_phase_2 "
  // 971:       @
  // 972:         func@(body_suffix) = create_function(entry@(body_suffix), @
  // 973:       @(par_count));@nl;@
  // 974:     return "func@(body_suffix)"
  // 975:   :
  // 976:     return "create_closure(entry@(body_suffix), @(par_count))"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  arguments->slots[2] = frame->slots[11] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body___to_c_442;
}
static void entry__compiler__body__to_c_433(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // body_suffix: 0
  // par_count: 1
  // return: 2
  frame->slots[0] = myself->closure.frame->slots[6]; /* body_suffix */
  frame->slots[1] = myself->closure.frame->slots[7]; /* par_count */
  frame->slots[2] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 970: ... "
  // 971:   @
  // 972:     func@(body_suffix) = create_function(entry@(body_suffix), @
  // 973:   @(par_count));@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__541f532081ce52b4;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__86eff1a866fd255c;
  arguments->slots[3] = frame->slots[0] /* body_suffix */;
  arguments->slots[4] = string__2d7981f4e6682be5;
  arguments->slots[5] = ((CELL *)frame->slots[1])->contents /* par_count */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_436;
}
static void cont__compiler__body__to_c_436(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 970: write_to_phase_2 "
  // 971:   @
  // 972:     func@(body_suffix) = create_function(entry@(body_suffix), @
  // 973:   @(par_count));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_437;
}
static void cont__compiler__body__to_c_437(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 974: ... "func@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__e0aec0b5d107d5a;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_438;
}
static void cont__compiler__body__to_c_438(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 974: return "func@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[2] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_c_439(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // return: 0
  // body_suffix: 1
  // par_count: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[6]; /* body_suffix */
  frame->slots[2] = myself->closure.frame->slots[7]; /* par_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 976: ... "create_closure(entry@(body_suffix), @(par_count))"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__4f4f87201b84976a;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__2d7981f4e6682be5;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* par_count */;
  arguments->slots[4] = string__578a5af303e9cc8;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_c_441;
}
static void cont__compiler__body__to_c_441(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 976: return "create_closure(entry@(body_suffix), @(par_count))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body___to_c_442(void) {
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__definition___to_c(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // self: 0
  // return: 1
  frame->slots[1] /* return */ = create_continuation();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 986: show_compiler_debug_info "generate definition"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b285329ce73409a7;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__definition___to_c_3;
}
static void cont__compiler__definition___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 987: ... attribute_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__definition___to_c_4;
}
static void cont__compiler__definition___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 987: ... attribute_kind_of(self) != NONE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = get__NONE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__definition___to_c_5;
}
static void cont__compiler__definition___to_c_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 987: ... attribute_kind_of(self) != NONE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__definition___to_c_6;
}
static void cont__compiler__definition___to_c_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 987: ... :
  // 988:   return
  // 989:     string
  // 990:       "var."
  // 991:       mangled_name_of(identifier_of(self))
  // 992:       "__"
  // 993:       mangled_name_of(attribute_of(self))
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__definition__to_c_7, 0);
  // 987: if attribute_kind_of(self) != NONE:
  // 988:   return
  // 989:     string
  // 990:       "var."
  // 991:       mangled_name_of(identifier_of(self))
  // 992:       "__"
  // 993:       mangled_name_of(attribute_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__definition___to_c_13;
}
static void entry__compiler__definition__to_c_7(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // return: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 991: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__definition__to_c_8;
}
static void cont__compiler__definition__to_c_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 991: mangled_name_of(identifier_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__definition__to_c_9;
}
static void cont__compiler__definition__to_c_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 993: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__definition__to_c_10;
}
static void cont__compiler__definition__to_c_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 993: mangled_name_of(attribute_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__definition__to_c_11;
}
static void cont__compiler__definition__to_c_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__2e0ae90b5df07d17;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e5f02b9a;
  arguments->slots[3] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__definition__to_c_12;
}
static void cont__compiler__definition__to_c_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 988: return
  // 989:   string
  // 990:     "var."
  // 991:     mangled_name_of(identifier_of(self))
  // 992:     "__"
  // 993:     mangled_name_of(attribute_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__definition___to_c_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 994: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__definition___to_c_14;
}
static void cont__compiler__definition___to_c_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 994: ... identifier_of(self).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__definition___to_c_15;
}
static void cont__compiler__definition___to_c_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 994: -> identifier_of(self).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__numeric_literal___to_c(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[1] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1000: show_compiler_debug_info "generate numeric literal"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b19618e04d55f805;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__numeric_literal___to_c_3;
}
static void cont__compiler__numeric_literal___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1001: ... mangled_name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__numeric_literal___to_c_4;
}
static void cont__compiler__numeric_literal___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1001: $name "number__@(mangled_name_of(self))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__64c0a950852db1bf;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__numeric_literal___to_c_6;
}
static void cont__compiler__numeric_literal___to_c_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1002: use_literal name self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 0;
  myself = get__use_literal();
  func = myself->type;
  frame->cont = cont__compiler__numeric_literal___to_c_7;
}
static void cont__compiler__numeric_literal___to_c_7(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1003: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__character_literal___to_c(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[1] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1009: show_compiler_debug_info "generate character literal"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__96912fd9d89a615a;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__character_literal___to_c_3;
}
static void cont__compiler__character_literal___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1010: ... node::value_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__value_of();
  func = myself->type;
  frame->cont = cont__compiler__character_literal___to_c_4;
}
static void cont__compiler__character_literal___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1010: ... node::value_of(self).to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__compiler__character_literal___to_c_5;
}
static void cont__compiler__character_literal___to_c_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1010: $name "character__@(node::value_of(self).to_integer)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__4ad975da2ff0e93f;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__character_literal___to_c_7;
}
static void cont__compiler__character_literal___to_c_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1011: use_literal name self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 0;
  myself = get__use_literal();
  func = myself->type;
  frame->cont = cont__compiler__character_literal___to_c_8;
}
static void cont__compiler__character_literal___to_c_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1012: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__to_c_string(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // str: 0
  // buf: 1
  // s: 2
  frame->slots[1] /* buf */ = create_cell();
  frame->slots[2] /* s */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1018: $$buf ""
  ((CELL *)frame->slots[1])->contents /* buf */ = empty_string;
  // 1019: $$s 1
  ((CELL *)frame->slots[2])->contents /* s */ = number__1;
  // 1020: ... : (idx chr)
  // 1021:   if chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\':
  // 1022:     append &buf range(str s idx-1)
  // 1023:     write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1024:     !s idx+1
  frame->slots[3] /* temp__1 */ = create_closure(entry__to_c_string_2, 2);
  // 1020: for_each str: (idx chr)
  // 1021:   if chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\':
  // 1022:     append &buf range(str s idx-1)
  // 1023:     write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1024:     !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__to_c_string_24;
}
static void entry__to_c_string_13(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // buf: 0
  // str: 1
  // s: 2
  // idx: 3
  // chr: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  frame->slots[2] = myself->closure.frame->slots[4]; /* s */
  frame->slots[3] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[4] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1022: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__to_c_string_14;
}
static void cont__to_c_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1022: ... range(str s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__to_c_string_15;
}
static void cont__to_c_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1022: append &buf range(str s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__to_c_string_16;
}
static void cont__to_c_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1023: ... chr.to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* chr */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__to_c_string_17;
}
static void cont__to_c_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 1023: ... oct(chr.to_integer)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__oct();
  func = myself->type;
  frame->cont = cont__to_c_string_18;
}
static void cont__to_c_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1023: ... pad_left(oct(chr.to_integer) 3 "0")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = number__3;
  arguments->slots[2] = string__578a5af303e9cd1;
  result_count = 1;
  myself = get__pad_left();
  func = myself->type;
  frame->cont = cont__to_c_string_20;
}
static void cont__to_c_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1023: write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = string__578a5af303e9cbd;
  arguments->slots[2] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__to_c_string_22;
}
static void cont__to_c_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1024: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__to_c_string_23;
}
static void cont__to_c_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__to_c_string_2(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // idx: 0
  // chr: 1
  // buf: 2
  // str: 3
  // s: 4
  frame->slots[2] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[0]; /* str */
  frame->slots[4] = myself->closure.frame->slots[2]; /* s */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1021: ... chr < ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__to_c_string_3;
}
static void cont__to_c_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1021: ... chr > '~' || chr == '@quot;' || chr == '\'
  frame->slots[7] /* temp__3 */ = create_closure(entry__to_c_string_4, 0);
  // 1021: ... chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__to_c_string_12;
}
static void entry__to_c_string_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1021: ... chr > '~'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__126;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__to_c_string_5;
}
static void cont__to_c_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1021: ... chr == '@quot;' || chr == '\'
  frame->slots[3] /* temp__3 */ = create_closure(entry__to_c_string_6, 0);
  // 1021: ... chr > '~' || chr == '@quot;' || chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__to_c_string_11;
}
static void entry__to_c_string_6(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1021: ... chr == '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__to_c_string_7;
}
static void cont__to_c_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1021: ... chr == '\'
  frame->slots[3] /* temp__3 */ = create_closure(entry__to_c_string_8, 0);
  // 1021: ... chr == '@quot;' || chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__to_c_string_10;
}
static void entry__to_c_string_8(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1021: ... chr == '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__92;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__to_c_string_9;
}
static void cont__to_c_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1021: ... chr == '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__to_c_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1021: ... chr == '@quot;' || chr == '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__to_c_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1021: ... chr > '~' || chr == '@quot;' || chr == '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__to_c_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1021: ... :
  // 1022:   append &buf range(str s idx-1)
  // 1023:   write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1024:   !s idx+1
  frame->slots[8] /* temp__4 */ = create_closure(entry__to_c_string_13, 0);
  // 1021: if chr < ' ' || chr > '~' || chr == '@quot;' || chr == '\':
  // 1022:   append &buf range(str s idx-1)
  // 1023:   write_to &buf "\" pad_left(oct(chr.to_integer) 3 "0")
  // 1024:   !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__to_c_string_24(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1025: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__to_c_string_25;
}
static void cont__to_c_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1025: ... s <= length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__to_c_string_26;
}
static void cont__to_c_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1025: ... s <= length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__to_c_string_27;
}
static void cont__to_c_string_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1025: ... : append &buf range(str s -1)
  frame->slots[6] /* temp__4 */ = create_closure(entry__to_c_string_28, 0);
  // 1025: if s <= length_of(str): append &buf range(str s -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__to_c_string_32;
}
static void entry__to_c_string_28(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // str: 1
  // s: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  frame->slots[2] = myself->closure.frame->slots[2]; /* s */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1025: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__to_c_string_29;
}
static void cont__to_c_string_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1025: ... range(str s -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__to_c_string_30;
}
static void cont__to_c_string_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1025: ... append &buf range(str s -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__to_c_string_31;
}
static void cont__to_c_string_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__to_c_string_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1026: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__register_string_4(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // str: 0
  // len: 1
  // name: 2
  // stored: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* len */
  frame->slots[2] /* name */ = create_cell();
  frame->slots[3] /* stored */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1034: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__register_string_5;
}
static void cont__register_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 1035: ... hash2(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__hash2();
  func = myself->type;
  frame->cont = cont__register_string_6;
}
static void cont__register_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1035: $$name hash2(str).hex
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__hex();
  func = myself->type;
  frame->cont = cont__register_string_7;
}
static void cont__register_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* name */ = arguments->slots[0];
  // 1036: $$stored string_literals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* name */;
  result_count = 1;
  myself = get__string_literals();
  func = myself->type;
  frame->cont = cont__register_string_8;
}
static void cont__register_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* stored */ = arguments->slots[0];
  // 1038: stored.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* stored */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__register_string_9;
}
static void cont__register_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1038: ... :
  // 1039:   if stored != str:
  // 1040:     # there is a collision
  // 1041:     
  // 1042:     if stored.is_a_string:
  // 1043:       # convert a single string into a list containing this string
  // 1044:       
  // 1045:       !stored list(stored)
  // 1046:     do: (-> break)
  // 1047:       # search for string in the collision list
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__register_string_10, 0);
  // 1061: :
  // 1062:   !string_literals(name) str
  frame->slots[6] /* temp__3 */ = create_closure(entry__register_string_31, 0);
  // 1037: if
  // 1038:   stored.is_defined:
  // 1039:     if stored != str:
  // 1040:       # there is a collision
  // 1041:       
  // 1042:       if stored.is_a_string:
  // 1043:         # convert a single string into a list containing this string
  // 1044:         
  // 1045:         !stored list(stored)
  // 1046:       do: (-> break)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__register_string_33;
}
static void entry__register_string_18(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // break: 0
  // stored: 1
  // str: 2
  // name: 3
  frame->slots[0] /* break */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* stored */
  frame->slots[2] = myself->closure.frame->slots[1]; /* str */
  frame->slots[3] = myself->closure.frame->slots[2]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1049: ... : (idx stored_str)
  // 1050:   if str == stored_str:
  // 1051:     # if it's not the first add a collision suffix
  // 1052:     
  // 1053:     if idx > 1: string &name '_' idx
  // 1054:     break
  frame->slots[4] /* temp__1 */ = create_closure(entry__register_string_19, 2);
  // 1049: for_each stored: (idx stored_str)
  // 1050:   if str == stored_str:
  // 1051:     # if it's not the first add a collision suffix
  // 1052:     
  // 1053:     if idx > 1: string &name '_' idx
  // 1054:     break
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* stored */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__register_string_26;
}
static void entry__register_string_21(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // idx: 0
  // name: 1
  // break: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[4]; /* break */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1053: ... idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__register_string_22;
}
static void cont__register_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1053: ... : string &name '_' idx
  frame->slots[4] /* temp__2 */ = create_closure(entry__register_string_23, 0);
  // 1053: if idx > 1: string &name '_' idx
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__register_string_25;
}
static void entry__register_string_23(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // name: 0
  // idx: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1053: ... string &name '_' idx
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* name */;
  arguments->slots[1] = character__95;
  arguments->slots[2] = frame->slots[1] /* idx */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__register_string_24;
}
static void cont__register_string_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* name */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_25(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1054: break
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[2] /* break */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_19(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // idx: 0
  // stored_str: 1
  // str: 2
  // name: 3
  // break: 4
  frame->slots[2] = myself->closure.frame->slots[2]; /* str */
  frame->slots[3] = myself->closure.frame->slots[3]; /* name */
  frame->slots[4] = myself->closure.frame->slots[0]; /* break */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1050: ... str == stored_str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  arguments->slots[1] = frame->slots[1] /* stored_str */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__register_string_20;
}
static void cont__register_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1050: ... :
  // 1051:   # if it's not the first add a collision suffix
  // 1052:   
  // 1053:   if idx > 1: string &name '_' idx
  // 1054:   break
  frame->slots[6] /* temp__2 */ = create_closure(entry__register_string_21, 0);
  // 1050: if str == stored_str:
  // 1051:   # if it's not the first add a collision suffix
  // 1052:   
  // 1053:   if idx > 1: string &name '_' idx
  // 1054:   break
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__register_string_26(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1058: push &stored str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* stored */;
  arguments->slots[1] = frame->slots[2] /* str */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__register_string_27;
}
static void cont__register_string_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* stored */ = arguments->slots[0];
  // 1059: !string_literals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* name */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* stored */;
  result_count = 1;
  myself = get__string_literals();
  func = myself->type;
  frame->cont = cont__register_string_28;
}
static void cont__register_string_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__string_literals(arguments->slots[0]);
  // 1060: ... length_of(stored)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* stored */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__register_string_29;
}
static void cont__register_string_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1060: string &name '_' length_of(stored) # append the collision suffix
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* name */;
  arguments->slots[1] = character__95;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__register_string_30;
}
static void cont__register_string_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* name */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__register_string_13(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // stored: 0
  // str: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* stored */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  frame->slots[2] = myself->closure.frame->slots[2]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1042: ... stored.is_a_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* stored */;
  result_count = 1;
  myself = get__is_a_string();
  func = myself->type;
  frame->cont = cont__register_string_14;
}
static void cont__register_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1042: ... :
  // 1043:   # convert a single string into a list containing this string
  // 1044:   
  // 1045:   !stored list(stored)
  frame->slots[4] /* temp__2 */ = create_closure(entry__register_string_15, 0);
  // 1042: if stored.is_a_string:
  // 1043:   # convert a single string into a list containing this string
  // 1044:   
  // 1045:   !stored list(stored)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__register_string_17;
}
static void entry__register_string_15(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // stored: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* stored */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1045: !stored list(stored)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* stored */;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__register_string_16;
}
static void cont__register_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* stored */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_17(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1046: ... : (-> break)
  // 1047:   # search for string in the collision list
  // 1048:   
  // 1049:   for_each stored: (idx stored_str)
  // 1050:     if str == stored_str:
  // 1051:       # if it's not the first add a collision suffix
  // 1052:       
  // 1053:       if idx > 1: string &name '_' idx
  // 1054:       break
  // 1055:   
  // ...
  frame->slots[3] /* temp__1 */ = create_closure(entry__register_string_18, 0);
  // 1046: do: (-> break)
  // 1047:   # search for string in the collision list
  // 1048:   
  // 1049:   for_each stored: (idx stored_str)
  // 1050:     if str == stored_str:
  // 1051:       # if it's not the first add a collision suffix
  // 1052:       
  // 1053:       if idx > 1: string &name '_' idx
  // 1054:       break
  // 1055:   
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_10(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // stored: 0
  // str: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* stored */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  frame->slots[2] = myself->closure.frame->slots[2]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1039: ... stored != str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* stored */;
  arguments->slots[1] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__register_string_11;
}
static void cont__register_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1039: ... stored != str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_12;
}
static void cont__register_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1039: ... :
  // 1040:   # there is a collision
  // 1041:   
  // 1042:   if stored.is_a_string:
  // 1043:     # convert a single string into a list containing this string
  // 1044:     
  // 1045:     !stored list(stored)
  // 1046:   do: (-> break)
  // 1047:     # search for string in the collision list
  // 1048:     
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__register_string_13, 0);
  // 1039: if stored != str:
  // 1040:   # there is a collision
  // 1041:   
  // 1042:   if stored.is_a_string:
  // 1043:     # convert a single string into a list containing this string
  // 1044:     
  // 1045:     !stored list(stored)
  // 1046:   do: (-> break)
  // 1047:     # search for string in the collision list
  // 1048:     
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_31(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // name: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1062: !string_literals(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* name */;
  arguments->slots[1] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__string_literals();
  func = myself->type;
  frame->cont = cont__register_string_32;
}
static void cont__register_string_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__string_literals(arguments->slots[0]);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_33(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1063: append "string__" &name # prepend the literal prefix
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__72c4ac1f052d021f;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* name */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__register_string_35;
}
static void cont__register_string_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* name */ = arguments->slots[0];
  // 1064: ... "static NODE *@(name);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__cb6a78473f66a6a1;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* name */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__register_string_37;
}
static void cont__register_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1064: write_to_declarations "static NODE *@(name);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__register_string_38;
}
static void cont__register_string_38(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1066: str.is_a_latin_1_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__is_a_latin_1_string();
  func = myself->type;
  frame->cont = cont__register_string_39;
}
static void cont__register_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1066: ... :
  // 1067:   write_to_phase_2 "  @(name) = from_latin_1_string("
  // 1068:   $n search_character(str '@nl;')
  // 1069:   if
  // 1070:     n.is_defined && len > n:
  // 1071:       for_each_line
  // 1072:         str: (line)
  // 1073:           write_to_phase_2
  // 1074:             "
  // 1075:               @
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__register_string_40, 0);
  // 1091: :
  // 1092:   write_to_phase_2 "  uint32_t @(name)_literal[@(len)] = {"
  // 1093:   for_each
  // 1094:     str: (chr)
  // 1095:       if
  // 1096:         ||
  // 1097:           &&
  // 1098:             chr >= ' '
  // 1099:             chr <= '~'
  // 1100:             chr != '@apos;'
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__register_string_68, 0);
  // 1065: if
  // 1066:   str.is_a_latin_1_string:
  // 1067:     write_to_phase_2 "  @(name) = from_latin_1_string("
  // 1068:     $n search_character(str '@nl;')
  // 1069:     if
  // 1070:       n.is_defined && len > n:
  // 1071:         for_each_line
  // 1072:           str: (line)
  // 1073:             write_to_phase_2
  // 1074:               "
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__register_string_113;
}
static void entry__register_string_49(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // str: 0
  // len: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* len */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1071: for_each_line
  // 1072:   str: (line)
  // 1073:     write_to_phase_2
  // 1074:       "
  // 1075:         @
  // 1076:         
  // 1077:             "@
  // 1078:       to_c_string(line)
  // 1079:   :
  // 1080:     write_to_phase_2 "\n@quot;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = func__register_string_50;
  arguments->slots[2] = func__register_string_53;
  result_count = 0;
  myself = get__for_each_line();
  func = myself->type;
  frame->cont = cont__register_string_55;
}
static void entry__register_string_50(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // line: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1078: to_c_string(line)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  result_count = 1;
  myself = func__to_c_string;
  func = myself->type;
  frame->cont = cont__register_string_51;
}
static void cont__register_string_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1073: write_to_phase_2
  // 1074:   "
  // 1075:     @
  // 1076:     
  // 1077:         "@
  // 1078:   to_c_string(line)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__d81f467583be52f5;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_53(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1080: write_to_phase_2 "\n@quot;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__fa72f415d596bee;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__register_string_55(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1082: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__register_string_56;
}
static void cont__register_string_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1082: str(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__register_string_57;
}
static void cont__register_string_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1082: str(-1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__register_string_58;
}
static void cont__register_string_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1081: if
  // 1082:   str(-1) == '@nl;':
  // 1083:     write_to_phase_2 "\n@quot;"
  // 1084:   :
  // 1085:     write_to_phase_2 "@quot;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = func__register_string_59;
  arguments->slots[2] = func__register_string_60;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__register_string_61;
}
static void entry__register_string_59(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1083: write_to_phase_2 "\n@quot;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__fa72f415d596bee;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_60(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1085: write_to_phase_2 "@quot;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc3;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__register_string_61(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1086: ... "
  // 1087:   ,
  // 1088:       @(len));
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__d81f466683bcf2f7;
  arguments->slots[1] = frame->slots[1] /* len */;
  arguments->slots[2] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__register_string_63;
}
static void cont__register_string_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1086: write_to_phase_2 "
  // 1087:   ,
  // 1088:       @(len));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_64(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // str: 0
  // len: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* len */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1090: ... to_c_string(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = func__to_c_string;
  func = myself->type;
  frame->cont = cont__register_string_65;
}
static void cont__register_string_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1090: ... "@quot;@(to_c_string(str))@quot;, @(len));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc3;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__fa730c15f496bec;
  arguments->slots[3] = frame->slots[1] /* len */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__register_string_67;
}
static void cont__register_string_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1090: write_to_phase_2 "@quot;@(to_c_string(str))@quot;, @(len));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_40(void) {
  allocate_initialized_frame_gc(3, 9);
  // slot allocations:
  // name: 0
  // str: 1
  // len: 2
  // n: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  frame->slots[2] = myself->closure.frame->slots[1]; /* len */
  frame->slots[3] /* n */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1067: ... "  @(name) = from_latin_1_string("
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* name */;
  arguments->slots[2] = string__a3d95bf5db908e15;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__register_string_42;
}
static void cont__register_string_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1067: write_to_phase_2 "  @(name) = from_latin_1_string("
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__register_string_43;
}
static void cont__register_string_43(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1068: $n search_character(str '@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__search_character();
  func = myself->type;
  frame->cont = cont__register_string_44;
}
static void cont__register_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* n */, arguments->slots[0]);
  // 1070: n.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* n */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__register_string_45;
}
static void cont__register_string_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1070: ... len > n
  frame->slots[6] /* temp__3 */ = create_closure(entry__register_string_46, 0);
  // 1070: n.is_defined && len > n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__register_string_48;
}
static void entry__register_string_46(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // n: 0
  // len: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* n */
  frame->slots[1] = myself->closure.frame->slots[2]; /* len */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1070: ... len > n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* n */;
  arguments->slots[1] = frame->slots[1] /* len */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__register_string_47;
}
static void cont__register_string_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1070: ... len > n
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1070: ... :
  // 1071:   for_each_line
  // 1072:     str: (line)
  // 1073:       write_to_phase_2
  // 1074:         "
  // 1075:           @
  // 1076:           
  // 1077:               "@
  // 1078:         to_c_string(line)
  // 1079:     :
  // ...
  frame->slots[7] /* temp__4 */ = create_closure(entry__register_string_49, 0);
  // 1089: :
  // 1090:   write_to_phase_2 "@quot;@(to_c_string(str))@quot;, @(len));@nl;"
  frame->slots[8] /* temp__5 */ = create_closure(entry__register_string_64, 0);
  // 1069: if
  // 1070:   n.is_defined && len > n:
  // 1071:     for_each_line
  // 1072:       str: (line)
  // 1073:         write_to_phase_2
  // 1074:           "
  // 1075:             @
  // 1076:             
  // 1077:                 "@
  // 1078:           to_c_string(line)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_68(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // name: 0
  // len: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* len */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1092: ... "  uint32_t @(name)_literal[@(len)] = {"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__24e73e91baac9a30;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* name */;
  arguments->slots[2] = string__4a9426e6bd63257e;
  arguments->slots[3] = frame->slots[1] /* len */;
  arguments->slots[4] = string__ca5afc43e8cbc02c;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__register_string_72;
}
static void cont__register_string_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1092: write_to_phase_2 "  uint32_t @(name)_literal[@(len)] = {"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__register_string_73;
}
static void cont__register_string_73(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1093: for_each
  // 1094:   str: (chr)
  // 1095:     if
  // 1096:       ||
  // 1097:         &&
  // 1098:           chr >= ' '
  // 1099:           chr <= '~'
  // 1100:           chr != '@apos;'
  // 1101:           chr != '@quot;'
  // 1102:           chr != '\'
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  arguments->slots[1] = func__register_string_74;
  arguments->slots[2] = func__register_string_106;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__register_string_107;
}
static void entry__register_string_101(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1105: write_to_phase_2 '@apos;' chr '@apos;'
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__39;
  arguments->slots[1] = frame->slots[0] /* chr */;
  arguments->slots[2] = character__39;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_102(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1107: ... chr.to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__register_string_103;
}
static void cont__register_string_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1107: ... hex(chr.to_integer)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__hex();
  func = myself->type;
  frame->cont = cont__register_string_104;
}
static void cont__register_string_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1107: write_to_phase_2 "0x" hex(chr.to_integer)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6882bbd;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_74(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // chr: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1098: chr >= ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__register_string_75;
}
static void cont__register_string_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 1098: chr >= ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_76;
}
static void cont__register_string_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  frame->slots[5] /* temp__5 */ = create_closure(entry__register_string_77, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__register_string_92;
}
static void entry__register_string_77(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1099: chr <= '~'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__126;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__register_string_78;
}
static void cont__register_string_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1099: chr <= '~'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_79;
}
static void cont__register_string_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__register_string_80, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__register_string_91;
}
static void entry__register_string_80(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1100: chr != '@apos;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__39;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__register_string_81;
}
static void cont__register_string_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1100: chr != '@apos;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_82;
}
static void cont__register_string_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__register_string_83, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__register_string_90;
}
static void entry__register_string_83(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1101: chr != '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__register_string_84;
}
static void cont__register_string_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1101: chr != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_85;
}
static void cont__register_string_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1102: chr != '\'
  frame->slots[4] /* temp__4 */ = create_closure(entry__register_string_86, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__register_string_89;
}
static void entry__register_string_86(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1102: chr != '\'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__92;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__register_string_87;
}
static void cont__register_string_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1102: chr != '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_88;
}
static void cont__register_string_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1102: chr != '\'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_90(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1103: chr >= '@nbsp;' && chr <= 'ÿ'
  frame->slots[6] /* temp__6 */ = create_closure(entry__register_string_93, 0);
  // 1096: ||
  // 1097:   &&
  // 1098:     chr >= ' '
  // 1099:     chr <= '~'
  // 1100:     chr != '@apos;'
  // 1101:     chr != '@quot;'
  // 1102:     chr != '\'
  // 1103:   chr >= '@nbsp;' && chr <= 'ÿ'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__register_string_100;
}
static void entry__register_string_93(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1103: chr >= '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__160;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__register_string_94;
}
static void cont__register_string_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1103: chr >= '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_95;
}
static void cont__register_string_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1103: ... chr <= 'ÿ'
  frame->slots[4] /* temp__4 */ = create_closure(entry__register_string_96, 0);
  // 1103: chr >= '@nbsp;' && chr <= 'ÿ'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__register_string_99;
}
static void entry__register_string_96(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1103: ... chr <= 'ÿ'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__255;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__register_string_97;
}
static void cont__register_string_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1103: ... chr <= 'ÿ'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__register_string_98;
}
static void cont__register_string_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1103: ... chr <= 'ÿ'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1103: chr >= '@nbsp;' && chr <= 'ÿ'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__register_string_100(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1104: :
  // 1105:   write_to_phase_2 '@apos;' chr '@apos;'
  frame->slots[7] /* temp__7 */ = create_closure(entry__register_string_101, 0);
  // 1106: :
  // 1107:   write_to_phase_2 "0x" hex(chr.to_integer)
  frame->slots[8] /* temp__8 */ = create_closure(entry__register_string_102, 0);
  // 1095: if
  // 1096:   ||
  // 1097:     &&
  // 1098:       chr >= ' '
  // 1099:       chr <= '~'
  // 1100:       chr != '@apos;'
  // 1101:       chr != '@quot;'
  // 1102:       chr != '\'
  // 1103:     chr >= '@nbsp;' && chr <= 'ÿ'
  // 1104:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__7 */;
  arguments->slots[2] = frame->slots[8] /* temp__8 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__register_string_106(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1109: write_to_phase_2 ", "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6682be5;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__register_string_107(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1110: write_to_phase_2 "};@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__fa727015ff16bc6;
  result_count = 0;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame->cont = cont__register_string_109;
}
static void cont__register_string_109(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1112: "  @(name) = from_uint32_string(@(name)_literal, @(len));@nl;"
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* name */;
  arguments->slots[2] = string__6bf55d38c602d6fa;
  arguments->slots[3] = ((CELL *)frame->slots[0])->contents /* name */;
  arguments->slots[4] = string__3735eb19284a5481;
  arguments->slots[5] = frame->slots[1] /* len */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__register_string_112;
}
static void cont__register_string_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1111: write_to_phase_2
  // 1112:   "  @(name) = from_uint32_string(@(name)_literal, @(len));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__register_string_113(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1113: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__register_string_114(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1032: -> "empty_string"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__ee21fa04ce7f45ad;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__register_string(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // str: 0
  // len: 1
  frame->slots[1] /* len */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1029: $len length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__register_string_2;
}
static void cont__register_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* len */, arguments->slots[0]);
  // 1031: len == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* len */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__register_string_3;
}
static void cont__register_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1033: :
  // 1034:   inc &index
  // 1035:   $$name hash2(str).hex
  // 1036:   $$stored string_literals(name)
  // 1037:   if
  // 1038:     stored.is_defined:
  // 1039:       if stored != str:
  // 1040:         # there is a collision
  // 1041:         
  // 1042:         if stored.is_a_string:
  // ...
  frame->slots[3] /* temp__2 */ = create_closure(entry__register_string_4, 0);
  // 1030: if
  // 1031:   len == 0
  // 1032:   -> "empty_string"
  // 1033:   :
  // 1034:     inc &index
  // 1035:     $$name hash2(str).hex
  // 1036:     $$stored string_literals(name)
  // 1037:     if
  // 1038:       stored.is_defined:
  // 1039:         if stored != str:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = func__register_string_114;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__string_literal__to_c_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // literal: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* literal */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1121: -> literal
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* literal */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__string_literal__to_c_8(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // text: 0
  // new_literal: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* text */
  frame->slots[1] /* new_literal */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1123: $new_literal register_string(text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  result_count = 1;
  myself = func__register_string;
  func = myself->type;
  frame->cont = cont__compiler__string_literal__to_c_9;
}
static void cont__compiler__string_literal__to_c_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* new_literal */, arguments->slots[0]);
  // 1124: !used_string_literals(text)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = frame->slots[1] /* new_literal */;
  result_count = 1;
  myself = get__used_string_literals();
  func = myself->type;
  frame->cont = cont__compiler__string_literal__to_c_10;
}
static void cont__compiler__string_literal__to_c_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__used_string_literals(arguments->slots[0]);
  // 1125: -> new_literal
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* new_literal */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__string_literal___to_c(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // text: 1
  // literal: 2
  frame->slots[1] /* text */ = create_future();
  frame->slots[2] /* literal */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1116: show_compiler_debug_info "generate string literal"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__92bdd3e04dbbd1c4;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__string_literal___to_c_3;
}
static void cont__compiler__string_literal___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1117: $text node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__compiler__string_literal___to_c_4;
}
static void cont__compiler__string_literal___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* text */, arguments->slots[0]);
  // 1118: $literal used_string_literals(text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  result_count = 1;
  myself = get__used_string_literals();
  func = myself->type;
  frame->cont = cont__compiler__string_literal___to_c_5;
}
static void cont__compiler__string_literal___to_c_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* literal */, arguments->slots[0]);
  // 1120: literal.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* literal */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__string_literal___to_c_6;
}
static void cont__compiler__string_literal___to_c_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1121: -> literal
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__string_literal__to_c_7, 0);
  // 1122: :
  // 1123:   $new_literal register_string(text)
  // 1124:   !used_string_literals(text) new_literal
  // 1125:   -> new_literal
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__string_literal__to_c_8, 0);
  // 1119: if
  // 1120:   literal.is_defined
  // 1121:   -> literal
  // 1122:   :
  // 1123:     $new_literal register_string(text)
  // 1124:     !used_string_literals(text) new_literal
  // 1125:     -> new_literal
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__unique_item___to_c(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // self: 0
  // name: 1
  // reg_name: 2
  frame->slots[1] /* name */ = create_future();
  frame->slots[2] /* reg_name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1131: show_compiler_debug_info "generate unique item"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__d48b67664260d740;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_3;
}
static void cont__compiler__unique_item___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1137: name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_4;
}
static void cont__compiler__unique_item___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1137: name_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_5;
}
static void cont__compiler__unique_item___to_c_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1138: -> name_of(self)
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__unique_item__to_c_6, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = func__compiler__unique_item__to_c_8;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_10;
}
static void entry__compiler__unique_item__to_c_6(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1138: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__unique_item__to_c_7;
}
static void cont__compiler__unique_item__to_c_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1138: -> name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__unique_item__to_c_8(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1140: inc &unique_item_index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__unique_item_index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__unique_item__to_c_9;
}
static void cont__compiler__unique_item__to_c_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__unique_item_index(arguments->slots[0]);
  // 1141: -> unique_item_index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__unique_item_index();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__unique_item___to_c_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1133: $name
  // 1134:   string
  // 1135:     "unique__"
  // 1136:     if
  // 1137:       name_of(self).is_defined
  // 1138:       -> name_of(self)
  // 1139:       :
  // 1140:         inc &unique_item_index
  // 1141:         -> unique_item_index
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__44acac92852c82df;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_12;
}
static void cont__compiler__unique_item___to_c_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1145: name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_13;
}
static void cont__compiler__unique_item___to_c_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1145: name_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_14;
}
static void cont__compiler__unique_item___to_c_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1146: -> name_of(self)
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__unique_item__to_c_15, 0);
  // 1147: -> name
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__unique_item__to_c_17, 0);
  // 1143: $reg_name
  // 1144:   if
  // 1145:     name_of(self).is_defined
  // 1146:     -> name_of(self)
  // 1147:     -> name
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_18;
}
static void entry__compiler__unique_item__to_c_15(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1146: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__unique_item__to_c_16;
}
static void cont__compiler__unique_item__to_c_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1146: -> name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__unique_item__to_c_17(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1147: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__unique_item___to_c_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* reg_name */, arguments->slots[0]);
  // 1149: ... used_unique_items(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  result_count = 1;
  myself = get__used_unique_items();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_19;
}
static void cont__compiler__unique_item___to_c_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1149: ... :
  // 1150:   !used_unique_items(name) true
  // 1151:   write_to_declarations "static NODE *@(name);@nl;"
  // 1152:   write_to_phase_2 "
  // 1153:     @
  // 1154:       @(name) = register_unique_item("@(reg_name)");
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__unique_item__to_c_20, 0);
  // 1149: unless used_unique_items(name):
  // 1150:   !used_unique_items(name) true
  // 1151:   write_to_declarations "static NODE *@(name);@nl;"
  // 1152:   write_to_phase_2 "
  // 1153:     @
  // 1154:       @(name) = register_unique_item("@(reg_name)");
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__unique_item___to_c_27;
}
static void entry__compiler__unique_item__to_c_20(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // name: 0
  // reg_name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* reg_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1150: !used_unique_items(name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = get__true();
  result_count = 1;
  myself = get__used_unique_items();
  func = myself->type;
  frame->cont = cont__compiler__unique_item__to_c_21;
}
static void cont__compiler__unique_item__to_c_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__used_unique_items(arguments->slots[0]);
  // 1151: ... "static NODE *@(name);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__cb6a78473f66a6a1;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__unique_item__to_c_22;
}
static void cont__compiler__unique_item__to_c_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1151: write_to_declarations "static NODE *@(name);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__unique_item__to_c_23;
}
static void cont__compiler__unique_item__to_c_23(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1152: ... "
  // 1153:   @
  // 1154:     @(name) = register_unique_item("@(reg_name)");
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__8b8ef598707f4603;
  arguments->slots[3] = frame->slots[1] /* reg_name */;
  arguments->slots[4] = string__860afb0b5fb87d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__unique_item__to_c_26;
}
static void cont__compiler__unique_item__to_c_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1152: write_to_phase_2 "
  // 1153:   @
  // 1154:     @(name) = register_unique_item("@(reg_name)");
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__unique_item___to_c_27(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1155: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_39(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // self: 0
  // name: 1
  // variable_kind: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  frame->slots[2] /* variable_kind */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1181: namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_40;
}
static void cont__compiler__identifier__to_c_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1181: namespace_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_41;
}
static void cont__compiler__identifier__to_c_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1182: -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__identifier__to_c_42, 0);
  // 1183: -> variable_kind_of(global_names(name))
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__identifier__to_c_48, 0);
  // 1179: $variable_kind
  // 1180:   if
  // 1181:     namespace_of(self).is_defined
  // 1182:     -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1183:     -> variable_kind_of(global_names(name))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_51;
}
static void entry__compiler__identifier__to_c_42(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1182: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_43;
}
static void cont__compiler__identifier__to_c_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1182: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_44;
}
static void cont__compiler__identifier__to_c_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 1182: ... exported_names(name_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_45;
}
static void cont__compiler__identifier__to_c_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 1182: ... exported_names(name_of(self))(namespace_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = frame->slots[4] /* temp__4 */;
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_46;
}
static void cont__compiler__identifier__to_c_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1182: ... variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_47;
}
static void cont__compiler__identifier__to_c_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1182: -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_48(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1183: ... global_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_49;
}
static void cont__compiler__identifier__to_c_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1183: ... variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_50;
}
static void cont__compiler__identifier__to_c_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1183: -> variable_kind_of(global_names(name))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__identifier__to_c_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* variable_kind */, arguments->slots[0]);
  // 1188: DYNAMIC_SINGLE, DYNAMIC_MULTI
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__DYNAMIC_SINGLE();
  arguments->slots[1] = get__DYNAMIC_MULTI();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_52;
}
static void cont__compiler__identifier__to_c_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1189: -> "get__@(name)()"
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__identifier__to_c_53, 0);
  // 1190: -> var_entry(name)
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__identifier__to_c_55, 0);
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* variable_kind */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  arguments->slots[3] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_57;
}
static void entry__compiler__identifier__to_c_53(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1189: ... "get__@(name)()"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__405aee03eb306008;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__2d7981f4e6482bec;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_54;
}
static void cont__compiler__identifier__to_c_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1189: -> "get__@(name)()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_55(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1190: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_56;
}
static void cont__compiler__identifier__to_c_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1190: -> var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__identifier__to_c_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1185: ->
  // 1186:   case
  // 1187:     variable_kind
  // 1188:     DYNAMIC_SINGLE, DYNAMIC_MULTI
  // 1189:     -> "get__@(name)()"
  // 1190:     -> var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_35(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1177: ... "get__@(name)()"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__405aee03eb306008;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__2d7981f4e6482bec;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_37;
}
static void cont__compiler__identifier__to_c_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1177: ... -> "get__@(name)()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_21(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1172: name.is_a_shared_local
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__is_a_shared_local();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_22;
}
static void cont__compiler__identifier__to_c_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1173: -> "
  // 1174:   ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1175:   */@
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__identifier__to_c_23, 0);
  // 1176: -> "frame->slots[@(current_locals(name))] /* @(name) */"
  frame->slots[4] /* temp__4 */ = create_closure(entry__compiler__identifier__to_c_28, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_31;
}
static void entry__compiler__identifier__to_c_23(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1174: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_24;
}
static void cont__compiler__identifier__to_c_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1173: ... "
  // 1174:   ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1175:   */@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__58e06d42b95eed3d;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__713cab8df53e8c2e;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__fa730415f796be3;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_27;
}
static void cont__compiler__identifier__to_c_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1173: -> "
  // 1174:   ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1175:   */@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_28(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1176: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_29;
}
static void cont__compiler__identifier__to_c_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1176: ... "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__9d12bd49b1f09f10;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__ca5af8c3e89bc077;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__fa730415f796be3;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_30;
}
static void cont__compiler__identifier__to_c_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1176: -> "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__identifier__to_c_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1170: ... ->
  // 1171:   if
  // 1172:     name.is_a_shared_local
  // 1173:     -> "
  // 1174:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1175:       */@
  // 1176:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_7(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1166: temporary_offset.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__temporary_offset();
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_8;
}
static void cont__compiler__identifier__to_c_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1166: ... :
  // 1167:   $idx temporary_offset+behind(name "__").to_integer-1
  // 1168:   -> "frame->slots[@(idx)] /* @(name) */"
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__identifier__to_c_9, 0);
  // 1169: -> name
  frame->slots[4] /* temp__4 */ = create_closure(entry__compiler__identifier__to_c_16, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_17;
}
static void entry__compiler__identifier__to_c_9(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // name: 0
  // idx: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  frame->slots[1] /* idx */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1167: ... behind(name "__")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__2d7981f4e5f02b9a;
  result_count = 1;
  myself = get__behind();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_10;
}
static void cont__compiler__identifier__to_c_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1167: ... behind(name "__").to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_11;
}
static void cont__compiler__identifier__to_c_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1167: ... temporary_offset+behind(name "__").to_integer
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__temporary_offset();
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_12;
}
static void cont__compiler__identifier__to_c_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1167: $idx temporary_offset+behind(name "__").to_integer-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_13;
}
static void cont__compiler__identifier__to_c_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* idx */, arguments->slots[0]);
  // 1168: ... "frame->slots[@(idx)] /* @(name) */"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__9d12bd49b1f09f10;
  arguments->slots[1] = frame->slots[1] /* idx */;
  arguments->slots[2] = string__ca5af8c3e89bc077;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__fa730415f796be3;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_15;
}
static void cont__compiler__identifier__to_c_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1168: -> "frame->slots[@(idx)] /* @(name) */"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_16(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1169: -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__identifier__to_c_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1164: ... ->
  // 1165:   if
  // 1166:     temporary_offset.is_defined:
  // 1167:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1168:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1169:     -> name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_5(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1164: ... self.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_6;
}
static void cont__compiler__identifier__to_c_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1164: ... ->
  // 1165:   if
  // 1166:     temporary_offset.is_defined:
  // 1167:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1168:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1169:     -> name
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__identifier__to_c_7, 0);
  // 1164: -> self.is_a_temporary ->
  // 1165:   if
  // 1166:     temporary_offset.is_defined:
  // 1167:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1168:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1169:     -> name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_18(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1170: ... current_locals(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__current_locals();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_19;
}
static void cont__compiler__identifier__to_c_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1170: ... current_locals(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_20;
}
static void cont__compiler__identifier__to_c_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1170: ... ->
  // 1171:   if
  // 1172:     name.is_a_shared_local
  // 1173:     -> "
  // 1174:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1175:       */@
  // 1176:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__identifier__to_c_21, 0);
  // 1170: -> current_locals(name).is_defined ->
  // 1171:   if
  // 1172:     name.is_a_shared_local
  // 1173:     -> "
  // 1174:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1175:       */@
  // 1176:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_32(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1177: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_33;
}
static void cont__compiler__identifier__to_c_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1177: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_c_34;
}
static void cont__compiler__identifier__to_c_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1177: ... -> "get__@(name)()"
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__identifier__to_c_35, 0);
  // 1177: -> needed_names(name).is_defined -> "get__@(name)()"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_c_38(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1178: ... :
  // 1179:   $variable_kind
  // 1180:     if
  // 1181:       namespace_of(self).is_defined
  // 1182:       -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1183:       -> variable_kind_of(global_names(name))
  // 1184:   
  // 1185:   ->
  // 1186:     case
  // 1187:       variable_kind
  // ...
  frame->slots[2] /* temp__1 */ = create_closure(entry__compiler__identifier__to_c_39, 0);
  // 1178: -> true:
  // 1179:   $variable_kind
  // 1180:     if
  // 1181:       namespace_of(self).is_defined
  // 1182:       -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1183:       -> variable_kind_of(global_names(name))
  // 1184:   
  // 1185:   ->
  // 1186:     case
  // 1187:       variable_kind
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier___to_c(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // name: 1
  frame->slots[1] /* name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1161: show_compiler_debug_info "generate identifier " self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__d48f33204edcb4ea;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__identifier___to_c_3;
}
static void cont__compiler__identifier___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1162: $name mangled_name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier___to_c_4;
}
static void cont__compiler__identifier___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* name */, arguments->slots[0]);
  // 1164: -> self.is_a_temporary ->
  // 1165:   if
  // 1166:     temporary_offset.is_defined:
  // 1167:       $idx temporary_offset+behind(name "__").to_integer-1
  // 1168:       -> "frame->slots[@(idx)] /* @(name) */"
  // 1169:     -> name
  frame->slots[2] /* temp__1 */ = create_closure(entry__compiler__identifier__to_c_5, 0);
  // 1170: -> current_locals(name).is_defined ->
  // 1171:   if
  // 1172:     name.is_a_shared_local
  // 1173:     -> "
  // 1174:       ((CELL *)frame->slots[@(current_locals(name))])->contents /* @(name) @
  // 1175:       */@
  // 1176:     -> "frame->slots[@(current_locals(name))] /* @(name) */"
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__identifier__to_c_18, 0);
  // 1177: -> needed_names(name).is_defined -> "get__@(name)()"
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__identifier__to_c_32, 0);
  // 1178: -> true:
  // 1179:   $variable_kind
  // 1180:     if
  // 1181:       namespace_of(self).is_defined
  // 1182:       -> variable_kind_of(exported_names(name_of(self))(namespace_of(self)))
  // 1183:       -> variable_kind_of(global_names(name))
  // 1184:   
  // 1185:   ->
  // 1186:     case
  // 1187:       variable_kind
  // ...
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__identifier__to_c_38, 0);
  // 1163: cond
  // 1164:   -> self.is_a_temporary ->
  // 1165:     if
  // 1166:       temporary_offset.is_defined:
  // 1167:         $idx temporary_offset+behind(name "__").to_integer-1
  // 1168:         -> "frame->slots[@(idx)] /* @(name) */"
  // 1169:       -> name
  // 1170:   -> current_locals(name).is_defined ->
  // 1171:     if
  // 1172:       name.is_a_shared_local
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  arguments->slots[3] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__c_body___to_c(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // body_suffix: 1
  // continuation_info: 2
  frame->slots[1] /* body_suffix */ = create_future();
  frame->slots[2] /* continuation_info */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1196: show_compiler_debug_info "generate C-body"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__9495a9c10d9ac4d0;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_3;
}
static void cont__compiler__c_body___to_c_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1197: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_4;
}
static void cont__compiler__c_body___to_c_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 1198: $body_suffix string(suffix '_' index)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__suffix();
  arguments->slots[1] = character__95;
  arguments->slots[2] = get__index();
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_5;
}
static void cont__compiler__c_body___to_c_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* body_suffix */, arguments->slots[0]);
  // 1199: $$continuation_info undefined
  ((CELL *)frame->slots[2])->contents /* continuation_info */ = get__undefined();
  // 1200: ... end_position_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__end_position_of();
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_6;
}
static void cont__compiler__c_body___to_c_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1200: ... end_position_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_7;
}
static void cont__compiler__c_body___to_c_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1200: ... :
  // 1201:   compute_source_text_info !continuation_info self
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__c_body__to_c_8, 0);
  // 1200: if end_position_of(self).is_defined:
  // 1201:   compute_source_text_info !continuation_info self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_10;
}
static void entry__compiler__c_body__to_c_8(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // continuation_info: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* continuation_info */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1201: compute_source_text_info !continuation_info self
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = func__compute_source_text_info;
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_9;
}
static void cont__compiler__c_body__to_c_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* continuation_info */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_body___to_c_10(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1202: ... :
  // 1203:   $par_count
  // 1204:     if
  // 1205:       source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  // 1206:       -> between(source_of(self) '(' ')')
  // 1207:       -> -1
  // 1208:   
  // 1209:   write_to_declarations "
  // 1210:     static void entry@(body_suffix)(void);
  // 1211:     static NODE *func@(body_suffix);
  // ...
  frame->slots[3] /* temp__1 */ = create_closure(entry__compiler__c_body__to_c_11, 0);
  // 1202: delayed:
  // 1203:   $par_count
  // 1204:     if
  // 1205:       source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  // 1206:       -> between(source_of(self) '(' ')')
  // 1207:       -> -1
  // 1208:   
  // 1209:   write_to_declarations "
  // 1210:     static void entry@(body_suffix)(void);
  // 1211:     static NODE *func@(body_suffix);
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = func__delayed;
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_38;
}
static void entry__compiler__c_body__to_c_11(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // self: 0
  // body_suffix: 1
  // continuation_info: 2
  // par_count: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* body_suffix */
  frame->slots[2] = myself->closure.frame->slots[2]; /* continuation_info */
  frame->slots[3] /* par_count */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1205: source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_12;
}
static void cont__compiler__c_body__to_c_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1205: source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = string__8d88533a39505214;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_14;
}
static void cont__compiler__c_body__to_c_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1206: -> between(source_of(self) '(' ')')
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_body__to_c_15, 0);
  // 1203: $par_count
  // 1204:   if
  // 1205:     source_of(self) .has_prefix. "CHECK_ARGUMENTS"
  // 1206:     -> between(source_of(self) '(' ')')
  // 1207:     -> -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = func__compiler__c_body__to_c_18;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_20;
}
static void entry__compiler__c_body__to_c_15(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1206: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_16;
}
static void cont__compiler__c_body__to_c_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1206: ... between(source_of(self) '(' ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__40;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__between();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_17;
}
static void cont__compiler__c_body__to_c_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1206: -> between(source_of(self) '(' ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__c_body__to_c_18(void) {
  allocate_initialized_frame_gc(0, 1);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1207: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_19;
}
static void cont__compiler__c_body__to_c_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 1207: -> -1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_body__to_c_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* par_count */, arguments->slots[0]);
  // 1209: ... "
  // 1210:   static void entry@(body_suffix)(void);
  // 1211:   static NODE *func@(body_suffix);
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__7b01aef649fee96f;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__c1009742fcdd65b8;
  arguments->slots[3] = frame->slots[1] /* body_suffix */;
  arguments->slots[4] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_23;
}
static void cont__compiler__c_body__to_c_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1209: write_to_declarations "
  // 1210:   static void entry@(body_suffix)(void);
  // 1211:   static NODE *func@(body_suffix);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_24;
}
static void cont__compiler__c_body__to_c_24(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1212: ... continuation_info.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* continuation_info */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_25;
}
static void cont__compiler__c_body__to_c_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1212: ... :
  // 1213:   write_to_continuation_table
  // 1214:     "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__c_body__to_c_26, 0);
  // 1212: if continuation_info.is_defined:
  // 1213:   write_to_continuation_table
  // 1214:     "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_30;
}
static void entry__compiler__c_body__to_c_26(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // body_suffix: 0
  // continuation_info: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* body_suffix */
  frame->slots[1] = myself->closure.frame->slots[2]; /* continuation_info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1214: "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__7394a8db8445c859;
  arguments->slots[1] = frame->slots[0] /* body_suffix */;
  arguments->slots[2] = string__3794a6c106b6c980;
  arguments->slots[3] = ((CELL *)frame->slots[1])->contents /* continuation_info */;
  arguments->slots[4] = string__fa727015f496bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_29;
}
static void cont__compiler__c_body__to_c_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1213: write_to_continuation_table
  // 1214:   "  {entry@(body_suffix), NULL, @(continuation_info)},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__c_body__to_c_30(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1217: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_31;
}
static void cont__compiler__c_body__to_c_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1217: ... source_of(self).converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_32;
}
static void cont__compiler__c_body__to_c_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1217: ... indented(2 source_of(self).converted)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_33;
}
static void cont__compiler__c_body__to_c_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1215: ... "
  // 1216:   static void entry@(body_suffix)(void) {
  // 1217:   @(indented(2 source_of(self).converted))@nl;}
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__7b01aef649fee96f;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__fc8c36a84adb366f;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  arguments->slots[4] = string__fa73ac15dc16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_35;
}
static void cont__compiler__c_body__to_c_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1215: write "
  // 1216:   static void entry@(body_suffix)(void) {
  // 1217:   @(indented(2 source_of(self).converted))@nl;}
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_36;
}
static void cont__compiler__c_body__to_c_36(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1218: ... "
  // 1219:   @
  // 1220:     func@(body_suffix) = create_function(entry@(body_suffix), @(par_count)@
  // 1221:   );@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__541f532081ce52b4;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  arguments->slots[2] = string__86eff1a866fd255c;
  arguments->slots[3] = frame->slots[1] /* body_suffix */;
  arguments->slots[4] = string__2d7981f4e6682be5;
  arguments->slots[5] = frame->slots[3] /* par_count */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_body__to_c_37;
}
static void cont__compiler__c_body__to_c_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1218: write_to_phase_2 "
  // 1219:   @
  // 1220:     func@(body_suffix) = create_function(entry@(body_suffix), @(par_count)@
  // 1221:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__c_body___to_c_38(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1222: ... "func@(body_suffix)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__e0aec0b5d107d5a;
  arguments->slots[1] = frame->slots[1] /* body_suffix */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_body___to_c_39;
}
static void cont__compiler__c_body___to_c_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1222: -> "func@(body_suffix)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__extract_destination(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // destination: 0
  // identifier: 1
  frame->slots[1] /* identifier */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1227: $identifier identifier_of(destination)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__extract_destination_2;
}
static void cont__extract_destination_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* identifier */, arguments->slots[0]);
  // 1228: ... namespace_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__extract_destination_3;
}
static void cont__extract_destination_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1228: ... name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__extract_destination_4;
}
static void cont__extract_destination_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1228: ... mangled_name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__extract_destination_5;
}
static void cont__extract_destination_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1228: -> namespace_of(identifier) name_of(identifier) mangled_name_of(identifier)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__is_single_assign(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // expr: 0
  // return: 1
  // info: 2
  frame->slots[1] /* return */ = create_continuation();
  frame->slots[2] /* info */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1235: ... expr.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_2;
}
static void cont__compiler__is_single_assign_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1235: ... not(expr.is_a_temporary)
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__is_single_assign_3, 0);
  // 1235: ... expr.is_an_identifier && not(expr.is_a_temporary)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_6;
}
static void entry__compiler__is_single_assign_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1235: ... expr.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_4;
}
static void cont__compiler__is_single_assign_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1235: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_5;
}
static void cont__compiler__is_single_assign_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1235: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__is_single_assign_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1235: ... : return false
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__is_single_assign_7, 0);
  // 1235: unless expr.is_an_identifier && not(expr.is_a_temporary): return false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_8;
}
static void entry__compiler__is_single_assign_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1235: ... return false
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__false();
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__is_single_assign_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1239: namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_9;
}
static void cont__compiler__is_single_assign_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1239: namespace_of(expr).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_10;
}
static void cont__compiler__is_single_assign_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1239: ... :
  // 1240:   $namespaces exported_names(name_of(expr))
  // 1241:   ->
  // 1242:     if
  // 1243:       namespaces.is_defined
  // 1244:       -> namespaces(namespace_of(expr))
  // 1245:       -> undefined
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__is_single_assign_11, 0);
  // 1246: -> global_names(name_of(expr))
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__is_single_assign_20, 0);
  // 1237: $info
  // 1238:   if
  // 1239:     namespace_of(expr).is_defined:
  // 1240:       $namespaces exported_names(name_of(expr))
  // 1241:       ->
  // 1242:         if
  // 1243:           namespaces.is_defined
  // 1244:           -> namespaces(namespace_of(expr))
  // 1245:           -> undefined
  // 1246:     -> global_names(name_of(expr))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_23;
}
static void entry__compiler__is_single_assign_11(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  // namespaces: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  frame->slots[1] /* namespaces */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1240: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_12;
}
static void cont__compiler__is_single_assign_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1240: $namespaces exported_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_13;
}
static void cont__compiler__is_single_assign_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* namespaces */, arguments->slots[0]);
  // 1243: namespaces.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* namespaces */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_14;
}
static void cont__compiler__is_single_assign_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1244: -> namespaces(namespace_of(expr))
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__is_single_assign_15, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = func__compiler__is_single_assign_18;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_19;
}
static void entry__compiler__is_single_assign_15(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // namespaces: 0
  // expr: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* namespaces */
  frame->slots[1] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1244: ... namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_16;
}
static void cont__compiler__is_single_assign_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1244: ... namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[0] /* namespaces */;
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_17;
}
static void cont__compiler__is_single_assign_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1244: -> namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__is_single_assign_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1245: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__is_single_assign_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1241: ->
  // 1242:   if
  // 1243:     namespaces.is_defined
  // 1244:     -> namespaces(namespace_of(expr))
  // 1245:     -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__is_single_assign_20(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1246: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_21;
}
static void cont__compiler__is_single_assign_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1246: ... global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_22;
}
static void cont__compiler__is_single_assign_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1246: -> global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__is_single_assign_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* info */, arguments->slots[0]);
  // 1248: ... info.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* info */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_24;
}
static void cont__compiler__is_single_assign_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1248: ... info.is_a_single_assign_definition
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__is_single_assign_25, 0);
  // 1248: ... info.is_defined && info.is_a_single_assign_definition
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_27;
}
static void entry__compiler__is_single_assign_25(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // info: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* info */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1248: ... info.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* info */;
  result_count = 1;
  myself = get__is_a_single_assign_definition();
  func = myself->type;
  frame->cont = cont__compiler__is_single_assign_26;
}
static void cont__compiler__is_single_assign_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1248: ... info.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__is_single_assign_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1248: -> info.is_defined && info.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__might_be_constant(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // expr: 0
  // return: 1
  // info: 2
  frame->slots[1] /* return */ = create_continuation();
  frame->slots[2] /* info */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1255: ... expr.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_2;
}
static void cont__compiler__might_be_constant_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1255: ... not(expr.is_a_temporary)
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__might_be_constant_3, 0);
  // 1255: ... expr.is_an_identifier && not(expr.is_a_temporary)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_6;
}
static void entry__compiler__might_be_constant_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1255: ... expr.is_a_temporary
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_temporary();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_4;
}
static void cont__compiler__might_be_constant_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1255: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_5;
}
static void cont__compiler__might_be_constant_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1255: ... not(expr.is_a_temporary)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__might_be_constant_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1255: ... : return false
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__might_be_constant_7, 0);
  // 1255: unless expr.is_an_identifier && not(expr.is_a_temporary): return false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_8;
}
static void entry__compiler__might_be_constant_7(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1255: ... return false
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__false();
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__might_be_constant_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1259: namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_9;
}
static void cont__compiler__might_be_constant_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1259: namespace_of(expr).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_10;
}
static void cont__compiler__might_be_constant_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1259: ... :
  // 1260:   $namespaces exported_names(name_of(expr))
  // 1261:   ->
  // 1262:     if
  // 1263:       namespaces.is_defined
  // 1264:       -> namespaces(namespace_of(expr))
  // 1265:       -> undefined
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__might_be_constant_11, 0);
  // 1266: -> global_names(name_of(expr))
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__might_be_constant_20, 0);
  // 1257: $info
  // 1258:   if
  // 1259:     namespace_of(expr).is_defined:
  // 1260:       $namespaces exported_names(name_of(expr))
  // 1261:       ->
  // 1262:         if
  // 1263:           namespaces.is_defined
  // 1264:           -> namespaces(namespace_of(expr))
  // 1265:           -> undefined
  // 1266:     -> global_names(name_of(expr))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_23;
}
static void entry__compiler__might_be_constant_11(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  // namespaces: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  frame->slots[1] /* namespaces */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1260: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_12;
}
static void cont__compiler__might_be_constant_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1260: $namespaces exported_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__exported_names();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_13;
}
static void cont__compiler__might_be_constant_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* namespaces */, arguments->slots[0]);
  // 1263: namespaces.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* namespaces */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_14;
}
static void cont__compiler__might_be_constant_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1264: -> namespaces(namespace_of(expr))
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__might_be_constant_15, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = func__compiler__might_be_constant_18;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_19;
}
static void entry__compiler__might_be_constant_15(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // namespaces: 0
  // expr: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* namespaces */
  frame->slots[1] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1264: ... namespace_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* expr */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_16;
}
static void cont__compiler__might_be_constant_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1264: ... namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[0] /* namespaces */;
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_17;
}
static void cont__compiler__might_be_constant_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1264: -> namespaces(namespace_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__might_be_constant_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1265: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__might_be_constant_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1261: ->
  // 1262:   if
  // 1263:     namespaces.is_defined
  // 1264:     -> namespaces(namespace_of(expr))
  // 1265:     -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__might_be_constant_20(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1266: ... name_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_21;
}
static void cont__compiler__might_be_constant_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1266: ... global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__global_names();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_22;
}
static void cont__compiler__might_be_constant_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1266: -> global_names(name_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__might_be_constant_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* info */, arguments->slots[0]);
  // 1268: ... info.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* info */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__compiler__might_be_constant_24;
}
static void cont__compiler__might_be_constant_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1268: -> info.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__assign_12(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // dest: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* dest */
  frame->slots[1] = myself->closure.frame->slots[0]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1277: ... "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__7d5cf5d8cf0f5f69;
  arguments->slots[1] = frame->slots[0] /* dest */;
  arguments->slots[2] = string__2d7981f4e6682be5;
  arguments->slots[3] = frame->slots[1] /* src */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_14;
}
static void cont__assign_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1277: write_to_phase_3 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign_6(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // dest: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* dest */
  frame->slots[1] = myself->closure.frame->slots[0]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1273: ... "  assign_variable(&@(dest), &@(src));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__468aa0a9b0dabd58;
  arguments->slots[1] = frame->slots[0] /* dest */;
  arguments->slots[2] = string__fa733415f296bea;
  arguments->slots[3] = frame->slots[1] /* src */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_9;
}
static void cont__assign_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1273: write_to_phase_5 "  assign_variable(&@(dest), &@(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign_2(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // src: 0
  // dest: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  frame->slots[1] = myself->closure.frame->slots[0]; /* dest */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1272: ... alt("var." "func__")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2e0ae90b5df07d17;
  arguments->slots[1] = string__441f568380430288;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__assign_4;
}
static void cont__assign_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1272: ... src .has_prefix. alt("var." "func__")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* src */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__assign_5;
}
static void cont__assign_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1272: ... :
  // 1273:   write_to_phase_5 "  assign_variable(&@(dest), &@(src));@nl;"
  frame->slots[4] /* temp__3 */ = create_closure(entry__assign_6, 0);
  // 1272: -> src .has_prefix. alt("var." "func__"):
  // 1273:   write_to_phase_5 "  assign_variable(&@(dest), &@(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__assign_10(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // src: 0
  // dest: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* src */
  frame->slots[1] = myself->closure.frame->slots[0]; /* dest */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1274: ... src .has_prefix. "unique__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* src */;
  arguments->slots[1] = string__44acac92852c82df;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__assign_11;
}
static void cont__assign_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1274: ... :
  // 1275:   # was originally assigned in phase 5, but in some cases this is to late
  // 1276:   
  // 1277:   write_to_phase_3 "  assign_value(&@(dest), @(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__assign_12, 0);
  // 1274: -> src .has_prefix. "unique__":
  // 1275:   # was originally assigned in phase 5, but in some cases this is to late
  // 1276:   
  // 1277:   write_to_phase_3 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__assign_15(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // dest: 0
  // src: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* dest */
  frame->slots[1] = myself->closure.frame->slots[1]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1279: ... "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__7d5cf5d8cf0f5f69;
  arguments->slots[1] = frame->slots[0] /* dest */;
  arguments->slots[2] = string__2d7981f4e6682be5;
  arguments->slots[3] = frame->slots[1] /* src */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_16;
}
static void cont__assign_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1279: write_to_phase_5 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // dest: 0
  // src: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1272: -> src .has_prefix. alt("var." "func__"):
  // 1273:   write_to_phase_5 "  assign_variable(&@(dest), &@(src));@nl;"
  frame->slots[2] /* temp__1 */ = create_closure(entry__assign_2, 0);
  // 1274: -> src .has_prefix. "unique__":
  // 1275:   # was originally assigned in phase 5, but in some cases this is to late
  // 1276:   
  // 1277:   write_to_phase_3 "  assign_value(&@(dest), @(src));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__assign_10, 0);
  // 1278: :
  // 1279:   write_to_phase_5 "  assign_value(&@(dest), @(src));@nl;"
  frame->slots[4] /* temp__3 */ = create_closure(entry__assign_15, 0);
  // 1271: cond
  // 1272:   -> src .has_prefix. alt("var." "func__"):
  // 1273:     write_to_phase_5 "  assign_variable(&@(dest), &@(src));@nl;"
  // 1274:   -> src .has_prefix. "unique__":
  // 1275:     # was originally assigned in phase 5, but in some cases this is to late
  // 1276:     
  // 1277:     write_to_phase_3 "  assign_value(&@(dest), @(src));@nl;"
  // 1278:   :
  // 1279:     write_to_phase_5 "  assign_value(&@(dest), @(src));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_129(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1435: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_130;
}
static void cont__compiler__define_variable_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1432: ... "
  // 1433:   @
  // 1434:     maybe_initialize_future(get__@(mangled_name)(), @
  // 1435:   @(source.to_c));@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__2690e3d8e7540abd;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__920afb0b5f007d19;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_133;
}
static void cont__compiler__define_variable_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1432: write_to_phase_5 "
  // 1433:   @
  // 1434:     maybe_initialize_future(get__@(mangled_name)(), @
  // 1435:   @(source.to_c));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_134(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1439: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_135;
}
static void cont__compiler__define_variable_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1437: ... "
  // 1438:   @
  // 1439:     initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // 1440:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__55defe7d73d85409;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__920afb0b5f007d19;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_137;
}
static void cont__compiler__define_variable_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1437: write_to_phase_5 "
  // 1438:   @
  // 1439:     initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // 1440:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_125(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1427: ... "
  // 1428:   @
  // 1429:     define__@(mangled_name)(create_future());
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__29721158e7d3e55e;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__8275ab8967245782;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_126;
}
static void cont__compiler__define_variable_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1427: write_to_phase_3 "
  // 1428:   @
  // 1429:     define__@(mangled_name)(create_future());
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_127;
}
static void cont__compiler__define_variable_127(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1431: source.might_be_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__might_be_constant();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_128;
}
static void cont__compiler__define_variable_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1431: ... :
  // 1432:   write_to_phase_5 "
  // 1433:     @
  // 1434:       maybe_initialize_future(get__@(mangled_name)(), @
  // 1435:     @(source.to_c));@nl;@
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__define_variable_129, 0);
  // 1436: :
  // 1437:   write_to_phase_5 "
  // 1438:     @
  // 1439:       initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // 1440:     );@nl;@
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__define_variable_134, 0);
  // 1430: if
  // 1431:   source.might_be_constant:
  // 1432:     write_to_phase_5 "
  // 1433:       @
  // 1434:         maybe_initialize_future(get__@(mangled_name)(), @
  // 1435:       @(source.to_c));@nl;@
  // 1436:   :
  // 1437:     write_to_phase_5 "
  // 1438:       @
  // 1439:         initialize_future(get__@(mangled_name)(), @(source.to_c)@
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_120(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1424: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_121;
}
static void cont__compiler__define_variable_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1424: ... "  define__@(mangled_name)(@(source.to_c));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__29721158e7d3e55e;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__578a5af303e9cc9;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_122;
}
static void cont__compiler__define_variable_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1424: write_to_phase_5 "  define__@(mangled_name)(@(source.to_c));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_123(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // source: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* source */
  frame->slots[1] = myself->closure.frame->slots[1]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1426: ... source.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_124;
}
static void cont__compiler__define_variable_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1426: ... :
  // 1427:   write_to_phase_3 "
  // 1428:     @
  // 1429:       define__@(mangled_name)(create_future());
  // 1430:   if
  // 1431:     source.might_be_constant:
  // 1432:       write_to_phase_5 "
  // 1433:         @
  // 1434:           maybe_initialize_future(get__@(mangled_name)(), @
  // 1435:         @(source.to_c));@nl;@
  // ...
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__define_variable_125, 0);
  // 1426: if source.is_an_identifier:
  // 1427:   write_to_phase_3 "
  // 1428:     @
  // 1429:       define__@(mangled_name)(create_future());
  // 1430:   if
  // 1431:     source.might_be_constant:
  // 1432:       write_to_phase_5 "
  // 1433:         @
  // 1434:           maybe_initialize_future(get__@(mangled_name)(), @
  // 1435:         @(source.to_c));@nl;@
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_118(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // source: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* source */
  frame->slots[1] = myself->closure.frame->slots[5]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1423: source.is_a_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_constant();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_119;
}
static void cont__compiler__define_variable_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1423: ... :
  // 1424:   write_to_phase_5 "  define__@(mangled_name)(@(source.to_c));@nl;"
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__define_variable_120, 0);
  // 1425: :
  // 1426:   if source.is_an_identifier:
  // 1427:     write_to_phase_3 "
  // 1428:       @
  // 1429:         define__@(mangled_name)(create_future());
  // 1430:     if
  // 1431:       source.might_be_constant:
  // 1432:         write_to_phase_5 "
  // 1433:           @
  // 1434:             maybe_initialize_future(get__@(mangled_name)(), @
  // ...
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__define_variable_123, 0);
  // 1422: if
  // 1423:   source.is_a_constant:
  // 1424:     write_to_phase_5 "  define__@(mangled_name)(@(source.to_c));@nl;"
  // 1425:   :
  // 1426:     if source.is_an_identifier:
  // 1427:       write_to_phase_3 "
  // 1428:         @
  // 1429:           define__@(mangled_name)(create_future());
  // 1430:       if
  // 1431:         source.might_be_constant:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable(void) {
  allocate_initialized_frame_gc(3, 11);
  // slot allocations:
  // definition: 0
  // source: 1
  // is_a_prototype: 2
  // namespace: 3
  // name: 4
  // mangled_name: 5
  // kind: 6
  frame->slots[3] /* namespace */ = create_future();
  frame->slots[4] /* name */ = create_future();
  frame->slots[5] /* mangled_name */ = create_future();
  frame->slots[6] /* kind */ = create_future();
  if (argument_count != 3) {
    invalid_arguments_error();
    return;
  }
  // 1282: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = func__extract_destination;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_2;
}
static void cont__compiler__define_variable_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* namespace */, arguments->slots[0]);
  initialize_future(frame->slots[4] /* name */, arguments->slots[1]);
  initialize_future(frame->slots[5] /* mangled_name */, arguments->slots[2]);
  // 1283: ... definition.is_a_static_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_a_static_definition();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_3;
}
static void cont__compiler__define_variable_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1283: ... :
  // 1284:   write_to_generated_collections "
  // 1285:     @
  // 1286:       @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1287:     );@nl;@
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__define_variable_4, 0);
  // 1283: if definition.is_a_static_definition:
  // 1284:   write_to_generated_collections "
  // 1285:     @
  // 1286:       @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1287:     );@nl;@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_9;
}
static void entry__compiler__define_variable_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1286: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_5;
}
static void cont__compiler__define_variable_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1286: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_6;
}
static void cont__compiler__define_variable_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1284: ... "
  // 1285:   @
  // 1286:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1287:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__29d4ac87c65f0ce6;
  arguments->slots[3] = frame->slots[3] /* temp__3 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_8;
}
static void cont__compiler__define_variable_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1284: write_to_generated_collections "
  // 1285:   @
  // 1286:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1287:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_variable_9(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1288: $kind variable_kind_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__variable_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_10;
}
static void cont__compiler__define_variable_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* kind */, arguments->slots[0]);
  // 1289: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_11;
}
static void cont__compiler__define_variable_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1289: ... kind == STATIC_SINGLE
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_variable_12, 0);
  // 1289: ... source.is_defined && kind == STATIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_14;
}
static void entry__compiler__define_variable_12(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1289: ... kind == STATIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__STATIC_SINGLE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_13;
}
static void cont__compiler__define_variable_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1289: ... kind == STATIC_SINGLE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_variable_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1289: ... :
  // 1290:   if
  // 1291:     is_a_prototype:
  // 1292:       write_to_phase_3 "
  // 1293:         @
  // 1294:           @(var_entry(mangled_name)) = create_future();
  // 1295:       write_to_phase_5
  // 1296:         "  initialize_future(@(var_entry(mangled_name)), @(source.to_c));@nl;"
  // 1297:     :
  // 1298:       assign var_entry(mangled_name) source.to_c
  // ...
  frame->slots[10] /* temp__4 */ = create_closure(entry__compiler__define_variable_15, 0);
  // 1289: if source.is_defined && kind == STATIC_SINGLE:
  // 1290:   if
  // 1291:     is_a_prototype:
  // 1292:       write_to_phase_3 "
  // 1293:         @
  // 1294:           @(var_entry(mangled_name)) = create_future();
  // 1295:       write_to_phase_5
  // 1296:         "  initialize_future(@(var_entry(mangled_name)), @(source.to_c));@nl;"
  // 1297:     :
  // 1298:       assign var_entry(mangled_name) source.to_c
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_28;
}
static void entry__compiler__define_variable_16(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1294: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_17;
}
static void cont__compiler__define_variable_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1292: ... "
  // 1293:   @
  // 1294:     @(var_entry(mangled_name)) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__dc0dbf3dca1e95fd;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_19;
}
static void cont__compiler__define_variable_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1292: write_to_phase_3 "
  // 1293:   @
  // 1294:     @(var_entry(mangled_name)) = create_future();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_20;
}
static void cont__compiler__define_variable_20(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1296: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_21;
}
static void cont__compiler__define_variable_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1296: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_22;
}
static void cont__compiler__define_variable_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1296: "  initialize_future(@(var_entry(mangled_name)), @(source.to_c));@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__e24c48ad3fbdc6fa;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6682be5;
  arguments->slots[3] = frame->slots[4] /* temp__3 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_24;
}
static void cont__compiler__define_variable_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1295: write_to_phase_5
  // 1296:   "  initialize_future(@(var_entry(mangled_name)), @(source.to_c));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_25(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1298: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_26;
}
static void cont__compiler__define_variable_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1298: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_27;
}
static void cont__compiler__define_variable_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1298: assign var_entry(mangled_name) source.to_c
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = func__assign;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_15(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // is_a_prototype: 0
  // mangled_name: 1
  // source: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* is_a_prototype */
  frame->slots[1] = myself->closure.frame->slots[5]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1291: ... :
  // 1292:   write_to_phase_3 "
  // 1293:     @
  // 1294:       @(var_entry(mangled_name)) = create_future();
  // 1295:   write_to_phase_5
  // 1296:     "  initialize_future(@(var_entry(mangled_name)), @(source.to_c));@nl;"
  frame->slots[3] /* temp__1 */ = create_closure(entry__compiler__define_variable_16, 0);
  // 1297: :
  // 1298:   assign var_entry(mangled_name) source.to_c
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__define_variable_25, 0);
  // 1290: if
  // 1291:   is_a_prototype:
  // 1292:     write_to_phase_3 "
  // 1293:       @
  // 1294:         @(var_entry(mangled_name)) = create_future();
  // 1295:     write_to_phase_5
  // 1296:       "  initialize_future(@(var_entry(mangled_name)), @(source.to_c));@nl;"
  // 1297:   :
  // 1298:     assign var_entry(mangled_name) source.to_c
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* is_a_prototype */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_variable_28(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1318: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_29;
}
static void cont__compiler__define_variable_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1318: ... :
  // 1319:   case kind
  // 1320:     STATIC_SINGLE:
  // 1321:       write_to_global_variable_declarations
  // 1322:         string("  NODE *" mangled_name ";@nl;")
  // 1323:       write_to_declarations "
  // 1324:         static NODE *get__@(namespace)__@(name)(void) {
  // 1325:           return var.@(namespace)__@(name);
  // 1326:         }
  // 1327:       write_to_phase_3 "
  // ...
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__define_variable_30, 0);
  // 1377: :
  // 1378:   case kind
  // 1379:     STATIC_SINGLE:
  // 1380:       write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1381:       write_to_top_level_variable_declarations
  // 1382:         string("  NODE *" var_name(mangled_name) ";@nl;")
  // 1383:       unless source.is_defined:
  // 1384:         write_to_phase_3 "
  // 1385:           @
  // 1386:             @(var_entry(name)) = create_future();
  // ...
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_variable_80, 0);
  // 1317: if
  // 1318:   namespace.is_defined:
  // 1319:     case kind
  // 1320:       STATIC_SINGLE:
  // 1321:         write_to_global_variable_declarations
  // 1322:           string("  NODE *" mangled_name ";@nl;")
  // 1323:         write_to_declarations "
  // 1324:           static NODE *get__@(namespace)__@(name)(void) {
  // 1325:             return var.@(namespace)__@(name);
  // 1326:           }
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_113;
}
static void entry__compiler__define_variable_105(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1402: ... "
  // 1403:   @
  // 1404:     define__@(name)(create_future());
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__29721158e7d3e55e;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__8275ab8967245782;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_108;
}
static void cont__compiler__define_variable_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1402: write_to_phase_3 "
  // 1403:   @
  // 1404:     define__@(name)(create_future());
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_90(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1386: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_91;
}
static void cont__compiler__define_variable_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1384: ... "
  // 1385:   @
  // 1386:     @(var_entry(name)) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__dc0dbf3dca1e95fd;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_92;
}
static void cont__compiler__define_variable_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1384: write_to_phase_3 "
  // 1385:   @
  // 1386:     @(var_entry(name)) = create_future();
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_81(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1380: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__fa730415f296bee;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__fa730c15f496bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_84;
}
static void cont__compiler__define_variable_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1380: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_85;
}
static void cont__compiler__define_variable_85(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1382: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_name;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_86;
}
static void cont__compiler__define_variable_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1382: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_87;
}
static void cont__compiler__define_variable_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1381: write_to_top_level_variable_declarations
  // 1382:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_88;
}
static void cont__compiler__define_variable_88(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1383: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_89;
}
static void cont__compiler__define_variable_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1383: ... :
  // 1384:   write_to_phase_3 "
  // 1385:     @
  // 1386:       @(var_entry(name)) = create_future();
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__define_variable_90, 0);
  // 1383: unless source.is_defined:
  // 1384:   write_to_phase_3 "
  // 1385:     @
  // 1386:       @(var_entry(name)) = create_future();
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_93(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1388: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__fa730415f296bee;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__fa730c15f496bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_94;
}
static void cont__compiler__define_variable_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1388: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_95;
}
static void cont__compiler__define_variable_95(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1390: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_name;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_96;
}
static void cont__compiler__define_variable_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1390: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_97;
}
static void cont__compiler__define_variable_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1389: write_to_top_level_variable_declarations
  // 1390:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_98(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1392: ... "
  // 1393:   static int dyna_idx__@(name);
  // 1394:   static NODE *get__@(name)(void) {
  // 1395:     return get_dynamic_slot(dyna_idx__@(name));
  // 1396:   }
  // 1397:   static void define__@(name)(NODE *node) {
  // 1398:     define_dynamic_slot(dyna_idx__@(name), node);
  // 1399:   }
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__dd395a997055f7fe;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__34fd7239574f514;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__70ebfdeaadefaa37;
  arguments->slots[5] = frame->slots[0] /* name */;
  arguments->slots[6] = string__5226770621835bc8;
  arguments->slots[7] = frame->slots[0] /* name */;
  arguments->slots[8] = string__473bf089a0140715;
  arguments->slots[9] = frame->slots[0] /* name */;
  arguments->slots[10] = string__36cf2bd921e53ad9;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_99;
}
static void cont__compiler__define_variable_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1392: write_to_declarations "
  // 1393:   static int dyna_idx__@(name);
  // 1394:   static NODE *get__@(name)(void) {
  // 1395:     return get_dynamic_slot(dyna_idx__@(name));
  // 1396:   }
  // 1397:   static void define__@(name)(NODE *node) {
  // 1398:     define_dynamic_slot(dyna_idx__@(name), node);
  // 1399:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_100;
}
static void cont__compiler__define_variable_100(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1400: ... "  register_dynamic(&dyna_idx__@(name));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__4c5ea74244cf1425;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_102;
}
static void cont__compiler__define_variable_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1400: write_to_phase_3 "  register_dynamic(&dyna_idx__@(name));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_103;
}
static void cont__compiler__define_variable_103(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1401: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_104;
}
static void cont__compiler__define_variable_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1401: ... :
  // 1402:   write_to_phase_3 "
  // 1403:     @
  // 1404:       define__@(name)(create_future());
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__define_variable_105, 0);
  // 1401: unless source.is_defined:
  // 1402:   write_to_phase_3 "
  // 1403:     @
  // 1404:       define__@(name)(create_future());
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_109(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1406: ... "
  // 1407:   static int dyna_idx__@(name);
  // 1408:   static NODE *get__@(name)(void) {
  // 1409:     return get_dynamic_cell(dyna_idx__@(name));
  // 1410:   }
  // 1411:   static void set__@(name)(NODE *node) {
  // 1412:     set_dynamic_cell(dyna_idx__@(name), node);
  // 1413:   }
  // 1414:   static void define__@(name)(NODE *node) {
  // 1415:     define_dynamic_cell(dyna_idx__@(name), node);
  // ...
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__dd395a997055f7fe;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__34fd7239574f514;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__746bfddaaddfea37;
  arguments->slots[5] = frame->slots[0] /* name */;
  arguments->slots[6] = string__13372791bc1cbb98;
  arguments->slots[7] = frame->slots[0] /* name */;
  arguments->slots[8] = string__8224dc1c3f83e7f2;
  arguments->slots[9] = frame->slots[0] /* name */;
  arguments->slots[10] = string__1e8f2aa38d3f4060;
  arguments->slots[11] = frame->slots[0] /* name */;
  arguments->slots[12] = string__43bbf0b9a0244715;
  arguments->slots[13] = frame->slots[0] /* name */;
  arguments->slots[14] = string__36cf2bd921e53ad9;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_110;
}
static void cont__compiler__define_variable_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1406: write_to_declarations "
  // 1407:   static int dyna_idx__@(name);
  // 1408:   static NODE *get__@(name)(void) {
  // 1409:     return get_dynamic_cell(dyna_idx__@(name));
  // 1410:   }
  // 1411:   static void set__@(name)(NODE *node) {
  // 1412:     set_dynamic_cell(dyna_idx__@(name), node);
  // 1413:   }
  // 1414:   static void define__@(name)(NODE *node) {
  // 1415:     define_dynamic_cell(dyna_idx__@(name), node);
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_111;
}
static void cont__compiler__define_variable_111(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1417: ... "
  // 1418:   @
  // 1419:     register_dynamic(&dyna_idx__@(name));
  // 1420:     define__@(name)(undefined);
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__4c5ea74244cf1425;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = string__5e7cd5f37502c62e;
  arguments->slots[3] = frame->slots[0] /* name */;
  arguments->slots[4] = string__4a4ee6e733be0622;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_112;
}
static void cont__compiler__define_variable_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1417: write_to_phase_3 "
  // 1418:   @
  // 1419:     register_dynamic(&dyna_idx__@(name));
  // 1420:     define__@(name)(undefined);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_31(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1322: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_33;
}
static void cont__compiler__define_variable_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1321: write_to_global_variable_declarations
  // 1322:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_34;
}
static void cont__compiler__define_variable_34(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1323: ... "
  // 1324:   static NODE *get__@(namespace)__@(name)(void) {
  // 1325:     return var.@(namespace)__@(name);
  // 1326:   }
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__55b34e50e74b4c7c;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__2d7981f4e5f02b9a;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__5a35746c23f76309;
  arguments->slots[5] = frame->slots[1] /* namespace */;
  arguments->slots[6] = string__2d7981f4e5f02b9a;
  arguments->slots[7] = frame->slots[2] /* name */;
  arguments->slots[8] = string__b40af3cb5d887d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_37;
}
static void cont__compiler__define_variable_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1323: write_to_declarations "
  // 1324:   static NODE *get__@(namespace)__@(name)(void) {
  // 1325:     return var.@(namespace)__@(name);
  // 1326:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_38;
}
static void cont__compiler__define_variable_38(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1330: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_variable_39;
}
static void cont__compiler__define_variable_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1327: ... "
  // 1328:   @
  // 1329:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1330:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__b29ac022d5eddd84;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__860afa4b5f607d1b;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__65a4a8f6052de83f;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__fa733415f296bea;
  arguments->slots[7] = frame->slots[4] /* temp__2 */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_43;
}
static void cont__compiler__define_variable_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1327: write_to_phase_3 "
  // 1328:   @
  // 1329:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1330:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_44(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1333: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_45;
}
static void cont__compiler__define_variable_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1332: write_to_global_variable_declarations
  // 1333:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_46;
}
static void cont__compiler__define_variable_46(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1334: ... "
  // 1335:   static NODE *get__@(namespace)__@(name)(void) {
  // 1336:     return var.@(namespace)__@(name);
  // 1337:   }
  // 1338:   static void set__@(namespace)__@(name)(NODE *val) {
  // 1339:     var.@(namespace)__@(name) = val;
  // 1340:   }
  argument_count = 17;
  arguments = node_p;
  arguments->slots[0] = string__55b34e50e74b4c7c;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__2d7981f4e5f02b9a;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__5a35746c23f76309;
  arguments->slots[5] = frame->slots[1] /* namespace */;
  arguments->slots[6] = string__2d7981f4e5f02b9a;
  arguments->slots[7] = frame->slots[2] /* name */;
  arguments->slots[8] = string__51b735d4017b50ea;
  arguments->slots[9] = frame->slots[1] /* namespace */;
  arguments->slots[10] = string__2d7981f4e5f02b9a;
  arguments->slots[11] = frame->slots[2] /* name */;
  arguments->slots[12] = string__8454c532619bd34d;
  arguments->slots[13] = frame->slots[1] /* namespace */;
  arguments->slots[14] = string__2d7981f4e5f02b9a;
  arguments->slots[15] = frame->slots[2] /* name */;
  arguments->slots[16] = string__833e0a9b7bc3bd8b;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_50;
}
static void cont__compiler__define_variable_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1334: write_to_declarations "
  // 1335:   static NODE *get__@(namespace)__@(name)(void) {
  // 1336:     return var.@(namespace)__@(name);
  // 1337:   }
  // 1338:   static void set__@(namespace)__@(name)(NODE *val) {
  // 1339:     var.@(namespace)__@(name) = val;
  // 1340:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_51;
}
static void cont__compiler__define_variable_51(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1341: ... "
  // 1342:   @
  // 1343:     define_multi_assign_static("@(namespace)", "@(name)", @
  // 1344:   get__@(mangled_name), set__@(mangled_name));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__e8ada4deabe9f7ad;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__860afa4b5f607d1b;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__65a4a8f6052de83f;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__b93408f29443f0a5;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_54;
}
static void cont__compiler__define_variable_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1341: write_to_phase_3 "
  // 1342:   @
  // 1343:     define_multi_assign_static("@(namespace)", "@(name)", @
  // 1344:   get__@(mangled_name), set__@(mangled_name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_55(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1346: ... "
  // 1347:   static int dyna_idx__@(mangled_name);
  // 1348:   static NODE *get__@(mangled_name)(void) {
  // 1349:     return get_dynamic_slot(dyna_idx__@(mangled_name));
  // 1350:   }
  // 1351:   static void define__@(mangled_name)(NODE *node) {
  // 1352:     define_dynamic_slot(dyna_idx__@(mangled_name), node);
  // 1353:   }
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__dd395a997055f7fe;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__34fd7239574f514;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__70ebfdeaadefaa37;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__5226770621835bc8;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__473bf089a0140715;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__36cf2bd921e53ad9;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_62;
}
static void cont__compiler__define_variable_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1346: write_to_declarations "
  // 1347:   static int dyna_idx__@(mangled_name);
  // 1348:   static NODE *get__@(mangled_name)(void) {
  // 1349:     return get_dynamic_slot(dyna_idx__@(mangled_name));
  // 1350:   }
  // 1351:   static void define__@(mangled_name)(NODE *node) {
  // 1352:     define_dynamic_slot(dyna_idx__@(mangled_name), node);
  // 1353:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_63;
}
static void cont__compiler__define_variable_63(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1354: ... "
  // 1355:   @
  // 1356:     define_single_assign_dynamic("@(namespace)", "@(name)", @
  // 1357:   get__@(mangled_name), define__@(mangled_name), @
  // 1358:   &dyna_idx__@(mangled_name));
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__152abda47b75d554;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__860afa4b5f607d1b;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__65a4a8f6052de83f;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__29727158e7d3e55e;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__4a6ef2ffac34c765;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_67;
}
static void cont__compiler__define_variable_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1354: write_to_phase_3 "
  // 1355:   @
  // 1356:     define_single_assign_dynamic("@(namespace)", "@(name)", @
  // 1357:   get__@(mangled_name), define__@(mangled_name), @
  // 1358:   &dyna_idx__@(mangled_name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_68(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // mangled_name: 0
  // namespace: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1360: ... "
  // 1361:   static int dyna_idx__@(mangled_name);
  // 1362:   static NODE *get__@(mangled_name)(void) {
  // 1363:     return get_dynamic_cell(dyna_idx__@(mangled_name));
  // 1364:   }
  // 1365:   static void set__@(mangled_name)(NODE *node) {
  // 1366:     set_dynamic_cell(dyna_idx__@(mangled_name), node);
  // 1367:   }
  // 1368:   static void define__@(mangled_name)(NODE *node) {
  // 1369:     define_dynamic_cell(dyna_idx__@(mangled_name), node);
  // ...
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__dd395a997055f7fe;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__34fd7239574f514;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__746bfddaaddfea37;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__13372791bc1cbb98;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__8224dc1c3f83e7f2;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__1e8f2aa38d3f4060;
  arguments->slots[11] = frame->slots[0] /* mangled_name */;
  arguments->slots[12] = string__43bbf0b9a0244715;
  arguments->slots[13] = frame->slots[0] /* mangled_name */;
  arguments->slots[14] = string__36cf2bd921e53ad9;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_74;
}
static void cont__compiler__define_variable_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1360: write_to_declarations "
  // 1361:   static int dyna_idx__@(mangled_name);
  // 1362:   static NODE *get__@(mangled_name)(void) {
  // 1363:     return get_dynamic_cell(dyna_idx__@(mangled_name));
  // 1364:   }
  // 1365:   static void set__@(mangled_name)(NODE *node) {
  // 1366:     set_dynamic_cell(dyna_idx__@(mangled_name), node);
  // 1367:   }
  // 1368:   static void define__@(mangled_name)(NODE *node) {
  // 1369:     define_dynamic_cell(dyna_idx__@(mangled_name), node);
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_75;
}
static void cont__compiler__define_variable_75(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1371: ... "
  // 1372:   @
  // 1373:     define_multi_assign_dynamic("@(namespace)", "@(name)", @
  // 1374:   get__@(mangled_name), set__@(mangled_name), define__@(mangled_name)@
  // 1375:   , &dyna_idx__@(mangled_name));
  // 1376:     define__@(mangled_name)(undefined);
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__32c94d852a3f04ef;
  arguments->slots[1] = frame->slots[1] /* namespace */;
  arguments->slots[2] = string__860afa4b5f607d1b;
  arguments->slots[3] = frame->slots[2] /* name */;
  arguments->slots[4] = string__65a4a8f6052de83f;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__b93408f29443f0a5;
  arguments->slots[7] = frame->slots[0] /* mangled_name */;
  arguments->slots[8] = string__29727158e7d3e55e;
  arguments->slots[9] = frame->slots[0] /* mangled_name */;
  arguments->slots[10] = string__4a6ef2ffac34c765;
  arguments->slots[11] = frame->slots[0] /* mangled_name */;
  arguments->slots[12] = string__5e7cd5f37502c62e;
  arguments->slots[13] = frame->slots[0] /* mangled_name */;
  arguments->slots[14] = string__4a4ee6e733be0622;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_79;
}
static void cont__compiler__define_variable_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1371: write_to_phase_3 "
  // 1372:   @
  // 1373:     define_multi_assign_dynamic("@(namespace)", "@(name)", @
  // 1374:   get__@(mangled_name), set__@(mangled_name), define__@(mangled_name)@
  // 1375:   , &dyna_idx__@(mangled_name));
  // 1376:     define__@(mangled_name)(undefined);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_30(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // kind: 0
  // mangled_name: 1
  // namespace: 2
  // name: 3
  frame->slots[0] = myself->closure.frame->slots[6]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[5]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[3]; /* namespace */
  frame->slots[3] = myself->closure.frame->slots[4]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1320: ... :
  // 1321:   write_to_global_variable_declarations
  // 1322:     string("  NODE *" mangled_name ";@nl;")
  // 1323:   write_to_declarations "
  // 1324:     static NODE *get__@(namespace)__@(name)(void) {
  // 1325:       return var.@(namespace)__@(name);
  // 1326:     }
  // 1327:   write_to_phase_3 "
  // 1328:     @
  // 1329:       define_single_assign_static("@(namespace)", "@(name)", @
  // ...
  frame->slots[4] /* temp__1 */ = create_closure(entry__compiler__define_variable_31, 0);
  // 1331: ... :
  // 1332:   write_to_global_variable_declarations
  // 1333:     string("  NODE *" mangled_name ";@nl;")
  // 1334:   write_to_declarations "
  // 1335:     static NODE *get__@(namespace)__@(name)(void) {
  // 1336:       return var.@(namespace)__@(name);
  // 1337:     }
  // 1338:     static void set__@(namespace)__@(name)(NODE *val) {
  // 1339:       var.@(namespace)__@(name) = val;
  // 1340:     }
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__define_variable_44, 0);
  // 1345: ... :
  // 1346:   write_to_declarations "
  // 1347:     static int dyna_idx__@(mangled_name);
  // 1348:     static NODE *get__@(mangled_name)(void) {
  // 1349:       return get_dynamic_slot(dyna_idx__@(mangled_name));
  // 1350:     }
  // 1351:     static void define__@(mangled_name)(NODE *node) {
  // 1352:       define_dynamic_slot(dyna_idx__@(mangled_name), node);
  // 1353:     }
  // 1354:   write_to_phase_3 "
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__define_variable_55, 0);
  // 1359: ... :
  // 1360:   write_to_declarations "
  // 1361:     static int dyna_idx__@(mangled_name);
  // 1362:     static NODE *get__@(mangled_name)(void) {
  // 1363:       return get_dynamic_cell(dyna_idx__@(mangled_name));
  // 1364:     }
  // 1365:     static void set__@(mangled_name)(NODE *node) {
  // 1366:       set_dynamic_cell(dyna_idx__@(mangled_name), node);
  // 1367:     }
  // 1368:     static void define__@(mangled_name)(NODE *node) {
  // ...
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__define_variable_68, 0);
  // 1319: case kind
  // 1320:   STATIC_SINGLE:
  // 1321:     write_to_global_variable_declarations
  // 1322:       string("  NODE *" mangled_name ";@nl;")
  // 1323:     write_to_declarations "
  // 1324:       static NODE *get__@(namespace)__@(name)(void) {
  // 1325:         return var.@(namespace)__@(name);
  // 1326:       }
  // 1327:     write_to_phase_3 "
  // 1328:       @
  // ...
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  arguments->slots[3] = get__STATIC_MULTI();
  arguments->slots[4] = frame->slots[5] /* temp__2 */;
  arguments->slots[5] = get__DYNAMIC_SINGLE();
  arguments->slots[6] = frame->slots[6] /* temp__3 */;
  arguments->slots[7] = get__DYNAMIC_MULTI();
  arguments->slots[8] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_variable_80(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // kind: 0
  // mangled_name: 1
  // source: 2
  // name: 3
  frame->slots[0] = myself->closure.frame->slots[6]; /* kind */
  frame->slots[1] = myself->closure.frame->slots[5]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[1]; /* source */
  frame->slots[3] = myself->closure.frame->slots[4]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1379: ... :
  // 1380:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1381:   write_to_top_level_variable_declarations
  // 1382:     string("  NODE *" var_name(mangled_name) ";@nl;")
  // 1383:   unless source.is_defined:
  // 1384:     write_to_phase_3 "
  // 1385:       @
  // 1386:         @(var_entry(name)) = create_future();
  frame->slots[4] /* temp__1 */ = create_closure(entry__compiler__define_variable_81, 0);
  // 1387: ... :
  // 1388:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1389:   write_to_top_level_variable_declarations
  // 1390:     string("  NODE *" var_name(mangled_name) ";@nl;")
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__define_variable_93, 0);
  // 1391: ... :
  // 1392:   write_to_declarations "
  // 1393:     static int dyna_idx__@(name);
  // 1394:     static NODE *get__@(name)(void) {
  // 1395:       return get_dynamic_slot(dyna_idx__@(name));
  // 1396:     }
  // 1397:     static void define__@(name)(NODE *node) {
  // 1398:       define_dynamic_slot(dyna_idx__@(name), node);
  // 1399:     }
  // 1400:   write_to_phase_3 "  register_dynamic(&dyna_idx__@(name));@nl;"
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__define_variable_98, 0);
  // 1405: ... :
  // 1406:   write_to_declarations "
  // 1407:     static int dyna_idx__@(name);
  // 1408:     static NODE *get__@(name)(void) {
  // 1409:       return get_dynamic_cell(dyna_idx__@(name));
  // 1410:     }
  // 1411:     static void set__@(name)(NODE *node) {
  // 1412:       set_dynamic_cell(dyna_idx__@(name), node);
  // 1413:     }
  // 1414:     static void define__@(name)(NODE *node) {
  // ...
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__define_variable_109, 0);
  // 1378: case kind
  // 1379:   STATIC_SINGLE:
  // 1380:     write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1381:     write_to_top_level_variable_declarations
  // 1382:       string("  NODE *" var_name(mangled_name) ";@nl;")
  // 1383:     unless source.is_defined:
  // 1384:       write_to_phase_3 "
  // 1385:         @
  // 1386:           @(var_entry(name)) = create_future();
  // 1387:   STATIC_MULTI:
  // ...
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__STATIC_SINGLE();
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  arguments->slots[3] = get__STATIC_MULTI();
  arguments->slots[4] = frame->slots[5] /* temp__2 */;
  arguments->slots[5] = get__DYNAMIC_SINGLE();
  arguments->slots[6] = frame->slots[6] /* temp__3 */;
  arguments->slots[7] = get__DYNAMIC_MULTI();
  arguments->slots[8] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_variable_113(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1421: ... source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_114;
}
static void cont__compiler__define_variable_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1421: ... kind == DYNAMIC_SINGLE
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_variable_115, 0);
  // 1421: ... source.is_defined && kind == DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_117;
}
static void entry__compiler__define_variable_115(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1421: ... kind == DYNAMIC_SINGLE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* kind */;
  arguments->slots[1] = get__DYNAMIC_SINGLE();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__define_variable_116;
}
static void cont__compiler__define_variable_116(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1421: ... kind == DYNAMIC_SINGLE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_variable_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1421: ... :
  // 1422:   if
  // 1423:     source.is_a_constant:
  // 1424:       write_to_phase_5 "  define__@(mangled_name)(@(source.to_c));@nl;"
  // 1425:     :
  // 1426:       if source.is_an_identifier:
  // 1427:         write_to_phase_3 "
  // 1428:           @
  // 1429:             define__@(mangled_name)(create_future());
  // 1430:         if
  // ...
  frame->slots[10] /* temp__4 */ = create_closure(entry__compiler__define_variable_118, 0);
  // 1421: if source.is_defined && kind == DYNAMIC_SINGLE:
  // 1422:   if
  // 1423:     source.is_a_constant:
  // 1424:       write_to_phase_5 "  define__@(mangled_name)(@(source.to_c));@nl;"
  // 1425:     :
  // 1426:       if source.is_an_identifier:
  // 1427:         write_to_phase_3 "
  // 1428:           @
  // 1429:             define__@(mangled_name)(create_future());
  // 1430:         if
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__namespace_argument_3(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // namespace: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* namespace */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1445: ... "@quot;@(namespace)@quot;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc3;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__578a5af303e9cc3;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__namespace_argument_4;
}
static void cont__namespace_argument_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1445: -> "@quot;@(namespace)@quot;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__namespace_argument_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1446: -> "NULL"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__5e0ae40b5c007d75;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__namespace_argument(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // namespace: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1444: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__namespace_argument_2;
}
static void cont__namespace_argument_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1445: -> "@quot;@(namespace)@quot;"
  frame->slots[2] /* temp__2 */ = create_closure(entry__namespace_argument_3, 0);
  // 1443: if
  // 1444:   namespace.is_defined
  // 1445:   -> "@quot;@(namespace)@quot;"
  // 1446:   -> "NULL"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = func__namespace_argument_5;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_attribute_18(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // attribute_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[3] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1466: ... namespace_argument(namespace)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = func__namespace_argument;
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_19;
}
static void cont__compiler__define_attribute_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1464: ... "
  // 1465:   @
  // 1466:     define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1467:   poly_idx__@(attribute_name), @(src));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__74e31c7f67a4e996;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__fa733415f296bee;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__ca0e521fba2cc724;
  arguments->slots[5] = frame->slots[2] /* attribute_name */;
  arguments->slots[6] = string__2d7981f4e6682be5;
  arguments->slots[7] = ((CELL *)frame->slots[3])->contents /* src */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_23;
}
static void cont__compiler__define_attribute_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1464: write_to_phase_4 "
  // 1465:   @
  // 1466:     define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1467:   poly_idx__@(attribute_name), @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_attribute_24(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // name: 0
  // attribute_name: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[2] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1472: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_25;
}
static void cont__compiler__define_attribute_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1469: ... "
  // 1470:   @
  // 1471:     update_start_p = node_p;
  // 1472:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1473:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__fccc671c88ddb4ed;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__82b9fe52d4649726;
  arguments->slots[3] = frame->slots[1] /* attribute_name */;
  arguments->slots[4] = string__23db4977718ddc08;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* src */;
  arguments->slots[6] = string__900afb0b5fb87d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_26;
}
static void cont__compiler__define_attribute_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1469: write_to_phase_4 "
  // 1470:   @
  // 1471:     update_start_p = node_p;
  // 1472:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1473:   MAKE_ATTRIBUTE_VALUE(@(src)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_attribute(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // source: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  // attribute_name: 5
  // src: 6
  frame->slots[2] /* namespace */ = create_future();
  frame->slots[3] /* name */ = create_future();
  frame->slots[4] /* mangled_name */ = create_future();
  frame->slots[5] /* attribute_name */ = create_future();
  frame->slots[6] /* src */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1449: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = func__extract_destination;
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_2;
}
static void cont__compiler__define_attribute_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* namespace */, arguments->slots[0]);
  initialize_future(frame->slots[3] /* name */, arguments->slots[1]);
  initialize_future(frame->slots[4] /* mangled_name */, arguments->slots[2]);
  // 1450: ... attribute_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_3;
}
static void cont__compiler__define_attribute_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1450: $attribute_name mangled_name_of(attribute_of(definition))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_4;
}
static void cont__compiler__define_attribute_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* attribute_name */, arguments->slots[0]);
  // 1451: $$src undefined
  ((CELL *)frame->slots[6])->contents /* src */ = get__undefined();
  // 1453: source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_5;
}
static void cont__compiler__define_attribute_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1453: ... :
  // 1454:   !src source.to_c
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__define_attribute_6, 0);
  // 1455: :
  // 1456:   !src string("var__" mangled_name "__" attribute_name)
  // 1457:   write_to_declarations "static NODE *@(src);@nl;"
  // 1458:   
  // 1459:   #write_to_phase_3 "
  // 1460:     @
  // 1461:       @(src) = create_future();
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_attribute_8, 0);
  // 1452: if
  // 1453:   source.is_defined:
  // 1454:     !src source.to_c
  // 1455:   :
  // 1456:     !src string("var__" mangled_name "__" attribute_name)
  // 1457:     write_to_declarations "static NODE *@(src);@nl;"
  // 1458:     
  // 1459:     #write_to_phase_3 "
  // 1460:       @
  // 1461:         @(src) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_12;
}
static void entry__compiler__define_attribute_6(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // src: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1454: !src source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_7;
}
static void cont__compiler__define_attribute_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_attribute_8(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // src: 0
  // mangled_name: 1
  // attribute_name: 2
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1456: !src string("var__" mangled_name "__" attribute_name)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__485aef83eb317008;
  arguments->slots[1] = frame->slots[1] /* mangled_name */;
  arguments->slots[2] = string__2d7981f4e5f02b9a;
  arguments->slots[3] = frame->slots[2] /* attribute_name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_10;
}
static void cont__compiler__define_attribute_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  // 1457: ... "static NODE *@(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__cb6a78473f66a6a1;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* src */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_11;
}
static void cont__compiler__define_attribute_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1457: write_to_declarations "static NODE *@(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_attribute_12(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1463: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_13;
}
static void cont__compiler__define_attribute_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1463: ... needed_names(name).is_defined
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_attribute_14, 0);
  // 1463: namespace.is_defined || needed_names(name).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_17;
}
static void entry__compiler__define_attribute_14(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1463: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_15;
}
static void cont__compiler__define_attribute_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1463: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_attribute_16;
}
static void cont__compiler__define_attribute_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1463: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_attribute_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1463: ... :
  // 1464:   write_to_phase_4 "
  // 1465:     @
  // 1466:       define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1467:     poly_idx__@(attribute_name), @(src));
  frame->slots[10] /* temp__4 */ = create_closure(entry__compiler__define_attribute_18, 0);
  // 1468: :
  // 1469:   write_to_phase_4 "
  // 1470:     @
  // 1471:       update_start_p = node_p;
  // 1472:       def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1473:     MAKE_ATTRIBUTE_VALUE(@(src)));
  frame->slots[11] /* temp__5 */ = create_closure(entry__compiler__define_attribute_24, 0);
  // 1462: if
  // 1463:   namespace.is_defined || needed_names(name).is_defined:
  // 1464:     write_to_phase_4 "
  // 1465:       @
  // 1466:         define_attribute(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1467:       poly_idx__@(attribute_name), @(src));
  // 1468:   :
  // 1469:     write_to_phase_4 "
  // 1470:       @
  // 1471:         update_start_p = node_p;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_method_17(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // attribute_name: 2
  // src: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[3] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1493: ... namespace_argument(namespace)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = func__namespace_argument;
  func = myself->type;
  frame->cont = cont__compiler__define_method_18;
}
static void cont__compiler__define_method_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1491: ... "
  // 1492:   @
  // 1493:     define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1494:   poly_idx__@(attribute_name), @(src));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__45b0be3ac644df67;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__fa733415f296bee;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__ca0e521fba2cc724;
  arguments->slots[5] = frame->slots[2] /* attribute_name */;
  arguments->slots[6] = string__2d7981f4e6682be5;
  arguments->slots[7] = ((CELL *)frame->slots[3])->contents /* src */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_method_20;
}
static void cont__compiler__define_method_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1491: write_to_phase_4 "
  // 1492:   @
  // 1493:     define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1494:   poly_idx__@(attribute_name), @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_method_21(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // name: 0
  // attribute_name: 1
  // src: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[5]; /* attribute_name */
  frame->slots[2] = myself->closure.frame->slots[6]; /* src */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1499: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_method_22;
}
static void cont__compiler__define_method_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1496: ... "
  // 1497:   @
  // 1498:     update_start_p = node_p;
  // 1499:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1500:   @(src));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__fccc671c88ddb4ed;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__82b9fe52d4649726;
  arguments->slots[3] = frame->slots[1] /* attribute_name */;
  arguments->slots[4] = string__2d7981f4e6682be5;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* src */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_method_23;
}
static void cont__compiler__define_method_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1496: write_to_phase_4 "
  // 1497:   @
  // 1498:     update_start_p = node_p;
  // 1499:     def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1500:   @(src));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_method(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // source: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  // attribute_name: 5
  // src: 6
  frame->slots[2] /* namespace */ = create_future();
  frame->slots[3] /* name */ = create_future();
  frame->slots[4] /* mangled_name */ = create_future();
  frame->slots[5] /* attribute_name */ = create_future();
  frame->slots[6] /* src */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1476: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = func__extract_destination;
  func = myself->type;
  frame->cont = cont__compiler__define_method_2;
}
static void cont__compiler__define_method_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* namespace */, arguments->slots[0]);
  initialize_future(frame->slots[3] /* name */, arguments->slots[1]);
  initialize_future(frame->slots[4] /* mangled_name */, arguments->slots[2]);
  // 1477: ... attribute_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__define_method_3;
}
static void cont__compiler__define_method_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1477: $attribute_name mangled_name_of(attribute_of(definition))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__define_method_4;
}
static void cont__compiler__define_method_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* attribute_name */, arguments->slots[0]);
  // 1478: $$src undefined
  ((CELL *)frame->slots[6])->contents /* src */ = get__undefined();
  // 1480: source.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_method_5;
}
static void cont__compiler__define_method_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1480: ... :
  // 1481:   !src source.to_c
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__define_method_6, 0);
  // 1482: :
  // 1483:   !src string("var__" mangled_name "__" attribute_name)
  // 1484:   write_to_declarations "static NODE *@(src);@nl;"
  // 1485:   
  // 1486:   #write_to_phase_3 "
  // 1487:     @
  // 1488:       @(src) = create_future();
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_method_8, 0);
  // 1479: if
  // 1480:   source.is_defined:
  // 1481:     !src source.to_c
  // 1482:   :
  // 1483:     !src string("var__" mangled_name "__" attribute_name)
  // 1484:     write_to_declarations "static NODE *@(src);@nl;"
  // 1485:     
  // 1486:     #write_to_phase_3 "
  // 1487:       @
  // 1488:         @(src) = create_future();
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_method_11;
}
static void entry__compiler__define_method_6(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // src: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[1]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1481: !src source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_method_7;
}
static void cont__compiler__define_method_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_method_8(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // src: 0
  // mangled_name: 1
  // attribute_name: 2
  frame->slots[0] = myself->closure.frame->slots[6]; /* src */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* attribute_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1483: !src string("var__" mangled_name "__" attribute_name)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__485aef83eb317008;
  arguments->slots[1] = frame->slots[1] /* mangled_name */;
  arguments->slots[2] = string__2d7981f4e5f02b9a;
  arguments->slots[3] = frame->slots[2] /* attribute_name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_method_9;
}
static void cont__compiler__define_method_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* src */ = arguments->slots[0];
  // 1484: ... "static NODE *@(src);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__cb6a78473f66a6a1;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* src */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_method_10;
}
static void cont__compiler__define_method_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1484: write_to_declarations "static NODE *@(src);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_method_11(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1490: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_method_12;
}
static void cont__compiler__define_method_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1490: ... needed_names(name).is_defined
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_method_13, 0);
  // 1490: namespace.is_defined || needed_names(name).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__define_method_16;
}
static void entry__compiler__define_method_13(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1490: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__compiler__define_method_14;
}
static void cont__compiler__define_method_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1490: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_method_15;
}
static void cont__compiler__define_method_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1490: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_method_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1490: ... :
  // 1491:   write_to_phase_4 "
  // 1492:     @
  // 1493:       define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1494:     poly_idx__@(attribute_name), @(src));
  frame->slots[10] /* temp__4 */ = create_closure(entry__compiler__define_method_17, 0);
  // 1495: :
  // 1496:   write_to_phase_4 "
  // 1497:     @
  // 1498:       update_start_p = node_p;
  // 1499:       def_attribute(&@(var_entry(name)), poly_idx__@(attribute_name), @
  // 1500:     @(src));
  frame->slots[11] /* temp__5 */ = create_closure(entry__compiler__define_method_21, 0);
  // 1489: if
  // 1490:   namespace.is_defined || needed_names(name).is_defined:
  // 1491:     write_to_phase_4 "
  // 1492:       @
  // 1493:         define_method(@(namespace_argument(namespace)), @quot;@(name)", @
  // 1494:       poly_idx__@(attribute_name), @(src));
  // 1495:   :
  // 1496:     write_to_phase_4 "
  // 1497:       @
  // 1498:         update_start_p = node_p;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_type_function_9(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // entry: 2
  // par_count: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[5]; /* entry */
  frame->slots[3] = myself->closure.frame->slots[6]; /* par_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1509: ... namespace_argument(namespace)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  result_count = 1;
  myself = func__namespace_argument;
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_10;
}
static void cont__compiler__define_type_function_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1507: ... "
  // 1508:   @
  // 1509:     define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1510:   @quot;, @(entry), @(par_count));@nl;@
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__292e5d6949e4a763;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__fa733415f296bee;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__fa730c15f496bec;
  arguments->slots[5] = frame->slots[2] /* entry */;
  arguments->slots[6] = string__2d7981f4e6682be5;
  arguments->slots[7] = frame->slots[3] /* par_count */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_12;
}
static void cont__compiler__define_type_function_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1507: write_to_phase_4 "
  // 1508:   @
  // 1509:     define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1510:   @quot;, @(entry), @(par_count));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_type_function_13(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // name: 0
  // entry: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  frame->slots[1] = myself->closure.frame->slots[5]; /* entry */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1515: ... var_entry(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_14;
}
static void cont__compiler__define_type_function_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1512: ... "
  // 1513:   @
  // 1514:     update_start_p = node_p;
  // 1515:     def_attribute(&@(var_entry(name)), -1, @(entry));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__fccc671c88ddb4ed;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__c21f422683de52f7;
  arguments->slots[3] = frame->slots[1] /* entry */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_15;
}
static void cont__compiler__define_type_function_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1512: write_to_phase_4 "
  // 1513:   @
  // 1514:     update_start_p = node_p;
  // 1515:     def_attribute(&@(var_entry(name)), -1, @(entry));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_4();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_type_function(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // source: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  // entry: 5
  // par_count: 6
  frame->slots[2] /* namespace */ = create_future();
  frame->slots[3] /* name */ = create_future();
  frame->slots[4] /* mangled_name */ = create_future();
  frame->slots[5] /* entry */ = create_future();
  frame->slots[6] /* par_count */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1503: extract_destination definition $namespace $name $_mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = func__extract_destination;
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_2;
}
static void cont__compiler__define_type_function_2(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* namespace */, arguments->slots[0]);
  initialize_future(frame->slots[3] /* name */, arguments->slots[1]);
  initialize_future(frame->slots[4] /* mangled_name */, arguments->slots[2]);
  // 1504: to_c source $entry $par_count
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 2;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_3;
}
static void cont__compiler__define_type_function_3(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* entry */, arguments->slots[0]);
  initialize_future(frame->slots[6] /* par_count */, arguments->slots[1]);
  // 1506: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_4;
}
static void cont__compiler__define_type_function_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1506: ... needed_names(name).is_defined
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__define_type_function_5, 0);
  // 1506: namespace.is_defined || needed_names(name).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_8;
}
static void entry__compiler__define_type_function_5(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1506: ... needed_names(name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  result_count = 1;
  myself = get__needed_names();
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_6;
}
static void cont__compiler__define_type_function_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1506: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_type_function_7;
}
static void cont__compiler__define_type_function_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1506: ... needed_names(name).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_type_function_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1506: ... :
  // 1507:   write_to_phase_4 "
  // 1508:     @
  // 1509:       define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1510:     @quot;, @(entry), @(par_count));@nl;@
  frame->slots[10] /* temp__4 */ = create_closure(entry__compiler__define_type_function_9, 0);
  // 1511: :
  // 1512:   write_to_phase_4 "
  // 1513:     @
  // 1514:       update_start_p = node_p;
  // 1515:       def_attribute(&@(var_entry(name)), -1, @(entry));
  frame->slots[11] /* temp__5 */ = create_closure(entry__compiler__define_type_function_13, 0);
  // 1505: if
  // 1506:   namespace.is_defined || needed_names(name).is_defined:
  // 1507:     write_to_phase_4 "
  // 1508:       @
  // 1509:         define_type_function(@(namespace_argument(namespace)), @quot;@(name)@
  // 1510:       @quot;, @(entry), @(par_count));@nl;@
  // 1511:   :
  // 1512:     write_to_phase_4 "
  // 1513:       @
  // 1514:         update_start_p = node_p;
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  arguments->slots[2] = frame->slots[11] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_polymorphic_function_45(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // namespace: 0
  // name: 1
  // mangled_name: 2
  // id: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[1]; /* name */
  frame->slots[2] = myself->closure.frame->slots[3]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[2]; /* id */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1559: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_46;
}
static void cont__compiler__define_polymorphic_function_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1556: ... "
  // 1557:   @
  // 1558:     define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1559:   ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  argument_count = 11;
  arguments = node_p;
  arguments->slots[0] = string__94aa6a2a3d156a1a;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__860afa4b5f607d1b;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__65a4a8f6052de83f;
  arguments->slots[5] = frame->slots[2] /* mangled_name */;
  arguments->slots[6] = string__2d7981f4e6682be5;
  arguments->slots[7] = frame->slots[3] /* id */;
  arguments->slots[8] = string__fa733415f296bea;
  arguments->slots[9] = frame->slots[5] /* temp__2 */;
  arguments->slots[10] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_48;
}
static void cont__compiler__define_polymorphic_function_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1556: write_to_phase_2 "
  // 1557:   @
  // 1558:     define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1559:   ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_polymorphic_function_49(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // with_setter: 0
  // namespace: 1
  // name: 2
  // mangled_name: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* with_setter */
  frame->slots[1] = myself->closure.frame->slots[0]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[1]; /* name */
  frame->slots[3] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1563: ... with_setter()
  argument_count = 0;
  arguments = node_p;
  result_count = 1;
  myself = frame->slots[0] /* with_setter */;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_50;
}
static void cont__compiler__define_polymorphic_function_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1565: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_51;
}
static void cont__compiler__define_polymorphic_function_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1561: ... "
  // 1562:   @
  // 1563:     define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // 1564:   "@(name)", get__@(mangled_name), &poly_idx__@(mangled_name), @
  // 1565:   &@(var_entry(mangled_name)));
  argument_count = 13;
  arguments = node_p;
  arguments->slots[0] = string__3764e728034d321b;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6482be7;
  arguments->slots[3] = frame->slots[1] /* namespace */;
  arguments->slots[4] = string__860afa4b5f607d1b;
  arguments->slots[5] = frame->slots[2] /* name */;
  arguments->slots[6] = string__65a4a8f6052de83f;
  arguments->slots[7] = frame->slots[3] /* mangled_name */;
  arguments->slots[8] = string__4a0e52ffba34c725;
  arguments->slots[9] = frame->slots[3] /* mangled_name */;
  arguments->slots[10] = string__fa733415f296bea;
  arguments->slots[11] = frame->slots[6] /* temp__3 */;
  arguments->slots[12] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_55;
}
static void cont__compiler__define_polymorphic_function_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1561: write_to_phase_2 "
  // 1562:   @
  // 1563:     define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // 1564:   "@(name)", get__@(mangled_name), &poly_idx__@(mangled_name), @
  // 1565:   &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_polymorphic_function_41(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // namespace: 0
  // name: 1
  // id: 2
  // mangled_name: 3
  // with_setter: 4
  frame->slots[0] = myself->closure.frame->slots[3]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[4]; /* name */
  frame->slots[2] = myself->closure.frame->slots[6]; /* id */
  frame->slots[3] = myself->closure.frame->slots[5]; /* mangled_name */
  frame->slots[4] = myself->closure.frame->slots[2]; /* with_setter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1550: ... "
  // 1551:   static NODE *get__@(namespace)__@(name)(void) {
  // 1552:     return var.@(namespace)__@(name);
  // 1553:   }
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__55b34e50e74b4c7c;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__2d7981f4e5f02b9a;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__5a35746c23f76309;
  arguments->slots[5] = frame->slots[0] /* namespace */;
  arguments->slots[6] = string__2d7981f4e5f02b9a;
  arguments->slots[7] = frame->slots[1] /* name */;
  arguments->slots[8] = string__b40af3cb5d887d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_42;
}
static void cont__compiler__define_polymorphic_function_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1550: write_to_declarations "
  // 1551:   static NODE *get__@(namespace)__@(name)(void) {
  // 1552:     return var.@(namespace)__@(name);
  // 1553:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_43;
}
static void cont__compiler__define_polymorphic_function_43(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1555: id.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* id */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_44;
}
static void cont__compiler__define_polymorphic_function_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1555: ... :
  // 1556:   write_to_phase_2 "
  // 1557:     @
  // 1558:       define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1559:     ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__define_polymorphic_function_45, 0);
  // 1560: :
  // 1561:   write_to_phase_2 "
  // 1562:     @
  // 1563:       define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // 1564:     "@(name)", get__@(mangled_name), &poly_idx__@(mangled_name), @
  // 1565:     &@(var_entry(mangled_name)));
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__define_polymorphic_function_49, 0);
  // 1554: if
  // 1555:   id.is_defined:
  // 1556:     write_to_phase_2 "
  // 1557:       @
  // 1558:         define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // 1559:       ", get__@(mangled_name), @(id), &@(var_entry(mangled_name)));
  // 1560:   :
  // 1561:     write_to_phase_2 "
  // 1562:       @
  // 1563:         define_polymorphic_function@(with_setter())(@quot;@(namespace)", @
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_polymorphic_function_56(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // with_setter: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* with_setter */
  frame->slots[1] = myself->closure.frame->slots[4]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1569: ... with_setter()
  argument_count = 0;
  arguments = node_p;
  result_count = 1;
  myself = frame->slots[0] /* with_setter */;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_57;
}
static void cont__compiler__define_polymorphic_function_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1567: ... "
  // 1568:   @
  // 1569:     register_polymorphic_function@(with_setter())(@quot;_@(module_name)@
  // 1570:   ::@(name)", &poly_idx__@(name));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__6a22d67b14b60a68;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__fa732415f396b93;
  arguments->slots[3] = get__module_name();
  arguments->slots[4] = string__2d7981f4e6d82bff;
  arguments->slots[5] = frame->slots[1] /* name */;
  arguments->slots[6] = string__286520bd3a268298;
  arguments->slots[7] = frame->slots[1] /* name */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_62;
}
static void cont__compiler__define_polymorphic_function_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1567: write_to_phase_2 "
  // 1568:   @
  // 1569:     register_polymorphic_function@(with_setter())(@quot;_@(module_name)@
  // 1570:   ::@(name)", &poly_idx__@(name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_2();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_polymorphic_function(void) {
  allocate_initialized_frame_gc(2, 12);
  // slot allocations:
  // definition: 0
  // is_a_setter: 1
  // with_setter: 2
  // namespace: 3
  // name: 4
  // mangled_name: 5
  // id: 6
  // info: 7
  frame->slots[2] /* with_setter */ = create_future();
  frame->slots[3] /* namespace */ = create_future();
  frame->slots[4] /* name */ = create_future();
  frame->slots[5] /* mangled_name */ = create_future();
  frame->slots[6] /* id */ = create_future();
  frame->slots[7] /* info */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1518: ... :
  // 1519:   if
  // 1520:     is_a_setter
  // 1521:     -> "_with_setter"
  // 1522:     -> ""
  frame->slots[8] /* temp__1 */ = create_closure(entry__compiler__define_polymorphic_function_2, 0);
  // 1518: $with_setter:
  // 1519:   if
  // 1520:     is_a_setter
  // 1521:     -> "_with_setter"
  // 1522:     -> ""
  initialize_future(frame->slots[2] /* with_setter */, frame->slots[8] /* temp__1 */);
  // 1524: extract_destination definition $namespace $name $mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 3;
  myself = func__extract_destination;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_6;
}
static void entry__compiler__define_polymorphic_function_3(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1521: -> "_with_setter"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__62213544ce52579e;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_polymorphic_function_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1522: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_polymorphic_function_2(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_a_setter: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* is_a_setter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1519: if
  // 1520:   is_a_setter
  // 1521:   -> "_with_setter"
  // 1522:   -> ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* is_a_setter */;
  arguments->slots[1] = func__compiler__define_polymorphic_function_3;
  arguments->slots[2] = func__compiler__define_polymorphic_function_5;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_polymorphic_function_6(void) {
  if (argument_count != 3) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* namespace */, arguments->slots[0]);
  initialize_future(frame->slots[4] /* name */, arguments->slots[1]);
  initialize_future(frame->slots[5] /* mangled_name */, arguments->slots[2]);
  // 1526: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_7;
}
static void cont__compiler__define_polymorphic_function_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1526: ... :
  // 1527:   write_to_global_variable_declarations
  // 1528:     string("  NODE *" mangled_name ";@nl;")
  frame->slots[9] /* temp__2 */ = create_closure(entry__compiler__define_polymorphic_function_8, 0);
  // 1529: :
  // 1530:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1531:   write_to_top_level_variable_declarations
  // 1532:     string("  NODE *" var_name(mangled_name) ";@nl;")
  frame->slots[10] /* temp__3 */ = create_closure(entry__compiler__define_polymorphic_function_10, 0);
  // 1525: if
  // 1526:   namespace.is_defined:
  // 1527:     write_to_global_variable_declarations
  // 1528:       string("  NODE *" mangled_name ";@nl;")
  // 1529:   :
  // 1530:     write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1531:     write_to_top_level_variable_declarations
  // 1532:       string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_15;
}
static void entry__compiler__define_polymorphic_function_8(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1528: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_9;
}
static void cont__compiler__define_polymorphic_function_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1527: write_to_global_variable_declarations
  // 1528:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_polymorphic_function_10(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1530: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__fa730415f296bee;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__fa730c15f496bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_11;
}
static void cont__compiler__define_polymorphic_function_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1530: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_12;
}
static void cont__compiler__define_polymorphic_function_12(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1532: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_name;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_13;
}
static void cont__compiler__define_polymorphic_function_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1532: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_14;
}
static void cont__compiler__define_polymorphic_function_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1531: write_to_top_level_variable_declarations
  // 1532:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_polymorphic_function_15(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1533: $id privileged_polymorphic_functions(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = get__privileged_polymorphic_functions();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_16;
}
static void cont__compiler__define_polymorphic_function_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* id */, arguments->slots[0]);
  // 1536: ... id.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* id */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_17;
}
static void cont__compiler__define_polymorphic_function_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 1536: ... -> " = @(id)"
  frame->slots[11] /* temp__4 */ = create_closure(entry__compiler__define_polymorphic_function_18, 0);
  // 1536: ... if(id.is_defined (-> " = @(id)") -> "")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__3 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  arguments->slots[2] = func__compiler__define_polymorphic_function_20;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_21;
}
static void entry__compiler__define_polymorphic_function_18(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // id: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* id */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1536: ... " = @(id)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__fa730415fc16bec;
  arguments->slots[1] = frame->slots[0] /* id */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_19;
}
static void cont__compiler__define_polymorphic_function_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1536: ... -> " = @(id)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_polymorphic_function_20(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1536: ... -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_polymorphic_function_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 1534: ... "
  // 1535:   static int poly_idx__@(mangled_name)@
  // 1536:   @(if(id.is_defined (-> " = @(id)") -> ""));@nl;@
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__dd59fa996655f7be;
  arguments->slots[1] = frame->slots[5] /* mangled_name */;
  arguments->slots[2] = frame->slots[9] /* temp__2 */;
  arguments->slots[3] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_23;
}
static void cont__compiler__define_polymorphic_function_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1534: write_to_declarations "
  // 1535:   static int poly_idx__@(mangled_name)@
  // 1536:   @(if(id.is_defined (-> " = @(id)") -> ""));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_24;
}
static void cont__compiler__define_polymorphic_function_24(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1539: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_25;
}
static void cont__compiler__define_polymorphic_function_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 1539: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_26;
}
static void cont__compiler__define_polymorphic_function_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 1537: ... "
  // 1538:   @
  // 1539:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1540:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = string__29d4ac87c65f0ce6;
  arguments->slots[3] = frame->slots[10] /* temp__3 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_27;
}
static void cont__compiler__define_polymorphic_function_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1537: write_to_generated_collections "
  // 1538:   @
  // 1539:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1540:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_28;
}
static void cont__compiler__define_polymorphic_function_28(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1541: ... identifier_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_29;
}
static void cont__compiler__define_polymorphic_function_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1541: compute_source_text_info $info identifier_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 1;
  myself = func__compute_source_text_info;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_30;
}
static void cont__compiler__define_polymorphic_function_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* info */, arguments->slots[0]);
  // 1542: ... "  {type__@(mangled_name), NULL, @(info)},@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__4edc27e6c3faecfa;
  arguments->slots[1] = frame->slots[5] /* mangled_name */;
  arguments->slots[2] = string__3794a6c106b6c980;
  arguments->slots[3] = frame->slots[7] /* info */;
  arguments->slots[4] = string__fa727015f496bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_32;
}
static void cont__compiler__define_polymorphic_function_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1542: write_to_continuation_table "  {type__@(mangled_name), NULL, @(info)},@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_continuation_table();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_33;
}
static void cont__compiler__define_polymorphic_function_33(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1543: generate_dispatcher_function mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 0;
  myself = get__generate_dispatcher_function();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_34;
}
static void cont__compiler__define_polymorphic_function_34(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1546: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_35;
}
static void cont__compiler__define_polymorphic_function_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 1544: ... "
  // 1545:   @
  // 1546:     assign_value(&@(var_entry(mangled_name)), @
  // 1547:   create_function(type__@(mangled_name), -1));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__7d5cf5d8cf0f5f69;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = string__63e6320520af81f6;
  arguments->slots[3] = frame->slots[5] /* mangled_name */;
  arguments->slots[4] = string__fd94bfb0860889aa;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_38;
}
static void cont__compiler__define_polymorphic_function_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1544: write_to_phase_5 "
  // 1545:   @
  // 1546:     assign_value(&@(var_entry(mangled_name)), @
  // 1547:   create_function(type__@(mangled_name), -1));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_phase_5();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_39;
}
static void cont__compiler__define_polymorphic_function_39(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1549: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_polymorphic_function_40;
}
static void cont__compiler__define_polymorphic_function_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 1549: ... :
  // 1550:   write_to_declarations "
  // 1551:     static NODE *get__@(namespace)__@(name)(void) {
  // 1552:       return var.@(namespace)__@(name);
  // 1553:     }
  // 1554:   if
  // 1555:     id.is_defined:
  // 1556:       write_to_phase_2 "
  // 1557:         @
  // 1558:           define_privileged_polymorphic_function("@(namespace)", "@(name)@
  // ...
  frame->slots[9] /* temp__2 */ = create_closure(entry__compiler__define_polymorphic_function_41, 0);
  // 1566: :
  // 1567:   write_to_phase_2 "
  // 1568:     @
  // 1569:       register_polymorphic_function@(with_setter())(@quot;_@(module_name)@
  // 1570:     ::@(name)", &poly_idx__@(name));
  frame->slots[10] /* temp__3 */ = create_closure(entry__compiler__define_polymorphic_function_56, 0);
  // 1548: if
  // 1549:   namespace.is_defined:
  // 1550:     write_to_declarations "
  // 1551:       static NODE *get__@(namespace)__@(name)(void) {
  // 1552:         return var.@(namespace)__@(name);
  // 1553:       }
  // 1554:     if
  // 1555:       id.is_defined:
  // 1556:         write_to_phase_2 "
  // 1557:           @
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  arguments->slots[2] = frame->slots[10] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_308(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // scope: 1
  frame->slots[1] = myself->closure.frame->slots[1]; /* scope */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1871: ... line .has_suffix. ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_309;
}
static void cont__compiler__define_c_code_309(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1871: ... line(1) > ' '
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__define_c_code_310, 0);
  // 1871: ... line .has_suffix. ';' && line(1) > ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_313;
}
static void entry__compiler__define_c_code_310(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // line: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1871: ... line(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* line */;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_311;
}
static void cont__compiler__define_c_code_311(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1871: ... line(1) > ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_312;
}
static void cont__compiler__define_c_code_312(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1871: ... line(1) > ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_313(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1871: ... :
  // 1872:   unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1873:     write_to_declarations scope
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__define_c_code_314, 0);
  // 1871: if line .has_suffix. ';' && line(1) > ' ':
  // 1872:   unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1873:     write_to_declarations scope
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_319;
}
static void entry__compiler__define_c_code_318(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // scope: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* scope */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1873: write_to_declarations scope
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_314(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // line: 0
  // scope: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* scope */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1872: ... alt("typedef" "static " "extern " '}')
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__b8540cde1593c09c;
  arguments->slots[1] = string__9a480f9895a2d0da;
  arguments->slots[2] = string__b810095e95cb80da;
  arguments->slots[3] = character__125;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_316;
}
static void cont__compiler__define_c_code_316(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1872: ... line .has_prefix. alt("typedef" "static " "extern " '}')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_317;
}
static void cont__compiler__define_c_code_317(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1872: ... :
  // 1873:   write_to_declarations scope
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__define_c_code_318, 0);
  // 1872: unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1873:   write_to_declarations scope
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_319(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1874: ... line.converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_320;
}
static void cont__compiler__define_c_code_320(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1874: write_to_declarations line.converted '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = character__10;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_266(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // namespace: 0
  // name: 1
  // mangled_name: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[3]; /* name */
  frame->slots[2] = myself->closure.frame->slots[4]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1834: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_267;
}
static void cont__compiler__define_c_code_267(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1831: ... "
  // 1832:   @
  // 1833:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1834:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__b29ac022d5eddd84;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__860afa4b5f607d1b;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__65a4a8f6052de83f;
  arguments->slots[5] = frame->slots[2] /* mangled_name */;
  arguments->slots[6] = string__fa733415f296bea;
  arguments->slots[7] = frame->slots[4] /* temp__2 */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_268;
}
static void cont__compiler__define_c_code_268(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1831: write_to_phase_3 "
  // 1832:   @
  // 1833:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1834:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_249(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // mangled_name: 0
  // scope: 1
  // constructor_name: 2
  // arguments: 3
  frame->slots[0] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* scope */
  frame->slots[2] = myself->closure.frame->slots[1]; /* constructor_name */
  frame->slots[3] = myself->closure.frame->slots[2]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1810: ... "
  // 1811:   SIMPLE_NODE @(mangled_name)__node =
  // 1812:     {
  // 1813:       type__@(mangled_name),
  // 1814:       &attributes__@(mangled_name)
  // 1815:     };
  // 1816:   
  // 1817:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1818:     return (NODE *)&@(mangled_name)__node;
  // 1819:   }
  argument_count = 15;
  arguments = node_p;
  arguments->slots[0] = string__94481952eb48e343;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__505bb7858ec4a9cf;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__b067b139c37c931b;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__89ac1b3296eec0f0;
  arguments->slots[7] = frame->slots[1] /* scope */;
  arguments->slots[8] = string__101f5f1783b8a2fd;
  arguments->slots[9] = frame->slots[2] /* constructor_name */;
  arguments->slots[10] = string__578a5af303e9cc9;
  arguments->slots[11] = ((CELL *)frame->slots[3])->contents /* arguments */;
  arguments->slots[12] = string__a9ca63e3254dce43;
  arguments->slots[13] = frame->slots[0] /* mangled_name */;
  arguments->slots[14] = string__8359f29999c3244b;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_256;
}
static void cont__compiler__define_c_code_256(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1810: write "
  // 1811:   SIMPLE_NODE @(mangled_name)__node =
  // 1812:     {
  // 1813:       type__@(mangled_name),
  // 1814:       &attributes__@(mangled_name)
  // 1815:     };
  // 1816:   
  // 1817:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1818:     return (NODE *)&@(mangled_name)__node;
  // 1819:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_257(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // scope: 0
  // constructor_name: 1
  // arguments: 2
  // node_name: 3
  // mangled_name: 4
  // initializers: 5
  frame->slots[0] = myself->closure.frame->slots[0]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[1]; /* constructor_name */
  frame->slots[2] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[3]; /* node_name */
  frame->slots[4] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[5] = myself->closure.frame->slots[5]; /* initializers */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1821: ... "
  // 1822:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1823:     NODE *node = allocate(sizeof(@(node_name)));
  // 1824:     node->type = type__@(mangled_name);
  // 1825:     node->attributes = &attributes__@(mangled_name)@
  // 1826:   ;@nl;@(initializers)  return node;
  // 1827:   }
  argument_count = 14;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  arguments->slots[1] = string__101f5f1783b8a2fd;
  arguments->slots[2] = frame->slots[1] /* constructor_name */;
  arguments->slots[3] = string__578a5af303e9cc9;
  arguments->slots[4] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[5] = string__27970d05ed81c641;
  arguments->slots[6] = frame->slots[3] /* node_name */;
  arguments->slots[7] = string__8262d9eaa714e89c;
  arguments->slots[8] = frame->slots[4] /* mangled_name */;
  arguments->slots[9] = string__16179a4c575e7ddc;
  arguments->slots[10] = frame->slots[4] /* mangled_name */;
  arguments->slots[11] = string__2d7981f4e6d02bcf;
  arguments->slots[12] = ((CELL *)frame->slots[5])->contents /* initializers */;
  arguments->slots[13] = string__59fe708e86aaa5e8;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_262;
}
static void cont__compiler__define_c_code_262(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1821: write "
  // 1822:   @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1823:     NODE *node = allocate(sizeof(@(node_name)));
  // 1824:     node->type = type__@(mangled_name);
  // 1825:     node->attributes = &attributes__@(mangled_name)@
  // 1826:   ;@nl;@(initializers)  return node;
  // 1827:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_243(void) {
  allocate_initialized_frame_gc(6, 9);
  // slot allocations:
  // scope: 0
  // constructor_name: 1
  // arguments: 2
  // node_name: 3
  // mangled_name: 4
  // initializers: 5
  frame->slots[0] = myself->closure.frame->slots[5]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[12]; /* constructor_name */
  frame->slots[2] = myself->closure.frame->slots[9]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[7]; /* node_name */
  frame->slots[4] = myself->closure.frame->slots[2]; /* mangled_name */
  frame->slots[5] = myself->closure.frame->slots[10]; /* initializers */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1807: "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  arguments->slots[1] = string__101f5f1783b8a2fd;
  arguments->slots[2] = frame->slots[1] /* constructor_name */;
  arguments->slots[3] = string__578a5af303e9cc9;
  arguments->slots[4] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[5] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_245;
}
static void cont__compiler__define_c_code_245(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1806: write_to_declarations
  // 1807:   "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_246;
}
static void cont__compiler__define_c_code_246(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1809: node_name == "SIMPLE_NODE"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* node_name */;
  arguments->slots[1] = string__1c6c7289032a5d69;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_248;
}
static void cont__compiler__define_c_code_248(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1809: ... :
  // 1810:   write "
  // 1811:     SIMPLE_NODE @(mangled_name)__node =
  // 1812:       {
  // 1813:         type__@(mangled_name),
  // 1814:         &attributes__@(mangled_name)
  // 1815:       };
  // 1816:     
  // 1817:     @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1818:       return (NODE *)&@(mangled_name)__node;
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__define_c_code_249, 0);
  // 1820: :
  // 1821:   write "
  // 1822:     @(scope)NODE *@(constructor_name)(@(arguments)) {
  // 1823:       NODE *node = allocate(sizeof(@(node_name)));
  // 1824:       node->type = type__@(mangled_name);
  // 1825:       node->attributes = &attributes__@(mangled_name)@
  // 1826:     ;@nl;@(initializers)  return node;
  // 1827:     }
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__define_c_code_257, 0);
  // 1808: if
  // 1809:   node_name == "SIMPLE_NODE":
  // 1810:     write "
  // 1811:       SIMPLE_NODE @(mangled_name)__node =
  // 1812:         {
  // 1813:           type__@(mangled_name),
  // 1814:           &attributes__@(mangled_name)
  // 1815:         };
  // 1816:       
  // 1817:       @(scope)NODE *@(constructor_name)(@(arguments)) {
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_93(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // scope: 0
  // collector_name: 1
  // mangled_name: 2
  // source: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[3]; /* collector_name */
  frame->slots[2] = myself->closure.frame->slots[1]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[0]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1672: ... "
  // 1673:   @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1674:     @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1675:     new_node->type = node->type;
  // 1676:     *(void **)node = ENCODE_ADDRESS(new_node);
  // 1677:     new_node->attributes = collect_attributes(node->attributes);
  argument_count = 10;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* scope */;
  arguments->slots[1] = string__4a1f574b83baa2fd;
  arguments->slots[2] = frame->slots[1] /* collector_name */;
  arguments->slots[3] = string__578a5af303e9cc9;
  arguments->slots[4] = frame->slots[2] /* mangled_name */;
  arguments->slots[5] = string__3cc912e9d780065b;
  arguments->slots[6] = frame->slots[2] /* mangled_name */;
  arguments->slots[7] = string__ace7f55a2ad7b400;
  arguments->slots[8] = frame->slots[2] /* mangled_name */;
  arguments->slots[9] = string__c14689165b56e017;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_98;
}
static void cont__compiler__define_c_code_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1672: write "
  // 1673:   @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1674:     @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1675:     new_node->type = node->type;
  // 1676:     *(void **)node = ENCODE_ADDRESS(new_node);
  // 1677:     new_node->attributes = collect_attributes(node->attributes);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_99;
}
static void cont__compiler__define_c_code_99(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1678: for_each_line source: ($line)
  // 1679:   truncate_from &line "//"
  // 1680:   normalize &line
  // 1681:   $field_type trim(truncate_behind(line alt(' ' '*') -1))
  // 1682:   
  // 1683:   $field_name
  // 1684:     trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  // 1685:   
  // 1686:   $base_type
  // 1687:     cond
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* source */;
  arguments->slots[1] = func__compiler__define_c_code_100;
  result_count = 0;
  myself = get__for_each_line();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_140;
}
static void entry__compiler__define_c_code_131(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // field_name: 0
  // base_type: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* field_name */
  frame->slots[1] = myself->closure.frame->slots[3]; /* base_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1697: ... base_type.to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* base_type */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_132;
}
static void cont__compiler__define_c_code_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1694: ... "
  // 1695:   @
  // 1696:     new_node->@(field_name) = @
  // 1697:   collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__8221090a5decf427;
  arguments->slots[1] = frame->slots[0] /* field_name */;
  arguments->slots[2] = string__8ae3d99defa96b0f;
  arguments->slots[3] = frame->slots[3] /* temp__2 */;
  arguments->slots[4] = string__bb240c9597d230c4;
  arguments->slots[5] = frame->slots[0] /* field_name */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_136;
}
static void cont__compiler__define_c_code_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1694: write "
  // 1695:   @
  // 1696:     new_node->@(field_name) = @
  // 1697:   collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_137(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // field_name: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* field_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1699: ... "  new_node->@(field_name) = node->@(field_name);@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__8221090a5decf427;
  arguments->slots[1] = frame->slots[0] /* field_name */;
  arguments->slots[2] = string__67b027ebc06b8f3b;
  arguments->slots[3] = frame->slots[0] /* field_name */;
  arguments->slots[4] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_139;
}
static void cont__compiler__define_c_code_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1699: write "  new_node->@(field_name) = node->@(field_name);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_100(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // line: 0
  // field_type: 1
  // field_name: 2
  // base_type: 3
  frame->slots[1] /* field_type */ = create_future();
  frame->slots[2] /* field_name */ = create_future();
  frame->slots[3] /* base_type */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* line */ = create_cell_with_contents(arguments->slots[0]);
  // 1679: truncate_from &line "//"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = string__2d7981f4e6702bea;
  result_count = 1;
  myself = get__truncate_from();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_102;
}
static void cont__compiler__define_c_code_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1680: normalize &line
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  result_count = 1;
  myself = get__normalize();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_103;
}
static void cont__compiler__define_c_code_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1681: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_104;
}
static void cont__compiler__define_c_code_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1681: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_105;
}
static void cont__compiler__define_c_code_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1681: ... truncate_behind(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__truncate_behind();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_106;
}
static void cont__compiler__define_c_code_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1681: $field_type trim(truncate_behind(line alt(' ' '*') -1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_107;
}
static void cont__compiler__define_c_code_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* field_type */, arguments->slots[0]);
  // 1684: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_108;
}
static void cont__compiler__define_c_code_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1684: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_109;
}
static void cont__compiler__define_c_code_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1684: ... truncate_until(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__truncate_until();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_110;
}
static void cont__compiler__define_c_code_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1684: ... truncate_until(line alt(' ' '*') -1) .without_suffix. ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__without_suffix();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_111;
}
static void cont__compiler__define_c_code_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1683: $field_name
  // 1684:   trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_112;
}
static void cont__compiler__define_c_code_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* field_name */, arguments->slots[0]);
  // 1688: -> field_type .has_suffix. " *" -> range(field_type 1 -3)
  frame->slots[4] /* temp__1 */ = create_closure(entry__compiler__define_c_code_113, 0);
  // 1689: -> field_type .has_suffix. '*' -> range(field_type 1 -2)
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__define_c_code_119, 0);
  // 1686: $base_type
  // 1687:   cond
  // 1688:     -> field_type .has_suffix. " *" -> range(field_type 1 -3)
  // 1689:     -> field_type .has_suffix. '*' -> range(field_type 1 -2)
  // 1690:     -> true -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = func__compiler__define_c_code_124;
  result_count = 1;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_126;
}
static void entry__compiler__define_c_code_125(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1690: ... -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_121(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1689: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_122;
}
static void cont__compiler__define_c_code_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1689: ... range(field_type 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_123;
}
static void cont__compiler__define_c_code_123(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1689: ... -> range(field_type 1 -2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_116(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1688: ... 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__3;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_117;
}
static void cont__compiler__define_c_code_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1688: ... range(field_type 1 -3)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_118;
}
static void cont__compiler__define_c_code_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1688: ... -> range(field_type 1 -3)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_113(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1688: ... field_type .has_suffix. " *"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = string__2d7981f4e6082bef;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_115;
}
static void cont__compiler__define_c_code_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1688: ... -> range(field_type 1 -3)
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__define_c_code_116, 0);
  // 1688: -> field_type .has_suffix. " *" -> range(field_type 1 -3)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_119(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // field_type: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* field_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1689: ... field_type .has_suffix. '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* field_type */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_120;
}
static void cont__compiler__define_c_code_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1689: ... -> range(field_type 1 -2)
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__define_c_code_121, 0);
  // 1689: -> field_type .has_suffix. '*' -> range(field_type 1 -2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_124(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1690: -> true -> undefined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = func__compiler__define_c_code_125;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* base_type */, arguments->slots[0]);
  // 1693: base_type.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* base_type */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_127;
}
static void cont__compiler__define_c_code_127(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1693: ... defined_structs(base_type)
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__define_c_code_128, 0);
  // 1693: base_type.is_defined && defined_structs(base_type)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_130;
}
static void entry__compiler__define_c_code_128(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // base_type: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* base_type */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1693: ... defined_structs(base_type)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* base_type */;
  result_count = 1;
  myself = get__defined_structs();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_129;
}
static void cont__compiler__define_c_code_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1693: ... defined_structs(base_type)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1693: ... :
  // 1694:   write "
  // 1695:     @
  // 1696:       new_node->@(field_name) = @
  // 1697:     collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__define_c_code_131, 0);
  // 1698: :
  // 1699:   write "  new_node->@(field_name) = node->@(field_name);@nl;"
  frame->slots[8] /* temp__5 */ = create_closure(entry__compiler__define_c_code_137, 0);
  // 1692: if
  // 1693:   base_type.is_defined && defined_structs(base_type):
  // 1694:     write "
  // 1695:       @
  // 1696:         new_node->@(field_name) = @
  // 1697:       collect_@(base_type.to_lower_case)(node->@(field_name));@nl;@
  // 1698:   :
  // 1699:     write "  new_node->@(field_name) = node->@(field_name);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_140(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1700: write "
  // 1701:     return new_node;
  // 1702:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__109c72e613b07f37;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_76(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // mangled_name: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[2]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1661: ... indented(2 source)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_77;
}
static void cont__compiler__define_c_code_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1658: ... "
  // 1659:   
  // 1660:   typedef struct @(mangled_name) @(mangled_name);
  // 1661:   struct @(mangled_name) {@nl;@(indented(2 source))
  // 1662:   };
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__3148e46705c3e08c;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__578a5af303e9cc1;
  arguments->slots[3] = frame->slots[0] /* mangled_name */;
  arguments->slots[4] = string__44fc2666d9a259c5;
  arguments->slots[5] = frame->slots[0] /* mangled_name */;
  arguments->slots[6] = string__fa730415df16bc6;
  arguments->slots[7] = frame->slots[3] /* temp__2 */;
  arguments->slots[8] = string__d60aee0b5fb87d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_82;
}
static void cont__compiler__define_c_code_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1658: write_to_declarations "
  // 1659:   
  // 1660:   typedef struct @(mangled_name) @(mangled_name);
  // 1661:   struct @(mangled_name) {@nl;@(indented(2 source))
  // 1662:   };
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_83(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // source: 0
  // mangled_name: 1
  // scope: 2
  // collector_name: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[3]; /* scope */
  frame->slots[3] /* collector_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1669: ... indented(2 source)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_84;
}
static void cont__compiler__define_c_code_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1664: ... "
  // 1665:   
  // 1666:   typedef struct {
  // 1667:     void *type;
  // 1668:     ATTRIBUTES *attributes;
  // 1669:   @(indented(2 source))@nl;} @(mangled_name);
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__dd8b990a9b395bcf;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__fa73ac15dc16bec;
  arguments->slots[3] = frame->slots[1] /* mangled_name */;
  arguments->slots[4] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_87;
}
static void cont__compiler__define_c_code_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1664: write_to_declarations "
  // 1665:   
  // 1666:   typedef struct {
  // 1667:     void *type;
  // 1668:     ATTRIBUTES *attributes;
  // 1669:   @(indented(2 source))@nl;} @(mangled_name);
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_88;
}
static void cont__compiler__define_c_code_88(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1670: ... mangled_name.to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_89;
}
static void cont__compiler__define_c_code_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1670: $collector_name "collect_@(mangled_name.to_lower_case)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__64a8ad100475501f;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_91;
}
static void cont__compiler__define_c_code_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* collector_name */, arguments->slots[0]);
  // 1671: ... defined_functions(collector_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* collector_name */;
  result_count = 1;
  myself = get__defined_functions();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_92;
}
static void cont__compiler__define_c_code_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1671: ... :
  // 1672:   write "
  // 1673:     @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1674:       @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1675:       new_node->type = node->type;
  // 1676:       *(void **)node = ENCODE_ADDRESS(new_node);
  // 1677:       new_node->attributes = collect_attributes(node->attributes);
  // 1678:   for_each_line source: ($line)
  // 1679:     truncate_from &line "//"
  // 1680:     normalize &line
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__define_c_code_93, 0);
  // 1671: unless defined_functions(collector_name):
  // 1672:   write "
  // 1673:     @(scope)void *@(collector_name)(@(mangled_name) *node) {
  // 1674:       @(mangled_name) *new_node = allocate(sizeof(@(mangled_name)));
  // 1675:       new_node->type = node->type;
  // 1676:       *(void **)node = ENCODE_ADDRESS(new_node);
  // 1677:       new_node->attributes = collect_attributes(node->attributes);
  // 1678:   for_each_line source: ($line)
  // 1679:     truncate_from &line "//"
  // 1680:     normalize &line
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_142(void) {
  allocate_initialized_frame_gc(7, 17);
  // slot allocations:
  // self: 0
  // initialize_object: 1
  // mangled_name: 2
  // namespace: 3
  // name: 4
  // scope: 5
  // source: 6
  // node_name: 7
  // node: 8
  // arguments: 9
  // initializers: 10
  // attributes_declaration: 11
  // constructor_name: 12
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[9]; /* initialize_object */
  frame->slots[2] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[3] = myself->closure.frame->slots[5]; /* namespace */
  frame->slots[4] = myself->closure.frame->slots[6]; /* name */
  frame->slots[5] = myself->closure.frame->slots[3]; /* scope */
  frame->slots[6] = myself->closure.frame->slots[2]; /* source */
  frame->slots[7] /* node_name */ = create_future();
  frame->slots[8] /* node */ = create_future();
  frame->slots[9] /* arguments */ = create_cell();
  frame->slots[10] /* initializers */ = create_cell();
  frame->slots[11] /* attributes_declaration */ = create_cell();
  frame->slots[12] /* constructor_name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1704: $node_name node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_143;
}
static void cont__compiler__define_c_code_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* node_name */, arguments->slots[0]);
  // 1705: $node defined_nodes(node_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* node_name */;
  result_count = 1;
  myself = get__defined_nodes();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_144;
}
static void cont__compiler__define_c_code_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* node */, arguments->slots[0]);
  // 1706: ... node.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* node */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_145;
}
static void cont__compiler__define_c_code_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1706: ... :
  // 1707:   Error "
  // 1708:     Missing definition for a node named "@(node_name)@quot;!@
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__define_c_code_146, 0);
  // 1706: unless node.is_defined:
  // 1707:   Error "
  // 1708:     Missing definition for a node named "@(node_name)@quot;!@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_150;
}
static void entry__compiler__define_c_code_146(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // node_name: 0
  frame->slots[0] = myself->closure.frame->slots[7]; /* node_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1707: ... "
  // 1708:   Missing definition for a node named "@(node_name)@quot;!@
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__b03fb6d3baf99607;
  arguments->slots[1] = frame->slots[0] /* node_name */;
  arguments->slots[2] = string__2d7981f4e6182be4;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_149;
}
static void cont__compiler__define_c_code_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1707: Error "
  // 1708:   Missing definition for a node named "@(node_name)@quot;!@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__Error();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_150(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1710: base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_151;
}
static void cont__compiler__define_c_code_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__2 */ = arguments->slots[0];
  // 1710: base_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[14] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_152;
}
static void cont__compiler__define_c_code_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1710: ... :
  // 1711:   initialize_object mangled_name true
  // 1712:   assign var_entry(mangled_name) base_of(self).to_c
  frame->slots[15] /* temp__3 */ = create_closure(entry__compiler__define_c_code_153, 0);
  // 1713: :
  // 1714:   initialize_object mangled_name
  frame->slots[16] /* temp__4 */ = create_closure(entry__compiler__define_c_code_158, 0);
  // 1709: if
  // 1710:   base_of(self).is_defined:
  // 1711:     initialize_object mangled_name true
  // 1712:     assign var_entry(mangled_name) base_of(self).to_c
  // 1713:   :
  // 1714:     initialize_object mangled_name
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[15] /* temp__3 */;
  arguments->slots[2] = frame->slots[16] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_159;
}
static void entry__compiler__define_c_code_153(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // initialize_object: 0
  // mangled_name: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* initialize_object */
  frame->slots[1] = myself->closure.frame->slots[2]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1711: initialize_object mangled_name true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  arguments->slots[1] = get__true();
  result_count = 0;
  myself = frame->slots[0] /* initialize_object */;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_154;
}
static void cont__compiler__define_c_code_154(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1712: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_155;
}
static void cont__compiler__define_c_code_155(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1712: ... base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_156;
}
static void cont__compiler__define_c_code_156(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1712: ... base_of(self).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_157;
}
static void cont__compiler__define_c_code_157(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1712: assign var_entry(mangled_name) base_of(self).to_c
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = func__assign;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_158(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // initialize_object: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* initialize_object */
  frame->slots[1] = myself->closure.frame->slots[2]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1714: initialize_object mangled_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mangled_name */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* initialize_object */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_159(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1715: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_160;
}
static void cont__compiler__define_c_code_160(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1715: ... :
  // 1716:   write_to_phase_3 "
  // 1717:     @
  // 1718:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1719:     get__@(mangled_name), &@(var_entry(mangled_name)));
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__define_c_code_161, 0);
  // 1715: if namespace.is_defined:
  // 1716:   write_to_phase_3 "
  // 1717:     @
  // 1718:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1719:     get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_164;
}
static void entry__compiler__define_c_code_161(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // namespace: 0
  // name: 1
  // mangled_name: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* namespace */
  frame->slots[1] = myself->closure.frame->slots[4]; /* name */
  frame->slots[2] = myself->closure.frame->slots[2]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1719: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_162;
}
static void cont__compiler__define_c_code_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1716: ... "
  // 1717:   @
  // 1718:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1719:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 9;
  arguments = node_p;
  arguments->slots[0] = string__b29ac022d5eddd84;
  arguments->slots[1] = frame->slots[0] /* namespace */;
  arguments->slots[2] = string__860afa4b5f607d1b;
  arguments->slots[3] = frame->slots[1] /* name */;
  arguments->slots[4] = string__65a4a8f6052de83f;
  arguments->slots[5] = frame->slots[2] /* mangled_name */;
  arguments->slots[6] = string__fa733415f296bea;
  arguments->slots[7] = frame->slots[4] /* temp__2 */;
  arguments->slots[8] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_163;
}
static void cont__compiler__define_c_code_163(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1716: write_to_phase_3 "
  // 1717:   @
  // 1718:     define_single_assign_static("@(namespace)", "@(name)", @
  // 1719:   get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_164(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1720: $$arguments ""
  ((CELL *)frame->slots[9])->contents /* arguments */ = empty_string;
  // 1721: $$initializers ""
  ((CELL *)frame->slots[10])->contents /* initializers */ = empty_string;
  // 1723: source_of(node)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* node */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_165;
}
static void cont__compiler__define_c_code_165(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1723: ... : ($line)
  // 1724:   truncate_from &line "//"
  // 1725:   normalize &line
  // 1726:   $field_type trim(truncate_behind(line alt(' ' '*') -1))
  // 1727:   
  // 1728:   $field_name
  // 1729:     trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  // 1730:   
  // 1731:   append &arguments field_type
  // 1732:   unless field_type .has_suffix. '*': push &arguments ' '
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__define_c_code_166, 1);
  // 1738: :
  // 1739:   append &arguments ", "
  frame->slots[15] /* temp__3 */ = create_closure(entry__compiler__define_c_code_189, 0);
  // 1722: for_each_line
  // 1723:   source_of(node): ($line)
  // 1724:     truncate_from &line "//"
  // 1725:     normalize &line
  // 1726:     $field_type trim(truncate_behind(line alt(' ' '*') -1))
  // 1727:     
  // 1728:     $field_name
  // 1729:       trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  // 1730:     
  // 1731:     append &arguments field_type
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__for_each_line();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_191;
}
static void entry__compiler__define_c_code_166(void) {
  allocate_initialized_frame_gc(4, 10);
  // slot allocations:
  // line: 0
  // arguments: 1
  // initializers: 2
  // node_name: 3
  // field_type: 4
  // field_name: 5
  frame->slots[1] = myself->closure.frame->slots[9]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[10]; /* initializers */
  frame->slots[3] = myself->closure.frame->slots[7]; /* node_name */
  frame->slots[4] /* field_type */ = create_future();
  frame->slots[5] /* field_name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* line */ = create_cell_with_contents(arguments->slots[0]);
  // 1724: truncate_from &line "//"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = string__2d7981f4e6702bea;
  result_count = 1;
  myself = get__truncate_from();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_167;
}
static void cont__compiler__define_c_code_167(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1725: normalize &line
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  result_count = 1;
  myself = get__normalize();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_168;
}
static void cont__compiler__define_c_code_168(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  // 1726: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_169;
}
static void cont__compiler__define_c_code_169(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1726: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_170;
}
static void cont__compiler__define_c_code_170(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 1726: ... truncate_behind(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__truncate_behind();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_171;
}
static void cont__compiler__define_c_code_171(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1726: $field_type trim(truncate_behind(line alt(' ' '*') -1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_172;
}
static void cont__compiler__define_c_code_172(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* field_type */, arguments->slots[0]);
  // 1729: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_173;
}
static void cont__compiler__define_c_code_173(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 1729: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_174;
}
static void cont__compiler__define_c_code_174(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__4 */ = arguments->slots[0];
  // 1729: ... truncate_until(line alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = 1;
  myself = get__truncate_until();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_175;
}
static void cont__compiler__define_c_code_175(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1729: ... truncate_until(line alt(' ' '*') -1) .without_suffix. ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__without_suffix();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_176;
}
static void cont__compiler__define_c_code_176(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1728: $field_name
  // 1729:   trim(truncate_until(line alt(' ' '*') -1) .without_suffix. ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__trim();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_177;
}
static void cont__compiler__define_c_code_177(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* field_name */, arguments->slots[0]);
  // 1731: append &arguments field_type
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = frame->slots[4] /* field_type */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_178;
}
static void cont__compiler__define_c_code_178(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* arguments */ = arguments->slots[0];
  // 1732: ... field_type .has_suffix. '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* field_type */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_179;
}
static void cont__compiler__define_c_code_179(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1732: ... : push &arguments ' '
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__define_c_code_180, 0);
  // 1732: unless field_type .has_suffix. '*': push &arguments ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_182;
}
static void entry__compiler__define_c_code_180(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1732: ... push &arguments ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_181;
}
static void cont__compiler__define_c_code_181(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_182(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1733: append &arguments field_name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = frame->slots[5] /* field_name */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_183;
}
static void cont__compiler__define_c_code_183(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* arguments */ = arguments->slots[0];
  // 1736: ... node_name.to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* node_name */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_184;
}
static void cont__compiler__define_c_code_184(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1734: ... "
  // 1735:   @
  // 1736:     node->@(node_name.to_lower_case).@(field_name) = @(field_name)@
  // 1737:   ;@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__6794ac9106bd681e;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9ccf;
  arguments->slots[3] = frame->slots[5] /* field_name */;
  arguments->slots[4] = string__fa730415fc16bec;
  arguments->slots[5] = frame->slots[5] /* field_name */;
  arguments->slots[6] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_187;
}
static void cont__compiler__define_c_code_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1734: write_to &initializers "
  // 1735:   @
  // 1736:     node->@(node_name.to_lower_case).@(field_name) = @(field_name)@
  // 1737:   ;@nl;@
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* initializers */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_188;
}
static void cont__compiler__define_c_code_188(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* initializers */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_189(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[9]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1739: append &arguments ", "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[1] = string__2d7981f4e6682be5;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_190;
}
static void cont__compiler__define_c_code_190(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_191(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1744: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_192;
}
static void cont__compiler__define_c_code_192(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1745: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_193;
}
static void cont__compiler__define_c_code_193(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__3 */ = arguments->slots[0];
  // 1745: ... node_of(self).to_lower_case
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__3 */;
  result_count = 1;
  myself = get__to_lower_case();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_194;
}
static void cont__compiler__define_c_code_194(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__2 */ = arguments->slots[0];
  // 1741: $$attributes_declaration "
  // 1742:   
  // 1743:   static VTABLE vtable__@(mangled_name) = {
  // 1744:     sizeof(@(node_of(self))),
  // 1745:     (COLLECTOR *)&collect_@(node_of(self).to_lower_case),
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__734b84c8aaa0637f;
  arguments->slots[1] = frame->slots[2] /* mangled_name */;
  arguments->slots[2] = string__6b4ef47674efbb78;
  arguments->slots[3] = frame->slots[13] /* temp__1 */;
  arguments->slots[4] = string__ff4aca011f98585e;
  arguments->slots[5] = frame->slots[14] /* temp__2 */;
  arguments->slots[6] = string__2d7981f4e6682bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_199;
}
static void cont__compiler__define_c_code_199(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[11])->contents /* attributes_declaration */ = arguments->slots[0];
  // 1748: ... : (entry)
  // 1749:   $func_name
  // 1750:     string
  // 1751:       if
  // 1752:         namespace.is_defined
  // 1753:         -> "@(namespace)::"
  // 1754:         -> ""
  // 1755:       name
  // 1756:       '/'
  // 1757:       entry
  // ...
  frame->slots[13] /* temp__1 */ = create_closure(entry__compiler__define_c_code_200, 1);
  // 1768: :
  // 1769:   append &attributes_declaration ",@nl;"
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__define_c_code_215, 0);
  // 1747: for_each
  // 1748:   vtable_entries: (entry)
  // 1749:     $func_name
  // 1750:       string
  // 1751:         if
  // 1752:           namespace.is_defined
  // 1753:           -> "@(namespace)::"
  // 1754:           -> ""
  // 1755:         name
  // 1756:         '/'
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__vtable_entries();
  arguments->slots[1] = frame->slots[13] /* temp__1 */;
  arguments->slots[2] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_217;
}
static void entry__compiler__define_c_code_208(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // attributes_declaration: 0
  // mangled_name: 1
  // entry: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* attributes_declaration */
  frame->slots[1] = myself->closure.frame->slots[4]; /* mangled_name */
  frame->slots[2] = myself->closure.frame->slots[0]; /* entry */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1761: write_to &attributes_declaration
  // 1762:   "  &func__"
  // 1763:   mangled_name
  // 1764:   "___"
  // 1765:   entry
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__73a8266fc3fa2cfa;
  arguments->slots[2] = frame->slots[1] /* mangled_name */;
  arguments->slots[3] = string__fa72f815cd16b93;
  arguments->slots[4] = frame->slots[2] /* entry */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_211;
}
static void cont__compiler__define_c_code_211(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_212(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // attributes_declaration: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* attributes_declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1767: append &attributes_declaration "  (void *)no_such_function"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__eaff60749c89e4cd;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_214;
}
static void cont__compiler__define_c_code_214(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_200(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // entry: 0
  // namespace: 1
  // name: 2
  // attributes_declaration: 3
  // mangled_name: 4
  // func_name: 5
  frame->slots[1] = myself->closure.frame->slots[3]; /* namespace */
  frame->slots[2] = myself->closure.frame->slots[4]; /* name */
  frame->slots[3] = myself->closure.frame->slots[11]; /* attributes_declaration */
  frame->slots[4] = myself->closure.frame->slots[2]; /* mangled_name */
  frame->slots[5] /* func_name */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1752: namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_201;
}
static void cont__compiler__define_c_code_201(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1753: -> "@(namespace)::"
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__define_c_code_202, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = func__compiler__define_c_code_204;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_205;
}
static void entry__compiler__define_c_code_202(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // namespace: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* namespace */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1753: ... "@(namespace)::"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* namespace */;
  arguments->slots[1] = string__2d7981f4e6d82bff;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_203;
}
static void cont__compiler__define_c_code_203(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1753: -> "@(namespace)::"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_204(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1754: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_205(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1749: $func_name
  // 1750:   string
  // 1751:     if
  // 1752:       namespace.is_defined
  // 1753:       -> "@(namespace)::"
  // 1754:       -> ""
  // 1755:     name
  // 1756:     '/'
  // 1757:     entry
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* name */;
  arguments->slots[2] = character__47;
  arguments->slots[3] = frame->slots[0] /* entry */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_206;
}
static void cont__compiler__define_c_code_206(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* func_name */, arguments->slots[0]);
  // 1760: defined_functions(func_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* func_name */;
  result_count = 1;
  myself = get__defined_functions();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_207;
}
static void cont__compiler__define_c_code_207(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1760: ... :
  // 1761:   write_to &attributes_declaration
  // 1762:     "  &func__"
  // 1763:     mangled_name
  // 1764:     "___"
  // 1765:     entry
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__define_c_code_208, 0);
  // 1766: :
  // 1767:   append &attributes_declaration "  (void *)no_such_function"
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__define_c_code_212, 0);
  // 1759: if
  // 1760:   defined_functions(func_name):
  // 1761:     write_to &attributes_declaration
  // 1762:       "  &func__"
  // 1763:       mangled_name
  // 1764:       "___"
  // 1765:       entry
  // 1766:   :
  // 1767:     append &attributes_declaration "  (void *)no_such_function"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_215(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // attributes_declaration: 0
  frame->slots[0] = myself->closure.frame->slots[11]; /* attributes_declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1769: append &attributes_declaration ",@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__2d7981f4e6682bcf;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_216;
}
static void cont__compiler__define_c_code_216(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_217(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1770: append &attributes_declaration "
  // 1771:   
  // 1772:   };
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* attributes_declaration */;
  arguments->slots[1] = string__d60aee0b5fb87d33;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_218;
}
static void cont__compiler__define_c_code_218(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[11])->contents /* attributes_declaration */ = arguments->slots[0];
  // 1774: mangled_name == "types__undefined"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mangled_name */;
  arguments->slots[1] = string__cd95367056669d06;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_220;
}
static void cont__compiler__define_c_code_220(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1774: ... :
  // 1775:   append &attributes_declaration "
  // 1776:     
  // 1777:     static ATTRIBUTES attributes__types__undefined = {
  // 1778:       &vtable__types__undefined,
  // 1779:       {
  // 1780:         &no_attributes_level_1, &no_attributes_level_2,
  // 1781:         &no_attributes_level_3, &no_attributes_level_4,
  // 1782:         &no_attributes_level_5, &no_attributes_level_6,
  // 1783:         &no_attributes_level_7
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__define_c_code_221, 0);
  // 1786: :
  // 1787:   append &attributes_declaration "
  // 1788:     
  // 1789:     static ATTRIBUTES attributes__@(mangled_name) = {
  // 1790:       &vtable__@(mangled_name),
  // 1791:       {
  // 1792:         &undefined_attributes_level_1, &undefined_attributes_level_2,
  // 1793:         &undefined_attributes_level_3, &undefined_attributes_level_4,
  // 1794:         &undefined_attributes_level_5, &undefined_attributes_level_6,
  // 1795:         &undefined_attributes_level_7
  // ...
  frame->slots[15] /* temp__3 */ = create_closure(entry__compiler__define_c_code_224, 0);
  // 1773: if
  // 1774:   mangled_name == "types__undefined":
  // 1775:     append &attributes_declaration "
  // 1776:       
  // 1777:       static ATTRIBUTES attributes__types__undefined = {
  // 1778:         &vtable__types__undefined,
  // 1779:         {
  // 1780:           &no_attributes_level_1, &no_attributes_level_2,
  // 1781:           &no_attributes_level_3, &no_attributes_level_4,
  // 1782:           &no_attributes_level_5, &no_attributes_level_6,
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_230;
}
static void entry__compiler__define_c_code_221(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // attributes_declaration: 0
  frame->slots[0] = myself->closure.frame->slots[11]; /* attributes_declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1775: append &attributes_declaration "
  // 1776:   
  // 1777:   static ATTRIBUTES attributes__types__undefined = {
  // 1778:     &vtable__types__undefined,
  // 1779:     {
  // 1780:       &no_attributes_level_1, &no_attributes_level_2,
  // 1781:       &no_attributes_level_3, &no_attributes_level_4,
  // 1782:       &no_attributes_level_5, &no_attributes_level_6,
  // 1783:       &no_attributes_level_7
  // 1784:     }
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = string__c94100bb7a7ab992;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_223;
}
static void cont__compiler__define_c_code_223(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_224(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // attributes_declaration: 0
  // mangled_name: 1
  frame->slots[0] = myself->closure.frame->slots[11]; /* attributes_declaration */
  frame->slots[1] = myself->closure.frame->slots[2]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1787: ... "
  // 1788:   
  // 1789:   static ATTRIBUTES attributes__@(mangled_name) = {
  // 1790:     &vtable__@(mangled_name),
  // 1791:     {
  // 1792:       &undefined_attributes_level_1, &undefined_attributes_level_2,
  // 1793:       &undefined_attributes_level_3, &undefined_attributes_level_4,
  // 1794:       &undefined_attributes_level_5, &undefined_attributes_level_6,
  // 1795:       &undefined_attributes_level_7
  // 1796:     }
  // ...
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__a56c0e191d6c2c6;
  arguments->slots[1] = frame->slots[1] /* mangled_name */;
  arguments->slots[2] = string__2fd6cd588445ce22;
  arguments->slots[3] = frame->slots[1] /* mangled_name */;
  arguments->slots[4] = string__b0750f892a4c2658;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_228;
}
static void cont__compiler__define_c_code_228(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1787: append &attributes_declaration "
  // 1788:   
  // 1789:   static ATTRIBUTES attributes__@(mangled_name) = {
  // 1790:     &vtable__@(mangled_name),
  // 1791:     {
  // 1792:       &undefined_attributes_level_1, &undefined_attributes_level_2,
  // 1793:       &undefined_attributes_level_3, &undefined_attributes_level_4,
  // 1794:       &undefined_attributes_level_5, &undefined_attributes_level_6,
  // 1795:       &undefined_attributes_level_7
  // 1796:     }
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* attributes_declaration */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_229;
}
static void cont__compiler__define_c_code_229(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* attributes_declaration */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_230(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1798: write attributes_declaration
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* attributes_declaration */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_231;
}
static void cont__compiler__define_c_code_231(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1800: "  collect_static_attributes(&attributes__@(mangled_name));@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__7ddeab9420211acf;
  arguments->slots[1] = frame->slots[2] /* mangled_name */;
  arguments->slots[2] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_233;
}
static void cont__compiler__define_c_code_233(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1799: write_to_generated_collections
  // 1800:   "  collect_static_attributes(&attributes__@(mangled_name));@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_234;
}
static void cont__compiler__define_c_code_234(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1803: ... source.converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* source */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_235;
}
static void cont__compiler__define_c_code_235(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__3 */ = arguments->slots[0];
  // 1803: ... indented(2 source.converted)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[15] /* temp__3 */;
  result_count = 1;
  myself = get__indented();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_236;
}
static void cont__compiler__define_c_code_236(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__2 */ = arguments->slots[0];
  // 1801: ... "
  // 1802:   @nl;@(scope)void type__@(mangled_name)(void) {
  // 1803:   @(indented(2 source.converted))@nl;}
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9ceb;
  arguments->slots[1] = frame->slots[5] /* scope */;
  arguments->slots[2] = string__21dd4811a7f03bfa;
  arguments->slots[3] = frame->slots[2] /* mangled_name */;
  arguments->slots[4] = string__fc8c36a84adb366f;
  arguments->slots[5] = frame->slots[14] /* temp__2 */;
  arguments->slots[6] = string__fa73ac15dc16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_238;
}
static void cont__compiler__define_c_code_238(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1801: write "
  // 1802:   @nl;@(scope)void type__@(mangled_name)(void) {
  // 1803:   @(indented(2 source.converted))@nl;}
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_239;
}
static void cont__compiler__define_c_code_239(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1804: $constructor_name "create__@(mangled_name)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__46dcac94852d801f;
  arguments->slots[1] = frame->slots[2] /* mangled_name */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_241;
}
static void cont__compiler__define_c_code_241(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[12] /* constructor_name */, arguments->slots[0]);
  // 1805: ... defined_functions(constructor_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* constructor_name */;
  result_count = 1;
  myself = get__defined_functions();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_242;
}
static void cont__compiler__define_c_code_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 1805: ... :
  // 1806:   write_to_declarations
  // 1807:     "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  // 1808:   if
  // 1809:     node_name == "SIMPLE_NODE":
  // 1810:       write "
  // 1811:         SIMPLE_NODE @(mangled_name)__node =
  // 1812:           {
  // 1813:             type__@(mangled_name),
  // 1814:             &attributes__@(mangled_name)
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__define_c_code_243, 0);
  // 1805: unless defined_functions(constructor_name):
  // 1806:   write_to_declarations
  // 1807:     "@(scope)NODE *@(constructor_name)(@(arguments));@nl;"
  // 1808:   if
  // 1809:     node_name == "SIMPLE_NODE":
  // 1810:       write "
  // 1811:         SIMPLE_NODE @(mangled_name)__node =
  // 1812:           {
  // 1813:             type__@(mangled_name),
  // 1814:             &attributes__@(mangled_name)
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_263(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // initialize_object: 0
  // type: 1
  // namespace: 2
  // name: 3
  // mangled_name: 4
  frame->slots[0] = myself->closure.frame->slots[9]; /* initialize_object */
  frame->slots[1] = myself->closure.frame->slots[8]; /* type */
  frame->slots[2] = myself->closure.frame->slots[5]; /* namespace */
  frame->slots[3] = myself->closure.frame->slots[6]; /* name */
  frame->slots[4] = myself->closure.frame->slots[7]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1829: initialize_object type
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* type */;
  result_count = 0;
  myself = frame->slots[0] /* initialize_object */;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_264;
}
static void cont__compiler__define_c_code_264(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1830: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_265;
}
static void cont__compiler__define_c_code_265(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1830: ... :
  // 1831:   write_to_phase_3 "
  // 1832:     @
  // 1833:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1834:     get__@(mangled_name), &@(var_entry(mangled_name)));
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__define_c_code_266, 0);
  // 1830: if namespace.is_defined:
  // 1831:   write_to_phase_3 "
  // 1832:     @
  // 1833:       define_single_assign_static("@(namespace)", "@(name)", @
  // 1834:     get__@(mangled_name), &@(var_entry(mangled_name)));
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_269(void) {
  allocate_initialized_frame_gc(3, 15);
  // slot allocations:
  // source: 0
  // self: 1
  // scope: 2
  // raw_declaration: 3
  // type_and_name: 4
  // function_name: 5
  // mangled_function_name: 6
  // function_type: 7
  // arguments: 8
  // declaration: 9
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* scope */
  frame->slots[3] /* raw_declaration */ = create_future();
  frame->slots[4] /* type_and_name */ = create_future();
  frame->slots[5] /* function_name */ = create_future();
  frame->slots[6] /* mangled_function_name */ = create_future();
  frame->slots[7] /* function_type */ = create_future();
  frame->slots[8] /* arguments */ = create_future();
  frame->slots[9] /* declaration */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1836: $raw_declaration source .until. ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__until();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_270;
}
static void cont__compiler__define_c_code_270(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* raw_declaration */, arguments->slots[0]);
  // 1837: $type_and_name raw_declaration .before. '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* raw_declaration */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__before();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_271;
}
static void cont__compiler__define_c_code_271(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* type_and_name */, arguments->slots[0]);
  // 1838: ... alt(' ' '*')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_272;
}
static void cont__compiler__define_c_code_272(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1838: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_273;
}
static void cont__compiler__define_c_code_273(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1838: $function_name behind(type_and_name alt(' ' '*') -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* type_and_name */;
  arguments->slots[1] = frame->slots[10] /* temp__1 */;
  arguments->slots[2] = frame->slots[11] /* temp__2 */;
  result_count = 1;
  myself = get__behind();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_274;
}
static void cont__compiler__define_c_code_274(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* function_name */, arguments->slots[0]);
  // 1842: scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_275;
}
static void cont__compiler__define_c_code_275(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1842: scope_of(self) == "runtime"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = string__9a4c0f9815d2209f;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_276;
}
static void cont__compiler__define_c_code_276(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1843: -> string("runtime__" function_name)
  frame->slots[12] /* temp__3 */ = create_closure(entry__compiler__define_c_code_277, 0);
  // 1844: -> function_name
  frame->slots[13] /* temp__4 */ = create_closure(entry__compiler__define_c_code_280, 0);
  // 1840: $mangled_function_name
  // 1841:   if
  // 1842:     scope_of(self) == "runtime"
  // 1843:     -> string("runtime__" function_name)
  // 1844:     -> function_name
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__3 */;
  arguments->slots[2] = frame->slots[13] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_281;
}
static void entry__compiler__define_c_code_277(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // function_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* function_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1843: ... string("runtime__" function_name)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__748827e691fbe65a;
  arguments->slots[1] = frame->slots[0] /* function_name */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_279;
}
static void cont__compiler__define_c_code_279(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1843: -> string("runtime__" function_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_280(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // function_name: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* function_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1844: -> function_name
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* function_name */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_281(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* mangled_function_name */, arguments->slots[0]);
  // 1846: ... length_of(function_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* function_name */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_282;
}
static void cont__compiler__define_c_code_282(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__3 */ = arguments->slots[0];
  // 1846: ... length_of(function_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__3 */;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_283;
}
static void cont__compiler__define_c_code_283(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1846: ... length_of(function_name)-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_284;
}
static void cont__compiler__define_c_code_284(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1846: $function_type range(type_and_name 1 -length_of(function_name)-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* type_and_name */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[10] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_285;
}
static void cont__compiler__define_c_code_285(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* function_type */, arguments->slots[0]);
  // 1847: $arguments raw_declaration .from. '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* raw_declaration */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__from();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_286;
}
static void cont__compiler__define_c_code_286(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* arguments */, arguments->slots[0]);
  // 1853: function_name .contains. "::"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* function_name */;
  arguments->slots[1] = string__2d7981f4e6d82bff;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_287;
}
static void cont__compiler__define_c_code_287(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = func__compiler__define_c_code_288;
  arguments->slots[2] = func__compiler__define_c_code_289;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_290;
}
static void entry__compiler__define_c_code_288(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1854: -> "func__"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__441f568380430288;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_289(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1855: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_290(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1856: ... "::" = "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6d82bff;
  arguments->slots[1] = string__2d7981f4e5f02b9a;
  result_count = 1;
  myself = get__std__key_value_pair();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_291;
}
static void cont__compiler__define_c_code_291(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__4 */ = arguments->slots[0];
  // 1856: ... '/' = "___"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__47;
  arguments->slots[1] = string__fa72f815cd16b93;
  result_count = 1;
  myself = get__std__key_value_pair();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_292;
}
static void cont__compiler__define_c_code_292(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__5 */ = arguments->slots[0];
  // 1856: replace_all(mangled_function_name "::" = "__" '/' = "___")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* mangled_function_name */;
  arguments->slots[1] = frame->slots[13] /* temp__4 */;
  arguments->slots[2] = frame->slots[14] /* temp__5 */;
  result_count = 1;
  myself = get__replace_all();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_293;
}
static void cont__compiler__define_c_code_293(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__3 */ = arguments->slots[0];
  // 1849: $declaration
  // 1850:   string
  // 1851:     function_type
  // 1852:     if
  // 1853:       function_name .contains. "::"
  // 1854:       -> "func__"
  // 1855:       -> ""
  // 1856:     replace_all(mangled_function_name "::" = "__" '/' = "___")
  // 1857:     arguments
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* function_type */;
  arguments->slots[1] = frame->slots[10] /* temp__1 */;
  arguments->slots[2] = frame->slots[12] /* temp__3 */;
  arguments->slots[3] = frame->slots[8] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_294;
}
static void cont__compiler__define_c_code_294(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[9] /* declaration */, arguments->slots[0]);
  // 1860: scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_295;
}
static void cont__compiler__define_c_code_295(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1860: scope_of(self) == "runtime"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = string__9a4c0f9815d2209f;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_296;
}
static void cont__compiler__define_c_code_296(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1860: ... :
  // 1861:   write_to_phase_1 "
  // 1862:     @
  // 1863:       define_c_function("@(function_name)@quot;, @
  // 1864:     @(mangled_function_name));
  frame->slots[12] /* temp__3 */ = create_closure(entry__compiler__define_c_code_297, 0);
  // 1865: :
  // 1866:   write_to_declarations "@nl;@(scope)@(declaration);@nl;"
  frame->slots[13] /* temp__4 */ = create_closure(entry__compiler__define_c_code_300, 0);
  // 1859: if
  // 1860:   scope_of(self) == "runtime":
  // 1861:     write_to_phase_1 "
  // 1862:       @
  // 1863:         define_c_function("@(function_name)@quot;, @
  // 1864:       @(mangled_function_name));
  // 1865:   :
  // 1866:     write_to_declarations "@nl;@(scope)@(declaration);@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__3 */;
  arguments->slots[2] = frame->slots[13] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_302;
}
static void entry__compiler__define_c_code_297(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // function_name: 0
  // mangled_function_name: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* function_name */
  frame->slots[1] = myself->closure.frame->slots[6]; /* mangled_function_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1861: ... "
  // 1862:   @
  // 1863:     define_c_function("@(function_name)@quot;, @
  // 1864:   @(mangled_function_name));
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__3d3ee41dbe82cf11;
  arguments->slots[1] = frame->slots[0] /* function_name */;
  arguments->slots[2] = string__fa730c15f496bec;
  arguments->slots[3] = frame->slots[1] /* mangled_function_name */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_299;
}
static void cont__compiler__define_c_code_299(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1861: write_to_phase_1 "
  // 1862:   @
  // 1863:     define_c_function("@(function_name)@quot;, @
  // 1864:   @(mangled_function_name));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_1();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_300(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // scope: 0
  // declaration: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* scope */
  frame->slots[1] = myself->closure.frame->slots[9]; /* declaration */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1866: ... "@nl;@(scope)@(declaration);@nl;"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9ceb;
  arguments->slots[1] = frame->slots[0] /* scope */;
  arguments->slots[2] = frame->slots[1] /* declaration */;
  arguments->slots[3] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_301;
}
static void cont__compiler__define_c_code_301(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1866: write_to_declarations "@nl;@(scope)@(declaration);@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_302(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1867: ... source .behind. ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__behind();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_303;
}
static void cont__compiler__define_c_code_303(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__3 */ = arguments->slots[0];
  // 1867: ... source .behind. ')').converted
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__3 */;
  result_count = 1;
  myself = get__converted();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_304;
}
static void cont__compiler__define_c_code_304(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1867: ... "@nl;@(scope)@(declaration)@((source .behind. ')').converted)@nl;"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9ceb;
  arguments->slots[1] = frame->slots[2] /* scope */;
  arguments->slots[2] = frame->slots[9] /* declaration */;
  arguments->slots[3] = frame->slots[11] /* temp__2 */;
  arguments->slots[4] = string__578a5af303e9ceb;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_305;
}
static void cont__compiler__define_c_code_305(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1867: write "@nl;@(scope)@(declaration)@((source .behind. ')').converted)@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_306(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // source: 0
  // scope: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* source */
  frame->slots[1] = myself->closure.frame->slots[3]; /* scope */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1869: write_to_declarations '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__10;
  result_count = 0;
  myself = get__write_to_declarations();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_307;
}
static void cont__compiler__define_c_code_307(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1870: ... : (line)
  // 1871:   if line .has_suffix. ';' && line(1) > ' ':
  // 1872:     unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1873:       write_to_declarations scope
  // 1874:   write_to_declarations line.converted '@nl;'
  frame->slots[2] /* temp__1 */ = create_closure(entry__compiler__define_c_code_308, 1);
  // 1870: for_each_line source: (line)
  // 1871:   if line .has_suffix. ';' && line(1) > ' ':
  // 1872:     unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1873:       write_to_declarations scope
  // 1874:   write_to_declarations line.converted '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_line();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_321(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // kind: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* kind */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1876: ... "
  // 1877:   Unknown kind ("@(kind)") in C-code declaration!@
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__dc390a4415e8342c;
  arguments->slots[1] = frame->slots[0] /* kind */;
  arguments->slots[2] = string__3cadee4d21d69e73;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_324;
}
static void cont__compiler__define_c_code_324(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1876: Error "
  // 1877:   Unknown kind ("@(kind)") in C-code declaration!@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__Error();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_4(void) {
  allocate_initialized_frame_gc(1, 17);
  // slot allocations:
  // self: 0
  // kind: 1
  // source: 2
  // scope: 3
  // identifier: 4
  // namespace: 5
  // name: 6
  // mangled_name: 7
  // type: 8
  // initialize_object: 9
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[9] /* initialize_object */ = create_future();
  frame->slots[1] /* kind */ = create_future();
  frame->slots[2] /* source */ = create_future();
  frame->slots[3] /* scope */ = create_future();
  frame->slots[4] /* identifier */ = create_future();
  frame->slots[5] /* namespace */ = create_future();
  frame->slots[6] /* name */ = create_future();
  frame->slots[7] /* mangled_name */ = create_future();
  frame->slots[8] /* type */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1615: ... :
  // 1616:   (
  // 1617:     obj_type
  // 1618:     as_a_future = false
  // 1619:   )
  // 1620:   $$arguments ""
  // 1621:   for_each
  // 1622:     arguments_of(self): (argument)
  // 1623:       write_to &arguments argument
  // 1624:     :
  // ...
  frame->slots[10] /* temp__1 */ = create_closure(entry__compiler__define_c_code_5, -1);
  // 1615: $initialize_object:
  // 1616:   (
  // 1617:     obj_type
  // 1618:     as_a_future = false
  // 1619:   )
  // 1620:   $$arguments ""
  // 1621:   for_each
  // 1622:     arguments_of(self): (argument)
  // 1623:       write_to &arguments argument
  // 1624:     :
  // ...
  initialize_future(frame->slots[9] /* initialize_object */, frame->slots[10] /* temp__1 */);
  // 1575: $kind kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__kind_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_39;
}
static void entry__compiler__define_c_code_35(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1652: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_36;
}
static void cont__compiler__define_c_code_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1650: ... "
  // 1651:   static NODE *get__@(mangled_name)(void) {
  // 1652:     return @(var_entry(mangled_name));
  // 1653:   }
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__55b34e50e74b4c7c;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__327b6356c2c20676;
  arguments->slots[3] = frame->slots[2] /* temp__2 */;
  arguments->slots[4] = string__b40af3cb5d887d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_38;
}
static void cont__compiler__define_c_code_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1650: write_to_declarations "
  // 1651:   static NODE *get__@(mangled_name)(void) {
  // 1652:     return @(var_entry(mangled_name));
  // 1653:   }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_5(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // obj_type: 0
  // as_a_future: 1
  // self: 2
  // mangled_name: 3
  // namespace: 4
  // arguments: 5
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[7]; /* mangled_name */
  frame->slots[4] = myself->closure.frame->slots[5]; /* namespace */
  frame->slots[5] /* arguments */ = create_cell();
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 2) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[1] /* as_a_future */ = arguments->slots[1];
    case 1:;
  }
  switch(argument_count) {
    case 1: frame->slots[1] /* as_a_future */ = get__false();
  }
  // 1620: $$arguments ""
  ((CELL *)frame->slots[5])->contents /* arguments */ = empty_string;
  // 1622: arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_6;
}
static void cont__compiler__define_c_code_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1622: ... : (argument)
  // 1623:   write_to &arguments argument
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__define_c_code_7, 1);
  // 1624: :
  // 1625:   append &arguments ", "
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__define_c_code_9, 0);
  // 1621: for_each
  // 1622:   arguments_of(self): (argument)
  // 1623:     write_to &arguments argument
  // 1624:   :
  // 1625:     append &arguments ", "
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_11;
}
static void entry__compiler__define_c_code_7(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // argument: 0
  // arguments: 1
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1623: write_to &arguments argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* arguments */;
  arguments->slots[1] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_8;
}
static void cont__compiler__define_c_code_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_9(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1625: append &arguments ", "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* arguments */;
  arguments->slots[1] = string__2d7981f4e6682be5;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_10;
}
static void cont__compiler__define_c_code_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_11(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1627: mangled_name .contains. "__"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  arguments->slots[1] = string__2d7981f4e5f02b9a;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_12;
}
static void cont__compiler__define_c_code_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1627: ... :
  // 1628:   write_to_global_variable_declarations
  // 1629:     string("  NODE *" mangled_name ";@nl;")
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__define_c_code_13, 0);
  // 1630: :
  // 1631:   write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1632:   write_to_top_level_variable_declarations
  // 1633:     string("  NODE *" var_name(mangled_name) ";@nl;")
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__define_c_code_15, 0);
  // 1626: if
  // 1627:   mangled_name .contains. "__":
  // 1628:     write_to_global_variable_declarations
  // 1629:       string("  NODE *" mangled_name ";@nl;")
  // 1630:   :
  // 1631:     write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  // 1632:     write_to_top_level_variable_declarations
  // 1633:       string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_20;
}
static void entry__compiler__define_c_code_13(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1629: string("  NODE *" mangled_name ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_14;
}
static void cont__compiler__define_c_code_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1628: write_to_global_variable_declarations
  // 1629:   string("  NODE *" mangled_name ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_global_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_15(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // mangled_name: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1631: ... "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__fa730415f296bee;
  arguments->slots[1] = frame->slots[0] /* mangled_name */;
  arguments->slots[2] = string__fa730c15f496bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_16;
}
static void cont__compiler__define_c_code_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1631: write_to_top_level_variable_names "  @quot;@(mangled_name)@quot;,@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_top_level_variable_names();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_17;
}
static void cont__compiler__define_c_code_17(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1633: ... var_name(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_name;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_18;
}
static void cont__compiler__define_c_code_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1633: string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2794a48106d7680a;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_19;
}
static void cont__compiler__define_c_code_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1632: write_to_top_level_variable_declarations
  // 1633:   string("  NODE *" var_name(mangled_name) ";@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_top_level_variable_declarations();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_20(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1636: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_21;
}
static void cont__compiler__define_c_code_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1636: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_22;
}
static void cont__compiler__define_c_code_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__3 */ = arguments->slots[0];
  // 1634: ... "
  // 1635:   @
  // 1636:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1637:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = string__29d4ac87c65f0ce6;
  arguments->slots[3] = frame->slots[8] /* temp__3 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_23;
}
static void cont__compiler__define_c_code_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1634: write_to_generated_collections "
  // 1635:   @
  // 1636:     @(var_entry(mangled_name)) = collect_node(@(var_entry(mangled_name))@
  // 1637:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__write_to_generated_collections();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_24;
}
static void cont__compiler__define_c_code_24(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1639: ... :
  // 1640:   write_to_phase_3 "
  // 1641:     @
  // 1642:       @(var_entry(mangled_name)) = @
  // 1643:     create_future_with_prototype(create__@(obj_type)(@(arguments)));
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__define_c_code_25, 0);
  // 1644: :
  // 1645:   write_to_phase_3 "
  // 1646:     @
  // 1647:       @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // 1648:     );@nl;@
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__define_c_code_29, 0);
  // 1638: if
  // 1639:   as_a_future:
  // 1640:     write_to_phase_3 "
  // 1641:       @
  // 1642:         @(var_entry(mangled_name)) = @
  // 1643:       create_future_with_prototype(create__@(obj_type)(@(arguments)));
  // 1644:   :
  // 1645:     write_to_phase_3 "
  // 1646:       @
  // 1647:         @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* as_a_future */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_33;
}
static void entry__compiler__define_c_code_25(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // obj_type: 1
  // arguments: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* obj_type */
  frame->slots[2] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1642: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_26;
}
static void cont__compiler__define_c_code_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1640: ... "
  // 1641:   @
  // 1642:     @(var_entry(mangled_name)) = @
  // 1643:   create_future_with_prototype(create__@(obj_type)(@(arguments)));
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__ed193cb4814526fb;
  arguments->slots[3] = frame->slots[1] /* obj_type */;
  arguments->slots[4] = string__578a5af303e9cc9;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[6] = string__900afb0b5fb87d33;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_28;
}
static void cont__compiler__define_c_code_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1640: write_to_phase_3 "
  // 1641:   @
  // 1642:     @(var_entry(mangled_name)) = @
  // 1643:   create_future_with_prototype(create__@(obj_type)(@(arguments)));
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code_29(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // mangled_name: 0
  // obj_type: 1
  // arguments: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* mangled_name */
  frame->slots[1] = myself->closure.frame->slots[0]; /* obj_type */
  frame->slots[2] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1647: ... var_entry(mangled_name)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mangled_name */;
  result_count = 1;
  myself = func__var_entry;
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_30;
}
static void cont__compiler__define_c_code_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1645: ... "
  // 1646:   @
  // 1647:     @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // 1648:   );@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__a897d8196ef1bb0f;
  arguments->slots[3] = frame->slots[1] /* obj_type */;
  arguments->slots[4] = string__578a5af303e9cc9;
  arguments->slots[5] = ((CELL *)frame->slots[2])->contents /* arguments */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_32;
}
static void cont__compiler__define_c_code_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1645: write_to_phase_3 "
  // 1646:   @
  // 1647:     @(var_entry(mangled_name)) = create__@(obj_type)(@(arguments)@
  // 1648:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write_to_phase_3();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_33(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1649: ... namespace.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* namespace */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_34;
}
static void cont__compiler__define_c_code_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1649: ... :
  // 1650:   write_to_declarations "
  // 1651:     static NODE *get__@(mangled_name)(void) {
  // 1652:       return @(var_entry(mangled_name));
  // 1653:     }
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__define_c_code_35, 0);
  // 1649: if namespace.is_defined:
  // 1650:   write_to_declarations "
  // 1651:     static NODE *get__@(mangled_name)(void) {
  // 1652:       return @(var_entry(mangled_name));
  // 1653:     }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_c_code_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* kind */, arguments->slots[0]);
  // 1576: $source source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_40;
}
static void cont__compiler__define_c_code_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* source */, arguments->slots[0]);
  // 1580: scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_41;
}
static void cont__compiler__define_c_code_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1578: $scope
  // 1579:   case
  // 1580:     scope_of(self)
  // 1581:     "runtime"
  // 1582:     -> ""
  // 1583:     "global"
  // 1584:     -> ""
  // 1585:     "extern"
  // 1586:     -> "extern "
  // 1587:     -> "static "
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = string__9a4c0f9815d2209f;
  arguments->slots[2] = func__compiler__define_c_code_43;
  arguments->slots[3] = string__461f56c301b292bb;
  arguments->slots[4] = func__compiler__define_c_code_45;
  arguments->slots[5] = string__701f5702012bd2b9;
  arguments->slots[6] = func__compiler__define_c_code_47;
  arguments->slots[7] = func__compiler__define_c_code_49;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_51;
}
static void entry__compiler__define_c_code_43(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1582: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_45(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1584: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_47(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1586: -> "extern "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__b810095e95cb80da;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_49(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1587: -> "static "
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__9a480f9895a2d0da;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* scope */, arguments->slots[0]);
  // 1589: $identifier identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_52;
}
static void cont__compiler__define_c_code_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* identifier */, arguments->slots[0]);
  // 1593: identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_53;
}
static void cont__compiler__define_c_code_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1594: -> namespace_of(identifier)
  frame->slots[11] /* temp__2 */ = create_closure(entry__compiler__define_c_code_54, 0);
  // 1591: $namespace
  // 1592:   if
  // 1593:     identifier.is_defined
  // 1594:     -> namespace_of(identifier)
  // 1595:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__2 */;
  arguments->slots[2] = func__compiler__define_c_code_56;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_57;
}
static void entry__compiler__define_c_code_54(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // identifier: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* identifier */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1594: ... namespace_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* identifier */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_55;
}
static void cont__compiler__define_c_code_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1594: -> namespace_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_56(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1595: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* namespace */, arguments->slots[0]);
  // 1599: identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_58;
}
static void cont__compiler__define_c_code_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1600: -> name_of(identifier)
  frame->slots[11] /* temp__2 */ = create_closure(entry__compiler__define_c_code_59, 0);
  // 1597: $name
  // 1598:   if
  // 1599:     identifier.is_defined
  // 1600:     -> name_of(identifier)
  // 1601:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__2 */;
  arguments->slots[2] = func__compiler__define_c_code_61;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_62;
}
static void entry__compiler__define_c_code_59(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // identifier: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* identifier */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1600: ... name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* identifier */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_60;
}
static void cont__compiler__define_c_code_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1600: -> name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_61(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1601: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* name */, arguments->slots[0]);
  // 1605: identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_63;
}
static void cont__compiler__define_c_code_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1606: -> mangled_name_of(identifier_of(self))
  frame->slots[11] /* temp__2 */ = create_closure(entry__compiler__define_c_code_64, 0);
  // 1603: $mangled_name
  // 1604:   if
  // 1605:     identifier.is_defined
  // 1606:     -> mangled_name_of(identifier_of(self))
  // 1607:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__2 */;
  arguments->slots[2] = func__compiler__define_c_code_67;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_68;
}
static void entry__compiler__define_c_code_64(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1606: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_65;
}
static void cont__compiler__define_c_code_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1606: ... mangled_name_of(identifier_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_66;
}
static void cont__compiler__define_c_code_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1606: -> mangled_name_of(identifier_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_67(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1607: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* mangled_name */, arguments->slots[0]);
  // 1611: node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_69;
}
static void cont__compiler__define_c_code_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 1611: node::type_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_70;
}
static void cont__compiler__define_c_code_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 1612: -> mangled_name_of(node::type_of(self))
  frame->slots[12] /* temp__3 */ = create_closure(entry__compiler__define_c_code_71, 0);
  // 1609: $type
  // 1610:   if
  // 1611:     node::type_of(self).is_defined
  // 1612:     -> mangled_name_of(node::type_of(self))
  // 1613:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__3 */;
  arguments->slots[2] = func__compiler__define_c_code_74;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_75;
}
static void entry__compiler__define_c_code_71(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1612: ... node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_72;
}
static void cont__compiler__define_c_code_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1612: ... mangled_name_of(node::type_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_73;
}
static void cont__compiler__define_c_code_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1612: -> mangled_name_of(node::type_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_c_code_74(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1613: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_c_code_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* type */, arguments->slots[0]);
  // 1657: ... :
  // 1658:   write_to_declarations "
  // 1659:     
  // 1660:     typedef struct @(mangled_name) @(mangled_name);
  // 1661:     struct @(mangled_name) {@nl;@(indented(2 source))
  // 1662:     };
  frame->slots[10] /* temp__1 */ = create_closure(entry__compiler__define_c_code_76, 0);
  // 1663: ... :
  // 1664:   write_to_declarations "
  // 1665:     
  // 1666:     typedef struct {
  // 1667:       void *type;
  // 1668:       ATTRIBUTES *attributes;
  // 1669:     @(indented(2 source))@nl;} @(mangled_name);
  // 1670:   $collector_name "collect_@(mangled_name.to_lower_case)"
  // 1671:   unless defined_functions(collector_name):
  // 1672:     write "
  // ...
  frame->slots[11] /* temp__2 */ = create_closure(entry__compiler__define_c_code_83, 0);
  // 1703: ... :
  // 1704:   $node_name node_of(self)
  // 1705:   $node defined_nodes(node_name)
  // 1706:   unless node.is_defined:
  // 1707:     Error "
  // 1708:       Missing definition for a node named "@(node_name)@quot;!@
  // 1709:   if
  // 1710:     base_of(self).is_defined:
  // 1711:       initialize_object mangled_name true
  // 1712:       assign var_entry(mangled_name) base_of(self).to_c
  // ...
  frame->slots[12] /* temp__3 */ = create_closure(entry__compiler__define_c_code_142, 0);
  // 1828: ... :
  // 1829:   initialize_object type
  // 1830:   if namespace.is_defined:
  // 1831:     write_to_phase_3 "
  // 1832:       @
  // 1833:         define_single_assign_static("@(namespace)", "@(name)", @
  // 1834:       get__@(mangled_name), &@(var_entry(mangled_name)));
  frame->slots[13] /* temp__4 */ = create_closure(entry__compiler__define_c_code_263, 0);
  // 1835: ... :
  // 1836:   $raw_declaration source .until. ')'
  // 1837:   $type_and_name raw_declaration .before. '('
  // 1838:   $function_name behind(type_and_name alt(' ' '*') -1)
  // 1839:   
  // 1840:   $mangled_function_name
  // 1841:     if
  // 1842:       scope_of(self) == "runtime"
  // 1843:       -> string("runtime__" function_name)
  // 1844:       -> function_name
  // ...
  frame->slots[14] /* temp__5 */ = create_closure(entry__compiler__define_c_code_269, 0);
  // 1868: ... :
  // 1869:   write_to_declarations '@nl;'
  // 1870:   for_each_line source: (line)
  // 1871:     if line .has_suffix. ';' && line(1) > ' ':
  // 1872:       unless line .has_prefix. alt("typedef" "static " "extern " '}'):
  // 1873:         write_to_declarations scope
  // 1874:     write_to_declarations line.converted '@nl;'
  frame->slots[15] /* temp__6 */ = create_closure(entry__compiler__define_c_code_306, 0);
  // 1875: :
  // 1876:   Error "
  // 1877:     Unknown kind ("@(kind)") in C-code declaration!@
  frame->slots[16] /* temp__7 */ = create_closure(entry__compiler__define_c_code_321, 0);
  // 1655: case
  // 1656:   kind
  // 1657:   "struct":
  // 1658:     write_to_declarations "
  // 1659:       
  // 1660:       typedef struct @(mangled_name) @(mangled_name);
  // 1661:       struct @(mangled_name) {@nl;@(indented(2 source))
  // 1662:       };
  // 1663:   "node":
  // 1664:     write_to_declarations "
  // ...
  argument_count = 14;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* kind */;
  arguments->slots[1] = string__7c1f530901a312a3;
  arguments->slots[2] = frame->slots[10] /* temp__1 */;
  arguments->slots[3] = string__1e0aea8b5d407d5c;
  arguments->slots[4] = frame->slots[11] /* temp__2 */;
  arguments->slots[5] = string__2a0aef0b5de07d5c;
  arguments->slots[6] = frame->slots[12] /* temp__3 */;
  arguments->slots[7] = string__4c1f570701a272a3;
  arguments->slots[8] = frame->slots[13] /* temp__4 */;
  arguments->slots[9] = string__46c0af9104ada08e;
  arguments->slots[10] = frame->slots[14] /* temp__5 */;
  arguments->slots[11] = get__undefined();
  arguments->slots[12] = frame->slots[15] /* temp__6 */;
  arguments->slots[13] = frame->slots[16] /* temp__7 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_c_code(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1573: show_compiler_debug_info "define C-code"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__456a9bb1ba62862f;
  result_count = 0;
  myself = get__show_compiler_debug_info();
  func = myself->type;
  frame->cont = cont__compiler__define_c_code_3;
}
static void cont__compiler__define_c_code_3(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1574: ... :
  // 1575:   $kind kind_of(self)
  // 1576:   $source source_of(self)
  // 1577:   
  // 1578:   $scope
  // 1579:     case
  // 1580:       scope_of(self)
  // 1581:       "runtime"
  // 1582:       -> ""
  // 1583:       "global"
  // ...
  frame->slots[1] /* temp__1 */ = create_closure(entry__compiler__define_c_code_4, 0);
  // 1574: delayed:
  // 1575:   $kind kind_of(self)
  // 1576:   $source source_of(self)
  // 1577:   
  // 1578:   $scope
  // 1579:     case
  // 1580:       scope_of(self)
  // 1581:       "runtime"
  // 1582:       -> ""
  // 1583:       "global"
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = func__delayed;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign_attributes(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // destination: 0
  // source: 1
  // attributes: 2
  // code: 3
  frame->slots[3] /* code */ = create_future();
  if (argument_count != 3) {
    invalid_arguments_error();
    return;
  }
  // 1883: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__assign_attributes_2;
}
static void cont__assign_attributes_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1880: ... "
  // 1881:   @
  // 1882:     {
  // 1883:       NODE *temp = clone_object_and_attributes(@(source.to_c));
  // 1884:       update_start_p = node_p;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__5aaca17e38892df6;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = string__3374d958c75663b2;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_attributes_5;
}
static void cont__assign_attributes_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1880: write "
  // 1881:   @
  // 1882:     {
  // 1883:       NODE *temp = clone_object_and_attributes(@(source.to_c));
  // 1884:       update_start_p = node_p;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__assign_attributes_6;
}
static void cont__assign_attributes_6(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1885: for_each attributes: (attribute)
  // 1886:   $identifier identifier_of(attribute)
  // 1887:   $value arguments_of(attribute)(1).to_c
  // 1888:   if
  // 1889:     identifier.is_defined:
  // 1890:       $kind
  // 1891:         if
  // 1892:           attribute.is_an_attribute_function_pair
  // 1893:           -> ""
  // 1894:           -> "_value"
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* attributes */;
  arguments->slots[1] = func__assign_attributes_7;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__assign_attributes_27;
}
static void entry__assign_attributes_13(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // attribute: 0
  // identifier: 1
  // value: 2
  // kind: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* attribute */
  frame->slots[1] = myself->closure.frame->slots[1]; /* identifier */
  frame->slots[2] = myself->closure.frame->slots[2]; /* value */
  frame->slots[3] /* kind */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1892: attribute.is_an_attribute_function_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* attribute */;
  result_count = 1;
  myself = get__is_an_attribute_function_pair();
  func = myself->type;
  frame->cont = cont__assign_attributes_14;
}
static void cont__assign_attributes_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1890: $kind
  // 1891:   if
  // 1892:     attribute.is_an_attribute_function_pair
  // 1893:     -> ""
  // 1894:     -> "_value"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = func__assign_attributes_15;
  arguments->slots[2] = func__assign_attributes_16;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__assign_attributes_18;
}
static void entry__assign_attributes_15(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1893: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__assign_attributes_16(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1894: -> "_value"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__5a1f555f011332b2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__assign_attributes_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* kind */, arguments->slots[0]);
  // 1899: ... mangled_name_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__mangled_name_of();
  func = myself->type;
  frame->cont = cont__assign_attributes_19;
}
static void cont__assign_attributes_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1896: ... "
  // 1897:   @
  // 1898:       set_attribute@(kind)(temp->attributes, @
  // 1899:   poly_idx__@(mangled_name_of(identifier)), @(value));@nl;@
  argument_count = 7;
  arguments = node_p;
  arguments->slots[0] = string__4913e735c7c32ec6;
  arguments->slots[1] = frame->slots[3] /* kind */;
  arguments->slots[2] = string__e44f3203f587e9fa;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  arguments->slots[4] = string__2d7981f4e6682be5;
  arguments->slots[5] = frame->slots[2] /* value */;
  arguments->slots[6] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_attributes_22;
}
static void cont__assign_attributes_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1896: write "
  // 1897:   @
  // 1898:       set_attribute@(kind)(temp->attributes, @
  // 1899:   poly_idx__@(mangled_name_of(identifier)), @(value));@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign_attributes_23(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // value: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* value */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1901: ... "
  // 1902:   @
  // 1903:       temp->type = @(value)->type;
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__7128a00098ab7c5;
  arguments->slots[1] = frame->slots[0] /* value */;
  arguments->slots[2] = string__4fecac9c060c098a;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_attributes_26;
}
static void cont__assign_attributes_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1901: write "
  // 1902:   @
  // 1903:       temp->type = @(value)->type;
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__assign_attributes_7(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // attribute: 0
  // identifier: 1
  // value: 2
  frame->slots[1] /* identifier */ = create_future();
  frame->slots[2] /* value */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1886: $identifier identifier_of(attribute)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* attribute */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__assign_attributes_8;
}
static void cont__assign_attributes_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* identifier */, arguments->slots[0]);
  // 1887: ... arguments_of(attribute)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* attribute */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__assign_attributes_9;
}
static void cont__assign_attributes_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1887: ... arguments_of(attribute)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__2 */;
  func = myself->type;
  frame->cont = cont__assign_attributes_10;
}
static void cont__assign_attributes_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1887: $value arguments_of(attribute)(1).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__assign_attributes_11;
}
static void cont__assign_attributes_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* value */, arguments->slots[0]);
  // 1889: identifier.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* identifier */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__assign_attributes_12;
}
static void cont__assign_attributes_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1889: ... :
  // 1890:   $kind
  // 1891:     if
  // 1892:       attribute.is_an_attribute_function_pair
  // 1893:       -> ""
  // 1894:       -> "_value"
  // 1895:   
  // 1896:   write "
  // 1897:     @
  // 1898:         set_attribute@(kind)(temp->attributes, @
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__assign_attributes_13, 0);
  // 1900: :
  // 1901:   write "
  // 1902:     @
  // 1903:         temp->type = @(value)->type;
  frame->slots[5] /* temp__3 */ = create_closure(entry__assign_attributes_23, 0);
  // 1888: if
  // 1889:   identifier.is_defined:
  // 1890:     $kind
  // 1891:       if
  // 1892:         attribute.is_an_attribute_function_pair
  // 1893:         -> ""
  // 1894:         -> "_value"
  // 1895:     
  // 1896:     write "
  // 1897:       @
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__assign_attributes_27(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1904: $code assignment_to_c(destination "temp")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  arguments->slots[1] = string__2a0ae80b5d087d49;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__assign_attributes_29;
}
static void cont__assign_attributes_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* code */, arguments->slots[0]);
  // 1905: ... "
  // 1906:   @
  // 1907:     @(code)
  // 1908:     }
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be5;
  arguments->slots[1] = frame->slots[3] /* code */;
  arguments->slots[2] = string__ca5afb03ea26b05d;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__assign_attributes_31;
}
static void cont__assign_attributes_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1905: write "
  // 1906:   @
  // 1907:     @(code)
  // 1908:     }
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_85(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // destination: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1988: ... destination.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_86;
}
static void cont__compiler__generate_statement_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1988: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_87;
}
static void cont__compiler__generate_statement_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1986: ... "
  // 1987:   @
  // 1988:     initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1989:   );@nl;@
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__b0d32d3bb6b3b99c;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6682be5;
  arguments->slots[3] = frame->slots[4] /* temp__3 */;
  arguments->slots[4] = string__fa732015ff16bc6;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_89;
}
static void cont__compiler__generate_statement_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1986: write "
  // 1987:   @
  // 1988:     initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1989:   );@nl;@
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_90(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // destination: 0
  // source: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* destination */
  frame->slots[1] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1991: ... source.to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* source */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_91;
}
static void cont__compiler__generate_statement_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1991: ... assignment_to_c(destination source.to_c)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__assignment_to_c();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_92;
}
static void cont__compiler__generate_statement_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1991: write assignment_to_c(destination source.to_c)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__write();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_43(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // input_arguments: 0
  // statement: 1
  // output_arguments: 2
  // functor: 3
  // sfx: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* input_arguments */
  frame->slots[1] = myself->closure.frame->slots[2]; /* statement */
  frame->slots[2] = myself->closure.frame->slots[3]; /* output_arguments */
  frame->slots[3] = myself->closure.frame->slots[0]; /* functor */
  frame->slots[4] /* sfx */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1947: generate_c_arguments input_arguments
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* input_arguments */;
  result_count = 0;
  myself = func__generate_c_arguments;
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_44;
}
static void cont__compiler__generate_statement_44(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1949: -> result_count_of(statement).is_defined:
  // 1950:   writeln
  // 1951:     "  result_count = to_int(@(result_count_of(statement).to_c));"
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__generate_statement_45, 0);
  // 1952: -> continuation_of(statement).is_defined:
  // 1953:   # This makes no sense because we're not in a tail-call position!
  // 1954:   
  // 1955:   SyntaxError
  // 1956:     statement
  // 1957:     "Call with continuation followed by another statement"
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__generate_statement_54, 0);
  // 1958: :
  // 1959:   $result_count count_arguments(output_arguments)
  // 1960:   case
  // 1961:     result_count
  // 1962:     undefined:
  // 1963:       writeln "  result_count = -1;"
  // 1964:     :
  // 1965:       writeln "  result_count = @(result_count);"
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__generate_statement_59, 0);
  // 1948: cond
  // 1949:   -> result_count_of(statement).is_defined:
  // 1950:     writeln
  // 1951:       "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1952:   -> continuation_of(statement).is_defined:
  // 1953:     # This makes no sense because we're not in a tail-call position!
  // 1954:     
  // 1955:     SyntaxError
  // 1956:       statement
  // 1957:       "Call with continuation followed by another statement"
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_67;
}
static void entry__compiler__generate_statement_61(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // result_count: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* result_count */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1965: ... "  result_count = @(result_count);"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__47feaa767baa1465;
  arguments->slots[1] = frame->slots[0] /* result_count */;
  arguments->slots[2] = string__578a5af303e9cda;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_64;
}
static void cont__compiler__generate_statement_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1965: writeln "  result_count = @(result_count);"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_65(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1963: writeln "  result_count = -1;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__ca8ff614ed7f5413;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_57(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1955: SyntaxError
  // 1956:   statement
  // 1957:   "Call with continuation followed by another statement"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  arguments->slots[1] = string__d263a6c16aa42f0f;
  result_count = frame->caller_result_count;
  myself = get__SyntaxError();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_48(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1951: ... result_count_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__result_count_of();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_49;
}
static void cont__compiler__generate_statement_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1951: ... result_count_of(statement).to_c
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__to_c();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_50;
}
static void cont__compiler__generate_statement_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1951: "  result_count = to_int(@(result_count_of(statement).to_c));"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2c055578f6e77c80;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e6402bfe;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_53;
}
static void cont__compiler__generate_statement_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1950: writeln
  // 1951:   "  result_count = to_int(@(result_count_of(statement).to_c));"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_45(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1949: ... result_count_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__result_count_of();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_46;
}
static void cont__compiler__generate_statement_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1949: ... result_count_of(statement).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_47;
}
static void cont__compiler__generate_statement_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1949: ... :
  // 1950:   writeln
  // 1951:     "  result_count = to_int(@(result_count_of(statement).to_c));"
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__generate_statement_48, 0);
  // 1949: -> result_count_of(statement).is_defined:
  // 1950:   writeln
  // 1951:     "  result_count = to_int(@(result_count_of(statement).to_c));"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_54(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1952: ... continuation_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__continuation_of();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_55;
}
static void cont__compiler__generate_statement_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1952: ... continuation_of(statement).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_56;
}
static void cont__compiler__generate_statement_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1952: ... :
  // 1953:   # This makes no sense because we're not in a tail-call position!
  // 1954:   
  // 1955:   SyntaxError
  // 1956:     statement
  // 1957:     "Call with continuation followed by another statement"
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__generate_statement_57, 0);
  // 1952: -> continuation_of(statement).is_defined:
  // 1953:   # This makes no sense because we're not in a tail-call position!
  // 1954:   
  // 1955:   SyntaxError
  // 1956:     statement
  // 1957:     "Call with continuation followed by another statement"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_59(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // output_arguments: 0
  // result_count: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* output_arguments */
  frame->slots[1] /* result_count */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1959: $result_count count_arguments(output_arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_arguments */;
  result_count = 1;
  myself = func__count_arguments;
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_60;
}
static void cont__compiler__generate_statement_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* result_count */, arguments->slots[0]);
  // 1964: :
  // 1965:   writeln "  result_count = @(result_count);"
  frame->slots[2] /* temp__1 */ = create_closure(entry__compiler__generate_statement_61, 0);
  // 1960: case
  // 1961:   result_count
  // 1962:   undefined:
  // 1963:     writeln "  result_count = -1;"
  // 1964:   :
  // 1965:     writeln "  result_count = @(result_count);"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* result_count */;
  arguments->slots[1] = get__undefined();
  arguments->slots[2] = func__compiler__generate_statement_65;
  arguments->slots[3] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__generate_statement_67(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1966: inc &index
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__index();
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_68;
}
static void cont__compiler__generate_statement_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__index(arguments->slots[0]);
  // 1970: cont_suffix.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__cont_suffix();
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_69;
}
static void cont__compiler__generate_statement_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1968: $sfx
  // 1969:   if
  // 1970:     cont_suffix.is_defined
  // 1971:     -> cont_suffix
  // 1972:     -> suffix
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = func__compiler__generate_statement_70;
  arguments->slots[2] = func__compiler__generate_statement_71;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_72;
}
static void entry__compiler__generate_statement_70(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1971: -> cont_suffix
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__cont_suffix();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_71(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1972: -> suffix
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__suffix();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__generate_statement_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* sfx */, arguments->slots[0]);
  // 1974: ... "cont@(sfx)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40aea8b5d107d4d;
  arguments->slots[1] = frame->slots[4] /* sfx */;
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_73;
}
static void cont__compiler__generate_statement_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1974: get_func_and_myself functor "cont@(sfx)_@(index)"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* functor */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = func__get_func_and_myself;
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_74;
}
static void cont__compiler__generate_statement_74(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1975: write "}@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e4e02bcf;
  result_count = 0;
  myself = get__write();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_75;
}
static void cont__compiler__generate_statement_75(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1976: ... "cont@(sfx)_@(index)"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__40aea8b5d107d4d;
  arguments->slots[1] = frame->slots[4] /* sfx */;
  arguments->slots[2] = string__578a5af303e9cbe;
  arguments->slots[3] = get__index();
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_76;
}
static void cont__compiler__generate_statement_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1976: next_continuation "cont@(sfx)_@(index)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__next_continuation();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_77;
}
static void cont__compiler__generate_statement_77(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1977: extract "results" output_arguments
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__984c0ed0151bf089;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* output_arguments */;
  result_count = frame->caller_result_count;
  myself = func__extract;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_78(void) {
  allocate_initialized_frame_gc(2, 9);
  // slot allocations:
  // output_arguments: 0
  // input_arguments: 1
  // destination: 2
  // source: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* output_arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* input_arguments */
  frame->slots[2] /* destination */ = create_future();
  frame->slots[3] /* source */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1979: $destination output_arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* output_arguments */;
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_79;
}
static void cont__compiler__generate_statement_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* destination */, arguments->slots[0]);
  // 1980: $source input_arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* input_arguments */;
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_80;
}
static void cont__compiler__generate_statement_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* source */, arguments->slots[0]);
  // 1983: destination.is_a_single_assign_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* destination */;
  result_count = 1;
  myself = get__is_a_single_assign_definition();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_81;
}
static void cont__compiler__generate_statement_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1984: source.might_be_constant
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__generate_statement_82, 0);
  // 1982: &&
  // 1983:   destination.is_a_single_assign_definition
  // 1984:   source.might_be_constant
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_84;
}
static void entry__compiler__generate_statement_82(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1984: source.might_be_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__might_be_constant();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_83;
}
static void cont__compiler__generate_statement_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1984: source.might_be_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__generate_statement_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1985: :
  // 1986:   write "
  // 1987:     @
  // 1988:       initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1989:     );@nl;@
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__generate_statement_85, 0);
  // 1990: :
  // 1991:   write assignment_to_c(destination source.to_c)
  frame->slots[8] /* temp__5 */ = create_closure(entry__compiler__generate_statement_90, 0);
  // 1981: if
  // 1982:   &&
  // 1983:     destination.is_a_single_assign_definition
  // 1984:     source.might_be_constant
  // 1985:   :
  // 1986:     write "
  // 1987:       @
  // 1988:         initialize_maybe_future(@(destination.to_c), @(source.to_c)@
  // 1989:       );@nl;@
  // 1990:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_35(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // output_arguments: 0
  // functor: 1
  // input_arguments: 2
  // destination: 3
  // source: 4
  frame->slots[0] = myself->closure.frame->slots[3]; /* output_arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[2] = myself->closure.frame->slots[2]; /* input_arguments */
  frame->slots[3] /* destination */ = create_future();
  frame->slots[4] /* source */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1935: $destination output_arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* output_arguments */;
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_36;
}
static void cont__compiler__generate_statement_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* destination */, arguments->slots[0]);
  // 1939: functor.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* functor */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_37;
}
static void cont__compiler__generate_statement_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1940: -> functor
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__generate_statement_38, 0);
  // 1941: -> destination
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__generate_statement_39, 0);
  // 1937: $source
  // 1938:   if
  // 1939:     functor.is_defined
  // 1940:     -> functor
  // 1941:     -> destination
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_40;
}
static void entry__compiler__generate_statement_38(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1940: -> functor
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_39(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // destination: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* destination */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1941: -> destination
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* destination */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__generate_statement_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* source */, arguments->slots[0]);
  // 1943: assign_attributes destination source input_arguments
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* destination */;
  arguments->slots[1] = frame->slots[4] /* source */;
  arguments->slots[2] = ((CELL *)frame->slots[2])->contents /* input_arguments */;
  result_count = frame->caller_result_count;
  myself = func__assign_attributes;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_41(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // functor: 0
  // input_arguments: 1
  // statement: 2
  // output_arguments: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[2]; /* input_arguments */
  frame->slots[2] = myself->closure.frame->slots[0]; /* statement */
  frame->slots[3] = myself->closure.frame->slots[3]; /* output_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1946: functor.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_42;
}
static void cont__compiler__generate_statement_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1946: ... :
  // 1947:   generate_c_arguments input_arguments
  // 1948:   cond
  // 1949:     -> result_count_of(statement).is_defined:
  // 1950:       writeln
  // 1951:         "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1952:     -> continuation_of(statement).is_defined:
  // 1953:       # This makes no sense because we're not in a tail-call position!
  // 1954:       
  // 1955:       SyntaxError
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__generate_statement_43, 0);
  // 1978: :
  // 1979:   $destination output_arguments(1)
  // 1980:   $source input_arguments(1)
  // 1981:   if
  // 1982:     &&
  // 1983:       destination.is_a_single_assign_definition
  // 1984:       source.might_be_constant
  // 1985:     :
  // 1986:       write "
  // 1987:         @
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__generate_statement_78, 0);
  // 1945: if
  // 1946:   functor.is_defined:
  // 1947:     generate_c_arguments input_arguments
  // 1948:     cond
  // 1949:       -> result_count_of(statement).is_defined:
  // 1950:         writeln
  // 1951:           "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1952:       -> continuation_of(statement).is_defined:
  // 1953:         # This makes no sense because we're not in a tail-call position!
  // 1954:         
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement(void) {
  allocate_initialized_frame_gc(1, 11);
  // slot allocations:
  // statement: 0
  // functor: 1
  // input_arguments: 2
  // output_arguments: 3
  frame->slots[1] /* functor */ = create_future();
  frame->slots[2] /* input_arguments */ = create_cell();
  frame->slots[3] /* output_arguments */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1913: ... :
  // 1914:   cond
  // 1915:     -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  // 1916:     -> statement.is_an_assignment: ewriteln "generate assignment"
  // 1917:     :
  // 1918:       ewriteln "generate unknown statement"
  frame->slots[4] /* temp__1 */ = create_closure(entry__compiler__generate_statement_2, 0);
  // 1913: if do_show_compiler_debug_infos:
  // 1914:   cond
  // 1915:     -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  // 1916:     -> statement.is_an_assignment: ewriteln "generate assignment"
  // 1917:     :
  // 1918:       ewriteln "generate unknown statement"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__do_show_compiler_debug_infos();
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_13;
}
static void entry__compiler__generate_statement_9(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1916: ... ewriteln "generate assignment"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__80851998713c7b1d;
  result_count = frame->caller_result_count;
  myself = get__ewriteln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1915: ... ewriteln "generate procedure call"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__1f458f464eec9b66;
  result_count = frame->caller_result_count;
  myself = get__ewriteln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_3(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1915: ... statement.is_a_procedure_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_a_procedure_call();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_4;
}
static void cont__compiler__generate_statement_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1915: -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__generate_statement_5;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_7(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1916: ... statement.is_an_assignment
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__is_an_assignment();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_8;
}
static void cont__compiler__generate_statement_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1916: -> statement.is_an_assignment: ewriteln "generate assignment"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__generate_statement_9;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_11(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1918: ewriteln "generate unknown statement"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__8b102f799cb53c4;
  result_count = frame->caller_result_count;
  myself = get__ewriteln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_2(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // statement: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1915: -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  frame->slots[1] /* temp__1 */ = create_closure(entry__compiler__generate_statement_3, 0);
  // 1916: -> statement.is_an_assignment: ewriteln "generate assignment"
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__generate_statement_7, 0);
  // 1914: cond
  // 1915:   -> statement.is_a_procedure_call: ewriteln "generate procedure call"
  // 1916:   -> statement.is_an_assignment: ewriteln "generate assignment"
  // 1917:   :
  // 1918:     ewriteln "generate unknown statement"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = func__compiler__generate_statement_11;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__generate_statement_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1919: write_source_as_remark statement
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 0;
  myself = get__write_source_as_remark();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_14;
}
static void cont__compiler__generate_statement_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1920: $functor functor_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_15;
}
static void cont__compiler__generate_statement_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* functor */, arguments->slots[0]);
  // 1921: $$input_arguments empty_list
  ((CELL *)frame->slots[2])->contents /* input_arguments */ = get__empty_list();
  // 1922: $$output_arguments empty_list
  ((CELL *)frame->slots[3])->contents /* output_arguments */ = get__empty_list();
  // 1923: ... arguments_of(statement)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* statement */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_16;
}
static void cont__compiler__generate_statement_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1923: ... : (argument)
  // 1924:   if
  // 1925:     argument.is_a_destination:
  // 1926:       push &output_arguments argument
  // 1927:       if argument.is_an_input_output_argument: push &input_arguments argument
  // 1928:     :
  // 1929:       push &input_arguments argument
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__generate_statement_17, 1);
  // 1923: for_each arguments_of(statement): (argument)
  // 1924:   if
  // 1925:     argument.is_a_destination:
  // 1926:       push &output_arguments argument
  // 1927:       if argument.is_an_input_output_argument: push &input_arguments argument
  // 1928:     :
  // 1929:       push &input_arguments argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_26;
}
static void entry__compiler__generate_statement_22(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // input_arguments: 0
  // argument: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* input_arguments */
  frame->slots[1] = myself->closure.frame->slots[1]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1927: ... push &input_arguments argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* input_arguments */;
  arguments->slots[1] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_23;
}
static void cont__compiler__generate_statement_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* input_arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_19(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // output_arguments: 0
  // argument: 1
  // input_arguments: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* output_arguments */
  frame->slots[1] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[2] = myself->closure.frame->slots[2]; /* input_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1926: push &output_arguments argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* output_arguments */;
  arguments->slots[1] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_20;
}
static void cont__compiler__generate_statement_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* output_arguments */ = arguments->slots[0];
  // 1927: ... argument.is_an_input_output_argument
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__is_an_input_output_argument();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_21;
}
static void cont__compiler__generate_statement_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1927: ... : push &input_arguments argument
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__generate_statement_22, 0);
  // 1927: if argument.is_an_input_output_argument: push &input_arguments argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__generate_statement_24(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // input_arguments: 0
  // argument: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* input_arguments */
  frame->slots[1] = myself->closure.frame->slots[0]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1929: push &input_arguments argument
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* input_arguments */;
  arguments->slots[1] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_25;
}
static void cont__compiler__generate_statement_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* input_arguments */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__generate_statement_17(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // argument: 0
  // output_arguments: 1
  // input_arguments: 2
  frame->slots[1] = myself->closure.frame->slots[3]; /* output_arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* input_arguments */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1925: argument.is_a_destination
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_a_destination();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_18;
}
static void cont__compiler__generate_statement_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1925: ... :
  // 1926:   push &output_arguments argument
  // 1927:   if argument.is_an_input_output_argument: push &input_arguments argument
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__generate_statement_19, 0);
  // 1928: :
  // 1929:   push &input_arguments argument
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__generate_statement_24, 0);
  // 1924: if
  // 1925:   argument.is_a_destination:
  // 1926:     push &output_arguments argument
  // 1927:     if argument.is_an_input_output_argument: push &input_arguments argument
  // 1928:   :
  // 1929:     push &input_arguments argument
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__generate_statement_26(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1932: length_of(input_arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* input_arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_27;
}
static void cont__compiler__generate_statement_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 1932: length_of(input_arguments) >= 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_28;
}
static void cont__compiler__generate_statement_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1932: length_of(input_arguments) >= 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_29;
}
static void cont__compiler__generate_statement_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1933: input_arguments(-1).is_an_attribute_value_pair
  frame->slots[8] /* temp__5 */ = create_closure(entry__compiler__generate_statement_30, 0);
  // 1931: &&
  // 1932:   length_of(input_arguments) >= 1
  // 1933:   input_arguments(-1).is_an_attribute_value_pair
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_34;
}
static void entry__compiler__generate_statement_30(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // input_arguments: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* input_arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1933: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_31;
}
static void cont__compiler__generate_statement_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1933: input_arguments(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* input_arguments */;
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_32;
}
static void cont__compiler__generate_statement_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1933: input_arguments(-1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_attribute_value_pair();
  func = myself->type;
  frame->cont = cont__compiler__generate_statement_33;
}
static void cont__compiler__generate_statement_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1933: input_arguments(-1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__generate_statement_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1934: :
  // 1935:   $destination output_arguments(1)
  // 1936:   
  // 1937:   $source
  // 1938:     if
  // 1939:       functor.is_defined
  // 1940:       -> functor
  // 1941:       -> destination
  // 1942:   
  // 1943:   assign_attributes destination source input_arguments
  frame->slots[9] /* temp__6 */ = create_closure(entry__compiler__generate_statement_35, 0);
  // 1944: :
  // 1945:   if
  // 1946:     functor.is_defined:
  // 1947:       generate_c_arguments input_arguments
  // 1948:       cond
  // 1949:         -> result_count_of(statement).is_defined:
  // 1950:           writeln
  // 1951:             "  result_count = to_int(@(result_count_of(statement).to_c));"
  // 1952:         -> continuation_of(statement).is_defined:
  // 1953:           # This makes no sense because we're not in a tail-call position!
  // ...
  frame->slots[10] /* temp__7 */ = create_closure(entry__compiler__generate_statement_41, 0);
  // 1930: if
  // 1931:   &&
  // 1932:     length_of(input_arguments) >= 1
  // 1933:     input_arguments(-1).is_an_attribute_value_pair
  // 1934:   :
  // 1935:     $destination output_arguments(1)
  // 1936:     
  // 1937:     $source
  // 1938:       if
  // 1939:         functor.is_defined
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__6 */;
  arguments->slots[2] = frame->slots[10] /* temp__7 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
EXPORT void collect__c_code_generator(void) {
  var.compiler__to_c = collect_node(var.compiler__to_c);
  var.compiler__begin_continuation = collect_node(var.compiler__begin_continuation);
  var.compiler__end_continuation = collect_node(var.compiler__end_continuation);
  var.compiler__next_continuation = collect_node(var.compiler__next_continuation);
  var.compiler__assignment_to_c = collect_node(var.compiler__assignment_to_c);
  var.compiler__write_source_as_remark = collect_node(var.compiler__write_source_as_remark);
  var.compiler__is_single_assign = collect_node(var.compiler__is_single_assign);
  var.compiler__might_be_constant = collect_node(var.compiler__might_be_constant);
  var.compiler__define_variable = collect_node(var.compiler__define_variable);
  var.compiler__define_attribute = collect_node(var.compiler__define_attribute);
  var.compiler__define_method = collect_node(var.compiler__define_method);
  var.compiler__define_type_function = collect_node(var.compiler__define_type_function);
  var.compiler__define_polymorphic_function = collect_node(var.compiler__define_polymorphic_function);
  var.compiler__define_c_code = collect_node(var.compiler__define_c_code);
  var.compiler__generate_statement = collect_node(var.compiler__generate_statement);
}

static int already_run_phase_1 = false;

EXPORT void phase_1__c_code_generator(void) {
  if (already_run_phase_1) return;
  already_run_phase_1 = true;
  register_module_info(&module_info);
}

static int already_run_phase_2 = false;

EXPORT void phase_2__c_code_generator(void) {
  if (already_run_phase_2) return;
  already_run_phase_2 = true;
  set_module("c_code_generator");
  character__92 = from_uchar32(92);
  character__47 = from_uchar32(47);
  character__160 = from_uchar32(160);
  character__10 = from_uchar32(10);
  number__0 = from_uint32(0U);
  number__3 = from_uint32(3U);
  character__126 = from_uchar32(126);
  character__95 = from_uchar32(95);
  character__40 = from_uchar32(40);
  character__34 = from_uchar32(34);
  character__255 = from_uchar32(255);
  number__5 = from_uint32(5U);
  character__39 = from_uchar32(39);
  character__32 = from_uchar32(32);
  number__9 = from_uint32(9U);
  character__125 = from_uchar32(125);
  character__41 = from_uchar32(41);
  character__59 = from_uchar32(59);
  number__1 = from_uint32(1U);
  number__2 = from_uint32(2U);
  character__42 = from_uchar32(42);
  define_polymorphic_function("compiler", "to_c", get__compiler__to_c, &poly_idx__compiler__to_c, &var.compiler__to_c);
  string__2d7981f4e5f02b9a = from_latin_1_string("__", 2);
  func__var_name = create_function(entry__var_name, 1);
  string__2e0ae90b5df07d17 = from_latin_1_string("var.", 4);
  string__485aef83e8b97008 = from_latin_1_string("var._", 5);
  func__var_entry = create_function(entry__var_entry, 1);
  func__insert_delayed = create_function(entry__insert_delayed, 0);
  func__delayed = create_function(entry__delayed, 1);
  string__94d1722d4e0367ec = from_latin_1_string("static void ", 12);
  string__66ccbf91860d092a = from_latin_1_string("(void);\012", 8);
  string__fc8c36a84adb366f = from_latin_1_string("(void) {\012", 9);
  string__fa730415f296bb7 = from_latin_1_string("  {", 3);
  string__2d7981f4e6682be5 = from_latin_1_string(", ", 2);
  string__578a5af303e9cc7 = from_latin_1_string("&", 1);
  func__compiler__begin_continuation_15 = create_function(entry__compiler__begin_continuation_15, 0);
  string__1f5d5783d902f7 = from_latin_1_string("NULL, ", 6);
  func__compiler__begin_continuation_18 = create_function(entry__compiler__begin_continuation_18, 0);
  func__compiler__begin_continuation = create_function(entry__compiler__begin_continuation, 1);
  string__fa727015f496bc6 = from_latin_1_string("},\012", 3);
  func__compiler__end_continuation_3 = create_function(entry__compiler__end_continuation_3, 0);
  func__compiler__end_continuation_7 = create_function(entry__compiler__end_continuation_7, 0);
  func__compiler__end_continuation = create_function(entry__compiler__end_continuation, 0);
  func__compiler__next_continuation = create_function(entry__compiler__next_continuation, 1);
  func__count_arguments = create_function(entry__count_arguments, 1);
  string__a1d76a17b79c4b5 = from_latin_1_string("  argument_count += ", 20);
  string__2d7981f4e6d02bcf = from_latin_1_string(";\012", 2);
  string__3892a143ae642f72 = from_latin_1_string("  argument_count = ", 19);
  string__13889e43284fcd2b = from_latin_1_string(
    ";\n"
    "  arguments = node_p;\n",
    24);
  string__7834b5f7cd2908a7 = from_latin_1_string("  optional_item(", 16);
  string__fa732015ff16bc6 = from_latin_1_string(");\012", 3);
  string__70e425abc2231c8d = from_latin_1_string("  unfold(", 9);
  string__4808b9f7f52b8767 = from_latin_1_string("argument_count++", 16);
  func__generate_c_arguments_31 = create_function(entry__generate_c_arguments_31, 0);
  string__fd6b440801406c9 = from_latin_1_string("  arguments->slots[", 19);
  string__780af94b5f887d19 = from_latin_1_string("] = ", 4);
  func__generate_c_arguments = create_function(entry__generate_c_arguments, -1);
  func__get_func_and_myself_7 = create_function(entry__get_func_and_myself_7, 0);
  string__8c93215920e16830 = from_latin_1_string("  myself = ", 11);
  string__b99451f7c76bbc46 = from_latin_1_string(
    ";\n"
    "  func = myself->type;",
    24);
  string__578a5af303e9ceb = from_latin_1_string("\012", 1);
  string__6c9a2bd2e7c4af5 = from_latin_1_string("frame->cont", 11);
  string__7c88f48f8c83734e = from_latin_1_string("  frame->cont = ", 16);
  func__get_func_and_myself = create_function(entry__get_func_and_myself, -1);
  string__2d7981f4e6082be5 = from_latin_1_string("  ", 2);
  string__b4b0e7de47027f92 = from_latin_1_string("initialize_future(", 18);
  string__fa730415fc16bec = from_latin_1_string(" = ", 3);
  string__7280ac95052d00ff = from_latin_1_string("define__", 8);
  string__578a5af303e9cc9 = from_latin_1_string("(", 1);
  string__405aee03eb312008 = from_latin_1_string("set__", 5);
  string__c0ae80b5dc07d66 = from_latin_1_string("get_", 4);
  string__240ae80b5dc07d66 = from_latin_1_string("set_", 4);
  func__compiler__assignment_to_c = create_function(entry__compiler__assignment_to_c, -1);
  string__64ac252603a3a696 = from_latin_1_string("arguments", 9);
  string__9d12bd49b1f09f10 = from_latin_1_string("frame->slots[", 13);
  string__ca5af8c3e89bc077 = from_latin_1_string("] /* ", 5);
  string__64bada731157029 = from_latin_1_string(" */ = create_cell_with_contents(", 32);
  func__assign_argument_or_result = create_function(entry__assign_argument_or_result, -1);
  string__3a411e083dfe7a1 = from_latin_1_string("  if (argument_count < ", 23);
  string__163aca4ea3526a62 = from_latin_1_string(
    ") {\n"
    "    too_few_",
    16);
  string__46700f340c500fa1 = from_latin_1_string(
    "_error();\n"
    "    return;\n"
    "  }\n",
    26);
  string__3a411e083cfe7a1 = from_latin_1_string("  if (argument_count > ", 23);
  string__5a751cd352200189 = from_latin_1_string(
    ") {\n"
    "    too_many_",
    17);
  string__8f0419bf3de01d00 = from_latin_1_string("  if (argument_count != ", 24);
  string__23ec94223c989c2 = from_latin_1_string(
    ") {\n"
    "    invalid_",
    16);
  string__984c0ed0151bf089 = from_latin_1_string("results", 7);
  string__858e9ccf5a7e0845 = from_latin_1_string("  allocate_arguments();", 23);
  func__extract_49 = create_function(entry__extract_49, 0);
  string__f8fbbe9f15fa69de = from_latin_1_string("arguments->slots[", 17);
  string__578a5af303e9cbc = from_latin_1_string("]", 1);
  string__41a90e180f1f464a = from_latin_1_string("arguments->slots[argument_count", 31);
  string__c641af060b3640ca = from_latin_1_string("from_arguments(", 15);
  string__eb230bd48e24a88 = from_latin_1_string(", argument_count-", 17);
  string__578a5af303e9cc8 = from_latin_1_string(")", 1);
  string__fcf46690a35325f6 = from_latin_1_string("  switch(argument_count) {\012", 27);
  string__485aefc3eae02077 = from_latin_1_string("case ", 5);
  string__b014089015daa08e = from_latin_1_string("default", 7);
  func__extract_99 = create_function(entry__extract_99, 0);
  string__820af94b5f607d19 = from_latin_1_string("    ", 4);
  string__2d7981f4e6d82be5 = from_latin_1_string(": ", 2);
  string__6db0224cc22b4c85 = from_latin_1_string("    case ", 9);
  string__3d141c30a0902819 = from_latin_1_string(
    ":;\n"
    "  }\n"
    "  switch(argument_count) {\n",
    34);
  func__extract_122 = create_function(entry__extract_122, 0);
  string__3d6fbe7ddbf3d274 = from_latin_1_string(
    ":\n"
    "      func = cont",
    19);
  string__578a5af303e9cbe = from_latin_1_string("_", 1);
  string__1392ca21613062f7 = from_latin_1_string(
    ";\n"
    "      return;\n",
    16);
  string__336c1dff155460f0 = from_latin_1_string(
    ":;\n"
    "  }\n",
    7);
  func__extract_145 = create_function(entry__extract_145, 1);
  string__7ca0252e172b1501 = from_latin_1_string("undefined", 9);
  string__456a7fcebab856fe = from_latin_1_string("  func = cont", 13);
  string__b40af3cb5d887d33 = from_latin_1_string(
    ";\n"
    "}\n",
    4);
  string__40aea8b5d107d4d = from_latin_1_string("cont", 4);
  func__extract_169 = create_function(entry__extract_169, 0);
  string__820af94b5d887d33 = from_latin_1_string("  }\012", 4);
  func__extract = create_function(entry__extract, 2);
  string__d81f45b583c652f7 = from_latin_1_string(
    "\n"
    "  // ",
    6);
  string__ca5af8c3e8b41077 = from_latin_1_string("  // ", 5);
  func__write_as_remark = create_function(entry__write_as_remark, 1);
  func__compute_column_no = create_function(entry__compute_column_no, 1);
  func__compute_source_text_info_56 = create_function(entry__compute_source_text_info_56, 0);
  string__9e0afacb5f107d19 = from_latin_1_string("... ", 4);
  string__ef94be7186a1680e = from_latin_1_string("  // ...", 8);
  func__compute_source_text_info_111 = create_function(entry__compute_source_text_info_111, 0);
  func__compute_source_text_info = create_function(entry__compute_source_text_info, -1);
  func__compiler__write_source_as_remark = create_function(entry__compiler__write_source_as_remark, 1);
  unique__EARLY = register_unique_item("EARLY");
  unique__STANDARD = register_unique_item("STANDARD");
  func__get_kind_15 = create_function(entry__get_kind_15, 0);
  func__get_kind_16 = create_function(entry__get_kind_16, 0);
  unique__UNKNOWN = register_unique_item("UNKNOWN");
  func__get_kind = create_function(entry__get_kind, 1);
  string__bce93a997a35ab67 = from_latin_1_string("generate expression", 19);
  string__fa737815fd16bf3 = from_latin_1_string("???", 3);
  func__types__grammar_node___to_c = create_function(entry__types__grammar_node___to_c, 1);
  string__463afb92a66256b1 = from_latin_1_string("generate body", 13);
  func__compiler__body__to_c_8 = create_function(entry__compiler__body__to_c_8, 0);
  string__e0aec0b5d107d5a = from_latin_1_string("func", 4);
  func__compiler__body__to_c_20 = create_function(entry__compiler__body__to_c_20, 0);
  func__compiler__body__to_c_32 = create_function(entry__compiler__body__to_c_32, 0);
  func__compiler__body__to_c_23 = create_function(entry__compiler__body__to_c_23, 1);
  string__7f76cf7c934307b4 = from_latin_1_string("get_value_or_future__", 21);
  string__2d7981f4e6482bec = from_latin_1_string("()", 2);
  string__3e418beaa4f754e1 = from_latin_1_string("create_future()", 15);
  func__compiler__body__to_c_45 = create_function(entry__compiler__body__to_c_45, 0);
  func__compiler__body__to_c_47 = create_function(entry__compiler__body__to_c_47, 0);
  func__compiler__body__to_c_34 = create_function(entry__compiler__body__to_c_34, 1);
  string__ed9510e8330beabe = from_latin_1_string(
    "  argument_count = 0;\n"
    "  arguments = node_p;\n"
    "  myself = ",
    55);
  string__53a8ae7fafe9c367 = from_latin_1_string(
    ";\n"
    "  func = myself->type;\n"
    "  frame->cont = invalid_continuation;\n",
    63);
  string__b30064368698509a = from_latin_1_string(
    "  frame = frame->caller_frame;\n"
    "  func = frame->cont;\n"
    "  frame->cont = invalid_continuation;\n",
    91);
  func__compiler__body__to_c_127 = create_function(entry__compiler__body__to_c_127, 0);
  string__6b846eb6691a1cd5 = from_latin_1_string("static NODE *func", 17);
  string__565aee03ea58402e = from_latin_1_string("entry", 5);
  string__e67ad3f0422c2c7e = from_latin_1_string("  allocate_arguments();\012", 24);
  func__compiler__body__to_c_163 = create_function(entry__compiler__body__to_c_163, 0);
  string__2acb68f672d208ee = from_latin_1_string("  caller_frame = frame;\012", 24);
  func__compiler__body__to_c_170 = create_function(entry__compiler__body__to_c_170, 0);
  string__81412d4a12e22ca0 = from_latin_1_string("  allocate_initialized_frame_gc(", 32);
  string__b723bfa8a9fda3ff = from_latin_1_string("  // slot allocations:", 22);
  string__d564cec0827db510 = from_latin_1_string("static FRAME_INFO frame", 23);
  string__820afe0b5f607d42 = from_latin_1_string(" = {", 4);
  string__fa733415f296bb7 = from_latin_1_string(", {", 3);
  func__compiler__body__to_c_189 = create_function(entry__compiler__body__to_c_189, 0);
  string__578a5af303e9cc3 = from_latin_1_string("\042", 1);
  func__compiler__body__to_c_184 = create_function(entry__compiler__body__to_c_184, 2);
  string__380aee0b5fb87d33 = from_latin_1_string("}};\012", 4);
  string__6e5aeb43eaa07032 = from_latin_1_string("frame", 5);
  string__dd22cae03536c939 = from_latin_1_string("static void exit", 16);
  string__cec1f2b7e8b1bf6a = from_latin_1_string("create_continuation_with_exit(exit", 34);
  string__ce243b1c25d80854 = from_latin_1_string("create_continuation()", 21);
  func__compiler__body__to_c_207 = create_function(entry__compiler__body__to_c_207, 0);
  string__6c6dcf991c09c1f6 = from_latin_1_string("  frame->slots[", 15);
  string__716ce75c96089b20 = from_latin_1_string("] = myself->closure.frame->slots[", 33);
  string__d81f459e03efe2f7 = from_latin_1_string("]; /* ", 6);
  string__820afbcb5f187d33 = from_latin_1_string(" */\012", 4);
  string__7c84ae5484fdf7e0 = from_latin_1_string("_define ", 8);
  string__578a5af303e9cc1 = from_latin_1_string(" ", 1);
  string__78fdfa78a6dea8bb = from_latin_1_string(" */ = create_cell();\012", 21);
  string__fccc671c88ddb4ed = from_latin_1_string(
    "  update_start_p = node_p;\n"
    "  def_attribute(&",
    44);
  string__82b9fe52d4649726 = from_latin_1_string(", poly_idx__", 12);
  string__23db4977718ddc08 = from_latin_1_string(", MAKE_ATTRIBUTE_VALUE(", 23);
  string__900afb0b5fb87d33 = from_latin_1_string("));\012", 4);
  string__c21f422683de52f7 = from_latin_1_string(", -1, ", 6);
  string__7e1f570601dbc2b1 = from_latin_1_string("myself", 6);
  func__compiler__body__to_c_308 = create_function(entry__compiler__body__to_c_308, 1);
  string__db8268c5e3e3998 = from_latin_1_string("continuation_trampoline", 23);
  string__3404e8fb37dde7ec = from_latin_1_string("  frame->slots[0] = ", 20);
  string__6b3b62c960789ef = from_latin_1_string(
    ";\n"
    "  if (frame->slots[0]->type != continuation_type_function)\n"
    "    invalid_continuation_error();\n"
    "  frame->slot_count = 1;\n"
    "  frame->caller_frame = NULL;\n"
    "  result_count = frame->slots[0]->continuation.result_count;\n",
    211);
  string__c178c7d8fee76458 = from_latin_1_string(
    "  result_count =\n"
    "    frame->caller_result_count >= ",
    51);
  string__8f22c8f0e8431566 = from_latin_1_string(
    " ?\n"
    "    frame->caller_result_count-",
    34);
  string__290419bf9766c0f0 = from_latin_1_string(" : -1;\012", 7);
  string__b0a76bfaa09e5475 = from_latin_1_string("  result_count = -1;\012", 21);
  func__compiler__body__to_c_357 = create_function(entry__compiler__body__to_c_357, 0);
  string__3f31837fe07336b7 = from_latin_1_string("  result_count = frame->caller_result_count;\012", 45);
  func__compiler__body__to_c_359 = create_function(entry__compiler__body__to_c_359, 0);
  string__2d7981f4e4e02bcf = from_latin_1_string("}\012", 2);
  string__add2b8040716429a = from_latin_1_string(
    "  int i = argument_count;\n"
    "  while (--i >= 0) {\n"
    "    arguments->slots[i+",
    70);
  string__fc381eaca84ce05b = from_latin_1_string(
    "] = arguments->slots[i];\n"
    "  }\n",
    29);
  string__ba62772f4c1bf545 = from_latin_1_string(
    "  int i;\n"
    "  int n = argument_count;\n"
    "  FRAME *return_arguments = arguments;\n"
    "  allocate_arguments();\n",
    98);
  string__7b93af9dc5bb91ae = from_latin_1_string(
    "  for (i = 0; i < n; ++i) {\n"
    "    arguments->slots[argument_count++] = return_arguments->slots[i];\n"
    "  }\n",
    101);
  string__da5f7a92b20e4d64 = from_latin_1_string("frame = frame->caller_frame;", 28);
  string__357d878b1635920f = from_latin_1_string(
    "(void) {\n"
    "  frame = ((CONTINUATION *)myself)->exit_frame;\n",
    57);
  string__8e4c39950c6aecc7 = from_latin_1_string(
    "  func = continuation_type_function;\n"
    "}\n",
    39);
  string__541f532081ce52b4 = from_latin_1_string("  func", 6);
  string__86eff1a866fd255c = from_latin_1_string(" = create_function(entry", 24);
  string__4f4f87201b84976a = from_latin_1_string("create_closure(entry", 20);
  func__compiler__body___to_c = create_function(entry__compiler__body___to_c, 1);
  string__b285329ce73409a7 = from_latin_1_string("generate definition", 19);
  func__compiler__definition___to_c = create_function(entry__compiler__definition___to_c, 1);
  string__b19618e04d55f805 = from_latin_1_string("generate numeric literal", 24);
  string__64c0a950852db1bf = from_latin_1_string("number__", 8);
  func__compiler__numeric_literal___to_c = create_function(entry__compiler__numeric_literal___to_c, 1);
  string__96912fd9d89a615a = from_latin_1_string("generate character literal", 26);
  string__4ad975da2ff0e93f = from_latin_1_string("character__", 11);
  func__compiler__character_literal___to_c = create_function(entry__compiler__character_literal___to_c, 1);
  string__578a5af303e9cd1 = from_latin_1_string("0", 1);
  string__578a5af303e9cbd = from_latin_1_string("\134", 1);
  func__to_c_string = create_function(entry__to_c_string, 1);
  string__72c4ac1f052d021f = from_latin_1_string("string__", 8);
  string__cb6a78473f66a6a1 = from_latin_1_string("static NODE *", 13);
  string__a3d95bf5db908e15 = from_latin_1_string(" = from_latin_1_string(", 23);
  string__d81f467583be52f5 = from_latin_1_string(
    "\n"
    "    \042",
    6);
  func__register_string_50 = create_function(entry__register_string_50, 1);
  string__fa72f415d596bee = from_latin_1_string("\134n\042", 3);
  func__register_string_53 = create_function(entry__register_string_53, 0);
  func__register_string_59 = create_function(entry__register_string_59, 0);
  func__register_string_60 = create_function(entry__register_string_60, 0);
  string__d81f466683bcf2f7 = from_latin_1_string(
    ",\n"
    "    ",
    6);
  string__fa730c15f496bec = from_latin_1_string("\042, ", 3);
  string__24e73e91baac9a30 = from_latin_1_string("  uint32_t ", 11);
  string__4a9426e6bd63257e = from_latin_1_string("_literal[", 9);
  string__ca5afc43e8cbc02c = from_latin_1_string("] = {", 5);
  string__2d7981f4e6882bbd = from_latin_1_string("0x", 2);
  func__register_string_74 = create_function(entry__register_string_74, 1);
  func__register_string_106 = create_function(entry__register_string_106, 0);
  string__fa727015ff16bc6 = from_latin_1_string("};\012", 3);
  string__6bf55d38c602d6fa = from_latin_1_string(" = from_uint32_string(", 22);
  string__3735eb19284a5481 = from_latin_1_string("_literal, ", 10);
  string__ee21fa04ce7f45ad = from_latin_1_string("empty_string", 12);
  func__register_string_114 = create_function(entry__register_string_114, 0);
  func__register_string = create_function(entry__register_string, 1);
  string__92bdd3e04dbbd1c4 = from_latin_1_string("generate string literal", 23);
  func__compiler__string_literal___to_c = create_function(entry__compiler__string_literal___to_c, 1);
  string__d48b67664260d740 = from_latin_1_string("generate unique item", 20);
  func__compiler__unique_item__to_c_8 = create_function(entry__compiler__unique_item__to_c_8, 0);
  string__44acac92852c82df = from_latin_1_string("unique__", 8);
  string__8b8ef598707f4603 = from_latin_1_string(" = register_unique_item(\042", 25);
  string__860afb0b5fb87d33 = from_latin_1_string("\042);\012", 4);
  func__compiler__unique_item___to_c = create_function(entry__compiler__unique_item___to_c, 1);
  string__d48f33204edcb4ea = from_latin_1_string("generate identifier ", 20);
  string__fa730415f796be3 = from_latin_1_string(" */", 3);
  string__58e06d42b95eed3d = from_latin_1_string("((CELL *)frame->slots[", 22);
  string__713cab8df53e8c2e = from_latin_1_string("])->contents /* ", 16);
  string__405aee03eb306008 = from_latin_1_string("get__", 5);
  func__compiler__identifier___to_c = create_function(entry__compiler__identifier___to_c, 1);
  string__9495a9c10d9ac4d0 = from_latin_1_string("generate C-body", 15);
  string__8d88533a39505214 = from_latin_1_string("CHECK_ARGUMENTS", 15);
  func__compiler__c_body__to_c_18 = create_function(entry__compiler__c_body__to_c_18, 0);
  string__7b01aef649fee96f = from_latin_1_string("static void entry", 17);
  string__c1009742fcdd65b8 = from_latin_1_string(
    "(void);\n"
    "static NODE *func",
    25);
  string__7394a8db8445c859 = from_latin_1_string("  {entry", 8);
  string__3794a6c106b6c980 = from_latin_1_string(", NULL, ", 8);
  string__fa73ac15dc16bc6 = from_latin_1_string(
    "\n"
    "}\n",
    3);
  func__compiler__c_body___to_c = create_function(entry__compiler__c_body___to_c, 1);
  func__extract_destination = create_function(entry__extract_destination, 1);
  func__compiler__is_single_assign_18 = create_function(entry__compiler__is_single_assign_18, 0);
  func__compiler__is_single_assign = create_function(entry__compiler__is_single_assign, 1);
  func__compiler__might_be_constant_18 = create_function(entry__compiler__might_be_constant_18, 0);
  func__compiler__might_be_constant = create_function(entry__compiler__might_be_constant, 1);
  string__441f568380430288 = from_latin_1_string("func__", 6);
  string__468aa0a9b0dabd58 = from_latin_1_string("  assign_variable(&", 19);
  string__fa733415f296bea = from_latin_1_string(", &", 3);
  string__7d5cf5d8cf0f5f69 = from_latin_1_string("  assign_value(&", 16);
  func__assign = create_function(entry__assign, 2);
  string__29d4ac87c65f0ce6 = from_latin_1_string(" = collect_node(", 16);
  string__dc0dbf3dca1e95fd = from_latin_1_string(" = create_future();\012", 20);
  string__e24c48ad3fbdc6fa = from_latin_1_string("  initialize_future(", 20);
  string__2794a48106d7680a = from_latin_1_string("  NODE *", 8);
  string__55b34e50e74b4c7c = from_latin_1_string("static NODE *get__", 18);
  string__5a35746c23f76309 = from_latin_1_string(
    "(void) {\n"
    "  return var.",
    22);
  string__b29ac022d5eddd84 = from_latin_1_string("  define_single_assign_static(\042", 31);
  string__860afa4b5f607d1b = from_latin_1_string("\042, \042", 4);
  string__65a4a8f6052de83f = from_latin_1_string("\042, get__", 8);
  string__51b735d4017b50ea = from_latin_1_string(
    ";\n"
    "}\n"
    "static void set__",
    21);
  string__8454c532619bd34d = from_latin_1_string(
    "(NODE *val) {\n"
    "  var.",
    20);
  string__833e0a9b7bc3bd8b = from_latin_1_string(
    " = val;\n"
    "}\n",
    10);
  string__e8ada4deabe9f7ad = from_latin_1_string("  define_multi_assign_static(\042", 30);
  string__b93408f29443f0a5 = from_latin_1_string(", set__", 7);
  string__dd395a997055f7fe = from_latin_1_string("static int dyna_idx__", 21);
  string__34fd7239574f514 = from_latin_1_string(
    ";\n"
    "static NODE *get__",
    20);
  string__70ebfdeaadefaa37 = from_latin_1_string(
    "(void) {\n"
    "  return get_dynamic_slot(dyna_idx__",
    45);
  string__5226770621835bc8 = from_latin_1_string(
    ");\n"
    "}\n"
    "static void define__",
    25);
  string__473bf089a0140715 = from_latin_1_string(
    "(NODE *node) {\n"
    "  define_dynamic_slot(dyna_idx__",
    47);
  string__36cf2bd921e53ad9 = from_latin_1_string(
    ", node);\n"
    "}\n",
    11);
  string__152abda47b75d554 = from_latin_1_string("  define_single_assign_dynamic(\042", 32);
  string__29727158e7d3e55e = from_latin_1_string(", define__", 10);
  string__4a6ef2ffac34c765 = from_latin_1_string(", &dyna_idx__", 13);
  string__746bfddaaddfea37 = from_latin_1_string(
    "(void) {\n"
    "  return get_dynamic_cell(dyna_idx__",
    45);
  string__13372791bc1cbb98 = from_latin_1_string(
    ");\n"
    "}\n"
    "static void set__",
    22);
  string__8224dc1c3f83e7f2 = from_latin_1_string(
    "(NODE *node) {\n"
    "  set_dynamic_cell(dyna_idx__",
    44);
  string__1e8f2aa38d3f4060 = from_latin_1_string(
    ", node);\n"
    "}\n"
    "static void define__",
    31);
  string__43bbf0b9a0244715 = from_latin_1_string(
    "(NODE *node) {\n"
    "  define_dynamic_cell(dyna_idx__",
    47);
  string__32c94d852a3f04ef = from_latin_1_string("  define_multi_assign_dynamic(\042", 31);
  string__5e7cd5f37502c62e = from_latin_1_string(
    ");\n"
    "  define__",
    13);
  string__4a4ee6e733be0622 = from_latin_1_string("(undefined);\012", 13);
  string__fa730415f296bee = from_latin_1_string("  \042", 3);
  string__fa730c15f496bc6 = from_latin_1_string("\042,\012", 3);
  string__4c5ea74244cf1425 = from_latin_1_string("  register_dynamic(&dyna_idx__", 30);
  string__29721158e7d3e55e = from_latin_1_string("  define__", 10);
  string__8275ab8967245782 = from_latin_1_string("(create_future());\012", 19);
  string__2690e3d8e7540abd = from_latin_1_string("  maybe_initialize_future(get__", 31);
  string__920afb0b5f007d19 = from_latin_1_string("(), ", 4);
  string__55defe7d73d85409 = from_latin_1_string("  initialize_future(get__", 25);
  func__compiler__define_variable = create_function(entry__compiler__define_variable, 3);
  string__5e0ae40b5c007d75 = from_latin_1_string("NULL", 4);
  func__namespace_argument_5 = create_function(entry__namespace_argument_5, 0);
  func__namespace_argument = create_function(entry__namespace_argument, 1);
  string__485aef83eb317008 = from_latin_1_string("var__", 5);
  string__74e31c7f67a4e996 = from_latin_1_string("  define_attribute(", 19);
  string__fa733415f296bee = from_latin_1_string(", \042", 3);
  string__ca0e521fba2cc724 = from_latin_1_string("\042, poly_idx__", 13);
  func__compiler__define_attribute = create_function(entry__compiler__define_attribute, 2);
  string__45b0be3ac644df67 = from_latin_1_string("  define_method(", 16);
  func__compiler__define_method = create_function(entry__compiler__define_method, 2);
  string__292e5d6949e4a763 = from_latin_1_string("  define_type_function(", 23);
  func__compiler__define_type_function = create_function(entry__compiler__define_type_function, 2);
  string__62213544ce52579e = from_latin_1_string("_with_setter", 12);
  func__compiler__define_polymorphic_function_3 = create_function(entry__compiler__define_polymorphic_function_3, 0);
  func__compiler__define_polymorphic_function_5 = create_function(entry__compiler__define_polymorphic_function_5, 0);
  func__compiler__define_polymorphic_function_20 = create_function(entry__compiler__define_polymorphic_function_20, 0);
  string__dd59fa996655f7be = from_latin_1_string("static int poly_idx__", 21);
  string__4edc27e6c3faecfa = from_latin_1_string("  {type__", 9);
  string__63e6320520af81f6 = from_latin_1_string(", create_function(type__", 24);
  string__fd94bfb0860889aa = from_latin_1_string(", -1));\012", 8);
  string__94aa6a2a3d156a1a = from_latin_1_string("  define_privileged_polymorphic_function(\042", 42);
  string__3764e728034d321b = from_latin_1_string("  define_polymorphic_function", 29);
  string__2d7981f4e6482be7 = from_latin_1_string("(\042", 2);
  string__4a0e52ffba34c725 = from_latin_1_string(", &poly_idx__", 13);
  string__6a22d67b14b60a68 = from_latin_1_string("  register_polymorphic_function", 31);
  string__fa732415f396b93 = from_latin_1_string("(\042_", 3);
  string__2d7981f4e6d82bff = from_latin_1_string("::", 2);
  string__286520bd3a268298 = from_latin_1_string("\042, &poly_idx__", 14);
  func__compiler__define_polymorphic_function = create_function(entry__compiler__define_polymorphic_function, 2);
  string__456a9bb1ba62862f = from_latin_1_string("define C-code", 13);
  string__ed193cb4814526fb = from_latin_1_string(" = create_future_with_prototype(create__", 40);
  string__a897d8196ef1bb0f = from_latin_1_string(" = create__", 11);
  string__327b6356c2c20676 = from_latin_1_string(
    "(void) {\n"
    "  return ",
    18);
  string__9a4c0f9815d2209f = from_latin_1_string("runtime", 7);
  func__compiler__define_c_code_43 = create_function(entry__compiler__define_c_code_43, 0);
  string__461f56c301b292bb = from_latin_1_string("global", 6);
  func__compiler__define_c_code_45 = create_function(entry__compiler__define_c_code_45, 0);
  string__701f5702012bd2b9 = from_latin_1_string("extern", 6);
  string__b810095e95cb80da = from_latin_1_string("extern ", 7);
  func__compiler__define_c_code_47 = create_function(entry__compiler__define_c_code_47, 0);
  string__9a480f9895a2d0da = from_latin_1_string("static ", 7);
  func__compiler__define_c_code_49 = create_function(entry__compiler__define_c_code_49, 0);
  func__compiler__define_c_code_56 = create_function(entry__compiler__define_c_code_56, 0);
  func__compiler__define_c_code_61 = create_function(entry__compiler__define_c_code_61, 0);
  func__compiler__define_c_code_67 = create_function(entry__compiler__define_c_code_67, 0);
  func__compiler__define_c_code_74 = create_function(entry__compiler__define_c_code_74, 0);
  string__3148e46705c3e08c = from_latin_1_string(
    "\n"
    "typedef struct ",
    16);
  string__44fc2666d9a259c5 = from_latin_1_string(
    ";\n"
    "struct ",
    9);
  string__fa730415df16bc6 = from_latin_1_string(" {\012", 3);
  string__d60aee0b5fb87d33 = from_latin_1_string(
    "\n"
    "};\n",
    4);
  string__dd8b990a9b395bcf = from_latin_1_string(
    "\n"
    "typedef struct {\n"
    "  void *type;\n"
    "  ATTRIBUTES *attributes;\n",
    58);
  string__fa73ac15dc16bec = from_latin_1_string(
    "\n"
    "} ",
    3);
  string__64a8ad100475501f = from_latin_1_string("collect_", 8);
  string__4a1f574b83baa2fd = from_latin_1_string("void *", 6);
  string__3cc912e9d780065b = from_latin_1_string(
    " *node) {\n"
    "  ",
    12);
  string__ace7f55a2ad7b400 = from_latin_1_string(" *new_node = allocate(sizeof(", 29);
  string__c14689165b56e017 = from_latin_1_string(
    "));\n"
    "  new_node->type = node->type;\n"
    "  *(void **)node = ENCODE_ADDRESS(new_node);\n"
    "  new_node->attributes = collect_attributes(node->attributes);\n",
    143);
  string__2d7981f4e6702bea = from_latin_1_string("//", 2);
  string__2d7981f4e6082bef = from_latin_1_string(" *", 2);
  func__compiler__define_c_code_125 = create_function(entry__compiler__define_c_code_125, 0);
  func__compiler__define_c_code_124 = create_function(entry__compiler__define_c_code_124, 0);
  string__8221090a5decf427 = from_latin_1_string("  new_node->", 12);
  string__8ae3d99defa96b0f = from_latin_1_string(" = collect_", 11);
  string__bb240c9597d230c4 = from_latin_1_string("(node->", 7);
  string__67b027ebc06b8f3b = from_latin_1_string(" = node->", 9);
  func__compiler__define_c_code_100 = create_function(entry__compiler__define_c_code_100, 1);
  string__109c72e613b07f37 = from_latin_1_string(
    "  return new_node;\n"
    "}\n",
    21);
  string__b03fb6d3baf99607 = from_latin_1_string("Missing definition for a node named \042", 37);
  string__2d7981f4e6182be4 = from_latin_1_string("\042!", 2);
  string__6794ac9106bd681e = from_latin_1_string("  node->", 8);
  string__578a5af303e9ccf = from_latin_1_string(".", 1);
  string__734b84c8aaa0637f = from_latin_1_string(
    "\n"
    "static VTABLE vtable__",
    23);
  string__6b4ef47674efbb78 = from_latin_1_string(
    " = {\n"
    "  sizeof(",
    14);
  string__ff4aca011f98585e = from_latin_1_string(
    "),\n"
    "  (COLLECTOR *)&collect_",
    27);
  string__2d7981f4e6682bcf = from_latin_1_string(",\012", 2);
  func__compiler__define_c_code_204 = create_function(entry__compiler__define_c_code_204, 0);
  string__73a8266fc3fa2cfa = from_latin_1_string("  &func__", 9);
  string__fa72f815cd16b93 = from_latin_1_string("___", 3);
  string__eaff60749c89e4cd = from_latin_1_string("  (void *)no_such_function", 26);
  string__cd95367056669d06 = from_latin_1_string("types__undefined", 16);
  string__c94100bb7a7ab992 = from_latin_1_string(
    "\n"
    "static ATTRIBUTES attributes__types__undefined = {\n"
    "  &vtable__types__undefined,\n"
    "  {\n"
    "    &no_attributes_level_1, &no_attributes_level_2,\n"
    "    &no_attributes_level_3, &no_attributes_level_4,\n"
    "    &no_attributes_level_5, &no_attributes_level_6,\n"
    "    &no_attributes_level_7\n"
    "  }\n"
    "};\n",
    275);
  string__a56c0e191d6c2c6 = from_latin_1_string(
    "\n"
    "static ATTRIBUTES attributes__",
    31);
  string__2fd6cd588445ce22 = from_latin_1_string(
    " = {\n"
    "  &vtable__",
    16);
  string__b0750f892a4c2658 = from_latin_1_string(
    ",\n"
    "  {\n"
    "    &undefined_attributes_level_1, &undefined_attributes_level_2,\n"
    "    &undefined_attributes_level_3, &undefined_attributes_level_4,\n"
    "    &undefined_attributes_level_5, &undefined_attributes_level_6,\n"
    "    &undefined_attributes_level_7\n"
    "  }\n"
    "};\n",
    245);
  string__7ddeab9420211acf = from_latin_1_string("  collect_static_attributes(&attributes__", 41);
  string__21dd4811a7f03bfa = from_latin_1_string("void type__", 11);
  string__46dcac94852d801f = from_latin_1_string("create__", 8);
  string__101f5f1783b8a2fd = from_latin_1_string("NODE *", 6);
  string__1c6c7289032a5d69 = from_latin_1_string("SIMPLE_NODE", 11);
  string__94481952eb48e343 = from_latin_1_string("SIMPLE_NODE ", 12);
  string__505bb7858ec4a9cf = from_latin_1_string(
    "__node =\n"
    "  {\n"
    "    type__",
    23);
  string__b067b139c37c931b = from_latin_1_string(
    ",\n"
    "    &attributes__",
    19);
  string__89ac1b3296eec0f0 = from_latin_1_string(
    "\n"
    "  };\n"
    "\n",
    7);
  string__a9ca63e3254dce43 = from_latin_1_string(
    ") {\n"
    "  return (NODE *)&",
    22);
  string__8359f29999c3244b = from_latin_1_string(
    "__node;\n"
    "}\n",
    10);
  string__27970d05ed81c641 = from_latin_1_string(
    ") {\n"
    "  NODE *node = allocate(sizeof(",
    35);
  string__8262d9eaa714e89c = from_latin_1_string(
    "));\n"
    "  node->type = type__",
    25);
  string__16179a4c575e7ddc = from_latin_1_string(
    ";\n"
    "  node->attributes = &attributes__",
    36);
  string__59fe708e86aaa5e8 = from_latin_1_string(
    "  return node;\n"
    "}\n",
    17);
  string__748827e691fbe65a = from_latin_1_string("runtime__", 9);
  func__compiler__define_c_code_288 = create_function(entry__compiler__define_c_code_288, 0);
  func__compiler__define_c_code_289 = create_function(entry__compiler__define_c_code_289, 0);
  string__3d3ee41dbe82cf11 = from_latin_1_string("  define_c_function(\042", 21);
  string__b8540cde1593c09c = from_latin_1_string("typedef", 7);
  string__dc390a4415e8342c = from_latin_1_string("Unknown kind (\042", 15);
  string__3cadee4d21d69e73 = from_latin_1_string("\042) in C-code declaration!", 25);
  string__7c1f530901a312a3 = from_latin_1_string("struct", 6);
  string__1e0aea8b5d407d5c = from_latin_1_string("node", 4);
  string__2a0aef0b5de07d5c = from_latin_1_string("type", 4);
  string__4c1f570701a272a3 = from_latin_1_string("object", 6);
  string__46c0af9104ada08e = from_latin_1_string("function", 8);
  func__compiler__define_c_code = create_function(entry__compiler__define_c_code, 1);
  string__5aaca17e38892df6 = from_latin_1_string(
    "  {\n"
    "    NODE *temp = clone_object_and_attributes(",
    49);
  string__3374d958c75663b2 = from_latin_1_string(
    ");\n"
    "    update_start_p = node_p;\n",
    32);
  func__assign_attributes_15 = create_function(entry__assign_attributes_15, 0);
  string__5a1f555f011332b2 = from_latin_1_string("_value", 6);
  func__assign_attributes_16 = create_function(entry__assign_attributes_16, 0);
  string__4913e735c7c32ec6 = from_latin_1_string("    set_attribute", 17);
  string__e44f3203f587e9fa = from_latin_1_string("(temp->attributes, poly_idx__", 29);
  string__7128a00098ab7c5 = from_latin_1_string("    temp->type = ", 17);
  string__4fecac9c060c098a = from_latin_1_string("->type;\012", 8);
  func__assign_attributes_7 = create_function(entry__assign_attributes_7, 1);
  string__2a0ae80b5d087d49 = from_latin_1_string("temp", 4);
  string__ca5afb03ea26b05d = from_latin_1_string(
    "\n"
    "  }\n",
    5);
  func__assign_attributes = create_function(entry__assign_attributes, 3);
  string__1f458f464eec9b66 = from_latin_1_string("generate procedure call", 23);
  func__compiler__generate_statement_5 = create_function(entry__compiler__generate_statement_5, 0);
  string__80851998713c7b1d = from_latin_1_string("generate assignment", 19);
  func__compiler__generate_statement_9 = create_function(entry__compiler__generate_statement_9, 0);
  string__8b102f799cb53c4 = from_latin_1_string("generate unknown statement", 26);
  func__compiler__generate_statement_11 = create_function(entry__compiler__generate_statement_11, 0);
  string__2c055578f6e77c80 = from_latin_1_string("  result_count = to_int(", 24);
  string__2d7981f4e6402bfe = from_latin_1_string(");", 2);
  string__d263a6c16aa42f0f = from_latin_1_string("Call with continuation followed by another statement", 52);
  string__47feaa767baa1465 = from_latin_1_string("  result_count = ", 17);
  string__578a5af303e9cda = from_latin_1_string(";", 1);
  string__ca8ff614ed7f5413 = from_latin_1_string("  result_count = -1;", 20);
  func__compiler__generate_statement_65 = create_function(entry__compiler__generate_statement_65, 0);
  func__compiler__generate_statement_70 = create_function(entry__compiler__generate_statement_70, 0);
  func__compiler__generate_statement_71 = create_function(entry__compiler__generate_statement_71, 0);
  string__b0d32d3bb6b3b99c = from_latin_1_string("  initialize_maybe_future(", 26);
  func__compiler__generate_statement = create_function(entry__compiler__generate_statement, 1);
}

static int already_run_phase_3 = false;

EXPORT void phase_3__c_code_generator(void) {
  if (already_run_phase_3) return;
  already_run_phase_3 = true;
  set_module("c_code_generator");
  set_used_namespaces(used_namespaces);
  define_single_assign_dynamic("compiler", "suffix", get__compiler__suffix, define__compiler__suffix, &dyna_idx__compiler__suffix);
  define__compiler__suffix(create_future());
  register_dynamic(&dyna_idx__level);
  register_dynamic(&dyna_idx__cont_suffix);
  define__cont_suffix(create_future());
  register_dynamic(&dyna_idx__current_locals);
  define__current_locals(create_future());
  register_dynamic(&dyna_idx__current_frame);
  define__current_frame(create_future());
  register_dynamic(&dyna_idx__is_a_shared_local);
  define__is_a_shared_local(create_future());
  register_dynamic(&dyna_idx__temporary_offset);
  define_multi_assign_dynamic("compiler", "delayed_code", get__compiler__delayed_code, set__compiler__delayed_code, define__compiler__delayed_code, &dyna_idx__compiler__delayed_code);
  define__compiler__delayed_code(undefined);
  var.compiler__begin_continuation = create_future();
  define_single_assign_static("compiler", "begin_continuation", get__compiler__begin_continuation, &var.compiler__begin_continuation);
  var.compiler__end_continuation = create_future();
  define_single_assign_static("compiler", "end_continuation", get__compiler__end_continuation, &var.compiler__end_continuation);
  var.compiler__next_continuation = create_future();
  define_single_assign_static("compiler", "next_continuation", get__compiler__next_continuation, &var.compiler__next_continuation);
  var.compiler__assignment_to_c = create_future();
  define_single_assign_static("compiler", "assignment_to_c", get__compiler__assignment_to_c, &var.compiler__assignment_to_c);
  var.compiler__write_source_as_remark = create_future();
  define_single_assign_static("compiler", "write_source_as_remark", get__compiler__write_source_as_remark, &var.compiler__write_source_as_remark);
  var.compiler__is_single_assign = create_future();
  define_single_assign_static("compiler", "is_single_assign", get__compiler__is_single_assign, &var.compiler__is_single_assign);
  var.compiler__might_be_constant = create_future();
  define_single_assign_static("compiler", "might_be_constant", get__compiler__might_be_constant, &var.compiler__might_be_constant);
  var.compiler__define_variable = create_future();
  define_single_assign_static("compiler", "define_variable", get__compiler__define_variable, &var.compiler__define_variable);
  var.compiler__define_attribute = create_future();
  define_single_assign_static("compiler", "define_attribute", get__compiler__define_attribute, &var.compiler__define_attribute);
  var.compiler__define_method = create_future();
  define_single_assign_static("compiler", "define_method", get__compiler__define_method, &var.compiler__define_method);
  var.compiler__define_type_function = create_future();
  define_single_assign_static("compiler", "define_type_function", get__compiler__define_type_function, &var.compiler__define_type_function);
  var.compiler__define_polymorphic_function = create_future();
  define_single_assign_static("compiler", "define_polymorphic_function", get__compiler__define_polymorphic_function, &var.compiler__define_polymorphic_function);
  var.compiler__define_c_code = create_future();
  define_single_assign_static("compiler", "define_c_code", get__compiler__define_c_code, &var.compiler__define_c_code);
  var.compiler__generate_statement = create_future();
  define_single_assign_static("compiler", "generate_statement", get__compiler__generate_statement, &var.compiler__generate_statement);
}

static int already_run_phase_4 = false;

EXPORT void phase_4__c_code_generator(void) {
  if (already_run_phase_4) return;
  already_run_phase_4 = true;
  set_module("c_code_generator");
  set_used_namespaces(used_namespaces);
  use_read_only(NULL, "ATTRIBUTE_KIND", &get__ATTRIBUTE_KIND, &get_value_or_future__ATTRIBUTE_KIND);
  use_read_only(NULL, "CONTINUATION_PARAMETER", &get__CONTINUATION_PARAMETER, &get_value_or_future__CONTINUATION_PARAMETER);
  use_read_only(NULL, "DYNAMIC_MULTI", &get__DYNAMIC_MULTI, &get_value_or_future__DYNAMIC_MULTI);
  use_read_only(NULL, "DYNAMIC_SINGLE", &get__DYNAMIC_SINGLE, &get_value_or_future__DYNAMIC_SINGLE);
  use_read_only(NULL, "Error", &get__Error, &get_value_or_future__Error);
  use_read_only(NULL, "IN_OUT_PARAMETER", &get__IN_OUT_PARAMETER, &get_value_or_future__IN_OUT_PARAMETER);
  use_read_only(NULL, "METHOD_KIND", &get__METHOD_KIND, &get_value_or_future__METHOD_KIND);
  use_read_only(NULL, "MYSELF_PARAMETER", &get__MYSELF_PARAMETER, &get_value_or_future__MYSELF_PARAMETER);
  use_read_only(NULL, "NONE", &get__NONE, &get_value_or_future__NONE);
  use_read_only(NULL, "OUT_PARAMETER", &get__OUT_PARAMETER, &get_value_or_future__OUT_PARAMETER);
  use_read_only(NULL, "POLYMORPHIC", &get__POLYMORPHIC, &get_value_or_future__POLYMORPHIC);
  use_read_only(NULL, "STATIC_MULTI", &get__STATIC_MULTI, &get_value_or_future__STATIC_MULTI);
  use_read_only(NULL, "STATIC_SINGLE", &get__STATIC_SINGLE, &get_value_or_future__STATIC_SINGLE);
  use_read_only(NULL, "SyntaxError", &get__SyntaxError, &get_value_or_future__SyntaxError);
  use_read_only(NULL, "alt", &get__alt, &get_value_or_future__alt);
  use_read_only(NULL, "any_of", &get__any_of, &get_value_or_future__any_of);
  use_read_only(NULL, "append", &get__append, &get_value_or_future__append);
  use_read_only(NULL, "arguments_of", &get__arguments_of, &get_value_or_future__arguments_of);
  use_read_only(NULL, "assignment_to_c", &get__assignment_to_c, &get_value_or_future__assignment_to_c);
  use_read_only(NULL, "attribute_kind_of", &get__attribute_kind_of, &get_value_or_future__attribute_kind_of);
  use_read_only(NULL, "attribute_of", &get__attribute_of, &get_value_or_future__attribute_of);
  use_read_only(NULL, "base_of", &get__base_of, &get_value_or_future__base_of);
  use_read_only(NULL, "before", &get__before, &get_value_or_future__before);
  use_read_only(NULL, "begin_continuation", &get__begin_continuation, &get_value_or_future__begin_continuation);
  use_read_only(NULL, "behind", &get__behind, &get_value_or_future__behind);
  use_read_only(NULL, "between", &get__between, &get_value_or_future__between);
  use_read_only(NULL, "case", &get__case, &get_value_or_future__case);
  use_read_only(NULL, "collect_output", &get__collect_output, &get_value_or_future__collect_output);
  use_read_only("compiler", "body", &get__compiler__body, &get_value_or_future__compiler__body);
  use_read_only("compiler", "c_body", &get__compiler__c_body, &get_value_or_future__compiler__c_body);
  use_read_only("compiler", "character_literal", &get__compiler__character_literal, &get_value_or_future__compiler__character_literal);
  use_multi_assign_dynamic("compiler", "current_continuation_info", &get__compiler__current_continuation_info, &set__compiler__current_continuation_info, &define__compiler__current_continuation_info);
  use_read_only("compiler", "definition", &get__compiler__definition, &get_value_or_future__compiler__definition);
  use_read_only("compiler", "identifier", &get__compiler__identifier, &get_value_or_future__compiler__identifier);
  use_read_only("compiler", "numeric_literal", &get__compiler__numeric_literal, &get_value_or_future__compiler__numeric_literal);
  use_read_only("compiler", "string_literal", &get__compiler__string_literal, &get_value_or_future__compiler__string_literal);
  use_read_only("compiler", "unique_item", &get__compiler__unique_item, &get_value_or_future__compiler__unique_item);
  use_read_only(NULL, "cond", &get__cond, &get_value_or_future__cond);
  use_read_only(NULL, "contains", &get__contains, &get_value_or_future__contains);
  use_read_only(NULL, "continuation_of", &get__continuation_of, &get_value_or_future__continuation_of);
  use_read_only(NULL, "converted", &get__converted, &get_value_or_future__converted);
  use_read_only(NULL, "count_character_occurrences", &get__count_character_occurrences, &get_value_or_future__count_character_occurrences);
  use_read_write(NULL, "current_continuation_info", &get__current_continuation_info, &set__current_continuation_info);
  use_read_only(NULL, "dec", &get__dec, &get_value_or_future__dec);
  use_read_only(NULL, "default_value", &get__default_value, &get_value_or_future__default_value);
  use_read_only(NULL, "default_value_of", &get__default_value_of, &get_value_or_future__default_value_of);
  use_read_only(NULL, "defined_functions", &get__defined_functions, &get_value_or_future__defined_functions);
  use_read_only(NULL, "defined_names_of", &get__defined_names_of, &get_value_or_future__defined_names_of);
  use_read_only(NULL, "defined_nodes", &get__defined_nodes, &get_value_or_future__defined_nodes);
  use_read_only(NULL, "defined_structs", &get__defined_structs, &get_value_or_future__defined_structs);
  use_read_only(NULL, "defines_a_dynamic", &get__defines_a_dynamic, &get_value_or_future__defines_a_dynamic);
  use_read_only(NULL, "definitions_of", &get__definitions_of, &get_value_or_future__definitions_of);
  use_read_write(NULL, "delayed_code", &get__delayed_code, &set__delayed_code);
  use_read_only(NULL, "do", &get__do, &get_value_or_future__do);
  use_read_only(NULL, "do_show_compiler_debug_infos", &get__do_show_compiler_debug_infos, &get_value_or_future__do_show_compiler_debug_infos);
  use_read_only(NULL, "dup", &get__dup, &get_value_or_future__dup);
  use_read_only(NULL, "empty_insert_order_table", &get__empty_insert_order_table, &get_value_or_future__empty_insert_order_table);
  use_read_only(NULL, "empty_list", &get__empty_list, &get_value_or_future__empty_list);
  use_read_only(NULL, "empty_set", &get__empty_set, &get_value_or_future__empty_set);
  use_read_only(NULL, "empty_table", &get__empty_table, &get_value_or_future__empty_table);
  use_read_only(NULL, "end_continuation", &get__end_continuation, &get_value_or_future__end_continuation);
  use_read_only(NULL, "end_position_of", &get__end_position_of, &get_value_or_future__end_position_of);
  use_read_only(NULL, "ewriteln", &get__ewriteln, &get_value_or_future__ewriteln);
  use_read_only(NULL, "exported_names", &get__exported_names, &get_value_or_future__exported_names);
  use_read_only(NULL, "false", &get__false, &get_value_or_future__false);
  use_read_only(NULL, "for_each", &get__for_each, &get_value_or_future__for_each);
  use_read_only(NULL, "for_each_from_to", &get__for_each_from_to, &get_value_or_future__for_each_from_to);
  use_read_only(NULL, "for_each_line", &get__for_each_line, &get_value_or_future__for_each_line);
  use_read_only(NULL, "fragment_of", &get__fragment_of, &get_value_or_future__fragment_of);
  use_read_only(NULL, "from", &get__from, &get_value_or_future__from);
  use_read_only(NULL, "from_down_to", &get__from_down_to, &get_value_or_future__from_down_to);
  use_read_only(NULL, "from_to", &get__from_to, &get_value_or_future__from_to);
  use_read_only(NULL, "functor_of", &get__functor_of, &get_value_or_future__functor_of);
  use_read_only(NULL, "generate_dispatcher_function", &get__generate_dispatcher_function, &get_value_or_future__generate_dispatcher_function);
  use_read_only(NULL, "generate_statement", &get__generate_statement, &get_value_or_future__generate_statement);
  use_read_only(NULL, "global_names", &get__global_names, &get_value_or_future__global_names);
  use_read_only(NULL, "has_prefix", &get__has_prefix, &get_value_or_future__has_prefix);
  use_read_only(NULL, "has_suffix", &get__has_suffix, &get_value_or_future__has_suffix);
  use_read_only(NULL, "hash2", &get__hash2, &get_value_or_future__hash2);
  use_read_only(NULL, "hex", &get__hex, &get_value_or_future__hex);
  use_read_only(NULL, "identifier_of", &get__identifier_of, &get_value_or_future__identifier_of);
  use_read_only(NULL, "if", &get__if, &get_value_or_future__if);
  use_read_only(NULL, "inc", &get__inc, &get_value_or_future__inc);
  use_read_only(NULL, "indent_marker", &get__indent_marker, &get_value_or_future__indent_marker);
  use_read_only(NULL, "indented", &get__indented, &get_value_or_future__indented);
  use_read_only(NULL, "indents_of", &get__indents_of, &get_value_or_future__indents_of);
  use_read_write(NULL, "index", &get__index, &set__index);
  use_read_only(NULL, "inherited_names_of", &get__inherited_names_of, &get_value_or_future__inherited_names_of);
  use_read_only(NULL, "is_a_constant", &get__is_a_constant, &get_value_or_future__is_a_constant);
  use_read_only(NULL, "is_a_definition", &get__is_a_definition, &get_value_or_future__is_a_definition);
  use_read_only(NULL, "is_a_destination", &get__is_a_destination, &get_value_or_future__is_a_destination);
  use_read_only(NULL, "is_a_function_call", &get__is_a_function_call, &get_value_or_future__is_a_function_call);
  use_read_only(NULL, "is_a_key_value_pair", &get__is_a_key_value_pair, &get_value_or_future__is_a_key_value_pair);
  use_read_only(NULL, "is_a_latin_1_string", &get__is_a_latin_1_string, &get_value_or_future__is_a_latin_1_string);
  use_read_only(NULL, "is_a_multi_assign_definition", &get__is_a_multi_assign_definition, &get_value_or_future__is_a_multi_assign_definition);
  use_read_only(NULL, "is_a_parameter", &get__is_a_parameter, &get_value_or_future__is_a_parameter);
  use_read_only(NULL, "is_a_procedure_call", &get__is_a_procedure_call, &get_value_or_future__is_a_procedure_call);
  use_read_only(NULL, "is_a_reference", &get__is_a_reference, &get_value_or_future__is_a_reference);
  use_read_only(NULL, "is_a_return", &get__is_a_return, &get_value_or_future__is_a_return);
  use_read_only(NULL, "is_a_single_assign_definition", &get__is_a_single_assign_definition, &get_value_or_future__is_a_single_assign_definition);
  use_read_only(NULL, "is_a_static_definition", &get__is_a_static_definition, &get_value_or_future__is_a_static_definition);
  use_read_only(NULL, "is_a_string", &get__is_a_string, &get_value_or_future__is_a_string);
  use_read_only(NULL, "is_a_temporary", &get__is_a_temporary, &get_value_or_future__is_a_temporary);
  use_read_only(NULL, "is_an_assignment", &get__is_an_assignment, &get_value_or_future__is_an_assignment);
  use_read_only(NULL, "is_an_attribute_function_pair", &get__is_an_attribute_function_pair, &get_value_or_future__is_an_attribute_function_pair);
  use_read_only(NULL, "is_an_attribute_value_pair", &get__is_an_attribute_value_pair, &get_value_or_future__is_an_attribute_value_pair);
  use_read_only(NULL, "is_an_expanded_item", &get__is_an_expanded_item, &get_value_or_future__is_an_expanded_item);
  use_read_only(NULL, "is_an_identifier", &get__is_an_identifier, &get_value_or_future__is_an_identifier);
  use_read_only(NULL, "is_an_initialization", &get__is_an_initialization, &get_value_or_future__is_an_initialization);
  use_read_only(NULL, "is_an_input_output_argument", &get__is_an_input_output_argument, &get_value_or_future__is_an_input_output_argument);
  use_read_only(NULL, "is_an_optional_item", &get__is_an_optional_item, &get_value_or_future__is_an_optional_item);
  use_read_only(NULL, "is_defined", &get__is_defined, &get_value_or_future__is_defined);
  use_read_only(NULL, "is_empty", &get__is_empty, &get_value_or_future__is_empty);
  use_read_only(NULL, "is_undefined", &get__is_undefined, &get_value_or_future__is_undefined);
  use_read_only(NULL, "key_of", &get__key_of, &get_value_or_future__key_of);
  use_read_only(NULL, "kind_of", &get__kind_of, &get_value_or_future__kind_of);
  use_read_only(NULL, "length_of", &get__length_of, &get_value_or_future__length_of);
  use_read_only(NULL, "line_no_of", &get__line_no_of, &get_value_or_future__line_no_of);
  use_read_only(NULL, "list", &get__list, &get_value_or_future__list);
  use_read_only(NULL, "mangled_name_of", &get__mangled_name_of, &get_value_or_future__mangled_name_of);
  use_read_only(NULL, "max", &get__max, &get_value_or_future__max);
  use_read_only(NULL, "might_be_constant", &get__might_be_constant, &get_value_or_future__might_be_constant);
  use_read_only(NULL, "module_name", &get__module_name, &get_value_or_future__module_name);
  use_read_only(NULL, "name_of", &get__name_of, &get_value_or_future__name_of);
  use_read_only(NULL, "namespace_of", &get__namespace_of, &get_value_or_future__namespace_of);
  use_read_only(NULL, "needed_names", &get__needed_names, &get_value_or_future__needed_names);
  use_read_only(NULL, "newline", &get__newline, &get_value_or_future__newline);
  use_read_only(NULL, "next_continuation", &get__next_continuation, &get_value_or_future__next_continuation);
  use_read_only("node", "text_of", &get__node__text_of, &get_value_or_future__node__text_of);
  use_read_only("node", "type_of", &get__node__type_of, &get_value_or_future__node__type_of);
  use_read_only("node", "value_of", &get__node__value_of, &get_value_or_future__node__value_of);
  use_read_only(NULL, "node_of", &get__node_of, &get_value_or_future__node_of);
  use_read_only(NULL, "normalize", &get__normalize, &get_value_or_future__normalize);
  use_read_only(NULL, "not", &get__not, &get_value_or_future__not);
  use_read_only(NULL, "oct", &get__oct, &get_value_or_future__oct);
  use_read_only(NULL, "outdent_marker", &get__outdent_marker, &get_value_or_future__outdent_marker);
  use_read_only(NULL, "pad_left", &get__pad_left, &get_value_or_future__pad_left);
  use_read_only(NULL, "parameter_count_of", &get__parameter_count_of, &get_value_or_future__parameter_count_of);
  use_read_only(NULL, "parameter_kind_of", &get__parameter_kind_of, &get_value_or_future__parameter_kind_of);
  use_read_only(NULL, "parameters_of", &get__parameters_of, &get_value_or_future__parameters_of);
  use_read_only(NULL, "plus", &get__plus, &get_value_or_future__plus);
  use_read_only(NULL, "privileged_polymorphic_functions", &get__privileged_polymorphic_functions, &get_value_or_future__privileged_polymorphic_functions);
  use_read_only(NULL, "push", &get__push, &get_value_or_future__push);
  use_read_only(NULL, "range", &get__range, &get_value_or_future__range);
  use_read_only(NULL, "replace_all", &get__replace_all, &get_value_or_future__replace_all);
  use_read_only(NULL, "result_count_of", &get__result_count_of, &get_value_or_future__result_count_of);
  use_read_only(NULL, "scope_of", &get__scope_of, &get_value_or_future__scope_of);
  use_read_only(NULL, "search_character", &get__search_character, &get_value_or_future__search_character);
  use_read_only(NULL, "show_compiler_debug_info", &get__show_compiler_debug_info, &get_value_or_future__show_compiler_debug_info);
  use_read_only(NULL, "source_of", &get__source_of, &get_value_or_future__source_of);
  use_read_only(NULL, "source_position_of", &get__source_position_of, &get_value_or_future__source_position_of);
  use_read_only(NULL, "statements_of", &get__statements_of, &get_value_or_future__statements_of);
  use_read_only("std", "and", &get__std__and, &get_value_or_future__std__and);
  use_read_only("std", "equal", &get__std__equal, &get_value_or_future__std__equal);
  use_read_only("std", "key_value_pair", &get__std__key_value_pair, &get_value_or_future__std__key_value_pair);
  use_read_only("std", "less", &get__std__less, &get_value_or_future__std__less);
  use_read_only("std", "minus", &get__std__minus, &get_value_or_future__std__minus);
  use_read_only("std", "negate", &get__std__negate, &get_value_or_future__std__negate);
  use_read_only("std", "not", &get__std__not, &get_value_or_future__std__not);
  use_read_only("std", "or", &get__std__or, &get_value_or_future__std__or);
  use_read_only("std", "plus", &get__std__plus, &get_value_or_future__std__plus);
  use_read_only("std", "sequence", &get__std__sequence, &get_value_or_future__std__sequence);
  use_read_only("std", "string", &get__std__string, &get_value_or_future__std__string);
  use_read_only("std", "value_of", &get__std__value_of, &get_value_or_future__std__value_of);
  use_read_only(NULL, "string", &get__string, &get_value_or_future__string);
  use_read_write(NULL, "string_literals", &get__string_literals, &set__string_literals);
  use_read_only(NULL, "submodule_no_of", &get__submodule_no_of, &get_value_or_future__submodule_no_of);
  use_read_only(NULL, "suffix", &get__suffix, &get_value_or_future__suffix);
  use_read_only(NULL, "temporary_count_of", &get__temporary_count_of, &get_value_or_future__temporary_count_of);
  use_polymorphic_function(NULL, "to_c", &get__to_c, &poly_idx__to_c);
  use_read_only(NULL, "to_integer", &get__to_integer, &get_value_or_future__to_integer);
  use_read_only(NULL, "to_lower_case", &get__to_lower_case, &get_value_or_future__to_lower_case);
  use_read_only(NULL, "to_string", &get__to_string, &get_value_or_future__to_string);
  use_read_only(NULL, "trim", &get__trim, &get_value_or_future__trim);
  use_read_only(NULL, "true", &get__true, &get_value_or_future__true);
  use_read_only(NULL, "truncate_behind", &get__truncate_behind, &get_value_or_future__truncate_behind);
  use_read_only(NULL, "truncate_from", &get__truncate_from, &get_value_or_future__truncate_from);
  use_read_only(NULL, "truncate_until", &get__truncate_until, &get_value_or_future__truncate_until);
  use_read_only("types", "grammar_node", &get__types__grammar_node, &get_value_or_future__types__grammar_node);
  use_read_only(NULL, "undefined", &get__undefined, &get_value_or_future__undefined);
  use_read_write(NULL, "unique_item_index", &get__unique_item_index, &set__unique_item_index);
  use_read_only(NULL, "unless", &get__unless, &get_value_or_future__unless);
  use_read_only(NULL, "until", &get__until, &get_value_or_future__until);
  use_read_only(NULL, "use_literal", &get__use_literal, &get_value_or_future__use_literal);
  use_read_write(NULL, "used_string_literals", &get__used_string_literals, &set__used_string_literals);
  use_read_write(NULL, "used_unique_items", &get__used_unique_items, &set__used_unique_items);
  use_read_only(NULL, "variable_kind_of", &get__variable_kind_of, &get_value_or_future__variable_kind_of);
  use_read_only(NULL, "vtable_entries", &get__vtable_entries, &get_value_or_future__vtable_entries);
  use_read_only(NULL, "while", &get__while, &get_value_or_future__while);
  use_read_only(NULL, "without_suffix", &get__without_suffix, &get_value_or_future__without_suffix);
  use_read_only(NULL, "write", &get__write, &get_value_or_future__write);
  use_read_only(NULL, "write_source_as_remark", &get__write_source_as_remark, &get_value_or_future__write_source_as_remark);
  use_read_only(NULL, "write_to", &get__write_to, &get_value_or_future__write_to);
  use_single_assign_dynamic(NULL, "write_to_continuation_table", &get__write_to_continuation_table, &define__write_to_continuation_table);
  use_read_only(NULL, "write_to_declarations", &get__write_to_declarations, &get_value_or_future__write_to_declarations);
  use_read_only(NULL, "write_to_delayed_continuation_table", &get__write_to_delayed_continuation_table, &get_value_or_future__write_to_delayed_continuation_table);
  use_read_only(NULL, "write_to_generated_collections", &get__write_to_generated_collections, &get_value_or_future__write_to_generated_collections);
  use_read_only(NULL, "write_to_global_variable_declarations", &get__write_to_global_variable_declarations, &get_value_or_future__write_to_global_variable_declarations);
  use_read_only(NULL, "write_to_phase_1", &get__write_to_phase_1, &get_value_or_future__write_to_phase_1);
  use_read_only(NULL, "write_to_phase_2", &get__write_to_phase_2, &get_value_or_future__write_to_phase_2);
  use_read_only(NULL, "write_to_phase_3", &get__write_to_phase_3, &get_value_or_future__write_to_phase_3);
  use_read_only(NULL, "write_to_phase_4", &get__write_to_phase_4, &get_value_or_future__write_to_phase_4);
  use_read_only(NULL, "write_to_phase_5", &get__write_to_phase_5, &get_value_or_future__write_to_phase_5);
  use_read_only(NULL, "write_to_top_level_variable_declarations", &get__write_to_top_level_variable_declarations, &get_value_or_future__write_to_top_level_variable_declarations);
  use_read_only(NULL, "write_to_top_level_variable_names", &get__write_to_top_level_variable_names, &get_value_or_future__write_to_top_level_variable_names);
  use_read_only(NULL, "writeln", &get__writeln, &get_value_or_future__writeln);
  define_method("types", "grammar_node", poly_idx__to_c, func__types__grammar_node___to_c);
  define_method("compiler", "body", poly_idx__to_c, func__compiler__body___to_c);
  define_method("compiler", "definition", poly_idx__to_c, func__compiler__definition___to_c);
  define_method("compiler", "numeric_literal", poly_idx__to_c, func__compiler__numeric_literal___to_c);
  define_method("compiler", "character_literal", poly_idx__to_c, func__compiler__character_literal___to_c);
  define_method("compiler", "string_literal", poly_idx__to_c, func__compiler__string_literal___to_c);
  define_method("compiler", "unique_item", poly_idx__to_c, func__compiler__unique_item___to_c);
  define_method("compiler", "identifier", poly_idx__to_c, func__compiler__identifier___to_c);
  define_method("compiler", "c_body", poly_idx__to_c, func__compiler__c_body___to_c);
}

static int already_run_phase_5 = false;

EXPORT void phase_5__c_code_generator(void) {
  if (already_run_phase_5) return;
  already_run_phase_5 = true;
  assign_value(&var.compiler__to_c, create_function(type__compiler__to_c, -1));
  maybe_initialize_future(get__compiler__suffix(), get__undefined());
  define__level(number__1);
  maybe_initialize_future(get__cont_suffix(), get__undefined());
  maybe_initialize_future(get__current_locals(), get__empty_table());
  maybe_initialize_future(get__current_frame(), get__undefined());
  maybe_initialize_future(get__is_a_shared_local(), get__empty_set());
  define__temporary_offset(number__0);
  initialize_future(var.compiler__begin_continuation, func__compiler__begin_continuation);
  initialize_future(var.compiler__end_continuation, func__compiler__end_continuation);
  initialize_future(var.compiler__next_continuation, func__compiler__next_continuation);
  initialize_future(var.compiler__assignment_to_c, func__compiler__assignment_to_c);
  initialize_future(var.compiler__write_source_as_remark, func__compiler__write_source_as_remark);
  initialize_future(var.compiler__is_single_assign, func__compiler__is_single_assign);
  initialize_future(var.compiler__might_be_constant, func__compiler__might_be_constant);
  initialize_future(var.compiler__define_variable, func__compiler__define_variable);
  initialize_future(var.compiler__define_attribute, func__compiler__define_attribute);
  initialize_future(var.compiler__define_method, func__compiler__define_method);
  initialize_future(var.compiler__define_type_function, func__compiler__define_type_function);
  initialize_future(var.compiler__define_polymorphic_function, func__compiler__define_polymorphic_function);
  initialize_future(var.compiler__define_c_code, func__compiler__define_c_code);
  initialize_future(var.compiler__generate_statement, func__compiler__generate_statement);
}

static int already_run_phase_6 = false;

EXPORT void phase_6__c_code_generator(void) {
  if (already_run_phase_6) return;
  already_run_phase_6 = true;
  register_collector(collect__c_code_generator);
}
