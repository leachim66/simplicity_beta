#include <runtime/platform.h>

/**********************
D E C L A R A T I O N S
**********************/

#ifndef IMPORT
  #define IMPORT extern
#endif

#ifndef EXPORT
  #define EXPORT
#endif

#ifndef NULL
  #define NULL ((void *)0)
#endif
#define false 0
#define true 1
typedef __INT8_TYPE__ int8_t;
typedef __INT16_TYPE__ int16_t;
typedef __INT32_TYPE__ int32_t;
typedef __INT64_TYPE__ int64_t;
typedef __INTPTR_TYPE__ intptr_t;

#ifdef __UINT8_TYPE__
  typedef __UINT8_TYPE__ uint8_t;
#else
  typedef unsigned __INT8_TYPE__ uint8_t;
#endif

#ifdef __UINT16_TYPE__
  typedef __UINT16_TYPE__ uint16_t;
#else
  typedef unsigned __INT16_TYPE__ uint16_t;
#endif

#ifdef __UINT32_TYPE__
  typedef __UINT32_TYPE__ uint32_t;
#else
  typedef unsigned __INT32_TYPE__ uint32_t;
#endif

#ifdef __UINT64_TYPE__
  typedef __UINT64_TYPE__ uint64_t;
#else
  typedef unsigned __INT64_TYPE__ uint64_t;
#endif

#ifdef __UINTPTR_TYPE__
  typedef __UINTPTR_TYPE__ uintptr_t;
#else
  typedef unsigned __INTPTR_TYPE__ uintptr_t;
#endif
typedef __SIZE_TYPE__ size_t;
typedef union NODE NODE;
IMPORT void *coll_node_buf;
IMPORT void *coll_node_buf_end;
IMPORT void *static_node_buf;
IMPORT void *static_node_buf_end;
typedef void (*DESTRUCTOR)(void *);
typedef struct MEMORY_BLOCK {
  struct MEMORY_BLOCK *link;
  long mark;
  DESTRUCTOR destructor;
} MEMORY_BLOCK;
IMPORT long current_mark;
typedef void (*FUNC)(void);
typedef NODE *(*NODE_GETTER)(void);
typedef void (*NODE_SETTER)(NODE *);
IMPORT NODE *get_dynamic_slot(int id);
IMPORT void define_dynamic_slot(int id, NODE *node);
typedef struct FRAME_INFO {
  int var_count;
  const char *var_names[];
} FRAME_INFO;
IMPORT NODE *get_dynamic_cell(int id);
IMPORT void set_dynamic_cell(int id, NODE *node);
IMPORT void define_dynamic_cell(int id, NODE *node);
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define REGISTER register
#else
  #define REGISTER IMPORT
#endif
typedef struct FRAME {
  FUNC cont;
  struct FRAME *caller_frame;
  long caller_result_count;
  long slot_count;
  NODE *slots[0];
} FRAME;
#if defined(__GNUC__) && !defined(__clang__) && defined(__x86_64)
  #define ASM(x) asm(x)
#else
  #define ASM(x)
#endif
REGISTER FRAME *arguments ASM("r12");
typedef struct CONTINUATION_INFO {
  FUNC continuation;
  struct FRAME_INFO *frame_info;
  uint16_t first_line;
  uint16_t last_line;
  uint8_t first_column;
  uint8_t last_column;
  uint8_t submodule_index;
  uint8_t unused;
} CONTINUATION_INFO;
typedef void *COLLECTOR(void *);
IMPORT uint32_t to_int8(NODE *node);
IMPORT uint64_t to_int16(NODE *node);
IMPORT uint32_t to_int32(NODE *node);
IMPORT uint64_t to_int64(NODE *node);
IMPORT uint32_t to_uint8(NODE *node);
IMPORT uint64_t to_uint16(NODE *node);
IMPORT uint32_t to_uint32(NODE *node);
IMPORT uint64_t to_uint64(NODE *node);
IMPORT uint32_t to_uchar32(NODE *node);
IMPORT int to_bool(NODE *node);
IMPORT int to_int(NODE *node);
IMPORT long to_long(NODE *node);
IMPORT double to_double(NODE *node);
IMPORT char *to_c_string(NODE *node);
IMPORT uint8_t *to_octets(NODE *node, long *size_p);
IMPORT NODE *get_item_of(NODE *node, long idx);
IMPORT long length_of(NODE *node);
IMPORT void unfold(NODE *node);
IMPORT long debug_string(NODE *node, int indent, int max_depth, char *buf);
typedef struct VTABLE {
  size_t size;
  COLLECTOR *collect;
  int8_t (*to_int8)(NODE *);
  int16_t (*to_int16)(NODE *);
  int32_t (*to_int32)(NODE *);
  int64_t (*to_int64)(NODE *);
  uint8_t (*to_uint8)(NODE *);
  uint16_t (*to_uint16)(NODE *);
  uint32_t (*to_uint32)(NODE *);
  uint64_t (*to_uint64)(NODE *);
  uint32_t (*to_uchar32)(NODE *);
  int (*to_bool)(NODE *);
  int (*to_int)(NODE *);
  long (*to_long)(NODE *);
  double (*to_double)(NODE *);
  char *(*to_c_string)(NODE *);
  uint8_t *(*to_octets)(NODE *, long *size_p);
  NODE *(*get_item_of)(NODE *, long idx);
  long (*length_of)(NODE *);
  void (*unfold)(NODE *);
  long (*debug_string)(NODE *, int indent, int max_depth, char *buf);
} VTABLE;
typedef struct OCTREE {
  struct OCTREE *nodes[8];
} OCTREE;
typedef struct ATTRIBUTES {
  struct VTABLE *vtable;
  struct OCTREE *nodes[7];
} ATTRIBUTES;
typedef struct DYNAMICS {
  struct OCTREE *nodes[8];
} DYNAMICS;
typedef struct CONTINUATION {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int result_count;
  struct FRAME *frame;
  struct DYNAMICS *dynamics;
  struct FRAME *exit_frame; // used by exit-functions
} CONTINUATION;
typedef struct CLOSURE {
  FUNC type;
  struct ATTRIBUTES *attributes;
  int parameter_count;
  struct FRAME *frame;
} CLOSURE;
REGISTER int argument_count ASM("ebx");
IMPORT void too_few_arguments_error(void);
REGISTER NODE *myself ASM("r13");
IMPORT NODE *get_attribute(NODE *node, int idx);
IMPORT void invalid_arguments_error(void);
IMPORT NODE *clone_object_and_attributes(NODE *node);
IMPORT void *update_start_p;
IMPORT void *node_p;
IMPORT void set_attribute_value(ATTRIBUTES *attributes, int idx, void *attr);
REGISTER FUNC func ASM("r14");
REGISTER FRAME *frame ASM("r15");
typedef struct MODULE_INFO {
  struct MODULE_INFO *link;
  const char *name;
  struct CONTINUATION_INFO *continuation_info;
  int continuation_count;
  NODE **var_tab;
  const char **var_names;
  int top_level_count;
  const char **used_namespaces;
  const char *filenames[];
} MODULE_INFO;
IMPORT void allocate_initialized_frame_gc(int slot_idx, int slot_count);
IMPORT void initialize_maybe_future(NODE *var, NODE *val);
IMPORT int result_count;
IMPORT void invalid_results_error(void);
IMPORT void initialize_future(NODE *var, NODE *val);
IMPORT NODE *undefined;
IMPORT NODE *create_closure(FUNC type, int par_count);
IMPORT NODE *create_cell(void);
IMPORT NODE *create_cell_with_contents(NODE *contents);
typedef struct CELL {
  FUNC type;
  struct ATTRIBUTES *attributes;
  NODE *contents;
} CELL;
IMPORT NODE *empty_string;
IMPORT NODE *create_continuation(void);
IMPORT NODE *create_future(void);
IMPORT NODE *zero;
IMPORT void too_many_arguments_error(void);
IMPORT NODE *create_continuation_with_exit(FUNC exit_func);
IMPORT void continuation_type_function(void);
IMPORT NODE *collect_node(NODE *node);
IMPORT void register_module_info(MODULE_INFO *info);
IMPORT void set_module(const char *name);
IMPORT NODE *from_uchar32(unsigned int chr);
IMPORT NODE *from_uint32(uint32_t val);
IMPORT void register_polymorphic_function(const char *name, int *id_p);
IMPORT NODE *register_unique_item(const char *name);
IMPORT NODE *create_function(FUNC func, int par_count);
IMPORT NODE *from_latin_1_string(const char *str, long len);
IMPORT void set_used_namespaces(const char **namespaces);
IMPORT void assign_value(NODE **dest, NODE *val);
IMPORT void define_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE_SETTER definer,
  int *id_p
);
IMPORT void register_dynamic(int *id_p);
IMPORT void define_single_assign_static(
  const char *namespace, const char *name,
  NODE_GETTER getter, NODE **var_p
);
IMPORT void use_read_only(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_GETTER *get_value_or_future
);
IMPORT void use_polymorphic_function(
  const char *namespace, const char *name, NODE_GETTER *getter, int *id
);
IMPORT void use_single_assign_dynamic(
  const char *namespace, const char *name,
  NODE_GETTER *getter, NODE_SETTER *definer
);
IMPORT void def_attribute(NODE **var_p, int idx, void *attr);
IMPORT void define_method(
  const char *namespace, const char *name,
  int id, NODE *method
);
IMPORT void maybe_initialize_future(NODE *var, NODE *val);
IMPORT void assign_variable(NODE **dest, NODE **var_p);
IMPORT void register_collector(FUNC collector);


#if UINTPTR_MAX == 0xffffffffffffffff
  #define FIRST_INVALID_ADDRESS 0xc000000000000000UL
  #define SAMPLE_POINTER ((void *)0x123456789abcdef0UL)
#else
  #define FIRST_INVALID_ADDRESS 0xc0000000
  #define SAMPLE_POINTER ((void *)0x12345678)
#endif

#define MAKE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)+1))
#define RETRIEVE_ATTRIBUTE_VALUE(node) ((NODE *)(((uintptr_t)node)-1))
#define CONTAINS_AN_ATTRIBUTE_VALUE(node) (((uintptr_t)node)&1)

#define ENCODE_ADDRESS(addr) ((void *)((uintptr_t)addr | 2))
#define DECODE_ADDRESS(addr) ((void *)((uintptr_t)addr & -3))
#define IS_AN_INVALID_ADDRESS(addr) ((uintptr_t)addr & 2)

#define MSB (1L << (8*sizeof(void *)-1))
#define ENCODE_TO_LENGTH(addr) ((void *)(((uintptr_t)addr >> 1) | MSB))
#define DECODE_FROM_LENGTH(addr) ((void *)((uintptr_t)addr << 1))
#define IS_AN_INVALID_LENGTH(addr) ((uintptr_t)addr & MSB)

#define IS_COLLECTED(addr) (((void *)(addr)) >= coll_node_buf && ((void *)(addr)) < coll_node_buf_end)
#define IS_STATIC(addr) (((void *)(addr)) >= static_node_buf && ((void *)(addr)) < static_node_buf_end)
#define MARK(addr) (((MEMORY_BLOCK *)(addr))-1)->mark = current_mark;

#define ALLOCATION_SIZE(size) (((size)+sizeof(void *)-1)&-sizeof(void *))
#define TYPEOF(node) (node)->type
#define SIZEOF(node) (node)->attributes->vtable->size

#ifdef WITHIN_LIBRARY
  #define DEBUG_FILENAME(filename) filename
#else
  #define DEBUG_FILENAME(filename) "./" filename
#endif

#ifdef __CYGWIN__
  extern FUNC invalid_continuation;
#else
  extern void invalid_continuation(void);
#endif
static NODE_GETTER get__ATTRIBUTE_KIND;
static NODE_GETTER get_value_or_future__ATTRIBUTE_KIND;
static NODE_GETTER get__CONTINUATION_PARAMETER;
static NODE_GETTER get_value_or_future__CONTINUATION_PARAMETER;
static NODE_GETTER get__HIGHEST_PRECEDENCE;
static NODE_GETTER get_value_or_future__HIGHEST_PRECEDENCE;
static NODE_GETTER get__INFIX_PRECEDENCE;
static NODE_GETTER get_value_or_future__INFIX_PRECEDENCE;
static NODE_GETTER get__IN_OUT_PARAMETER;
static NODE_GETTER get_value_or_future__IN_OUT_PARAMETER;
static NODE_GETTER get__IN_PARAMETER;
static NODE_GETTER get_value_or_future__IN_PARAMETER;
static NODE_GETTER get__METHOD_KIND;
static NODE_GETTER get_value_or_future__METHOD_KIND;
static NODE_GETTER get__MYSELF_PARAMETER;
static NODE_GETTER get_value_or_future__MYSELF_PARAMETER;
static NODE_GETTER get__OUT_PARAMETER;
static NODE_GETTER get_value_or_future__OUT_PARAMETER;
static NODE_GETTER get__all_of;
static NODE_GETTER get_value_or_future__all_of;
static NODE_GETTER get__alt;
static NODE_GETTER get_value_or_future__alt;
static NODE_GETTER get__any_of;
static NODE_GETTER get_value_or_future__any_of;
static NODE_GETTER get__append;
static NODE_GETTER get_value_or_future__append;
static int poly_idx__arguments_of;
static NODE_GETTER get__arguments_of;
static NODE_GETTER get__attribute_kind_of;
static NODE_GETTER get_value_or_future__attribute_kind_of;
static NODE_GETTER get__attribute_of;
static NODE_GETTER get_value_or_future__attribute_of;
static NODE_GETTER get__base_of;
static NODE_GETTER get_value_or_future__base_of;
static NODE_GETTER get__case;
static NODE_GETTER get_value_or_future__case;
static NODE_GETTER get__character;
static NODE_GETTER get_value_or_future__character;
static NODE_GETTER get__character_names;
static NODE_GETTER get_value_or_future__character_names;
static NODE_GETTER get__check_case;
static NODE_GETTER get_value_or_future__check_case;
static NODE_GETTER get__compiler__attribute_function_pair;
static NODE_GETTER get_value_or_future__compiler__attribute_function_pair;
static NODE_GETTER get__compiler__attribute_value_pair;
static NODE_GETTER get_value_or_future__compiler__attribute_value_pair;
static NODE_GETTER get__compiler__backquoted;
static NODE_GETTER get_value_or_future__compiler__backquoted;
static NODE_GETTER get__compiler__body;
static NODE_GETTER get_value_or_future__compiler__body;
static NODE_GETTER get__compiler__c_code;
static NODE_GETTER get_value_or_future__compiler__c_code;
static NODE_GETTER get__compiler__call;
static NODE_GETTER get_value_or_future__compiler__call;
static NODE_GETTER get__compiler__character_literal;
static NODE_GETTER get_value_or_future__compiler__character_literal;
static NODE_GETTER get__compiler__data_instruction;
static NODE_GETTER get_value_or_future__compiler__data_instruction;
static NODE_GETTER get__compiler__define_dynamic_multi;
static NODE_GETTER get_value_or_future__compiler__define_dynamic_multi;
static NODE_GETTER get__compiler__define_dynamic_single;
static NODE_GETTER get_value_or_future__compiler__define_dynamic_single;
static NODE_GETTER get__compiler__define_static_multi;
static NODE_GETTER get_value_or_future__compiler__define_static_multi;
static NODE_GETTER get__compiler__define_static_single;
static NODE_GETTER get_value_or_future__compiler__define_static_single;
static NODE_GETTER get__compiler__function_call;
static NODE_GETTER get_value_or_future__compiler__function_call;
static NODE_GETTER get__compiler__identifier;
static NODE_GETTER get_value_or_future__compiler__identifier;
static NODE_GETTER get__compiler__include_instruction;
static NODE_GETTER get_value_or_future__compiler__include_instruction;
static NODE_GETTER get__compiler__link_instruction;
static NODE_GETTER get_value_or_future__compiler__link_instruction;
static NODE_GETTER get__compiler__namespace_instruction;
static NODE_GETTER get_value_or_future__compiler__namespace_instruction;
static NODE_GETTER get__compiler__numeric_literal;
static NODE_GETTER get_value_or_future__compiler__numeric_literal;
static NODE_GETTER get__compiler__polymorphic_function;
static NODE_GETTER get_value_or_future__compiler__polymorphic_function;
static NODE_GETTER get__compiler__remark_argument;
static NODE_GETTER get_value_or_future__compiler__remark_argument;
static NODE_GETTER get__compiler__remark_statement;
static NODE_GETTER get_value_or_future__compiler__remark_statement;
static NODE_GETTER get__compiler__require_instruction;
static NODE_GETTER get_value_or_future__compiler__require_instruction;
static NODE_GETTER get__compiler__string_literal;
static NODE_GETTER get_value_or_future__compiler__string_literal;
static NODE_GETTER get__compiler__unique_item;
static NODE_GETTER get_value_or_future__compiler__unique_item;
static NODE_GETTER get__compiler__using_instruction;
static NODE_GETTER get_value_or_future__compiler__using_instruction;
static NODE_GETTER get__cond;
static NODE_GETTER get_value_or_future__cond;
static NODE_GETTER get__contains;
static NODE_GETTER get_value_or_future__contains;
static NODE_GETTER get__default_value;
static NODE_GETTER get_value_or_future__default_value;
static NODE_GETTER get__default_value_of;
static NODE_GETTER get_value_or_future__default_value_of;
static NODE_GETTER get__div;
static NODE_GETTER get_value_or_future__div;
static NODE_GETTER get__do;
static NODE_GETTER get_value_or_future__do;
static NODE_GETTER get__do_while;
static NODE_GETTER get_value_or_future__do_while;
static NODE_GETTER get__dup;
static NODE_GETTER get_value_or_future__dup;
static NODE_GETTER get__empty_list;
static NODE_GETTER get_value_or_future__empty_list;
static NODE_GETTER get__empty_table;
static NODE_GETTER get_value_or_future__empty_table;
static NODE_GETTER get__false;
static NODE_GETTER get_value_or_future__false;
static NODE_GETTER get__for_each;
static NODE_GETTER get_value_or_future__for_each;
static NODE_GETTER get__for_each_from_to;
static NODE_GETTER get_value_or_future__for_each_from_to;
static NODE_GETTER get__for_each_line;
static NODE_GETTER get_value_or_future__for_each_line;
static NODE_GETTER get__from_down_to;
static NODE_GETTER get_value_or_future__from_down_to;
static NODE_GETTER get__from_to;
static NODE_GETTER get_value_or_future__from_to;
static NODE_GETTER get__functor_of;
static NODE_GETTER get_value_or_future__functor_of;
static int poly_idx__grammar__match;
static NODE_GETTER get__grammar__match;
static NODE_GETTER get__has_minimum_length;
static NODE_GETTER get_value_or_future__has_minimum_length;
static NODE_GETTER get__has_prefix;
static NODE_GETTER get_value_or_future__has_prefix;
static NODE_GETTER get__has_suffix;
static NODE_GETTER get_value_or_future__has_suffix;
static NODE_GETTER get__hex;
static NODE_GETTER get_value_or_future__hex;
static NODE_GETTER get__hide_body_statements;
static NODE_GETTER get_value_or_future__hide_body_statements;
static NODE_GETTER get__identifier_of;
static NODE_GETTER get_value_or_future__identifier_of;
static NODE_GETTER get__if;
static NODE_GETTER get_value_or_future__if;
static NODE_GETTER get__inc;
static NODE_GETTER get_value_or_future__inc;
static NODE_GETTER get__is_a_body;
static NODE_GETTER get_value_or_future__is_a_body;
static NODE_GETTER get__is_a_definition;
static NODE_GETTER get_value_or_future__is_a_definition;
static NODE_GETTER get__is_a_destination;
static NODE_GETTER get_value_or_future__is_a_destination;
static NODE_GETTER get__is_a_function_call;
static NODE_GETTER get_value_or_future__is_a_function_call;
static NODE_GETTER get__is_a_letter;
static NODE_GETTER get_value_or_future__is_a_letter;
static NODE_GETTER get__is_a_method_definition;
static NODE_GETTER get_value_or_future__is_a_method_definition;
static NODE_GETTER get__is_a_parameter;
static NODE_GETTER get_value_or_future__is_a_parameter;
static NODE_GETTER get__is_a_polymorphic_function_constant;
static NODE_GETTER get_value_or_future__is_a_polymorphic_function_constant;
static NODE_GETTER get__is_a_remark;
static NODE_GETTER get_value_or_future__is_a_remark;
static NODE_GETTER get__is_a_return;
static NODE_GETTER get_value_or_future__is_a_return;
static NODE_GETTER get__is_a_setter;
static NODE_GETTER get_value_or_future__is_a_setter;
static NODE_GETTER get__is_a_string_literal;
static NODE_GETTER get_value_or_future__is_a_string_literal;
static NODE_GETTER get__is_a_string_template;
static NODE_GETTER get_value_or_future__is_a_string_template;
static NODE_GETTER get__is_a_unique_item_constant;
static NODE_GETTER get_value_or_future__is_a_unique_item_constant;
static NODE_GETTER get__is_an_assignment;
static NODE_GETTER get_value_or_future__is_an_assignment;
static NODE_GETTER get__is_an_attribute_access;
static NODE_GETTER get_value_or_future__is_an_attribute_access;
static NODE_GETTER get__is_an_attribute_value_pair;
static NODE_GETTER get_value_or_future__is_an_attribute_value_pair;
static NODE_GETTER get__is_an_expanded_item;
static NODE_GETTER get_value_or_future__is_an_expanded_item;
static NODE_GETTER get__is_an_identifier;
static NODE_GETTER get_value_or_future__is_an_identifier;
static NODE_GETTER get__is_an_input_output_argument;
static NODE_GETTER get_value_or_future__is_an_input_output_argument;
static NODE_GETTER get__is_an_operator_symbol;
static NODE_GETTER get_value_or_future__is_an_operator_symbol;
static NODE_GETTER get__is_an_optional_item;
static NODE_GETTER get_value_or_future__is_an_optional_item;
static NODE_GETTER get__is_defined;
static NODE_GETTER get_value_or_future__is_defined;
static NODE_GETTER get__is_empty;
static NODE_GETTER get_value_or_future__is_empty;
static NODE_GETTER get__is_in_infix_notation;
static NODE_GETTER get_value_or_future__is_in_infix_notation;
static NODE_GETTER get__is_in_numeric_notation;
static NODE_GETTER get_value_or_future__is_in_numeric_notation;
static NODE_GETTER get__is_left_associative;
static NODE_GETTER get_value_or_future__is_left_associative;
static NODE_GETTER get__is_not_used;
static NODE_GETTER get_value_or_future__is_not_used;
static NODE_GETTER get__is_undefined;
static NODE_GETTER get_value_or_future__is_undefined;
static NODE_GETTER get__kind_of;
static NODE_GETTER get_value_or_future__kind_of;
static NODE_GETTER get__length_of;
static NODE_GETTER get_value_or_future__length_of;
static NODE_GETTER get__line_width;
static NODE_SETTER define__line_width;
static NODE_GETTER get__list;
static NODE_GETTER get_value_or_future__list;
static NODE_GETTER get__matches;
static NODE_GETTER get_value_or_future__matches;
static NODE_GETTER get__max;
static NODE_GETTER get_value_or_future__max;
static NODE_GETTER get__minus;
static NODE_GETTER get_value_or_future__minus;
static NODE_GETTER get__name_of;
static NODE_GETTER get_value_or_future__name_of;
static NODE_GETTER get__namespace_alias_of;
static NODE_GETTER get_value_or_future__namespace_alias_of;
static NODE_GETTER get__namespace_of;
static NODE_GETTER get_value_or_future__namespace_of;
static NODE_GETTER get__newline;
static NODE_GETTER get_value_or_future__newline;
static NODE_GETTER get__node__filemask_of;
static NODE_GETTER get_value_or_future__node__filemask_of;
static NODE_GETTER get__node__filename_of;
static NODE_GETTER get_value_or_future__node__filename_of;
static NODE_GETTER get__node__text_of;
static NODE_GETTER get_value_or_future__node__text_of;
static NODE_GETTER get__node__type_of;
static NODE_GETTER get_value_or_future__node__type_of;
static NODE_GETTER get__node__value_of;
static NODE_GETTER get_value_or_future__node__value_of;
static NODE_GETTER get__node_of;
static NODE_GETTER get_value_or_future__node_of;
static NODE_GETTER get__not;
static NODE_GETTER get_value_or_future__not;
static NODE_GETTER get__parameter_kind_of;
static NODE_GETTER get_value_or_future__parameter_kind_of;
static NODE_GETTER get__parameters_of;
static NODE_GETTER get_value_or_future__parameters_of;
static NODE_GETTER get__pass;
static NODE_GETTER get_value_or_future__pass;
static NODE_GETTER get__plus;
static NODE_GETTER get_value_or_future__plus;
static NODE_GETTER get__precedence;
static NODE_GETTER get_value_or_future__precedence;
static NODE_GETTER get__push;
static NODE_GETTER get_value_or_future__push;
static NODE_GETTER get__put;
static NODE_GETTER get_value_or_future__put;
static NODE_GETTER get__range;
static NODE_GETTER get_value_or_future__range;
static NODE_GETTER get__remark_lines_of;
static NODE_GETTER get_value_or_future__remark_lines_of;
static NODE_GETTER get__repeat;
static NODE_GETTER get_value_or_future__repeat;
static NODE_GETTER get__scope_of;
static NODE_GETTER get_value_or_future__scope_of;
static NODE_GETTER get__some;
static NODE_GETTER get_value_or_future__some;
static NODE_GETTER get__source_of;
static NODE_GETTER get_value_or_future__source_of;
static NODE_GETTER get__statements_of;
static NODE_GETTER get_value_or_future__statements_of;
static NODE_GETTER get__std__and;
static NODE_GETTER get_value_or_future__std__and;
static NODE_GETTER get__std__equal;
static NODE_GETTER get_value_or_future__std__equal;
static NODE_GETTER get__std__less;
static NODE_GETTER get_value_or_future__std__less;
static NODE_GETTER get__std__minus;
static NODE_GETTER get_value_or_future__std__minus;
static NODE_GETTER get__std__negate;
static NODE_GETTER get_value_or_future__std__negate;
static NODE_GETTER get__std__not;
static NODE_GETTER get_value_or_future__std__not;
static NODE_GETTER get__std__or;
static NODE_GETTER get_value_or_future__std__or;
static NODE_GETTER get__std__plus;
static NODE_GETTER get_value_or_future__std__plus;
static NODE_GETTER get__std__sequence;
static NODE_GETTER get_value_or_future__std__sequence;
static NODE_GETTER get__std__shift_right;
static NODE_GETTER get_value_or_future__std__shift_right;
static NODE_GETTER get__std__spaces;
static NODE_GETTER get_value_or_future__std__spaces;
static NODE_GETTER get__std__string;
static NODE_GETTER get_value_or_future__std__string;
static NODE_GETTER get__std__times;
static NODE_GETTER get_value_or_future__std__times;
static NODE_GETTER get__string;
static NODE_GETTER get_value_or_future__string;
static NODE_GETTER get__to_integer;
static NODE_GETTER get_value_or_future__to_integer;
static int poly_idx__to_string;
static NODE_GETTER get__to_string;
static NODE_GETTER get__true;
static NODE_GETTER get_value_or_future__true;
static NODE_GETTER get__truncate_from;
static NODE_GETTER get_value_or_future__truncate_from;
static NODE_GETTER get__types__grammar_node;
static NODE_GETTER get_value_or_future__types__grammar_node;
static NODE_GETTER get__types__grammar_object;
static NODE_GETTER get_value_or_future__types__grammar_object;
static NODE_GETTER get__undefined;
static NODE_GETTER get_value_or_future__undefined;
static NODE_GETTER get__unless;
static NODE_GETTER get_value_or_future__unless;
static NODE_GETTER get__while;
static NODE_GETTER get_value_or_future__while;
static NODE_GETTER get__write_to;
static NODE_GETTER get_value_or_future__write_to;
static NODE_GETTER get__writeln;
static NODE_GETTER get_value_or_future__writeln;
static NODE_GETTER get__writeln_to;
static NODE_GETTER get_value_or_future__writeln_to;
static struct {
  NODE *_needs_parenthesis;
  NODE *_ALWAYS;
  NODE *_SHEBANG;
  NODE *_REMARK;
  NODE *_CODE_EXCLUSION;
  NODE *_REQUIRE;
  NODE *_NAMESPACE;
  NODE *_USING;
  NODE *_INCLUDE;
  NODE *_LINK;
  NODE *_DATA;
  NODE *_POLYMORPHIC_FUNCTION;
  NODE *_UNIQUE;
  NODE *_PROC;
  NODE *_FUNC;
  NODE *_UNLIMITED;
  NODE *_INDENTATION_MARKER;
  NODE *_INDENTATION_MARKER_HIGH;
  NODE *_INDENTATION;
  NODE *_indentation_string;
  NODE *_line_start_remark_to_string;
  NODE *_add_remark_lines;
  NODE *_add_statement_remark;
  NODE *_add_remark;
  NODE *_add_indented_remark;
  NODE *_argument_to_string;
  NODE *_arguments_to_string;
  NODE *_definition_to_string;
  NODE *_precedence_of;
  NODE *_operator_of;
  NODE *_pair_to_string;
  NODE *_character_to_name;
  NODE *_create_character_table;
  NODE *_escaped_character;
  NODE *_analyze_string_literal;
  NODE *_print_string_literal;
  NODE *_string_template_to_string;
  NODE *compiler__print_trees;
} var;
static const char *var_names[] = {
  "needs_parenthesis",
  "ALWAYS",
  "SHEBANG",
  "REMARK",
  "CODE_EXCLUSION",
  "REQUIRE",
  "NAMESPACE",
  "USING",
  "INCLUDE",
  "LINK",
  "DATA",
  "POLYMORPHIC_FUNCTION",
  "UNIQUE",
  "PROC",
  "FUNC",
  "UNLIMITED",
  "INDENTATION_MARKER",
  "INDENTATION_MARKER_HIGH",
  "INDENTATION",
  "indentation_string",
  "line_start_remark_to_string",
  "add_remark_lines",
  "add_statement_remark",
  "add_remark",
  "add_indented_remark",
  "argument_to_string",
  "arguments_to_string",
  "definition_to_string",
  "precedence_of",
  "operator_of",
  "pair_to_string",
  "character_to_name",
  "create_character_table",
  "escaped_character",
  "analyze_string_literal",
  "print_string_literal",
  "string_template_to_string"
};
static int poly_idx__needs_parenthesis;
static void type__needs_parenthesis(void);
static NODE *unique__ALWAYS;
static NODE *unique__SHEBANG;
static NODE *unique__REMARK;
static NODE *unique__CODE_EXCLUSION;
static NODE *unique__REQUIRE;
static NODE *unique__NAMESPACE;
static NODE *unique__USING;
static NODE *unique__INCLUDE;
static NODE *unique__LINK;
static NODE *unique__DATA;
static NODE *unique__POLYMORPHIC_FUNCTION;
static NODE *unique__UNIQUE;
static NODE *unique__PROC;
static NODE *unique__FUNC;
static int dyna_idx__compiler__hide_body_statements;
static NODE *get__compiler__hide_body_statements(void) {
  return get_dynamic_slot(dyna_idx__compiler__hide_body_statements);
}
static void define__compiler__hide_body_statements(NODE *node) {
  define_dynamic_slot(dyna_idx__compiler__hide_body_statements, node);
}
static int dyna_idx__compiler__line_width;
static NODE *get__compiler__line_width(void) {
  return get_dynamic_slot(dyna_idx__compiler__line_width);
}
static void define__compiler__line_width(NODE *node) {
  define_dynamic_slot(dyna_idx__compiler__line_width, node);
}
static int dyna_idx__expression_indent;
static NODE *get__expression_indent(void) {
  return get_dynamic_slot(dyna_idx__expression_indent);
}
static void define__expression_indent(NODE *node) {
  define_dynamic_slot(dyna_idx__expression_indent, node);
}
static int dyna_idx__line_end_expression_width;
static NODE *get__line_end_expression_width(void) {
  return get_dynamic_slot(dyna_idx__line_end_expression_width);
}
static void define__line_end_expression_width(NODE *node) {
  define_dynamic_slot(dyna_idx__line_end_expression_width, node);
}
static NODE *func__INDENTATION__grammar__match_1;
static void entry__INDENTATION__grammar__match_1(void);
static FRAME_INFO frame__INDENTATION__grammar__match_1 = {2, {"self", "stream"}};
static void cont__INDENTATION__grammar__match_2(void);
static NODE *func__INDENTATION__grammar__match_3;
static void entry__INDENTATION__grammar__match_3(void);
static FRAME_INFO frame__INDENTATION__grammar__match_3 = {1, {"stream"}};
static void cont__INDENTATION__grammar__match_4(void);
static void cont__INDENTATION__grammar__match_5(void);
static void cont__INDENTATION__grammar__match_6(void);
static NODE *func__INDENTATION__grammar__match_7;
static void entry__INDENTATION__grammar__match_7(void);
static FRAME_INFO frame__INDENTATION__grammar__match_7 = {1, {"stream"}};
static void cont__INDENTATION__grammar__match_8(void);
static void cont__INDENTATION__grammar__match_9(void);
static void cont__INDENTATION__grammar__match_10(void);
static void cont__INDENTATION__grammar__match_11(void);
static void cont__INDENTATION__grammar__match_12(void);
static NODE *func__INDENTATION__grammar__match_13;
static void entry__INDENTATION__grammar__match_13(void);
static FRAME_INFO frame__INDENTATION__grammar__match_13 = {0, {}};
static NODE *func__INDENTATION__grammar__match_14;
static void entry__INDENTATION__grammar__match_14(void);
static FRAME_INFO frame__INDENTATION__grammar__match_14 = {0, {}};
static int dyna_idx__statement_tag;
static NODE *get__statement_tag(void) {
  return get_dynamic_cell(dyna_idx__statement_tag);
}
static void set__statement_tag(NODE *node) {
  set_dynamic_cell(dyna_idx__statement_tag, node);
}
static void define__statement_tag(NODE *node) {
  define_dynamic_cell(dyna_idx__statement_tag, node);
}
static int dyna_idx__spaces;
static NODE *get__spaces(void) {
  return get_dynamic_slot(dyna_idx__spaces);
}
static void define__spaces(NODE *node) {
  define_dynamic_slot(dyna_idx__spaces, node);
}
static NODE *func__indentation_string_1;
static void entry__indentation_string_1(void);
static FRAME_INFO frame__indentation_string_1 = {2, {"indent", "indentation"}};
static NODE *func__indentation_string_2;
static void entry__indentation_string_2(void);
static FRAME_INFO frame__indentation_string_2 = {2, {"indent", "indentation"}};
static void cont__indentation_string_3(void);
static void cont__indentation_string_4(void);
static NODE *func__indentation_string_5;
static void entry__indentation_string_5(void);
static FRAME_INFO frame__indentation_string_5 = {2, {"indentation", "indent"}};
static void cont__indentation_string_6(void);
static void cont__indentation_string_7(void);
static void cont__indentation_string_8(void);
static void cont__indentation_string_9(void);
static NODE *func__compiler__print_trees_1;
static void entry__compiler__print_trees_1(void);
static FRAME_INFO frame__compiler__print_trees_1 = {2, {"trees", "return__1"}};
static NODE *func__compiler__print_trees_2;
static void entry__compiler__print_trees_2(void);
static FRAME_INFO frame__compiler__print_trees_2 = {1, {"indent"}};
static void cont__compiler__print_trees_3(void);
static void cont__compiler__print_trees_4(void);
static void cont__compiler__print_trees_5(void);
static NODE *func__compiler__print_trees_6;
static void entry__compiler__print_trees_6(void);
static FRAME_INFO frame__compiler__print_trees_6 = {7, {"idx", "tree", "previous_statement_tag", "str", "lines", "add_line", "n"}};
static NODE *func__compiler__print_trees_7;
static void entry__compiler__print_trees_7(void);
static FRAME_INFO frame__compiler__print_trees_7 = {2, {"line", "lines"}};
static void cont__compiler__print_trees_8(void);
static void cont__compiler__print_trees_9(void);
static NODE *func__compiler__print_trees_10;
static void entry__compiler__print_trees_10(void);
static FRAME_INFO frame__compiler__print_trees_10 = {4, {"line", "lines", "indent", "text"}};
static void cont__compiler__print_trees_11(void);
static void cont__compiler__print_trees_12(void);
static void cont__compiler__print_trees_13(void);
static void cont__compiler__print_trees_14(void);
static void cont__compiler__print_trees_15(void);
static void cont__compiler__print_trees_16(void);
static void cont__compiler__print_trees_17(void);
static void cont__compiler__print_trees_18(void);
static NODE *func__compiler__print_trees_19;
static void entry__compiler__print_trees_19(void);
static FRAME_INFO frame__compiler__print_trees_19 = {1, {"lines"}};
static void cont__compiler__print_trees_20(void);
static void cont__compiler__print_trees_21(void);
static void cont__compiler__print_trees_22(void);
static NODE *func__compiler__print_trees_23;
static void entry__compiler__print_trees_23(void);
static FRAME_INFO frame__compiler__print_trees_23 = {1, {"previous_statement_tag"}};
static void cont__compiler__print_trees_24(void);
static NODE *func__compiler__print_trees_25;
static void entry__compiler__print_trees_25(void);
static FRAME_INFO frame__compiler__print_trees_25 = {1, {"previous_statement_tag"}};
static void cont__compiler__print_trees_26(void);
static void cont__compiler__print_trees_27(void);
static void cont__compiler__print_trees_28(void);
static void cont__compiler__print_trees_29(void);
static NODE *func__compiler__print_trees_30;
static void entry__compiler__print_trees_30(void);
static FRAME_INFO frame__compiler__print_trees_30 = {0, {}};
static void cont__compiler__print_trees_31(void);
static void cont__compiler__print_trees_32(void);
static NODE *func__compiler__print_trees_33;
static void entry__compiler__print_trees_33(void);
static FRAME_INFO frame__compiler__print_trees_33 = {4, {"i", "str", "add_line", "n"}};
static void cont__compiler__print_trees_34(void);
static void cont__compiler__print_trees_35(void);
static NODE *func__compiler__print_trees_36;
static void entry__compiler__print_trees_36(void);
static FRAME_INFO frame__compiler__print_trees_36 = {4, {"add_line", "str", "i", "n"}};
static void cont__compiler__print_trees_37(void);
static void cont__compiler__print_trees_38(void);
static void cont__compiler__print_trees_39(void);
static void cont__compiler__print_trees_40(void);
static void cont__compiler__print_trees_41(void);
static void cont__compiler__print_trees_42(void);
static void cont__compiler__print_trees_43(void);
static void cont__compiler__print_trees_44(void);
static void cont__compiler__print_trees_45(void);
static NODE *func__compiler__print_trees_46;
static void entry__compiler__print_trees_46(void);
static FRAME_INFO frame__compiler__print_trees_46 = {1, {"line"}};
static void cont__compiler__print_trees_47(void);
static NODE *get__compiler__print_trees(void) {
  return var.compiler__print_trees;
}
static NODE *func__line_start_remark_to_string_1;
static void entry__line_start_remark_to_string_1(void);
static FRAME_INFO frame__line_start_remark_to_string_1 = {4, {"remark_lines", "indent", "buf", "indentation"}};
static NODE *string__578a5af303e9ceb;
static void cont__line_start_remark_to_string_3(void);
static void cont__line_start_remark_to_string_4(void);
static void cont__line_start_remark_to_string_5(void);
static void cont__line_start_remark_to_string_6(void);
static void cont__line_start_remark_to_string_7(void);
static void cont__line_start_remark_to_string_8(void);
static NODE *func__line_start_remark_to_string_9;
static void entry__line_start_remark_to_string_9(void);
static FRAME_INFO frame__line_start_remark_to_string_9 = {3, {"remark_line", "buf", "indentation"}};
static void cont__line_start_remark_to_string_10(void);
static void cont__line_start_remark_to_string_11(void);
static NODE *func__add_remark_lines_1;
static void entry__add_remark_lines_1(void);
static FRAME_INFO frame__add_remark_lines_1 = {4, {"str", "remark_lines", "is_a_statement", "remark_prefix"}};
static void cont__add_remark_lines_2(void);
static NODE *func__add_remark_lines_3;
static void entry__add_remark_lines_3(void);
static FRAME_INFO frame__add_remark_lines_3 = {0, {}};
static NODE *string__578a5af303e9cc2;
static NODE *func__add_remark_lines_5;
static void entry__add_remark_lines_5(void);
static FRAME_INFO frame__add_remark_lines_5 = {0, {}};
static NODE *string__2d7981f4e6082be6;
static void cont__add_remark_lines_7(void);
static void cont__add_remark_lines_8(void);
static void cont__add_remark_lines_9(void);
static NODE *func__add_remark_lines_10;
static void entry__add_remark_lines_10(void);
static FRAME_INFO frame__add_remark_lines_10 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__add_remark_lines_11(void);
static void cont__add_remark_lines_12(void);
static void cont__add_remark_lines_13(void);
static void cont__add_remark_lines_14(void);
static void cont__add_remark_lines_15(void);
static void cont__add_remark_lines_16(void);
static void cont__add_remark_lines_17(void);
static void cont__add_remark_lines_18(void);
static void cont__add_remark_lines_19(void);
static NODE *func__add_remark_lines_20;
static void entry__add_remark_lines_20(void);
static FRAME_INFO frame__add_remark_lines_20 = {5, {"str", "is_a_statement", "remark_lines", "indent", "buf"}};
static void cont__add_remark_lines_21(void);
static void cont__add_remark_lines_22(void);
static NODE *func__add_remark_lines_23;
static void entry__add_remark_lines_23(void);
static FRAME_INFO frame__add_remark_lines_23 = {1, {"str"}};
static NODE *string__578a5af303e9cdb;
static void cont__add_remark_lines_25(void);
static void cont__add_remark_lines_26(void);
static void cont__add_remark_lines_27(void);
static NODE *func__add_remark_lines_28;
static void entry__add_remark_lines_28(void);
static FRAME_INFO frame__add_remark_lines_28 = {4, {"is_a_statement", "buf", "str", "indent"}};
static NODE *func__add_remark_lines_29;
static void entry__add_remark_lines_29(void);
static FRAME_INFO frame__add_remark_lines_29 = {2, {"buf", "str"}};
static void cont__add_remark_lines_30(void);
static void cont__add_remark_lines_31(void);
static void cont__add_remark_lines_32(void);
static void cont__add_remark_lines_33(void);
static void cont__add_remark_lines_34(void);
static void cont__add_remark_lines_35(void);
static void cont__add_remark_lines_36(void);
static NODE *func__add_remark_lines_37;
static void entry__add_remark_lines_37(void);
static FRAME_INFO frame__add_remark_lines_37 = {4, {"str", "remark_prefix", "remark_lines", "is_a_statement"}};
static void cont__add_remark_lines_38(void);
static void cont__add_remark_lines_39(void);
static void cont__add_remark_lines_40(void);
static void cont__add_remark_lines_41(void);
static void cont__add_remark_lines_42(void);
static void cont__add_remark_lines_43(void);
static void cont__add_remark_lines_44(void);
static NODE *func__add_remark_lines_45;
static void entry__add_remark_lines_45(void);
static FRAME_INFO frame__add_remark_lines_45 = {4, {"str", "remark_lines", "is_a_statement", "remark_prefix"}};
static void cont__add_remark_lines_46(void);
static NODE *func__add_remark_lines_47;
static void entry__add_remark_lines_47(void);
static FRAME_INFO frame__add_remark_lines_47 = {2, {"str", "remark_lines"}};
static void cont__add_remark_lines_48(void);
static void cont__add_remark_lines_49(void);
static void cont__add_remark_lines_50(void);
static NODE *func__add_remark_lines_51;
static void entry__add_remark_lines_51(void);
static FRAME_INFO frame__add_remark_lines_51 = {4, {"is_a_statement", "str", "remark_prefix", "remark_lines"}};
static NODE *func__add_remark_lines_52;
static void entry__add_remark_lines_52(void);
static FRAME_INFO frame__add_remark_lines_52 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__add_remark_lines_53(void);
static void cont__add_remark_lines_54(void);
static NODE *func__add_remark_lines_55;
static void entry__add_remark_lines_55(void);
static FRAME_INFO frame__add_remark_lines_55 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__add_remark_lines_56(void);
static void cont__add_remark_lines_57(void);
static void cont__add_remark_lines_58(void);
static void cont__add_remark_lines_59(void);
static NODE *func__add_remark_lines_60;
static void entry__add_remark_lines_60(void);
static FRAME_INFO frame__add_remark_lines_60 = {3, {"str", "remark_prefix", "remark_lines"}};
static void cont__add_remark_lines_61(void);
static void cont__add_remark_lines_62(void);
static NODE *func__add_statement_remark_1;
static void entry__add_statement_remark_1(void);
static FRAME_INFO frame__add_statement_remark_1 = {3, {"self", "str", "remark_lines"}};
static void cont__add_statement_remark_2(void);
static void cont__add_statement_remark_3(void);
static NODE *func__add_statement_remark_4;
static void entry__add_statement_remark_4(void);
static FRAME_INFO frame__add_statement_remark_4 = {1, {"str"}};
static NODE *func__add_statement_remark_5;
static void entry__add_statement_remark_5(void);
static FRAME_INFO frame__add_statement_remark_5 = {2, {"str", "remark_lines"}};
static void cont__add_statement_remark_6(void);
static NODE *func__add_remark_1;
static void entry__add_remark_1(void);
static FRAME_INFO frame__add_remark_1 = {3, {"self", "str", "remark_lines"}};
static void cont__add_remark_2(void);
static void cont__add_remark_3(void);
static NODE *func__add_remark_4;
static void entry__add_remark_4(void);
static FRAME_INFO frame__add_remark_4 = {1, {"str"}};
static NODE *func__add_remark_5;
static void entry__add_remark_5(void);
static FRAME_INFO frame__add_remark_5 = {2, {"str", "remark_lines"}};
static void cont__add_remark_6(void);
static NODE *func__add_indented_remark_1;
static void entry__add_indented_remark_1(void);
static FRAME_INFO frame__add_indented_remark_1 = {3, {"self", "str", "indent"}};
static NODE *func__add_indented_remark_2;
static void entry__add_indented_remark_2(void);
static FRAME_INFO frame__add_indented_remark_2 = {4, {"return__1", "indent", "self", "str"}};
static void cont__add_indented_remark_3(void);
static void cont__add_indented_remark_4(void);
static NODE *func__types__grammar_node__to_string_1;
static void entry__types__grammar_node__to_string_1(void);
static FRAME_INFO frame__types__grammar_node__to_string_1 = {1, {"self"}};
static NODE *string__f45afcc3e835d069;
static NODE *func__compiler__require_instruction__to_string_1;
static void entry__compiler__require_instruction__to_string_1(void);
static FRAME_INFO frame__compiler__require_instruction__to_string_1 = {1, {"self"}};
static void cont__compiler__require_instruction__to_string_2(void);
static NODE *string__7ca422245e2a26c5;
static NODE *string__578a5af303e9cdf;
static void cont__compiler__require_instruction__to_string_5(void);
static NODE *func__compiler__namespace_instruction__to_string_1;
static void entry__compiler__namespace_instruction__to_string_1(void);
static FRAME_INFO frame__compiler__namespace_instruction__to_string_1 = {1, {"self"}};
static void cont__compiler__namespace_instruction__to_string_2(void);
static void cont__compiler__namespace_instruction__to_string_3(void);
static NODE *func__compiler__namespace_instruction__to_string_4;
static void entry__compiler__namespace_instruction__to_string_4(void);
static FRAME_INFO frame__compiler__namespace_instruction__to_string_4 = {1, {"self"}};
static void cont__compiler__namespace_instruction__to_string_5(void);
static void cont__compiler__namespace_instruction__to_string_6(void);
static NODE *string__82c941922e20aab7;
static NODE *string__fa730415fc16bec;
static void cont__compiler__namespace_instruction__to_string_9(void);
static NODE *func__compiler__namespace_instruction__to_string_10;
static void entry__compiler__namespace_instruction__to_string_10(void);
static FRAME_INFO frame__compiler__namespace_instruction__to_string_10 = {1, {"self"}};
static void cont__compiler__namespace_instruction__to_string_11(void);
static void cont__compiler__namespace_instruction__to_string_12(void);
static void cont__compiler__namespace_instruction__to_string_13(void);
static NODE *func__compiler__using_instruction__to_string_1;
static void entry__compiler__using_instruction__to_string_1(void);
static FRAME_INFO frame__compiler__using_instruction__to_string_1 = {1, {"self"}};
static void cont__compiler__using_instruction__to_string_2(void);
static NODE *string__a1740e581583f0da;
static void cont__compiler__using_instruction__to_string_4(void);
static NODE *func__compiler__include_instruction__to_string_1;
static void entry__compiler__include_instruction__to_string_1(void);
static FRAME_INFO frame__compiler__include_instruction__to_string_1 = {1, {"self"}};
static void cont__compiler__include_instruction__to_string_2(void);
static NODE *string__448827ad5e2bb5a5;
static void cont__compiler__include_instruction__to_string_4(void);
static NODE *func__compiler__link_instruction__to_string_1;
static void entry__compiler__link_instruction__to_string_1(void);
static FRAME_INFO frame__compiler__link_instruction__to_string_1 = {1, {"self"}};
static void cont__compiler__link_instruction__to_string_2(void);
static NODE *string__4a1f55ee81e292f7;
static void cont__compiler__link_instruction__to_string_4(void);
static NODE *func__compiler__data_instruction__to_string_1;
static void entry__compiler__data_instruction__to_string_1(void);
static FRAME_INFO frame__compiler__data_instruction__to_string_1 = {1, {"self"}};
static void cont__compiler__data_instruction__to_string_2(void);
static NODE *string__5a1f536e81b212f7;
static void cont__compiler__data_instruction__to_string_4(void);
static NODE *func__compiler__remark_statement__to_string_1;
static void entry__compiler__remark_statement__to_string_1(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_1 = {3, {"self", "remark_lines", "buf"}};
static void cont__compiler__remark_statement__to_string_2(void);
static NODE *func__compiler__remark_statement__to_string_3;
static void entry__compiler__remark_statement__to_string_3(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_3 = {1, {"remark_lines"}};
static void cont__compiler__remark_statement__to_string_4(void);
static void cont__compiler__remark_statement__to_string_5(void);
static NODE *func__compiler__remark_statement__to_string_6;
static void entry__compiler__remark_statement__to_string_6(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_6 = {0, {}};
static NODE *func__compiler__remark_statement__to_string_7;
static void entry__compiler__remark_statement__to_string_7(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_7 = {1, {"remark_lines"}};
static void cont__compiler__remark_statement__to_string_8(void);
static void cont__compiler__remark_statement__to_string_9(void);
static void cont__compiler__remark_statement__to_string_10(void);
static NODE *func__compiler__remark_statement__to_string_11;
static void entry__compiler__remark_statement__to_string_11(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_11 = {1, {"remark_lines"}};
static void cont__compiler__remark_statement__to_string_12(void);
static void cont__compiler__remark_statement__to_string_13(void);
static void cont__compiler__remark_statement__to_string_14(void);
static void cont__compiler__remark_statement__to_string_15(void);
static NODE *func__compiler__remark_statement__to_string_16;
static void entry__compiler__remark_statement__to_string_16(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_16 = {1, {"remark_lines"}};
static void cont__compiler__remark_statement__to_string_17(void);
static void cont__compiler__remark_statement__to_string_18(void);
static void cont__compiler__remark_statement__to_string_19(void);
static void cont__compiler__remark_statement__to_string_20(void);
static void cont__compiler__remark_statement__to_string_21(void);
static void cont__compiler__remark_statement__to_string_22(void);
static NODE *func__compiler__remark_statement__to_string_23;
static void entry__compiler__remark_statement__to_string_23(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_23 = {0, {}};
static NODE *func__compiler__remark_statement__to_string_24;
static void entry__compiler__remark_statement__to_string_24(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_24 = {1, {"remark_lines"}};
static void cont__compiler__remark_statement__to_string_25(void);
static void cont__compiler__remark_statement__to_string_26(void);
static NODE *func__compiler__remark_statement__to_string_27;
static void entry__compiler__remark_statement__to_string_27(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_27 = {0, {}};
static NODE *func__compiler__remark_statement__to_string_28;
static void entry__compiler__remark_statement__to_string_28(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_28 = {0, {}};
static NODE *func__compiler__remark_statement__to_string_29;
static void entry__compiler__remark_statement__to_string_29(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_29 = {0, {}};
static void cont__compiler__remark_statement__to_string_30(void);
static void cont__compiler__remark_statement__to_string_31(void);
static void cont__compiler__remark_statement__to_string_32(void);
static void cont__compiler__remark_statement__to_string_33(void);
static void cont__compiler__remark_statement__to_string_34(void);
static NODE *func__compiler__remark_statement__to_string_35;
static void entry__compiler__remark_statement__to_string_35(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_35 = {3, {"remark_lines", "buf", "indent"}};
static void cont__compiler__remark_statement__to_string_36(void);
static void cont__compiler__remark_statement__to_string_37(void);
static NODE *func__compiler__remark_statement__to_string_38;
static void entry__compiler__remark_statement__to_string_38(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_38 = {3, {"line", "buf", "indent"}};
static void cont__compiler__remark_statement__to_string_39(void);
static void cont__compiler__remark_statement__to_string_40(void);
static void cont__compiler__remark_statement__to_string_41(void);
static NODE *func__compiler__remark_statement__to_string_42;
static void entry__compiler__remark_statement__to_string_42(void);
static FRAME_INFO frame__compiler__remark_statement__to_string_42 = {3, {"buf", "indent", "line"}};
static void cont__compiler__remark_statement__to_string_43(void);
static void cont__compiler__remark_statement__to_string_44(void);
static void cont__compiler__remark_statement__to_string_45(void);
static NODE *func__compiler__body__to_string_1;
static void entry__compiler__body__to_string_1(void);
static FRAME_INFO frame__compiler__body__to_string_1 = {4, {"self", "indent", "remark_lines", "parameters"}};
static void cont__compiler__body__to_string_2(void);
static void cont__compiler__body__to_string_3(void);
static void cont__compiler__body__to_string_4(void);
static void cont__compiler__body__to_string_5(void);
static NODE *func__compiler__body__to_string_6;
static void entry__compiler__body__to_string_6(void);
static FRAME_INFO frame__compiler__body__to_string_6 = {1, {"self"}};
static void cont__compiler__body__to_string_7(void);
static void cont__compiler__body__to_string_8(void);
static void cont__compiler__body__to_string_9(void);
static NODE *func__compiler__body__to_string_10;
static void entry__compiler__body__to_string_10(void);
static FRAME_INFO frame__compiler__body__to_string_10 = {1, {"self"}};
static void cont__compiler__body__to_string_11(void);
static void cont__compiler__body__to_string_12(void);
static void cont__compiler__body__to_string_13(void);
static void cont__compiler__body__to_string_14(void);
static void cont__compiler__body__to_string_15(void);
static NODE *func__compiler__body__to_string_16;
static void entry__compiler__body__to_string_16(void);
static FRAME_INFO frame__compiler__body__to_string_16 = {3, {"self", "indent", "str"}};
static void cont__compiler__body__to_string_17(void);
static void cont__compiler__body__to_string_18(void);
static void cont__compiler__body__to_string_19(void);
static void cont__compiler__body__to_string_20(void);
static NODE *func__compiler__body__to_string_21;
static void entry__compiler__body__to_string_21(void);
static FRAME_INFO frame__compiler__body__to_string_21 = {1, {"str"}};
static void cont__compiler__body__to_string_22(void);
static void cont__compiler__body__to_string_23(void);
static NODE *func__compiler__body__to_string_24;
static void entry__compiler__body__to_string_24(void);
static FRAME_INFO frame__compiler__body__to_string_24 = {2, {"indent", "str"}};
static void cont__compiler__body__to_string_25(void);
static void cont__compiler__body__to_string_26(void);
static NODE *func__compiler__body__to_string_27;
static void entry__compiler__body__to_string_27(void);
static FRAME_INFO frame__compiler__body__to_string_27 = {1, {"str"}};
static NODE *func__compiler__body__to_string_28;
static void entry__compiler__body__to_string_28(void);
static FRAME_INFO frame__compiler__body__to_string_28 = {9, {"indent", "parameters", "remark_lines", "self", "buf", "check_for_line_end_expression", "handle_simple_parameters", "handle_complex_parameters", "outer_line_end_expression_width"}};
static NODE *func__compiler__body__to_string_29;
static void entry__compiler__body__to_string_29(void);
static FRAME_INFO frame__compiler__body__to_string_29 = {2, {"buf", "indent"}};
static void cont__compiler__body__to_string_30(void);
static NODE *func__compiler__body__to_string_31;
static void entry__compiler__body__to_string_31(void);
static FRAME_INFO frame__compiler__body__to_string_31 = {1, {"buf"}};
static NODE *func__compiler__body__to_string_32;
static void entry__compiler__body__to_string_32(void);
static FRAME_INFO frame__compiler__body__to_string_32 = {2, {"buf", "indent"}};
static void cont__compiler__body__to_string_33(void);
static void cont__compiler__body__to_string_34(void);
static void cont__compiler__body__to_string_35(void);
static NODE *func__compiler__body__to_string_36;
static void entry__compiler__body__to_string_36(void);
static FRAME_INFO frame__compiler__body__to_string_36 = {6, {"parameters", "buf", "indent", "handle_complex_parameters", "parameter_text", "parameter_text_length"}};
static NODE *string__fa736c15f296be4;
static NODE *func__compiler__body__to_string_38;
static void entry__compiler__body__to_string_38(void);
static FRAME_INFO frame__compiler__body__to_string_38 = {2, {"parameter", "parameter_text"}};
static void cont__compiler__body__to_string_39(void);
static void cont__compiler__body__to_string_40(void);
static NODE *func__compiler__body__to_string_41;
static void entry__compiler__body__to_string_41(void);
static FRAME_INFO frame__compiler__body__to_string_41 = {1, {"parameter_text"}};
static void cont__compiler__body__to_string_42(void);
static void cont__compiler__body__to_string_43(void);
static void cont__compiler__body__to_string_44(void);
static void cont__compiler__body__to_string_45(void);
static void cont__compiler__body__to_string_46(void);
static void cont__compiler__body__to_string_47(void);
static NODE *func__compiler__body__to_string_48;
static void entry__compiler__body__to_string_48(void);
static FRAME_INFO frame__compiler__body__to_string_48 = {2, {"buf", "parameter_text"}};
static NODE *func__compiler__body__to_string_49;
static void entry__compiler__body__to_string_49(void);
static FRAME_INFO frame__compiler__body__to_string_49 = {5, {"indent", "parameter_text_length", "buf", "parameter_text", "handle_complex_parameters"}};
static void cont__compiler__body__to_string_50(void);
static void cont__compiler__body__to_string_51(void);
static void cont__compiler__body__to_string_52(void);
static NODE *func__compiler__body__to_string_53;
static void entry__compiler__body__to_string_53(void);
static FRAME_INFO frame__compiler__body__to_string_53 = {3, {"buf", "indent", "parameter_text"}};
static void cont__compiler__body__to_string_54(void);
static void cont__compiler__body__to_string_55(void);
static void cont__compiler__body__to_string_56(void);
static NODE *func__compiler__body__to_string_57;
static void entry__compiler__body__to_string_57(void);
static FRAME_INFO frame__compiler__body__to_string_57 = {1, {"handle_complex_parameters"}};
static NODE *func__compiler__body__to_string_58;
static void entry__compiler__body__to_string_58(void);
static FRAME_INFO frame__compiler__body__to_string_58 = {7, {"return__1", "check_for_line_end_expression", "indent", "remark_lines", "buf", "parameters", "parameter_indentation"}};
static void cont__compiler__body__to_string_59(void);
static void cont__compiler__body__to_string_60(void);
static void cont__compiler__body__to_string_61(void);
static void cont__compiler__body__to_string_62(void);
static NODE *func__compiler__body__to_string_63;
static void entry__compiler__body__to_string_63(void);
static FRAME_INFO frame__compiler__body__to_string_63 = {2, {"buf", "remark_lines"}};
static void cont__compiler__body__to_string_64(void);
static void cont__compiler__body__to_string_65(void);
static void cont__compiler__body__to_string_66(void);
static void cont__compiler__body__to_string_67(void);
static NODE *string__578a5af303e9cc9;
static void cont__compiler__body__to_string_69(void);
static NODE *func__compiler__body__to_string_70;
static void entry__compiler__body__to_string_70(void);
static FRAME_INFO frame__compiler__body__to_string_70 = {3, {"parameter", "buf", "parameter_indentation"}};
static void cont__compiler__body__to_string_71(void);
static void cont__compiler__body__to_string_72(void);
static void cont__compiler__body__to_string_73(void);
static NODE *func__compiler__body__to_string_74;
static void entry__compiler__body__to_string_74(void);
static FRAME_INFO frame__compiler__body__to_string_74 = {2, {"buf", "parameter"}};
static void cont__compiler__body__to_string_75(void);
static NODE *func__compiler__body__to_string_76;
static void entry__compiler__body__to_string_76(void);
static FRAME_INFO frame__compiler__body__to_string_76 = {3, {"buf", "parameter_indentation", "parameter"}};
static void cont__compiler__body__to_string_77(void);
static void cont__compiler__body__to_string_78(void);
static void cont__compiler__body__to_string_79(void);
static void cont__compiler__body__to_string_80(void);
static void cont__compiler__body__to_string_81(void);
static void cont__compiler__body__to_string_82(void);
static NODE *func__compiler__body__to_string_83;
static void entry__compiler__body__to_string_83(void);
static FRAME_INFO frame__compiler__body__to_string_83 = {1, {"check_for_line_end_expression"}};
static NODE *func__compiler__body__to_string_84;
static void entry__compiler__body__to_string_84(void);
static FRAME_INFO frame__compiler__body__to_string_84 = {5, {"remark_lines", "parameters", "handle_simple_parameters", "handle_complex_parameters", "has_simple_parameters"}};
static void cont__compiler__body__to_string_85(void);
static NODE *func__compiler__body__to_string_86;
static void entry__compiler__body__to_string_86(void);
static FRAME_INFO frame__compiler__body__to_string_86 = {1, {"parameters"}};
static void cont__compiler__body__to_string_87(void);
static void cont__compiler__body__to_string_88(void);
static NODE *func__compiler__body__to_string_89;
static void entry__compiler__body__to_string_89(void);
static FRAME_INFO frame__compiler__body__to_string_89 = {1, {"parameters"}};
static NODE *func__compiler__body__to_string_90;
static void entry__compiler__body__to_string_90(void);
static FRAME_INFO frame__compiler__body__to_string_90 = {1, {"parameter"}};
static void cont__compiler__body__to_string_91(void);
static void cont__compiler__body__to_string_92(void);
static void cont__compiler__body__to_string_93(void);
static NODE *func__compiler__body__to_string_94;
static void entry__compiler__body__to_string_94(void);
static FRAME_INFO frame__compiler__body__to_string_94 = {1, {"parameter"}};
static void cont__compiler__body__to_string_95(void);
static void cont__compiler__body__to_string_96(void);
static void cont__compiler__body__to_string_97(void);
static void cont__compiler__body__to_string_98(void);
static void cont__compiler__body__to_string_99(void);
static void cont__compiler__body__to_string_100(void);
static NODE *func__compiler__body__to_string_101;
static void entry__compiler__body__to_string_101(void);
static FRAME_INFO frame__compiler__body__to_string_101 = {1, {"parameters"}};
static NODE *func__compiler__body__to_string_102;
static void entry__compiler__body__to_string_102(void);
static FRAME_INFO frame__compiler__body__to_string_102 = {1, {"parameter"}};
static void cont__compiler__body__to_string_103(void);
static void cont__compiler__body__to_string_104(void);
static void cont__compiler__body__to_string_105(void);
static void cont__compiler__body__to_string_106(void);
static void cont__compiler__body__to_string_107(void);
static NODE *func__compiler__body__to_string_108;
static void entry__compiler__body__to_string_108(void);
static FRAME_INFO frame__compiler__body__to_string_108 = {1, {"handle_simple_parameters"}};
static NODE *func__compiler__body__to_string_109;
static void entry__compiler__body__to_string_109(void);
static FRAME_INFO frame__compiler__body__to_string_109 = {1, {"handle_complex_parameters"}};
static void cont__compiler__body__to_string_110(void);
static NODE *func__compiler__body__to_string_111;
static void entry__compiler__body__to_string_111(void);
static FRAME_INFO frame__compiler__body__to_string_111 = {6, {"return__3", "indent", "buf", "self", "outer_line_end_expression_width", "indentation"}};
static void cont__compiler__body__to_string_112(void);
static NODE *func__compiler__body__to_string_113;
static void entry__compiler__body__to_string_113(void);
static FRAME_INFO frame__compiler__body__to_string_113 = {2, {"buf", "indentation"}};
static NODE *string__9e0afacb5f107d33;
static void cont__compiler__body__to_string_115(void);
static NODE *func__compiler__body__to_string_116;
static void entry__compiler__body__to_string_116(void);
static FRAME_INFO frame__compiler__body__to_string_116 = {7, {"return__2", "self", "buf", "outer_line_end_expression_width", "indentation", "statements", "n"}};
static void cont__compiler__body__to_string_117(void);
static void cont__compiler__body__to_string_118(void);
static void cont__compiler__body__to_string_119(void);
static NODE *func__compiler__body__to_string_120;
static void entry__compiler__body__to_string_120(void);
static FRAME_INFO frame__compiler__body__to_string_120 = {8, {"idx", "statement", "buf", "n", "outer_line_end_expression_width", "indentation", "previous_statement_tag", "str"}};
static void cont__compiler__body__to_string_121(void);
static void cont__compiler__body__to_string_122(void);
static NODE *func__compiler__body__to_string_123;
static void entry__compiler__body__to_string_123(void);
static FRAME_INFO frame__compiler__body__to_string_123 = {1, {"previous_statement_tag"}};
static void cont__compiler__body__to_string_124(void);
static NODE *func__compiler__body__to_string_125;
static void entry__compiler__body__to_string_125(void);
static FRAME_INFO frame__compiler__body__to_string_125 = {1, {"previous_statement_tag"}};
static void cont__compiler__body__to_string_126(void);
static void cont__compiler__body__to_string_127(void);
static void cont__compiler__body__to_string_128(void);
static void cont__compiler__body__to_string_129(void);
static NODE *func__compiler__body__to_string_130;
static void entry__compiler__body__to_string_130(void);
static FRAME_INFO frame__compiler__body__to_string_130 = {1, {"buf"}};
static void cont__compiler__body__to_string_131(void);
static void cont__compiler__body__to_string_132(void);
static void cont__compiler__body__to_string_133(void);
static NODE *func__compiler__body__to_string_134;
static void entry__compiler__body__to_string_134(void);
static FRAME_INFO frame__compiler__body__to_string_134 = {3, {"buf", "str", "outer_line_end_expression_width"}};
static void cont__compiler__body__to_string_135(void);
static NODE *func__compiler__body__to_string_136;
static void entry__compiler__body__to_string_136(void);
static FRAME_INFO frame__compiler__body__to_string_136 = {3, {"str", "outer_line_end_expression_width", "buf"}};
static void cont__compiler__body__to_string_137(void);
static NODE *func__compiler__body__to_string_138;
static void entry__compiler__body__to_string_138(void);
static FRAME_INFO frame__compiler__body__to_string_138 = {3, {"outer_line_end_expression_width", "buf", "str"}};
static void cont__compiler__body__to_string_139(void);
static void cont__compiler__body__to_string_140(void);
static void cont__compiler__body__to_string_141(void);
static void cont__compiler__body__to_string_142(void);
static void cont__compiler__body__to_string_143(void);
static void cont__compiler__body__to_string_144(void);
static void cont__compiler__body__to_string_145(void);
static void cont__compiler__body__to_string_146(void);
static NODE *func__compiler__body__to_string_147;
static void entry__compiler__body__to_string_147(void);
static FRAME_INFO frame__compiler__body__to_string_147 = {3, {"buf", "indentation", "str"}};
static void cont__compiler__body__to_string_148(void);
static NODE *func__compiler__body__to_string_149;
static void entry__compiler__body__to_string_149(void);
static FRAME_INFO frame__compiler__body__to_string_149 = {2, {"buf", "str"}};
static void cont__compiler__body__to_string_150(void);
static void cont__compiler__body__to_string_151(void);
static void cont__compiler__body__to_string_152(void);
static void cont__compiler__body__to_string_153(void);
static NODE *func__argument_to_string_1;
static void entry__argument_to_string_1(void);
static FRAME_INFO frame__argument_to_string_1 = {2, {"argument", "width"}};
static NODE *func__argument_to_string_2;
static void entry__argument_to_string_2(void);
static FRAME_INFO frame__argument_to_string_2 = {5, {"return__1", "argument", "width", "str", "first_chr"}};
static void cont__argument_to_string_3(void);
static NODE *func__argument_to_string_4;
static void entry__argument_to_string_4(void);
static FRAME_INFO frame__argument_to_string_4 = {1, {"argument"}};
static void cont__argument_to_string_5(void);
static NODE *func__argument_to_string_6;
static void entry__argument_to_string_6(void);
static FRAME_INFO frame__argument_to_string_6 = {1, {"argument"}};
static void cont__argument_to_string_7(void);
static void cont__argument_to_string_8(void);
static void cont__argument_to_string_9(void);
static NODE *func__argument_to_string_10;
static void entry__argument_to_string_10(void);
static FRAME_INFO frame__argument_to_string_10 = {1, {"width"}};
static NODE *func__argument_to_string_11;
static void entry__argument_to_string_11(void);
static FRAME_INFO frame__argument_to_string_11 = {0, {}};
static void cont__argument_to_string_12(void);
static void cont__argument_to_string_13(void);
static NODE *func__argument_to_string_14;
static void entry__argument_to_string_14(void);
static FRAME_INFO frame__argument_to_string_14 = {2, {"argument", "str"}};
static void cont__argument_to_string_15(void);
static NODE *func__argument_to_string_16;
static void entry__argument_to_string_16(void);
static FRAME_INFO frame__argument_to_string_16 = {2, {"argument", "str"}};
static void cont__argument_to_string_17(void);
static void cont__argument_to_string_18(void);
static NODE *func__argument_to_string_19;
static void entry__argument_to_string_19(void);
static FRAME_INFO frame__argument_to_string_19 = {1, {"str"}};
static void cont__argument_to_string_20(void);
static void cont__argument_to_string_21(void);
static void cont__argument_to_string_22(void);
static NODE *func__argument_to_string_23;
static void entry__argument_to_string_23(void);
static FRAME_INFO frame__argument_to_string_23 = {2, {"argument", "str"}};
static void cont__argument_to_string_24(void);
static NODE *func__argument_to_string_25;
static void entry__argument_to_string_25(void);
static FRAME_INFO frame__argument_to_string_25 = {2, {"argument", "str"}};
static void cont__argument_to_string_26(void);
static void cont__argument_to_string_27(void);
static NODE *func__argument_to_string_28;
static void entry__argument_to_string_28(void);
static FRAME_INFO frame__argument_to_string_28 = {1, {"str"}};
static void cont__argument_to_string_29(void);
static void cont__argument_to_string_30(void);
static void cont__argument_to_string_31(void);
static void cont__argument_to_string_32(void);
static void cont__argument_to_string_33(void);
static void cont__argument_to_string_34(void);
static NODE *func__argument_to_string_35;
static void entry__argument_to_string_35(void);
static FRAME_INFO frame__argument_to_string_35 = {1, {"first_chr"}};
static void cont__argument_to_string_36(void);
static void cont__argument_to_string_37(void);
static NODE *func__argument_to_string_38;
static void entry__argument_to_string_38(void);
static FRAME_INFO frame__argument_to_string_38 = {1, {"first_chr"}};
static void cont__argument_to_string_39(void);
static void cont__argument_to_string_40(void);
static void cont__argument_to_string_41(void);
static void cont__argument_to_string_42(void);
static NODE *func__argument_to_string_43;
static void entry__argument_to_string_43(void);
static FRAME_INFO frame__argument_to_string_43 = {2, {"argument", "str"}};
static void cont__argument_to_string_44(void);
static NODE *func__argument_to_string_45;
static void entry__argument_to_string_45(void);
static FRAME_INFO frame__argument_to_string_45 = {1, {"str"}};
static void cont__argument_to_string_46(void);
static NODE *func__argument_to_string_47;
static void entry__argument_to_string_47(void);
static FRAME_INFO frame__argument_to_string_47 = {1, {"str"}};
static void cont__argument_to_string_48(void);
static void cont__argument_to_string_49(void);
static NODE *func__argument_to_string_50;
static void entry__argument_to_string_50(void);
static FRAME_INFO frame__argument_to_string_50 = {1, {"str"}};
static void cont__argument_to_string_51(void);
static NODE *func__arguments_to_string_1;
static void entry__arguments_to_string_1(void);
static FRAME_INFO frame__arguments_to_string_1 = {15, {"self", "mode", "available_width", "return", "line_end_width", "arguments", "first", "n", "total_length", "strings", "has_final_remark", "do_use_multiple_lines", "buf", "print_on_one_line", "print_on_multiple_lines"}};
static NODE *func__arguments_to_string_2;
static void entry__arguments_to_string_2(void);
static FRAME_INFO frame__arguments_to_string_2 = {5, {"from", "to", "strings", "buf", "n"}};
static NODE *func__arguments_to_string_3;
static void entry__arguments_to_string_3(void);
static FRAME_INFO frame__arguments_to_string_3 = {4, {"idx", "str", "buf", "n"}};
static void cont__arguments_to_string_4(void);
static NODE *func__arguments_to_string_5;
static void entry__arguments_to_string_5(void);
static FRAME_INFO frame__arguments_to_string_5 = {1, {"str"}};
static void cont__arguments_to_string_6(void);
static void cont__arguments_to_string_7(void);
static NODE *func__arguments_to_string_8;
static void entry__arguments_to_string_8(void);
static FRAME_INFO frame__arguments_to_string_8 = {1, {"str"}};
static void cont__arguments_to_string_9(void);
static void cont__arguments_to_string_10(void);
static void cont__arguments_to_string_11(void);
static void cont__arguments_to_string_12(void);
static NODE *func__arguments_to_string_13;
static void entry__arguments_to_string_13(void);
static FRAME_INFO frame__arguments_to_string_13 = {1, {"buf"}};
static void cont__arguments_to_string_14(void);
static void cont__arguments_to_string_15(void);
static void cont__arguments_to_string_16(void);
static NODE *func__arguments_to_string_17;
static void entry__arguments_to_string_17(void);
static FRAME_INFO frame__arguments_to_string_17 = {1, {"str"}};
static NODE *string__2d7981f4e6602bfb;
static void cont__arguments_to_string_19(void);
static NODE *func__arguments_to_string_20;
static void entry__arguments_to_string_20(void);
static FRAME_INFO frame__arguments_to_string_20 = {1, {"str"}};
static void cont__arguments_to_string_21(void);
static void cont__arguments_to_string_22(void);
static void cont__arguments_to_string_23(void);
static void cont__arguments_to_string_24(void);
static NODE *func__arguments_to_string_25;
static void entry__arguments_to_string_25(void);
static FRAME_INFO frame__arguments_to_string_25 = {2, {"buf", "str"}};
static void cont__arguments_to_string_26(void);
static void cont__arguments_to_string_27(void);
static void cont__arguments_to_string_28(void);
static NODE *func__arguments_to_string_29;
static void entry__arguments_to_string_29(void);
static FRAME_INFO frame__arguments_to_string_29 = {2, {"buf", "str"}};
static void cont__arguments_to_string_30(void);
static NODE *func__arguments_to_string_31;
static void entry__arguments_to_string_31(void);
static FRAME_INFO frame__arguments_to_string_31 = {8, {"from", "to", "strings", "buf", "first", "n", "indentation", "line_end_conversion_is_allowed"}};
static void cont__arguments_to_string_32(void);
static NODE *func__arguments_to_string_33;
static void entry__arguments_to_string_33(void);
static FRAME_INFO frame__arguments_to_string_33 = {8, {"idx", "str", "line_end_conversion_is_allowed", "strings", "buf", "first", "indentation", "n"}};
static NODE *func__arguments_to_string_34;
static void entry__arguments_to_string_34(void);
static FRAME_INFO frame__arguments_to_string_34 = {3, {"str", "strings", "idx"}};
static void cont__arguments_to_string_35(void);
static void cont__arguments_to_string_36(void);
static void cont__arguments_to_string_37(void);
static NODE *func__arguments_to_string_38;
static void entry__arguments_to_string_38(void);
static FRAME_INFO frame__arguments_to_string_38 = {3, {"strings", "idx", "str"}};
static void cont__arguments_to_string_39(void);
static void cont__arguments_to_string_40(void);
static void cont__arguments_to_string_41(void);
static void cont__arguments_to_string_42(void);
static NODE *func__arguments_to_string_43;
static void entry__arguments_to_string_43(void);
static FRAME_INFO frame__arguments_to_string_43 = {3, {"strings", "idx", "str"}};
static void cont__arguments_to_string_44(void);
static void cont__arguments_to_string_45(void);
static void cont__arguments_to_string_46(void);
static void cont__arguments_to_string_47(void);
static void cont__arguments_to_string_48(void);
static void cont__arguments_to_string_49(void);
static NODE *func__arguments_to_string_50;
static void entry__arguments_to_string_50(void);
static FRAME_INFO frame__arguments_to_string_50 = {0, {}};
static NODE *func__arguments_to_string_51;
static void entry__arguments_to_string_51(void);
static FRAME_INFO frame__arguments_to_string_51 = {0, {}};
static void cont__arguments_to_string_52(void);
static void cont__arguments_to_string_53(void);
static void cont__arguments_to_string_54(void);
static void cont__arguments_to_string_55(void);
static void cont__arguments_to_string_56(void);
static void cont__arguments_to_string_57(void);
static void cont__arguments_to_string_58(void);
static void cont__arguments_to_string_59(void);
static void cont__arguments_to_string_60(void);
static void cont__arguments_to_string_61(void);
static void cont__arguments_to_string_62(void);
static void cont__arguments_to_string_63(void);
static NODE *func__arguments_to_string_64;
static void entry__arguments_to_string_64(void);
static FRAME_INFO frame__arguments_to_string_64 = {3, {"str", "buf", "line_end_conversion_is_allowed"}};
static void cont__arguments_to_string_65(void);
static void cont__arguments_to_string_66(void);
static NODE *func__arguments_to_string_67;
static void entry__arguments_to_string_67(void);
static FRAME_INFO frame__arguments_to_string_67 = {1, {"buf"}};
static void cont__arguments_to_string_68(void);
static void cont__arguments_to_string_69(void);
static void cont__arguments_to_string_70(void);
static void cont__arguments_to_string_71(void);
static void cont__arguments_to_string_72(void);
static NODE *func__arguments_to_string_73;
static void entry__arguments_to_string_73(void);
static FRAME_INFO frame__arguments_to_string_73 = {7, {"first", "idx", "str", "buf", "indentation", "n", "line_end_conversion_is_allowed"}};
static void cont__arguments_to_string_74(void);
static NODE *func__arguments_to_string_75;
static void entry__arguments_to_string_75(void);
static FRAME_INFO frame__arguments_to_string_75 = {1, {"str"}};
static void cont__arguments_to_string_76(void);
static void cont__arguments_to_string_77(void);
static void cont__arguments_to_string_78(void);
static NODE *func__arguments_to_string_79;
static void entry__arguments_to_string_79(void);
static FRAME_INFO frame__arguments_to_string_79 = {1, {"buf"}};
static void cont__arguments_to_string_80(void);
static void cont__arguments_to_string_81(void);
static void cont__arguments_to_string_82(void);
static void cont__arguments_to_string_83(void);
static NODE *func__arguments_to_string_84;
static void entry__arguments_to_string_84(void);
static FRAME_INFO frame__arguments_to_string_84 = {2, {"buf", "indentation"}};
static void cont__arguments_to_string_85(void);
static void cont__arguments_to_string_86(void);
static void cont__arguments_to_string_87(void);
static void cont__arguments_to_string_88(void);
static void cont__arguments_to_string_89(void);
static NODE *func__arguments_to_string_90;
static void entry__arguments_to_string_90(void);
static FRAME_INFO frame__arguments_to_string_90 = {1, {"str"}};
static void cont__arguments_to_string_91(void);
static void cont__arguments_to_string_92(void);
static void cont__arguments_to_string_93(void);
static NODE *func__arguments_to_string_94;
static void entry__arguments_to_string_94(void);
static FRAME_INFO frame__arguments_to_string_94 = {1, {"buf"}};
static void cont__arguments_to_string_95(void);
static void cont__arguments_to_string_96(void);
static void cont__arguments_to_string_97(void);
static void cont__arguments_to_string_98(void);
static void cont__arguments_to_string_99(void);
static NODE *func__arguments_to_string_100;
static void entry__arguments_to_string_100(void);
static FRAME_INFO frame__arguments_to_string_100 = {1, {"str"}};
static void cont__arguments_to_string_101(void);
static void cont__arguments_to_string_102(void);
static void cont__arguments_to_string_103(void);
static NODE *func__arguments_to_string_104;
static void entry__arguments_to_string_104(void);
static FRAME_INFO frame__arguments_to_string_104 = {1, {"str"}};
static NODE *string__2d7981f4e6182bcf;
static void cont__arguments_to_string_106(void);
static void cont__arguments_to_string_107(void);
static NODE *func__arguments_to_string_108;
static void entry__arguments_to_string_108(void);
static FRAME_INFO frame__arguments_to_string_108 = {1, {"str"}};
static void cont__arguments_to_string_109(void);
static void cont__arguments_to_string_110(void);
static void cont__arguments_to_string_111(void);
static void cont__arguments_to_string_112(void);
static void cont__arguments_to_string_113(void);
static void cont__arguments_to_string_114(void);
static void cont__arguments_to_string_115(void);
static NODE *func__arguments_to_string_116;
static void entry__arguments_to_string_116(void);
static FRAME_INFO frame__arguments_to_string_116 = {1, {"return"}};
static void cont__arguments_to_string_117(void);
static void cont__arguments_to_string_118(void);
static void cont__arguments_to_string_119(void);
static void cont__arguments_to_string_120(void);
static NODE *func__arguments_to_string_121;
static void entry__arguments_to_string_121(void);
static FRAME_INFO frame__arguments_to_string_121 = {3, {"mode", "arguments", "self"}};
static void cont__arguments_to_string_122(void);
static NODE *func__arguments_to_string_123;
static void entry__arguments_to_string_123(void);
static FRAME_INFO frame__arguments_to_string_123 = {1, {"arguments"}};
static void cont__arguments_to_string_124(void);
static void cont__arguments_to_string_125(void);
static void cont__arguments_to_string_126(void);
static NODE *func__arguments_to_string_127;
static void entry__arguments_to_string_127(void);
static FRAME_INFO frame__arguments_to_string_127 = {3, {"mode", "arguments", "self"}};
static void cont__arguments_to_string_128(void);
static NODE *func__arguments_to_string_129;
static void entry__arguments_to_string_129(void);
static FRAME_INFO frame__arguments_to_string_129 = {1, {"arguments"}};
static void cont__arguments_to_string_130(void);
static void cont__arguments_to_string_131(void);
static NODE *func__arguments_to_string_132;
static void entry__arguments_to_string_132(void);
static FRAME_INFO frame__arguments_to_string_132 = {1, {"self"}};
static void cont__arguments_to_string_133(void);
static void cont__arguments_to_string_134(void);
static void cont__arguments_to_string_135(void);
static void cont__arguments_to_string_136(void);
static NODE *func__arguments_to_string_137;
static void entry__arguments_to_string_137(void);
static FRAME_INFO frame__arguments_to_string_137 = {1, {"self"}};
static void cont__arguments_to_string_138(void);
static void cont__arguments_to_string_139(void);
static void cont__arguments_to_string_140(void);
static void cont__arguments_to_string_141(void);
static void cont__arguments_to_string_142(void);
static void cont__arguments_to_string_143(void);
static void cont__arguments_to_string_144(void);
static void cont__arguments_to_string_145(void);
static NODE *func__arguments_to_string_146;
static void entry__arguments_to_string_146(void);
static FRAME_INFO frame__arguments_to_string_146 = {12, {"idx", "argument", "return__1", "mode", "n", "total_length", "line_end_width", "do_use_multiple_lines", "has_final_remark", "available_width", "strings", "str"}};
static void cont__arguments_to_string_147(void);
static NODE *func__arguments_to_string_148;
static void entry__arguments_to_string_148(void);
static FRAME_INFO frame__arguments_to_string_148 = {5, {"idx", "n", "total_length", "line_end_width", "do_use_multiple_lines"}};
static void cont__arguments_to_string_149(void);
static NODE *func__arguments_to_string_150;
static void entry__arguments_to_string_150(void);
static FRAME_INFO frame__arguments_to_string_150 = {3, {"total_length", "line_end_width", "do_use_multiple_lines"}};
static void cont__arguments_to_string_151(void);
static NODE *func__arguments_to_string_152;
static void entry__arguments_to_string_152(void);
static FRAME_INFO frame__arguments_to_string_152 = {1, {"do_use_multiple_lines"}};
static void cont__arguments_to_string_153(void);
static void cont__arguments_to_string_154(void);
static void cont__arguments_to_string_155(void);
static void cont__arguments_to_string_156(void);
static NODE *func__arguments_to_string_157;
static void entry__arguments_to_string_157(void);
static FRAME_INFO frame__arguments_to_string_157 = {2, {"line_end_width", "total_length"}};
static void cont__arguments_to_string_158(void);
static NODE *func__arguments_to_string_159;
static void entry__arguments_to_string_159(void);
static FRAME_INFO frame__arguments_to_string_159 = {0, {}};
static void cont__arguments_to_string_160(void);
static void cont__arguments_to_string_161(void);
static void cont__arguments_to_string_162(void);
static NODE *func__arguments_to_string_163;
static void entry__arguments_to_string_163(void);
static FRAME_INFO frame__arguments_to_string_163 = {7, {"mode", "str", "idx", "n", "argument", "has_final_remark", "do_use_multiple_lines"}};
static void cont__arguments_to_string_164(void);
static NODE *func__arguments_to_string_165;
static void entry__arguments_to_string_165(void);
static FRAME_INFO frame__arguments_to_string_165 = {1, {"str"}};
static void cont__arguments_to_string_166(void);
static void cont__arguments_to_string_167(void);
static void cont__arguments_to_string_168(void);
static NODE *func__arguments_to_string_169;
static void entry__arguments_to_string_169(void);
static FRAME_INFO frame__arguments_to_string_169 = {6, {"mode", "idx", "n", "argument", "has_final_remark", "do_use_multiple_lines"}};
static void cont__arguments_to_string_170(void);
static NODE *func__arguments_to_string_171;
static void entry__arguments_to_string_171(void);
static FRAME_INFO frame__arguments_to_string_171 = {3, {"idx", "n", "argument"}};
static void cont__arguments_to_string_172(void);
static NODE *func__arguments_to_string_173;
static void entry__arguments_to_string_173(void);
static FRAME_INFO frame__arguments_to_string_173 = {1, {"argument"}};
static void cont__arguments_to_string_174(void);
static void cont__arguments_to_string_175(void);
static void cont__arguments_to_string_176(void);
static NODE *func__arguments_to_string_177;
static void entry__arguments_to_string_177(void);
static FRAME_INFO frame__arguments_to_string_177 = {1, {"has_final_remark"}};
static NODE *func__arguments_to_string_178;
static void entry__arguments_to_string_178(void);
static FRAME_INFO frame__arguments_to_string_178 = {1, {"do_use_multiple_lines"}};
static NODE *func__arguments_to_string_179;
static void entry__arguments_to_string_179(void);
static FRAME_INFO frame__arguments_to_string_179 = {9, {"idx", "n", "mode", "total_length", "str", "available_width", "do_use_multiple_lines", "argument", "has_final_remark"}};
static void cont__arguments_to_string_180(void);
static NODE *func__arguments_to_string_181;
static void entry__arguments_to_string_181(void);
static FRAME_INFO frame__arguments_to_string_181 = {6, {"mode", "idx", "total_length", "str", "available_width", "do_use_multiple_lines"}};
static void cont__arguments_to_string_182(void);
static NODE *func__arguments_to_string_183;
static void entry__arguments_to_string_183(void);
static FRAME_INFO frame__arguments_to_string_183 = {1, {"idx"}};
static void cont__arguments_to_string_184(void);
static void cont__arguments_to_string_185(void);
static NODE *func__arguments_to_string_186;
static void entry__arguments_to_string_186(void);
static FRAME_INFO frame__arguments_to_string_186 = {1, {"total_length"}};
static void cont__arguments_to_string_187(void);
static void cont__arguments_to_string_188(void);
static void cont__arguments_to_string_189(void);
static void cont__arguments_to_string_190(void);
static void cont__arguments_to_string_191(void);
static NODE *func__arguments_to_string_192;
static void entry__arguments_to_string_192(void);
static FRAME_INFO frame__arguments_to_string_192 = {1, {"total_length"}};
static void cont__arguments_to_string_193(void);
static void cont__arguments_to_string_194(void);
static void cont__arguments_to_string_195(void);
static NODE *func__arguments_to_string_196;
static void entry__arguments_to_string_196(void);
static FRAME_INFO frame__arguments_to_string_196 = {1, {"do_use_multiple_lines"}};
static NODE *func__arguments_to_string_197;
static void entry__arguments_to_string_197(void);
static FRAME_INFO frame__arguments_to_string_197 = {8, {"mode", "idx", "str", "total_length", "available_width", "argument", "has_final_remark", "do_use_multiple_lines"}};
static void cont__arguments_to_string_198(void);
static NODE *func__arguments_to_string_199;
static void entry__arguments_to_string_199(void);
static FRAME_INFO frame__arguments_to_string_199 = {1, {"idx"}};
static void cont__arguments_to_string_200(void);
static void cont__arguments_to_string_201(void);
static NODE *func__arguments_to_string_202;
static void entry__arguments_to_string_202(void);
static FRAME_INFO frame__arguments_to_string_202 = {1, {"str"}};
static void cont__arguments_to_string_203(void);
static void cont__arguments_to_string_204(void);
static void cont__arguments_to_string_205(void);
static void cont__arguments_to_string_206(void);
static NODE *func__arguments_to_string_207;
static void entry__arguments_to_string_207(void);
static FRAME_INFO frame__arguments_to_string_207 = {1, {"total_length"}};
static void cont__arguments_to_string_208(void);
static void cont__arguments_to_string_209(void);
static void cont__arguments_to_string_210(void);
static void cont__arguments_to_string_211(void);
static void cont__arguments_to_string_212(void);
static NODE *func__arguments_to_string_213;
static void entry__arguments_to_string_213(void);
static FRAME_INFO frame__arguments_to_string_213 = {4, {"mode", "argument", "has_final_remark", "do_use_multiple_lines"}};
static void cont__arguments_to_string_214(void);
static NODE *func__arguments_to_string_215;
static void entry__arguments_to_string_215(void);
static FRAME_INFO frame__arguments_to_string_215 = {1, {"argument"}};
static void cont__arguments_to_string_216(void);
static void cont__arguments_to_string_217(void);
static NODE *func__arguments_to_string_218;
static void entry__arguments_to_string_218(void);
static FRAME_INFO frame__arguments_to_string_218 = {1, {"has_final_remark"}};
static NODE *func__arguments_to_string_219;
static void entry__arguments_to_string_219(void);
static FRAME_INFO frame__arguments_to_string_219 = {1, {"do_use_multiple_lines"}};
static void cont__arguments_to_string_220(void);
static void cont__arguments_to_string_221(void);
static void cont__arguments_to_string_222(void);
static NODE *func__arguments_to_string_223;
static void entry__arguments_to_string_223(void);
static FRAME_INFO frame__arguments_to_string_223 = {8, {"done", "strings", "print_on_one_line", "print_on_multiple_lines", "n", "mode", "arguments", "print_strings"}};
static NODE *func__arguments_to_string_224;
static void entry__arguments_to_string_224(void);
static FRAME_INFO frame__arguments_to_string_224 = {6, {"from", "to", "on_first_line", "strings", "print_on_one_line", "print_on_multiple_lines"}};
static NODE *func__arguments_to_string_225;
static void entry__arguments_to_string_225(void);
static FRAME_INFO frame__arguments_to_string_225 = {3, {"strings", "from", "to"}};
static void cont__arguments_to_string_226(void);
static void cont__arguments_to_string_227(void);
static void cont__arguments_to_string_228(void);
static void cont__arguments_to_string_229(void);
static NODE *func__arguments_to_string_230;
static void entry__arguments_to_string_230(void);
static FRAME_INFO frame__arguments_to_string_230 = {3, {"print_on_one_line", "from", "to"}};
static NODE *func__arguments_to_string_231;
static void entry__arguments_to_string_231(void);
static FRAME_INFO frame__arguments_to_string_231 = {3, {"print_on_multiple_lines", "from", "to"}};
static void cont__arguments_to_string_232(void);
static void cont__arguments_to_string_233(void);
static NODE *func__arguments_to_string_234;
static void entry__arguments_to_string_234(void);
static FRAME_INFO frame__arguments_to_string_234 = {7, {"strings", "n", "print_strings", "mode", "print_on_multiple_lines", "done", "pattern"}};
static NODE *func__arguments_to_string_235;
static void entry__arguments_to_string_235(void);
static FRAME_INFO frame__arguments_to_string_235 = {2, {"string", "pattern"}};
static void cont__arguments_to_string_236(void);
static void cont__arguments_to_string_237(void);
static void cont__arguments_to_string_238(void);
static void cont__arguments_to_string_239(void);
static void cont__arguments_to_string_240(void);
static void cont__arguments_to_string_241(void);
static void cont__arguments_to_string_242(void);
static void cont__arguments_to_string_243(void);
static NODE *func__arguments_to_string_244;
static void entry__arguments_to_string_244(void);
static FRAME_INFO frame__arguments_to_string_244 = {0, {}};
static NODE *func__arguments_to_string_245;
static void entry__arguments_to_string_245(void);
static FRAME_INFO frame__arguments_to_string_245 = {0, {}};
static NODE *func__arguments_to_string_246;
static void entry__arguments_to_string_246(void);
static FRAME_INFO frame__arguments_to_string_246 = {0, {}};
static NODE *func__arguments_to_string_247;
static void entry__arguments_to_string_247(void);
static FRAME_INFO frame__arguments_to_string_247 = {0, {}};
static NODE *func__arguments_to_string_248;
static void entry__arguments_to_string_248(void);
static FRAME_INFO frame__arguments_to_string_248 = {0, {}};
static NODE *func__arguments_to_string_249;
static void entry__arguments_to_string_249(void);
static FRAME_INFO frame__arguments_to_string_249 = {0, {}};
static NODE *func__arguments_to_string_250;
static void entry__arguments_to_string_250(void);
static FRAME_INFO frame__arguments_to_string_250 = {0, {}};
static NODE *func__arguments_to_string_251;
static void entry__arguments_to_string_251(void);
static FRAME_INFO frame__arguments_to_string_251 = {0, {}};
static void cont__arguments_to_string_252(void);
static void cont__arguments_to_string_253(void);
static void cont__arguments_to_string_254(void);
static NODE *func__arguments_to_string_255;
static void entry__arguments_to_string_255(void);
static FRAME_INFO frame__arguments_to_string_255 = {6, {"n", "pattern", "print_strings", "mode", "print_on_multiple_lines", "done"}};
static NODE *func__arguments_to_string_256;
static void entry__arguments_to_string_256(void);
static FRAME_INFO frame__arguments_to_string_256 = {7, {"pat_len", "n", "pattern", "print_strings", "mode", "print_on_multiple_lines", "done"}};
static NODE *func__arguments_to_string_257;
static void entry__arguments_to_string_257(void);
static FRAME_INFO frame__arguments_to_string_257 = {8, {"s", "n", "pat_len", "pattern", "print_strings", "mode", "print_on_multiple_lines", "done"}};
static void cont__arguments_to_string_258(void);
static void cont__arguments_to_string_259(void);
static void cont__arguments_to_string_260(void);
static void cont__arguments_to_string_261(void);
static NODE *func__arguments_to_string_262;
static void entry__arguments_to_string_262(void);
static FRAME_INFO frame__arguments_to_string_262 = {10, {"pattern", "s", "pat_len", "n", "print_strings", "mode", "print_on_multiple_lines", "done", "pat", "rep"}};
static void cont__arguments_to_string_263(void);
static void cont__arguments_to_string_264(void);
static void cont__arguments_to_string_265(void);
static void cont__arguments_to_string_266(void);
static void cont__arguments_to_string_267(void);
static void cont__arguments_to_string_268(void);
static void cont__arguments_to_string_269(void);
static NODE *func__arguments_to_string_270;
static void entry__arguments_to_string_270(void);
static FRAME_INFO frame__arguments_to_string_270 = {11, {"pat", "rep", "pattern", "s", "print_strings", "mode", "print_on_multiple_lines", "pat_len", "n", "done", "rep_pat"}};
static void cont__arguments_to_string_271(void);
static void cont__arguments_to_string_272(void);
static void cont__arguments_to_string_273(void);
static void cont__arguments_to_string_274(void);
static void cont__arguments_to_string_275(void);
static void cont__arguments_to_string_276(void);
static NODE *func__arguments_to_string_277;
static void entry__arguments_to_string_277(void);
static FRAME_INFO frame__arguments_to_string_277 = {8, {"s", "print_strings", "mode", "rep", "print_on_multiple_lines", "pat_len", "n", "done"}};
static void cont__arguments_to_string_278(void);
static NODE *func__arguments_to_string_279;
static void entry__arguments_to_string_279(void);
static FRAME_INFO frame__arguments_to_string_279 = {3, {"print_strings", "s", "mode"}};
static void cont__arguments_to_string_280(void);
static void cont__arguments_to_string_281(void);
static void cont__arguments_to_string_282(void);
static NODE *func__arguments_to_string_283;
static void entry__arguments_to_string_283(void);
static FRAME_INFO frame__arguments_to_string_283 = {3, {"print_on_multiple_lines", "s", "pat_len"}};
static void cont__arguments_to_string_284(void);
static void cont__arguments_to_string_285(void);
static void cont__arguments_to_string_286(void);
static void cont__arguments_to_string_287(void);
static void cont__arguments_to_string_288(void);
static void cont__arguments_to_string_289(void);
static void cont__arguments_to_string_290(void);
static NODE *func__arguments_to_string_291;
static void entry__arguments_to_string_291(void);
static FRAME_INFO frame__arguments_to_string_291 = {3, {"print_on_multiple_lines", "s", "n"}};
static void cont__arguments_to_string_292(void);
static void cont__arguments_to_string_293(void);
static void cont__arguments_to_string_294(void);
static void cont__arguments_to_string_295(void);
static NODE *func__arguments_to_string_296;
static void entry__arguments_to_string_296(void);
static FRAME_INFO frame__arguments_to_string_296 = {2, {"arguments", "n"}};
static void cont__arguments_to_string_297(void);
static void cont__arguments_to_string_298(void);
static void cont__arguments_to_string_299(void);
static void cont__arguments_to_string_300(void);
static NODE *func__arguments_to_string_301;
static void entry__arguments_to_string_301(void);
static FRAME_INFO frame__arguments_to_string_301 = {4, {"print_strings", "mode", "print_on_multiple_lines", "n"}};
static void cont__arguments_to_string_302(void);
static void cont__arguments_to_string_303(void);
static NODE *func__arguments_to_string_304;
static void entry__arguments_to_string_304(void);
static FRAME_INFO frame__arguments_to_string_304 = {2, {"print_strings", "n"}};
static void cont__arguments_to_string_305(void);
static NODE *func__arguments_to_string_306;
static void entry__arguments_to_string_306(void);
static FRAME_INFO frame__arguments_to_string_306 = {5, {"has_final_remark", "print_on_one_line", "n", "first", "print_on_multiple_lines"}};
static NODE *func__arguments_to_string_307;
static void entry__arguments_to_string_307(void);
static FRAME_INFO frame__arguments_to_string_307 = {4, {"print_on_one_line", "n", "first", "print_on_multiple_lines"}};
static void cont__arguments_to_string_308(void);
static void cont__arguments_to_string_309(void);
static NODE *func__arguments_to_string_310;
static void entry__arguments_to_string_310(void);
static FRAME_INFO frame__arguments_to_string_310 = {2, {"print_on_one_line", "n"}};
static void cont__arguments_to_string_311(void);
static void cont__arguments_to_string_312(void);
static NODE *func__arguments_to_string_313;
static void entry__arguments_to_string_313(void);
static FRAME_INFO frame__arguments_to_string_313 = {2, {"buf", "arguments"}};
static void cont__arguments_to_string_314(void);
static void cont__arguments_to_string_315(void);
static void cont__arguments_to_string_316(void);
static NODE *func__arguments_to_string_317;
static void entry__arguments_to_string_317(void);
static FRAME_INFO frame__arguments_to_string_317 = {1, {"arguments"}};
static void cont__arguments_to_string_318(void);
static void cont__arguments_to_string_319(void);
static void cont__arguments_to_string_320(void);
static void cont__arguments_to_string_321(void);
static void cont__arguments_to_string_322(void);
static NODE *func__arguments_to_string_323;
static void entry__arguments_to_string_323(void);
static FRAME_INFO frame__arguments_to_string_323 = {1, {"buf"}};
static void cont__arguments_to_string_324(void);
static void cont__arguments_to_string_325(void);
static void cont__arguments_to_string_326(void);
static void cont__arguments_to_string_327(void);
static NODE *func__arguments_to_string_328;
static void entry__arguments_to_string_328(void);
static FRAME_INFO frame__arguments_to_string_328 = {1, {"buf"}};
static void cont__arguments_to_string_329(void);
static NODE *func__arguments_to_string_330;
static void entry__arguments_to_string_330(void);
static FRAME_INFO frame__arguments_to_string_330 = {1, {"buf"}};
static void cont__arguments_to_string_331(void);
static void cont__arguments_to_string_332(void);
static NODE *func__arguments_to_string_333;
static void entry__arguments_to_string_333(void);
static FRAME_INFO frame__arguments_to_string_333 = {1, {"buf"}};
static void cont__arguments_to_string_334(void);
static void cont__arguments_to_string_335(void);
static void cont__arguments_to_string_336(void);
static void cont__arguments_to_string_337(void);
static void cont__arguments_to_string_338(void);
static NODE *func__arguments_to_string_339;
static void entry__arguments_to_string_339(void);
static FRAME_INFO frame__arguments_to_string_339 = {1, {"buf"}};
static NODE *func__arguments_to_string_340;
static void entry__arguments_to_string_340(void);
static FRAME_INFO frame__arguments_to_string_340 = {1, {"buf"}};
static void cont__arguments_to_string_341(void);
static void cont__arguments_to_string_342(void);
static NODE *func__compiler__call__to_string_1;
static void entry__compiler__call__to_string_1(void);
static FRAME_INFO frame__compiler__call__to_string_1 = {3, {"self", "indent", "outer_line_end_expression_width"}};
static void cont__compiler__call__to_string_2(void);
static NODE *func__compiler__call__to_string_3;
static void entry__compiler__call__to_string_3(void);
static FRAME_INFO frame__compiler__call__to_string_3 = {5, {"return__1", "outer_line_end_expression_width", "indent", "self", "arguments"}};
static void cont__compiler__call__to_string_4(void);
static NODE *func__compiler__call__to_string_5;
static void entry__compiler__call__to_string_5(void);
static FRAME_INFO frame__compiler__call__to_string_5 = {1, {"indent"}};
static NODE *func__compiler__call__to_string_6;
static void entry__compiler__call__to_string_6(void);
static FRAME_INFO frame__compiler__call__to_string_6 = {1, {"indent"}};
static void cont__compiler__call__to_string_7(void);
static void cont__compiler__call__to_string_8(void);
static void cont__compiler__call__to_string_9(void);
static void cont__compiler__call__to_string_10(void);
static void cont__compiler__call__to_string_11(void);
static void cont__compiler__call__to_string_12(void);
static NODE *func__compiler__call__to_string_13;
static void entry__compiler__call__to_string_13(void);
static FRAME_INFO frame__compiler__call__to_string_13 = {6, {"return__3", "indent", "self", "functor", "this_is_a_definition", "arguments"}};
static void cont__compiler__call__to_string_14(void);
static NODE *func__compiler__call__to_string_15;
static void entry__compiler__call__to_string_15(void);
static FRAME_INFO frame__compiler__call__to_string_15 = {4, {"return__2", "self", "functor", "this_is_a_definition"}};
static void cont__compiler__call__to_string_16(void);
static NODE *func__compiler__call__to_string_17;
static void entry__compiler__call__to_string_17(void);
static FRAME_INFO frame__compiler__call__to_string_17 = {4, {"functor", "self", "this_is_a_definition", "source"}};
static void cont__compiler__call__to_string_18(void);
static void cont__compiler__call__to_string_19(void);
static void cont__compiler__call__to_string_20(void);
static void cont__compiler__call__to_string_21(void);
static void cont__compiler__call__to_string_22(void);
static void cont__compiler__call__to_string_23(void);
static void cont__compiler__call__to_string_24(void);
static void cont__compiler__call__to_string_25(void);
static void cont__compiler__call__to_string_26(void);
static NODE *func__compiler__call__to_string_27;
static void entry__compiler__call__to_string_27(void);
static FRAME_INFO frame__compiler__call__to_string_27 = {1, {"source"}};
static void cont__compiler__call__to_string_28(void);
static NODE *func__compiler__call__to_string_29;
static void entry__compiler__call__to_string_29(void);
static FRAME_INFO frame__compiler__call__to_string_29 = {0, {}};
static NODE *func__compiler__call__to_string_30;
static void entry__compiler__call__to_string_30(void);
static FRAME_INFO frame__compiler__call__to_string_30 = {1, {"source"}};
static void cont__compiler__call__to_string_31(void);
static NODE *func__compiler__call__to_string_32;
static void entry__compiler__call__to_string_32(void);
static FRAME_INFO frame__compiler__call__to_string_32 = {0, {}};
static NODE *func__compiler__call__to_string_33;
static void entry__compiler__call__to_string_33(void);
static FRAME_INFO frame__compiler__call__to_string_33 = {1, {"source"}};
static void cont__compiler__call__to_string_34(void);
static NODE *func__compiler__call__to_string_35;
static void entry__compiler__call__to_string_35(void);
static FRAME_INFO frame__compiler__call__to_string_35 = {0, {}};
static NODE *func__compiler__call__to_string_36;
static void entry__compiler__call__to_string_36(void);
static FRAME_INFO frame__compiler__call__to_string_36 = {2, {"functor", "self"}};
static void cont__compiler__call__to_string_37(void);
static void cont__compiler__call__to_string_38(void);
static void cont__compiler__call__to_string_39(void);
static void cont__compiler__call__to_string_40(void);
static void cont__compiler__call__to_string_41(void);
static void cont__compiler__call__to_string_42(void);
static void cont__compiler__call__to_string_43(void);
static void cont__compiler__call__to_string_44(void);
static NODE *func__compiler__call__to_string_45;
static void entry__compiler__call__to_string_45(void);
static FRAME_INFO frame__compiler__call__to_string_45 = {1, {"arguments"}};
static void cont__compiler__call__to_string_46(void);
static void cont__compiler__call__to_string_47(void);
static NODE *func__compiler__call__to_string_48;
static void entry__compiler__call__to_string_48(void);
static FRAME_INFO frame__compiler__call__to_string_48 = {0, {}};
static void cont__compiler__call__to_string_49(void);
static void cont__compiler__call__to_string_50(void);
static NODE *func__definition_to_string_1;
static void entry__definition_to_string_1(void);
static FRAME_INFO frame__definition_to_string_1 = {3, {"prefix", "definition", "buf"}};
static void cont__definition_to_string_2(void);
static void cont__definition_to_string_3(void);
static NODE *func__definition_to_string_4;
static void entry__definition_to_string_4(void);
static FRAME_INFO frame__definition_to_string_4 = {1, {"buf"}};
static NODE *string__fa733015fd96bec;
static void cont__definition_to_string_6(void);
static void cont__definition_to_string_7(void);
static void cont__definition_to_string_8(void);
static void cont__definition_to_string_9(void);
static void cont__definition_to_string_10(void);
static void cont__definition_to_string_11(void);
static void cont__definition_to_string_12(void);
static NODE *func__definition_to_string_13;
static void entry__definition_to_string_13(void);
static FRAME_INFO frame__definition_to_string_13 = {2, {"definition", "buf"}};
static void cont__definition_to_string_14(void);
static void cont__definition_to_string_15(void);
static NODE *func__definition_to_string_16;
static void entry__definition_to_string_16(void);
static FRAME_INFO frame__definition_to_string_16 = {1, {"buf"}};
static void cont__definition_to_string_17(void);
static void cont__definition_to_string_18(void);
static NODE *func__definition_to_string_19;
static void entry__definition_to_string_19(void);
static FRAME_INFO frame__definition_to_string_19 = {2, {"definition", "buf"}};
static void cont__definition_to_string_20(void);
static NODE *func__definition_to_string_21;
static void entry__definition_to_string_21(void);
static FRAME_INFO frame__definition_to_string_21 = {2, {"definition", "buf"}};
static void cont__definition_to_string_22(void);
static void cont__definition_to_string_23(void);
static NODE *func__definition_to_string_24;
static void entry__definition_to_string_24(void);
static FRAME_INFO frame__definition_to_string_24 = {2, {"buf", "definition"}};
static void cont__definition_to_string_25(void);
static void cont__definition_to_string_26(void);
static NODE *func__definition_to_string_27;
static void entry__definition_to_string_27(void);
static FRAME_INFO frame__definition_to_string_27 = {1, {"buf"}};
static void cont__definition_to_string_28(void);
static NODE *func__definition_to_string_29;
static void entry__definition_to_string_29(void);
static FRAME_INFO frame__definition_to_string_29 = {2, {"definition", "buf"}};
static void cont__definition_to_string_30(void);
static NODE *func__definition_to_string_31;
static void entry__definition_to_string_31(void);
static FRAME_INFO frame__definition_to_string_31 = {1, {"buf"}};
static void cont__definition_to_string_32(void);
static void cont__definition_to_string_33(void);
static NODE *func__compiler__define_static_single__to_string_1;
static void entry__compiler__define_static_single__to_string_1(void);
static FRAME_INFO frame__compiler__define_static_single__to_string_1 = {3, {"self", "prefix", "buf"}};
static void cont__compiler__define_static_single__to_string_2(void);
static void cont__compiler__define_static_single__to_string_3(void);
static NODE *func__compiler__define_static_single__to_string_4;
static void entry__compiler__define_static_single__to_string_4(void);
static FRAME_INFO frame__compiler__define_static_single__to_string_4 = {0, {}};
static NODE *func__compiler__define_static_single__to_string_5;
static void entry__compiler__define_static_single__to_string_5(void);
static FRAME_INFO frame__compiler__define_static_single__to_string_5 = {0, {}};
static NODE *string__578a5af303e9cc5;
static void cont__compiler__define_static_single__to_string_7(void);
static void cont__compiler__define_static_single__to_string_8(void);
static void cont__compiler__define_static_single__to_string_9(void);
static NODE *func__compiler__define_static_single__to_string_10;
static void entry__compiler__define_static_single__to_string_10(void);
static FRAME_INFO frame__compiler__define_static_single__to_string_10 = {2, {"buf", "self"}};
static void cont__compiler__define_static_single__to_string_11(void);
static void cont__compiler__define_static_single__to_string_12(void);
static NODE *func__compiler__define_static_single__to_string_13;
static void entry__compiler__define_static_single__to_string_13(void);
static FRAME_INFO frame__compiler__define_static_single__to_string_13 = {2, {"buf", "self"}};
static void cont__compiler__define_static_single__to_string_14(void);
static void cont__compiler__define_static_single__to_string_15(void);
static void cont__compiler__define_static_single__to_string_16(void);
static NODE *func__compiler__define_static_single__to_string_17;
static void entry__compiler__define_static_single__to_string_17(void);
static FRAME_INFO frame__compiler__define_static_single__to_string_17 = {2, {"buf", "self"}};
static void cont__compiler__define_static_single__to_string_18(void);
static void cont__compiler__define_static_single__to_string_19(void);
static void cont__compiler__define_static_single__to_string_20(void);
static NODE *func__compiler__define_static_multi__to_string_1;
static void entry__compiler__define_static_multi__to_string_1(void);
static FRAME_INFO frame__compiler__define_static_multi__to_string_1 = {2, {"self", "prefix"}};
static void cont__compiler__define_static_multi__to_string_2(void);
static void cont__compiler__define_static_multi__to_string_3(void);
static NODE *func__compiler__define_static_multi__to_string_4;
static void entry__compiler__define_static_multi__to_string_4(void);
static FRAME_INFO frame__compiler__define_static_multi__to_string_4 = {0, {}};
static NODE *func__compiler__define_static_multi__to_string_5;
static void entry__compiler__define_static_multi__to_string_5(void);
static FRAME_INFO frame__compiler__define_static_multi__to_string_5 = {0, {}};
static NODE *string__578a5af303e9cc0;
static NODE *func__compiler__define_static_multi__to_string_7;
static void entry__compiler__define_static_multi__to_string_7(void);
static FRAME_INFO frame__compiler__define_static_multi__to_string_7 = {0, {}};
static NODE *string__578a5af303e9cc7;
static NODE *func__compiler__define_static_multi__to_string_9;
static void entry__compiler__define_static_multi__to_string_9(void);
static FRAME_INFO frame__compiler__define_static_multi__to_string_9 = {0, {}};
static NODE *string__2d7981f4e6282be1;
static void cont__compiler__define_static_multi__to_string_11(void);
static void cont__compiler__define_static_multi__to_string_12(void);
static NODE *func__compiler__define_dynamic_single__to_string_1;
static void entry__compiler__define_dynamic_single__to_string_1(void);
static FRAME_INFO frame__compiler__define_dynamic_single__to_string_1 = {1, {"self"}};
static NODE *string__578a5af303e9cc4;
static NODE *func__compiler__define_dynamic_multi__to_string_1;
static void entry__compiler__define_dynamic_multi__to_string_1(void);
static FRAME_INFO frame__compiler__define_dynamic_multi__to_string_1 = {1, {"self"}};
static NODE *string__2d7981f4e6202be0;
static NODE *func__precedence_of_1;
static void entry__precedence_of_1(void);
static FRAME_INFO frame__precedence_of_1 = {1, {"expr"}};
static void cont__precedence_of_2(void);
static NODE *func__precedence_of_3;
static void entry__precedence_of_3(void);
static FRAME_INFO frame__precedence_of_3 = {1, {"expr"}};
static void cont__precedence_of_4(void);
static void cont__precedence_of_5(void);
static void cont__precedence_of_6(void);
static void cont__precedence_of_7(void);
static NODE *func__precedence_of_8;
static void entry__precedence_of_8(void);
static FRAME_INFO frame__precedence_of_8 = {1, {"expr"}};
static void cont__precedence_of_9(void);
static void cont__precedence_of_10(void);
static NODE *func__precedence_of_11;
static void entry__precedence_of_11(void);
static FRAME_INFO frame__precedence_of_11 = {1, {"expr"}};
static void cont__precedence_of_12(void);
static void cont__precedence_of_13(void);
static void cont__precedence_of_14(void);
static NODE *func__precedence_of_15;
static void entry__precedence_of_15(void);
static FRAME_INFO frame__precedence_of_15 = {1, {"expr"}};
static void cont__precedence_of_16(void);
static NODE *func__precedence_of_17;
static void entry__precedence_of_17(void);
static FRAME_INFO frame__precedence_of_17 = {0, {}};
static NODE *func__precedence_of_18;
static void entry__precedence_of_18(void);
static FRAME_INFO frame__precedence_of_18 = {0, {}};
static NODE *func__precedence_of_19;
static void entry__precedence_of_19(void);
static FRAME_INFO frame__precedence_of_19 = {0, {}};
static NODE *func__operator_of_1;
static void entry__operator_of_1(void);
static FRAME_INFO frame__operator_of_1 = {1, {"expr"}};
static void cont__operator_of_2(void);
static NODE *func__operator_of_3;
static void entry__operator_of_3(void);
static FRAME_INFO frame__operator_of_3 = {1, {"expr"}};
static void cont__operator_of_4(void);
static void cont__operator_of_5(void);
static void cont__operator_of_6(void);
static NODE *func__operator_of_7;
static void entry__operator_of_7(void);
static FRAME_INFO frame__operator_of_7 = {1, {"expr"}};
static void cont__operator_of_8(void);
static void cont__operator_of_9(void);
static void cont__operator_of_10(void);
static void cont__operator_of_11(void);
static NODE *func__operator_of_12;
static void entry__operator_of_12(void);
static FRAME_INFO frame__operator_of_12 = {1, {"expr"}};
static void cont__operator_of_13(void);
static void cont__operator_of_14(void);
static NODE *func__operator_of_15;
static void entry__operator_of_15(void);
static FRAME_INFO frame__operator_of_15 = {0, {}};
static NODE *func__compiler__function_call__to_string_1;
static void entry__compiler__function_call__to_string_1(void);
static FRAME_INFO frame__compiler__function_call__to_string_1 = {6, {"self", "indent", "functor", "functor_string", "default_call", "arguments"}};
static NODE *func__compiler__function_call__to_string_2;
static void entry__compiler__function_call__to_string_2(void);
static FRAME_INFO frame__compiler__function_call__to_string_2 = {5, {"return__2", "indent", "self", "functor_string", "arguments_string"}};
static void cont__compiler__function_call__to_string_3(void);
static void cont__compiler__function_call__to_string_4(void);
static void cont__compiler__function_call__to_string_5(void);
static void cont__compiler__function_call__to_string_6(void);
static void cont__compiler__function_call__to_string_7(void);
static void cont__compiler__function_call__to_string_8(void);
static void cont__compiler__function_call__to_string_9(void);
static NODE *func__compiler__function_call__to_string_10;
static void entry__compiler__function_call__to_string_10(void);
static FRAME_INFO frame__compiler__function_call__to_string_10 = {3, {"indent", "functor_string", "arguments_string"}};
static void cont__compiler__function_call__to_string_11(void);
static void cont__compiler__function_call__to_string_12(void);
static NODE *func__compiler__function_call__to_string_13;
static void entry__compiler__function_call__to_string_13(void);
static FRAME_INFO frame__compiler__function_call__to_string_13 = {2, {"functor_string", "arguments_string"}};
static void cont__compiler__function_call__to_string_14(void);
static void cont__compiler__function_call__to_string_15(void);
static void cont__compiler__function_call__to_string_16(void);
static void cont__compiler__function_call__to_string_17(void);
static NODE *func__compiler__function_call__to_string_18;
static void entry__compiler__function_call__to_string_18(void);
static FRAME_INFO frame__compiler__function_call__to_string_18 = {2, {"return__1", "self"}};
static void cont__compiler__function_call__to_string_19(void);
static void cont__compiler__function_call__to_string_20(void);
static NODE *func__compiler__function_call__to_string_21;
static void entry__compiler__function_call__to_string_21(void);
static FRAME_INFO frame__compiler__function_call__to_string_21 = {0, {}};
static void cont__compiler__function_call__to_string_22(void);
static void cont__compiler__function_call__to_string_23(void);
static NODE *func__compiler__function_call__to_string_24;
static void entry__compiler__function_call__to_string_24(void);
static FRAME_INFO frame__compiler__function_call__to_string_24 = {3, {"self", "arguments", "functor_string"}};
static void cont__compiler__function_call__to_string_25(void);
static NODE *func__compiler__function_call__to_string_26;
static void entry__compiler__function_call__to_string_26(void);
static FRAME_INFO frame__compiler__function_call__to_string_26 = {4, {"return__3", "arguments", "functor_string", "argument"}};
static void cont__compiler__function_call__to_string_27(void);
static void cont__compiler__function_call__to_string_28(void);
static NODE *func__compiler__function_call__to_string_29;
static void entry__compiler__function_call__to_string_29(void);
static FRAME_INFO frame__compiler__function_call__to_string_29 = {2, {"argument", "functor_string"}};
static void cont__compiler__function_call__to_string_30(void);
static NODE *func__compiler__function_call__to_string_31;
static void entry__compiler__function_call__to_string_31(void);
static FRAME_INFO frame__compiler__function_call__to_string_31 = {1, {"argument"}};
static void cont__compiler__function_call__to_string_32(void);
static void cont__compiler__function_call__to_string_33(void);
static NODE *func__compiler__function_call__to_string_34;
static void entry__compiler__function_call__to_string_34(void);
static FRAME_INFO frame__compiler__function_call__to_string_34 = {3, {"self", "arguments", "functor_string"}};
static void cont__compiler__function_call__to_string_35(void);
static NODE *func__compiler__function_call__to_string_36;
static void entry__compiler__function_call__to_string_36(void);
static FRAME_INFO frame__compiler__function_call__to_string_36 = {3, {"arguments", "functor_string", "argument"}};
static void cont__compiler__function_call__to_string_37(void);
static void cont__compiler__function_call__to_string_38(void);
static void cont__compiler__function_call__to_string_39(void);
static NODE *func__compiler__function_call__to_string_40;
static void entry__compiler__function_call__to_string_40(void);
static FRAME_INFO frame__compiler__function_call__to_string_40 = {1, {"argument"}};
static void cont__compiler__function_call__to_string_41(void);
static void cont__compiler__function_call__to_string_42(void);
static void cont__compiler__function_call__to_string_43(void);
static NODE *func__compiler__function_call__to_string_44;
static void entry__compiler__function_call__to_string_44(void);
static FRAME_INFO frame__compiler__function_call__to_string_44 = {5, {"functor_string", "self", "arguments", "default_call", "functor"}};
static void cont__compiler__function_call__to_string_45(void);
static NODE *func__compiler__function_call__to_string_46;
static void entry__compiler__function_call__to_string_46(void);
static FRAME_INFO frame__compiler__function_call__to_string_46 = {5, {"self", "arguments", "functor_string", "default_call", "functor"}};
static NODE *func__compiler__function_call__to_string_47;
static void entry__compiler__function_call__to_string_47(void);
static FRAME_INFO frame__compiler__function_call__to_string_47 = {4, {"self", "arguments", "functor_string", "default_call"}};
static void cont__compiler__function_call__to_string_48(void);
static NODE *func__compiler__function_call__to_string_49;
static void entry__compiler__function_call__to_string_49(void);
static FRAME_INFO frame__compiler__function_call__to_string_49 = {8, {"arguments", "functor_string", "default_call", "left_argument", "right_argument", "left", "right", "length"}};
static void cont__compiler__function_call__to_string_50(void);
static void cont__compiler__function_call__to_string_51(void);
static void cont__compiler__function_call__to_string_52(void);
static void cont__compiler__function_call__to_string_53(void);
static void cont__compiler__function_call__to_string_54(void);
static void cont__compiler__function_call__to_string_55(void);
static NODE *func__compiler__function_call__to_string_56;
static void entry__compiler__function_call__to_string_56(void);
static FRAME_INFO frame__compiler__function_call__to_string_56 = {1, {"left"}};
static void cont__compiler__function_call__to_string_57(void);
static void cont__compiler__function_call__to_string_58(void);
static void cont__compiler__function_call__to_string_59(void);
static void cont__compiler__function_call__to_string_60(void);
static void cont__compiler__function_call__to_string_61(void);
static NODE *func__compiler__function_call__to_string_62;
static void entry__compiler__function_call__to_string_62(void);
static FRAME_INFO frame__compiler__function_call__to_string_62 = {1, {"right"}};
static void cont__compiler__function_call__to_string_63(void);
static void cont__compiler__function_call__to_string_64(void);
static void cont__compiler__function_call__to_string_65(void);
static void cont__compiler__function_call__to_string_66(void);
static void cont__compiler__function_call__to_string_67(void);
static void cont__compiler__function_call__to_string_68(void);
static void cont__compiler__function_call__to_string_69(void);
static void cont__compiler__function_call__to_string_70(void);
static void cont__compiler__function_call__to_string_71(void);
static void cont__compiler__function_call__to_string_72(void);
static void cont__compiler__function_call__to_string_73(void);
static NODE *func__compiler__function_call__to_string_74;
static void entry__compiler__function_call__to_string_74(void);
static FRAME_INFO frame__compiler__function_call__to_string_74 = {3, {"left", "functor_string", "right"}};
static NODE *string__2d7981f4e6082beb;
static NODE *string__2d7981f4e6782be5;
static void cont__compiler__function_call__to_string_77(void);
static NODE *func__compiler__function_call__to_string_78;
static void entry__compiler__function_call__to_string_78(void);
static FRAME_INFO frame__compiler__function_call__to_string_78 = {1, {"self"}};
static void cont__compiler__function_call__to_string_79(void);
static NODE *func__compiler__function_call__to_string_80;
static void entry__compiler__function_call__to_string_80(void);
static FRAME_INFO frame__compiler__function_call__to_string_80 = {1, {"self"}};
static void cont__compiler__function_call__to_string_81(void);
static NODE *func__compiler__function_call__to_string_82;
static void entry__compiler__function_call__to_string_82(void);
static FRAME_INFO frame__compiler__function_call__to_string_82 = {2, {"functor", "arguments"}};
static void cont__compiler__function_call__to_string_83(void);
static NODE *func__compiler__function_call__to_string_84;
static void entry__compiler__function_call__to_string_84(void);
static FRAME_INFO frame__compiler__function_call__to_string_84 = {2, {"functor", "arguments"}};
static void cont__compiler__function_call__to_string_85(void);
static NODE *string__fa724815d896ba8;
static void cont__compiler__function_call__to_string_87(void);
static NODE *func__compiler__function_call__to_string_88;
static void entry__compiler__function_call__to_string_88(void);
static FRAME_INFO frame__compiler__function_call__to_string_88 = {2, {"functor", "arguments"}};
static void cont__compiler__function_call__to_string_89(void);
static NODE *string__64d512703527e2ab;
static void cont__compiler__function_call__to_string_91(void);
static NODE *func__compiler__function_call__to_string_92;
static void entry__compiler__function_call__to_string_92(void);
static FRAME_INFO frame__compiler__function_call__to_string_92 = {1, {"arguments"}};
static void cont__compiler__function_call__to_string_93(void);
static void cont__compiler__function_call__to_string_94(void);
static NODE *func__compiler__function_call__to_string_95;
static void entry__compiler__function_call__to_string_95(void);
static FRAME_INFO frame__compiler__function_call__to_string_95 = {1, {"arguments"}};
static void cont__compiler__function_call__to_string_96(void);
static void cont__compiler__function_call__to_string_97(void);
static NODE *func__compiler__function_call__to_string_98;
static void entry__compiler__function_call__to_string_98(void);
static FRAME_INFO frame__compiler__function_call__to_string_98 = {1, {"arguments"}};
static void cont__compiler__function_call__to_string_99(void);
static void cont__compiler__function_call__to_string_100(void);
static NODE *func__compiler__function_call__to_string_101;
static void entry__compiler__function_call__to_string_101(void);
static FRAME_INFO frame__compiler__function_call__to_string_101 = {1, {"arguments"}};
static void cont__compiler__function_call__to_string_102(void);
static void cont__compiler__function_call__to_string_103(void);
static void cont__compiler__function_call__to_string_104(void);
static NODE *func__compiler__function_call__to_string_105;
static void entry__compiler__function_call__to_string_105(void);
static FRAME_INFO frame__compiler__function_call__to_string_105 = {1, {"arguments"}};
static void cont__compiler__function_call__to_string_106(void);
static void cont__compiler__function_call__to_string_107(void);
static NODE *string__2a0aedcb5dc87d5c;
static void cont__compiler__function_call__to_string_109(void);
static void cont__compiler__function_call__to_string_110(void);
static void cont__compiler__function_call__to_string_111(void);
static void cont__compiler__function_call__to_string_112(void);
static void cont__compiler__function_call__to_string_113(void);
static void cont__compiler__function_call__to_string_114(void);
static void cont__compiler__function_call__to_string_115(void);
static void cont__compiler__function_call__to_string_116(void);
static NODE *func__compiler__function_call__to_string_117;
static void entry__compiler__function_call__to_string_117(void);
static FRAME_INFO frame__compiler__function_call__to_string_117 = {1, {"arguments"}};
static void cont__compiler__function_call__to_string_118(void);
static NODE *string__2d7981f4e6602be8;
static void cont__compiler__function_call__to_string_120(void);
static NODE *func__compiler__function_call__to_string_121;
static void entry__compiler__function_call__to_string_121(void);
static FRAME_INFO frame__compiler__function_call__to_string_121 = {1, {"default_call"}};
static NODE *func__compiler__function_call__to_string_122;
static void entry__compiler__function_call__to_string_122(void);
static FRAME_INFO frame__compiler__function_call__to_string_122 = {3, {"indent", "arguments", "functor_string"}};
static NODE *func__compiler__function_call__to_string_123;
static void entry__compiler__function_call__to_string_123(void);
static FRAME_INFO frame__compiler__function_call__to_string_123 = {4, {"return__5", "indent", "arguments", "functor_string"}};
static void cont__compiler__function_call__to_string_124(void);
static void cont__compiler__function_call__to_string_125(void);
static void cont__compiler__function_call__to_string_126(void);
static NODE *func__compiler__function_call__to_string_127;
static void entry__compiler__function_call__to_string_127(void);
static FRAME_INFO frame__compiler__function_call__to_string_127 = {3, {"arguments", "functor_string", "argument"}};
static void cont__compiler__function_call__to_string_128(void);
static void cont__compiler__function_call__to_string_129(void);
static void cont__compiler__function_call__to_string_130(void);
static NODE *func__compiler__function_call__to_string_131;
static void entry__compiler__function_call__to_string_131(void);
static FRAME_INFO frame__compiler__function_call__to_string_131 = {2, {"functor_string", "argument"}};
static void cont__compiler__function_call__to_string_132(void);
static NODE *func__compiler__function_call__to_string_133;
static void entry__compiler__function_call__to_string_133(void);
static FRAME_INFO frame__compiler__function_call__to_string_133 = {2, {"functor_string", "argument"}};
static void cont__compiler__function_call__to_string_134(void);
static NODE *func__compiler__function_call__to_string_135;
static void entry__compiler__function_call__to_string_135(void);
static FRAME_INFO frame__compiler__function_call__to_string_135 = {13, {"return__4", "functor_string", "arguments", "indent", "prec", "left", "right", "stringify_le", "stringify_lt", "strings", "inline_functor", "total_width", "buf"}};
static NODE *func__compiler__function_call__to_string_136;
static void entry__compiler__function_call__to_string_136(void);
static FRAME_INFO frame__compiler__function_call__to_string_136 = {3, {"expr", "prec", "str"}};
static void cont__compiler__function_call__to_string_137(void);
static void cont__compiler__function_call__to_string_138(void);
static void cont__compiler__function_call__to_string_139(void);
static void cont__compiler__function_call__to_string_140(void);
static NODE *func__compiler__function_call__to_string_141;
static void entry__compiler__function_call__to_string_141(void);
static FRAME_INFO frame__compiler__function_call__to_string_141 = {1, {"str"}};
static NODE *func__compiler__function_call__to_string_142;
static void entry__compiler__function_call__to_string_142(void);
static FRAME_INFO frame__compiler__function_call__to_string_142 = {1, {"str"}};
static NODE *func__compiler__function_call__to_string_143;
static void entry__compiler__function_call__to_string_143(void);
static FRAME_INFO frame__compiler__function_call__to_string_143 = {3, {"expr", "prec", "str"}};
static void cont__compiler__function_call__to_string_144(void);
static void cont__compiler__function_call__to_string_145(void);
static void cont__compiler__function_call__to_string_146(void);
static NODE *func__compiler__function_call__to_string_147;
static void entry__compiler__function_call__to_string_147(void);
static FRAME_INFO frame__compiler__function_call__to_string_147 = {1, {"str"}};
static NODE *func__compiler__function_call__to_string_148;
static void entry__compiler__function_call__to_string_148(void);
static FRAME_INFO frame__compiler__function_call__to_string_148 = {1, {"str"}};
static void cont__compiler__function_call__to_string_149(void);
static void cont__compiler__function_call__to_string_150(void);
static void cont__compiler__function_call__to_string_151(void);
static void cont__compiler__function_call__to_string_152(void);
static NODE *func__compiler__function_call__to_string_153;
static void entry__compiler__function_call__to_string_153(void);
static FRAME_INFO frame__compiler__function_call__to_string_153 = {6, {"strings", "stringify_le", "right", "left", "functor_string", "stringify_lt"}};
static void cont__compiler__function_call__to_string_154(void);
static void cont__compiler__function_call__to_string_155(void);
static NODE *func__compiler__function_call__to_string_156;
static void entry__compiler__function_call__to_string_156(void);
static FRAME_INFO frame__compiler__function_call__to_string_156 = {4, {"left", "functor_string", "strings", "stringify_le"}};
static void cont__compiler__function_call__to_string_157(void);
static void cont__compiler__function_call__to_string_158(void);
static NODE *func__compiler__function_call__to_string_159;
static void entry__compiler__function_call__to_string_159(void);
static FRAME_INFO frame__compiler__function_call__to_string_159 = {4, {"left", "strings", "stringify_le", "left_operands"}};
static void cont__compiler__function_call__to_string_160(void);
static void cont__compiler__function_call__to_string_161(void);
static void cont__compiler__function_call__to_string_162(void);
static void cont__compiler__function_call__to_string_163(void);
static void cont__compiler__function_call__to_string_164(void);
static void cont__compiler__function_call__to_string_165(void);
static void cont__compiler__function_call__to_string_166(void);
static void cont__compiler__function_call__to_string_167(void);
static NODE *func__compiler__function_call__to_string_168;
static void entry__compiler__function_call__to_string_168(void);
static FRAME_INFO frame__compiler__function_call__to_string_168 = {6, {"strings", "stringify_le", "left", "right", "functor_string", "stringify_lt"}};
static void cont__compiler__function_call__to_string_169(void);
static void cont__compiler__function_call__to_string_170(void);
static NODE *func__compiler__function_call__to_string_171;
static void entry__compiler__function_call__to_string_171(void);
static FRAME_INFO frame__compiler__function_call__to_string_171 = {4, {"right", "functor_string", "strings", "stringify_le"}};
static void cont__compiler__function_call__to_string_172(void);
static void cont__compiler__function_call__to_string_173(void);
static NODE *func__compiler__function_call__to_string_174;
static void entry__compiler__function_call__to_string_174(void);
static FRAME_INFO frame__compiler__function_call__to_string_174 = {4, {"right", "strings", "stringify_le", "right_operands"}};
static void cont__compiler__function_call__to_string_175(void);
static void cont__compiler__function_call__to_string_176(void);
static void cont__compiler__function_call__to_string_177(void);
static void cont__compiler__function_call__to_string_178(void);
static void cont__compiler__function_call__to_string_179(void);
static void cont__compiler__function_call__to_string_180(void);
static void cont__compiler__function_call__to_string_181(void);
static void cont__compiler__function_call__to_string_182(void);
static void cont__compiler__function_call__to_string_183(void);
static NODE *func__compiler__function_call__to_string_184;
static void entry__compiler__function_call__to_string_184(void);
static FRAME_INFO frame__compiler__function_call__to_string_184 = {3, {"break", "strings", "total_width"}};
static NODE *func__compiler__function_call__to_string_185;
static void entry__compiler__function_call__to_string_185(void);
static FRAME_INFO frame__compiler__function_call__to_string_185 = {3, {"str", "total_width", "break"}};
static void cont__compiler__function_call__to_string_186(void);
static void cont__compiler__function_call__to_string_187(void);
static NODE *func__compiler__function_call__to_string_188;
static void entry__compiler__function_call__to_string_188(void);
static FRAME_INFO frame__compiler__function_call__to_string_188 = {2, {"total_width", "break"}};
static void cont__compiler__function_call__to_string_189(void);
static void cont__compiler__function_call__to_string_190(void);
static void cont__compiler__function_call__to_string_191(void);
static void cont__compiler__function_call__to_string_192(void);
static NODE *func__compiler__function_call__to_string_193;
static void entry__compiler__function_call__to_string_193(void);
static FRAME_INFO frame__compiler__function_call__to_string_193 = {1, {"total_width"}};
static void cont__compiler__function_call__to_string_194(void);
static void cont__compiler__function_call__to_string_195(void);
static void cont__compiler__function_call__to_string_196(void);
static void cont__compiler__function_call__to_string_197(void);
static NODE *func__compiler__function_call__to_string_198;
static void entry__compiler__function_call__to_string_198(void);
static FRAME_INFO frame__compiler__function_call__to_string_198 = {5, {"inline_functor", "functor_string", "total_width", "strings", "indent"}};
static NODE *string__578a5af303e9cca;
static NODE *string__578a5af303e9ccc;
static NODE *string__578a5af303e9ccb;
static NODE *string__578a5af303e9cce;
static void cont__compiler__function_call__to_string_203(void);
static NODE *func__compiler__function_call__to_string_204;
static void entry__compiler__function_call__to_string_204(void);
static FRAME_INFO frame__compiler__function_call__to_string_204 = {1, {"functor_string"}};
static NODE *func__compiler__function_call__to_string_205;
static void entry__compiler__function_call__to_string_205(void);
static FRAME_INFO frame__compiler__function_call__to_string_205 = {1, {"functor_string"}};
static void cont__compiler__function_call__to_string_206(void);
static NODE *func__compiler__function_call__to_string_207;
static void entry__compiler__function_call__to_string_207(void);
static FRAME_INFO frame__compiler__function_call__to_string_207 = {1, {"functor_string"}};
static void cont__compiler__function_call__to_string_208(void);
static NODE *string__578a5af303e9ccd;
static void cont__compiler__function_call__to_string_210(void);
static void cont__compiler__function_call__to_string_211(void);
static void cont__compiler__function_call__to_string_212(void);
static void cont__compiler__function_call__to_string_213(void);
static void cont__compiler__function_call__to_string_214(void);
static void cont__compiler__function_call__to_string_215(void);
static void cont__compiler__function_call__to_string_216(void);
static void cont__compiler__function_call__to_string_217(void);
static NODE *func__compiler__function_call__to_string_218;
static void entry__compiler__function_call__to_string_218(void);
static FRAME_INFO frame__compiler__function_call__to_string_218 = {1, {"total_width"}};
static void cont__compiler__function_call__to_string_219(void);
static void cont__compiler__function_call__to_string_220(void);
static NODE *func__compiler__function_call__to_string_221;
static void entry__compiler__function_call__to_string_221(void);
static FRAME_INFO frame__compiler__function_call__to_string_221 = {3, {"strings", "buf", "inline_functor"}};
static NODE *func__compiler__function_call__to_string_222;
static void entry__compiler__function_call__to_string_222(void);
static FRAME_INFO frame__compiler__function_call__to_string_222 = {2, {"str", "buf"}};
static void cont__compiler__function_call__to_string_223(void);
static NODE *func__compiler__function_call__to_string_224;
static void entry__compiler__function_call__to_string_224(void);
static FRAME_INFO frame__compiler__function_call__to_string_224 = {1, {"buf"}};
static void cont__compiler__function_call__to_string_225(void);
static void cont__compiler__function_call__to_string_226(void);
static void cont__compiler__function_call__to_string_227(void);
static void cont__compiler__function_call__to_string_228(void);
static NODE *func__compiler__function_call__to_string_229;
static void entry__compiler__function_call__to_string_229(void);
static FRAME_INFO frame__compiler__function_call__to_string_229 = {1, {"buf"}};
static void cont__compiler__function_call__to_string_230(void);
static NODE *func__compiler__function_call__to_string_231;
static void entry__compiler__function_call__to_string_231(void);
static FRAME_INFO frame__compiler__function_call__to_string_231 = {2, {"buf", "inline_functor"}};
static void cont__compiler__function_call__to_string_232(void);
static NODE *func__compiler__function_call__to_string_233;
static void entry__compiler__function_call__to_string_233(void);
static FRAME_INFO frame__compiler__function_call__to_string_233 = {5, {"functor_string", "buf", "indent", "strings", "indentation"}};
static NODE *func__compiler__function_call__to_string_234;
static void entry__compiler__function_call__to_string_234(void);
static FRAME_INFO frame__compiler__function_call__to_string_234 = {1, {"functor_string"}};
static NODE *string__6480ae5e84ccc225;
static void cont__compiler__function_call__to_string_236(void);
static void cont__compiler__function_call__to_string_237(void);
static void cont__compiler__function_call__to_string_238(void);
static void cont__compiler__function_call__to_string_239(void);
static NODE *func__compiler__function_call__to_string_240;
static void entry__compiler__function_call__to_string_240(void);
static FRAME_INFO frame__compiler__function_call__to_string_240 = {3, {"str", "buf", "indentation"}};
static void cont__compiler__function_call__to_string_241(void);
static void cont__compiler__function_call__to_string_242(void);
static NODE *func__compiler__function_call__to_string_243;
static void entry__compiler__function_call__to_string_243(void);
static FRAME_INFO frame__compiler__function_call__to_string_243 = {2, {"buf", "indentation"}};
static void cont__compiler__function_call__to_string_244(void);
static void cont__compiler__function_call__to_string_245(void);
static void cont__compiler__function_call__to_string_246(void);
static void cont__compiler__function_call__to_string_247(void);
static void cont__compiler__function_call__to_string_248(void);
static void cont__compiler__function_call__to_string_249(void);
static NODE *func__compiler__remark_argument__to_string_1;
static void entry__compiler__remark_argument__to_string_1(void);
static FRAME_INFO frame__compiler__remark_argument__to_string_1 = {2, {"self", "remark_lines"}};
static void cont__compiler__remark_argument__to_string_2(void);
static void cont__compiler__remark_argument__to_string_3(void);
static void cont__compiler__remark_argument__to_string_4(void);
static NODE *func__compiler__remark_argument__to_string_5;
static void entry__compiler__remark_argument__to_string_5(void);
static FRAME_INFO frame__compiler__remark_argument__to_string_5 = {3, {"remark_lines", "buf", "indentation"}};
static void cont__compiler__remark_argument__to_string_6(void);
static void cont__compiler__remark_argument__to_string_7(void);
static void cont__compiler__remark_argument__to_string_8(void);
static void cont__compiler__remark_argument__to_string_9(void);
static void cont__compiler__remark_argument__to_string_10(void);
static void cont__compiler__remark_argument__to_string_11(void);
static NODE *func__compiler__remark_argument__to_string_12;
static void entry__compiler__remark_argument__to_string_12(void);
static FRAME_INFO frame__compiler__remark_argument__to_string_12 = {3, {"remark_line", "buf", "indentation"}};
static void cont__compiler__remark_argument__to_string_13(void);
static void cont__compiler__remark_argument__to_string_14(void);
static NODE *func__compiler__remark_argument__to_string_15;
static void entry__compiler__remark_argument__to_string_15(void);
static FRAME_INFO frame__compiler__remark_argument__to_string_15 = {1, {"remark_lines"}};
static void cont__compiler__remark_argument__to_string_16(void);
static void cont__compiler__remark_argument__to_string_17(void);
static NODE *func__compiler__backquoted__to_string_1;
static void entry__compiler__backquoted__to_string_1(void);
static FRAME_INFO frame__compiler__backquoted__to_string_1 = {1, {"self"}};
static void cont__compiler__backquoted__to_string_2(void);
static void cont__compiler__backquoted__to_string_3(void);
static NODE *func__pair_to_string_1;
static void entry__pair_to_string_1(void);
static FRAME_INFO frame__pair_to_string_1 = {3, {"self", "symbol", "indent"}};
static NODE *func__pair_to_string_2;
static void entry__pair_to_string_2(void);
static FRAME_INFO frame__pair_to_string_2 = {7, {"return__1", "indent", "self", "symbol", "identifier", "arguments", "pair"}};
static void cont__pair_to_string_3(void);
static void cont__pair_to_string_4(void);
static void cont__pair_to_string_5(void);
static void cont__pair_to_string_6(void);
static void cont__pair_to_string_7(void);
static void cont__pair_to_string_8(void);
static void cont__pair_to_string_9(void);
static void cont__pair_to_string_10(void);
static void cont__pair_to_string_11(void);
static void cont__pair_to_string_12(void);
static void cont__pair_to_string_13(void);
static void cont__pair_to_string_14(void);
static NODE *func__pair_to_string_15;
static void entry__pair_to_string_15(void);
static FRAME_INFO frame__pair_to_string_15 = {2, {"indent", "pair"}};
static void cont__pair_to_string_16(void);
static void cont__pair_to_string_17(void);
static NODE *func__pair_to_string_18;
static void entry__pair_to_string_18(void);
static FRAME_INFO frame__pair_to_string_18 = {1, {"pair"}};
static void cont__pair_to_string_19(void);
static NODE *func__compiler__attribute_value_pair__to_string_1;
static void entry__compiler__attribute_value_pair__to_string_1(void);
static FRAME_INFO frame__compiler__attribute_value_pair__to_string_1 = {1, {"self"}};
static NODE *func__compiler__attribute_function_pair__to_string_1;
static void entry__compiler__attribute_function_pair__to_string_1(void);
static FRAME_INFO frame__compiler__attribute_function_pair__to_string_1 = {1, {"self"}};
static NODE *func__compiler__numeric_literal__to_string_1;
static void entry__compiler__numeric_literal__to_string_1(void);
static FRAME_INFO frame__compiler__numeric_literal__to_string_1 = {1, {"self"}};
static void cont__compiler__numeric_literal__to_string_2(void);
static NODE *func__create_character_table_1;
static void entry__create_character_table_1(void);
static FRAME_INFO frame__create_character_table_1 = {0, {}};
static NODE *func__create_character_table_2;
static void entry__create_character_table_2(void);
static FRAME_INFO frame__create_character_table_2 = {2, {"name", "chr"}};
static void cont__create_character_table_3(void);
static NODE *func__create_character_table_4;
static void entry__create_character_table_4(void);
static FRAME_INFO frame__create_character_table_4 = {1, {"chr"}};
static void cont__create_character_table_5(void);
static void cont__create_character_table_6(void);
static NODE *func__create_character_table_7;
static void entry__create_character_table_7(void);
static FRAME_INFO frame__create_character_table_7 = {2, {"chr", "name"}};
static void cont__create_character_table_8(void);
static void cont__create_character_table_9(void);
static void cont__create_character_table_10(void);
static NODE *func__escaped_character_1;
static void entry__escaped_character_1(void);
static FRAME_INFO frame__escaped_character_1 = {3, {"chr", "use_numerical_encoding", "numerical_encoding"}};
static NODE *func__escaped_character_2;
static void entry__escaped_character_2(void);
static FRAME_INFO frame__escaped_character_2 = {1, {"chr"}};
static void cont__escaped_character_3(void);
static void cont__escaped_character_4(void);
static NODE *string__fa728415fa96bb4;
static void cont__escaped_character_6(void);
static NODE *func__escaped_character_7;
static void entry__escaped_character_7(void);
static FRAME_INFO frame__escaped_character_7 = {1, {"numerical_encoding"}};
static void cont__escaped_character_8(void);
static NODE *func__escaped_character_9;
static void entry__escaped_character_9(void);
static FRAME_INFO frame__escaped_character_9 = {3, {"chr", "numerical_encoding", "name"}};
static void cont__escaped_character_10(void);
static void cont__escaped_character_11(void);
static void cont__escaped_character_12(void);
static void cont__escaped_character_13(void);
static NODE *func__escaped_character_14;
static void entry__escaped_character_14(void);
static FRAME_INFO frame__escaped_character_14 = {1, {"name"}};
static NODE *func__escaped_character_15;
static void entry__escaped_character_15(void);
static FRAME_INFO frame__escaped_character_15 = {1, {"name"}};
static void cont__escaped_character_16(void);
static NODE *string__2d7981f4e4002bb1;
static NODE *func__escaped_character_18;
static void entry__escaped_character_18(void);
static FRAME_INFO frame__escaped_character_18 = {0, {}};
static NODE *string__2d7981f4e5082b85;
static NODE *string__fa720015d416bbc;
static NODE *func__escaped_character_21;
static void entry__escaped_character_21(void);
static FRAME_INFO frame__escaped_character_21 = {0, {}};
static NODE *func__escaped_character_22;
static void entry__escaped_character_22(void);
static FRAME_INFO frame__escaped_character_22 = {2, {"chr", "numerical_encoding"}};
static void cont__escaped_character_23(void);
static void cont__escaped_character_24(void);
static NODE *func__escaped_character_25;
static void entry__escaped_character_25(void);
static FRAME_INFO frame__escaped_character_25 = {1, {"chr"}};
static void cont__escaped_character_26(void);
static void cont__escaped_character_27(void);
static NODE *func__escaped_character_28;
static void entry__escaped_character_28(void);
static FRAME_INFO frame__escaped_character_28 = {1, {"chr"}};
static void cont__escaped_character_29(void);
static void cont__escaped_character_30(void);
static void cont__escaped_character_31(void);
static void cont__escaped_character_32(void);
static NODE *func__escaped_character_33;
static void entry__escaped_character_33(void);
static FRAME_INFO frame__escaped_character_33 = {1, {"numerical_encoding"}};
static void cont__escaped_character_34(void);
static NODE *func__escaped_character_35;
static void entry__escaped_character_35(void);
static FRAME_INFO frame__escaped_character_35 = {1, {"chr"}};
static void cont__escaped_character_36(void);
static NODE *func__compiler__character_literal__to_string_1;
static void entry__compiler__character_literal__to_string_1(void);
static FRAME_INFO frame__compiler__character_literal__to_string_1 = {1, {"self"}};
static void cont__compiler__character_literal__to_string_2(void);
static void cont__compiler__character_literal__to_string_3(void);
static void cont__compiler__character_literal__to_string_4(void);
static NODE *func__analyze_string_literal_1;
static void entry__analyze_string_literal_1(void);
static FRAME_INFO frame__analyze_string_literal_1 = {7, {"text", "return", "lines", "is_inline", "use_single_line_form", "part", "s"}};
static void exit__analyze_string_literal_1(void);
static void cont__analyze_string_literal_2(void);
static NODE *func__analyze_string_literal_3;
static void entry__analyze_string_literal_3(void);
static FRAME_INFO frame__analyze_string_literal_3 = {2, {"lines", "return"}};
static void cont__analyze_string_literal_4(void);
static void cont__analyze_string_literal_5(void);
static void cont__analyze_string_literal_6(void);
static void cont__analyze_string_literal_7(void);
static NODE *func__analyze_string_literal_8;
static void entry__analyze_string_literal_8(void);
static FRAME_INFO frame__analyze_string_literal_8 = {3, {"lines", "text", "return"}};
static void cont__analyze_string_literal_9(void);
static NODE *string__420aeacb5d007d02;
static void cont__analyze_string_literal_11(void);
static void cont__analyze_string_literal_12(void);
static void cont__analyze_string_literal_13(void);
static void cont__analyze_string_literal_14(void);
static NODE *func__analyze_string_literal_15;
static void entry__analyze_string_literal_15(void);
static FRAME_INFO frame__analyze_string_literal_15 = {1, {"text"}};
static void cont__analyze_string_literal_16(void);
static void cont__analyze_string_literal_17(void);
static void cont__analyze_string_literal_18(void);
static void cont__analyze_string_literal_19(void);
static NODE *func__analyze_string_literal_20;
static void entry__analyze_string_literal_20(void);
static FRAME_INFO frame__analyze_string_literal_20 = {8, {"idx", "chr", "part", "text", "s", "use_single_line_form", "lines", "is_inline"}};
static NODE *func__analyze_string_literal_21;
static void entry__analyze_string_literal_21(void);
static FRAME_INFO frame__analyze_string_literal_21 = {6, {"part", "text", "s", "idx", "use_single_line_form", "lines"}};
static void cont__analyze_string_literal_22(void);
static void cont__analyze_string_literal_23(void);
static void cont__analyze_string_literal_24(void);
static NODE *func__analyze_string_literal_25;
static void entry__analyze_string_literal_25(void);
static FRAME_INFO frame__analyze_string_literal_25 = {1, {"part"}};
static void cont__analyze_string_literal_26(void);
static NODE *func__analyze_string_literal_27;
static void entry__analyze_string_literal_27(void);
static FRAME_INFO frame__analyze_string_literal_27 = {2, {"lines", "part"}};
static void cont__analyze_string_literal_28(void);
static void cont__analyze_string_literal_29(void);
static void cont__analyze_string_literal_30(void);
static NODE *func__analyze_string_literal_31;
static void entry__analyze_string_literal_31(void);
static FRAME_INFO frame__analyze_string_literal_31 = {6, {"use_single_line_form", "part", "text", "s", "idx", "is_inline"}};
static NODE *func__analyze_string_literal_32;
static void entry__analyze_string_literal_32(void);
static FRAME_INFO frame__analyze_string_literal_32 = {4, {"part", "text", "s", "idx"}};
static void cont__analyze_string_literal_33(void);
static void cont__analyze_string_literal_34(void);
static void cont__analyze_string_literal_35(void);
static NODE *string__721f5590811b42ec;
static void cont__analyze_string_literal_37(void);
static void cont__analyze_string_literal_38(void);
static NODE *func__analyze_string_literal_39;
static void entry__analyze_string_literal_39(void);
static FRAME_INFO frame__analyze_string_literal_39 = {1, {"is_inline"}};
static NODE *func__analyze_string_literal_40;
static void entry__analyze_string_literal_40(void);
static FRAME_INFO frame__analyze_string_literal_40 = {4, {"part", "text", "s", "idx"}};
static void cont__analyze_string_literal_41(void);
static void cont__analyze_string_literal_42(void);
static void cont__analyze_string_literal_43(void);
static void cont__analyze_string_literal_44(void);
static void cont__analyze_string_literal_45(void);
static NODE *func__analyze_string_literal_46;
static void entry__analyze_string_literal_46(void);
static FRAME_INFO frame__analyze_string_literal_46 = {6, {"chr", "part", "text", "s", "idx", "escaped"}};
static void cont__analyze_string_literal_47(void);
static void cont__analyze_string_literal_48(void);
static void cont__analyze_string_literal_49(void);
static NODE *func__analyze_string_literal_50;
static void entry__analyze_string_literal_50(void);
static FRAME_INFO frame__analyze_string_literal_50 = {5, {"part", "text", "s", "idx", "escaped"}};
static void cont__analyze_string_literal_51(void);
static void cont__analyze_string_literal_52(void);
static void cont__analyze_string_literal_53(void);
static void cont__analyze_string_literal_54(void);
static void cont__analyze_string_literal_55(void);
static void cont__analyze_string_literal_56(void);
static void cont__analyze_string_literal_57(void);
static void cont__analyze_string_literal_58(void);
static void cont__analyze_string_literal_59(void);
static void cont__analyze_string_literal_60(void);
static NODE *func__analyze_string_literal_61;
static void entry__analyze_string_literal_61(void);
static FRAME_INFO frame__analyze_string_literal_61 = {1, {"is_inline"}};
static NODE *func__analyze_string_literal_62;
static void entry__analyze_string_literal_62(void);
static FRAME_INFO frame__analyze_string_literal_62 = {4, {"lines", "part", "is_inline", "max_width"}};
static void cont__analyze_string_literal_63(void);
static void cont__analyze_string_literal_64(void);
static void cont__analyze_string_literal_65(void);
static void cont__analyze_string_literal_66(void);
static NODE *func__analyze_string_literal_67;
static void entry__analyze_string_literal_67(void);
static FRAME_INFO frame__analyze_string_literal_67 = {0, {}};
static NODE *func__analyze_string_literal_68;
static void entry__analyze_string_literal_68(void);
static FRAME_INFO frame__analyze_string_literal_68 = {0, {}};
static void cont__analyze_string_literal_69(void);
static void cont__analyze_string_literal_70(void);
static void cont__analyze_string_literal_71(void);
static NODE *func__analyze_string_literal_72;
static void entry__analyze_string_literal_72(void);
static FRAME_INFO frame__analyze_string_literal_72 = {2, {"max_width", "part"}};
static void cont__analyze_string_literal_73(void);
static void cont__analyze_string_literal_74(void);
static void cont__analyze_string_literal_75(void);
static void cont__analyze_string_literal_76(void);
static void cont__analyze_string_literal_77(void);
static NODE *func__analyze_string_literal_78;
static void entry__analyze_string_literal_78(void);
static FRAME_INFO frame__analyze_string_literal_78 = {1, {"is_inline"}};
static void cont__analyze_string_literal_79(void);
static NODE *func__analyze_string_literal_80;
static void entry__analyze_string_literal_80(void);
static FRAME_INFO frame__analyze_string_literal_80 = {2, {"lines", "part"}};
static void cont__analyze_string_literal_81(void);
static NODE *func__analyze_string_literal_82;
static void entry__analyze_string_literal_82(void);
static FRAME_INFO frame__analyze_string_literal_82 = {2, {"lines", "part"}};
static void cont__analyze_string_literal_83(void);
static void cont__analyze_string_literal_84(void);
static void cont__analyze_string_literal_85(void);
static NODE *func__print_string_literal_1;
static void entry__print_string_literal_1(void);
static FRAME_INFO frame__print_string_literal_1 = {2, {"lines", "is_inline"}};
static NODE *func__print_string_literal_2;
static void entry__print_string_literal_2(void);
static FRAME_INFO frame__print_string_literal_2 = {2, {"lines", "is_inline"}};
static void cont__print_string_literal_3(void);
static NODE *func__print_string_literal_4;
static void entry__print_string_literal_4(void);
static FRAME_INFO frame__print_string_literal_4 = {2, {"lines", "is_inline"}};
static void cont__print_string_literal_5(void);
static void cont__print_string_literal_6(void);
static void cont__print_string_literal_7(void);
static void cont__print_string_literal_8(void);
static void cont__print_string_literal_9(void);
static NODE *func__print_string_literal_10;
static void entry__print_string_literal_10(void);
static FRAME_INFO frame__print_string_literal_10 = {2, {"lines", "is_inline"}};
static void cont__print_string_literal_11(void);
static void cont__print_string_literal_12(void);
static void cont__print_string_literal_13(void);
static void cont__print_string_literal_14(void);
static NODE *func__print_string_literal_15;
static void entry__print_string_literal_15(void);
static FRAME_INFO frame__print_string_literal_15 = {1, {"lines"}};
static void cont__print_string_literal_16(void);
static void cont__print_string_literal_17(void);
static NODE *func__print_string_literal_18;
static void entry__print_string_literal_18(void);
static FRAME_INFO frame__print_string_literal_18 = {7, {"lines", "max_width", "has_leading_spaces", "split_lines", "buf", "indent", "indentation"}};
static void cont__print_string_literal_19(void);
static void cont__print_string_literal_20(void);
static void cont__print_string_literal_21(void);
static void cont__print_string_literal_22(void);
static NODE *func__print_string_literal_23;
static void entry__print_string_literal_23(void);
static FRAME_INFO frame__print_string_literal_23 = {0, {}};
static NODE *func__print_string_literal_24;
static void entry__print_string_literal_24(void);
static FRAME_INFO frame__print_string_literal_24 = {0, {}};
static void cont__print_string_literal_25(void);
static void cont__print_string_literal_26(void);
static void cont__print_string_literal_27(void);
static void cont__print_string_literal_28(void);
static void cont__print_string_literal_29(void);
static void cont__print_string_literal_30(void);
static NODE *func__print_string_literal_31;
static void entry__print_string_literal_31(void);
static FRAME_INFO frame__print_string_literal_31 = {4, {"line", "has_leading_spaces", "max_width", "split_lines"}};
static void cont__print_string_literal_32(void);
static void cont__print_string_literal_33(void);
static NODE *func__print_string_literal_34;
static void entry__print_string_literal_34(void);
static FRAME_INFO frame__print_string_literal_34 = {1, {"line"}};
static void cont__print_string_literal_35(void);
static void cont__print_string_literal_36(void);
static void cont__print_string_literal_37(void);
static void cont__print_string_literal_38(void);
static NODE *func__print_string_literal_39;
static void entry__print_string_literal_39(void);
static FRAME_INFO frame__print_string_literal_39 = {1, {"has_leading_spaces"}};
static void cont__print_string_literal_40(void);
static NODE *func__print_string_literal_41;
static void entry__print_string_literal_41(void);
static FRAME_INFO frame__print_string_literal_41 = {3, {"max_width", "line", "split_lines"}};
static void cont__print_string_literal_42(void);
static void cont__print_string_literal_43(void);
static NODE *func__print_string_literal_44;
static void entry__print_string_literal_44(void);
static FRAME_INFO frame__print_string_literal_44 = {9, {"line", "max_width", "split_lines", "skip_till_end_of_string", "skip_till_close", "skip_special", "best_split_pos", "last_valid_pos", "pos"}};
static NODE *func__print_string_literal_45;
static void entry__print_string_literal_45(void);
static FRAME_INFO frame__print_string_literal_45 = {3, {"pos", "line", "skip_special"}};
static NODE *func__print_string_literal_46;
static void entry__print_string_literal_46(void);
static FRAME_INFO frame__print_string_literal_46 = {3, {"pos", "line", "skip_special"}};
static void cont__print_string_literal_47(void);
static void cont__print_string_literal_48(void);
static void cont__print_string_literal_49(void);
static NODE *func__print_string_literal_50;
static void entry__print_string_literal_50(void);
static FRAME_INFO frame__print_string_literal_50 = {2, {"skip_special", "pos"}};
static void cont__print_string_literal_51(void);
static void cont__print_string_literal_52(void);
static void cont__print_string_literal_53(void);
static void cont__print_string_literal_54(void);
static void cont__print_string_literal_55(void);
static void cont__print_string_literal_56(void);
static NODE *func__print_string_literal_57;
static void entry__print_string_literal_57(void);
static FRAME_INFO frame__print_string_literal_57 = {4, {"pos", "line", "skip_till_close", "skip_till_end_of_string"}};
static NODE *func__print_string_literal_58;
static void entry__print_string_literal_58(void);
static FRAME_INFO frame__print_string_literal_58 = {4, {"pos", "line", "skip_till_close", "skip_till_end_of_string"}};
static void cont__print_string_literal_59(void);
static void cont__print_string_literal_60(void);
static void cont__print_string_literal_61(void);
static NODE *func__print_string_literal_62;
static void entry__print_string_literal_62(void);
static FRAME_INFO frame__print_string_literal_62 = {2, {"skip_till_close", "pos"}};
static void cont__print_string_literal_63(void);
static void cont__print_string_literal_64(void);
static void cont__print_string_literal_65(void);
static void cont__print_string_literal_66(void);
static void cont__print_string_literal_67(void);
static NODE *func__print_string_literal_68;
static void entry__print_string_literal_68(void);
static FRAME_INFO frame__print_string_literal_68 = {2, {"skip_till_end_of_string", "pos"}};
static void cont__print_string_literal_69(void);
static void cont__print_string_literal_70(void);
static void cont__print_string_literal_71(void);
static void cont__print_string_literal_72(void);
static void cont__print_string_literal_73(void);
static void cont__print_string_literal_74(void);
static NODE *func__print_string_literal_75;
static void entry__print_string_literal_75(void);
static FRAME_INFO frame__print_string_literal_75 = {3, {"pos", "line", "skip_till_close"}};
static void cont__print_string_literal_76(void);
static void cont__print_string_literal_77(void);
static void cont__print_string_literal_78(void);
static NODE *func__print_string_literal_79;
static void entry__print_string_literal_79(void);
static FRAME_INFO frame__print_string_literal_79 = {3, {"line", "pos", "skip_till_close"}};
static void cont__print_string_literal_80(void);
static void cont__print_string_literal_81(void);
static NODE *func__print_string_literal_82;
static void entry__print_string_literal_82(void);
static FRAME_INFO frame__print_string_literal_82 = {1, {"skip_till_close"}};
static NODE *func__print_string_literal_83;
static void entry__print_string_literal_83(void);
static FRAME_INFO frame__print_string_literal_83 = {2, {"line", "pos"}};
static NODE *func__print_string_literal_84;
static void entry__print_string_literal_84(void);
static FRAME_INFO frame__print_string_literal_84 = {2, {"line", "pos"}};
static void cont__print_string_literal_85(void);
static void cont__print_string_literal_86(void);
static void cont__print_string_literal_87(void);
static NODE *func__print_string_literal_88;
static void entry__print_string_literal_88(void);
static FRAME_INFO frame__print_string_literal_88 = {1, {"pos"}};
static void cont__print_string_literal_89(void);
static NODE *func__print_string_literal_90;
static void entry__print_string_literal_90(void);
static FRAME_INFO frame__print_string_literal_90 = {6, {"pos", "max_width", "line", "best_split_pos", "skip_special", "last_valid_pos"}};
static void cont__print_string_literal_91(void);
static NODE *func__print_string_literal_92;
static void entry__print_string_literal_92(void);
static FRAME_INFO frame__print_string_literal_92 = {7, {"line", "pos", "best_split_pos", "skip_special", "max_width", "last_valid_pos", "chr"}};
static void cont__print_string_literal_93(void);
static void cont__print_string_literal_94(void);
static NODE *func__print_string_literal_95;
static void entry__print_string_literal_95(void);
static FRAME_INFO frame__print_string_literal_95 = {2, {"best_split_pos", "pos"}};
static NODE *func__print_string_literal_96;
static void entry__print_string_literal_96(void);
static FRAME_INFO frame__print_string_literal_96 = {7, {"chr", "skip_special", "pos", "max_width", "line", "best_split_pos", "last_valid_pos"}};
static void cont__print_string_literal_97(void);
static NODE *func__print_string_literal_98;
static void entry__print_string_literal_98(void);
static FRAME_INFO frame__print_string_literal_98 = {6, {"skip_special", "pos", "max_width", "line", "best_split_pos", "last_valid_pos"}};
static void cont__print_string_literal_99(void);
static NODE *func__print_string_literal_100;
static void entry__print_string_literal_100(void);
static FRAME_INFO frame__print_string_literal_100 = {4, {"pos", "max_width", "line", "best_split_pos"}};
static void cont__print_string_literal_101(void);
static NODE *func__print_string_literal_102;
static void entry__print_string_literal_102(void);
static FRAME_INFO frame__print_string_literal_102 = {2, {"line", "pos"}};
static void cont__print_string_literal_103(void);
static void cont__print_string_literal_104(void);
static void cont__print_string_literal_105(void);
static NODE *func__print_string_literal_106;
static void entry__print_string_literal_106(void);
static FRAME_INFO frame__print_string_literal_106 = {2, {"best_split_pos", "pos"}};
static NODE *func__print_string_literal_107;
static void entry__print_string_literal_107(void);
static FRAME_INFO frame__print_string_literal_107 = {2, {"last_valid_pos", "pos"}};
static void cont__print_string_literal_108(void);
static NODE *func__print_string_literal_109;
static void entry__print_string_literal_109(void);
static FRAME_INFO frame__print_string_literal_109 = {2, {"last_valid_pos", "pos"}};
static NODE *func__print_string_literal_110;
static void entry__print_string_literal_110(void);
static FRAME_INFO frame__print_string_literal_110 = {2, {"last_valid_pos", "pos"}};
static void cont__print_string_literal_111(void);
static void cont__print_string_literal_112(void);
static void cont__print_string_literal_113(void);
static void cont__print_string_literal_114(void);
static NODE *func__print_string_literal_115;
static void entry__print_string_literal_115(void);
static FRAME_INFO frame__print_string_literal_115 = {2, {"best_split_pos", "last_valid_pos"}};
static void cont__print_string_literal_116(void);
static void cont__print_string_literal_117(void);
static void cont__print_string_literal_118(void);
static void cont__print_string_literal_119(void);
static void cont__print_string_literal_120(void);
static void cont__print_string_literal_121(void);
static void cont__print_string_literal_122(void);
static void cont__print_string_literal_123(void);
static void cont__print_string_literal_124(void);
static void cont__print_string_literal_125(void);
static NODE *func__print_string_literal_126;
static void entry__print_string_literal_126(void);
static FRAME_INFO frame__print_string_literal_126 = {1, {"lines"}};
static NODE *string__578a5af303e9ca1;
static void cont__print_string_literal_128(void);
static void cont__print_string_literal_129(void);
static void cont__print_string_literal_130(void);
static void cont__print_string_literal_131(void);
static void cont__print_string_literal_132(void);
static NODE *func__print_string_literal_133;
static void entry__print_string_literal_133(void);
static FRAME_INFO frame__print_string_literal_133 = {1, {"lines"}};
static void cont__print_string_literal_134(void);
static NODE *string__2d7981f4e5082bfe;
static void cont__print_string_literal_136(void);
static void cont__print_string_literal_137(void);
static void cont__print_string_literal_138(void);
static void cont__print_string_literal_139(void);
static NODE *func__print_string_literal_140;
static void entry__print_string_literal_140(void);
static FRAME_INFO frame__print_string_literal_140 = {1, {"buf"}};
static NODE *string__578a5af303e9cc3;
static NODE *func__print_string_literal_142;
static void entry__print_string_literal_142(void);
static FRAME_INFO frame__print_string_literal_142 = {2, {"buf", "indent"}};
static void cont__print_string_literal_143(void);
static void cont__print_string_literal_144(void);
static void cont__print_string_literal_145(void);
static void cont__print_string_literal_146(void);
static void cont__print_string_literal_147(void);
static NODE *func__print_string_literal_148;
static void entry__print_string_literal_148(void);
static FRAME_INFO frame__print_string_literal_148 = {3, {"line", "buf", "indentation"}};
static void cont__print_string_literal_149(void);
static void cont__print_string_literal_150(void);
static NODE *func__print_string_literal_151;
static void entry__print_string_literal_151(void);
static FRAME_INFO frame__print_string_literal_151 = {3, {"buf", "indentation", "line"}};
static void cont__print_string_literal_152(void);
static void cont__print_string_literal_153(void);
static void cont__print_string_literal_154(void);
static NODE *func__string_template_to_string_1;
static void entry__string_template_to_string_1(void);
static FRAME_INFO frame__string_template_to_string_1 = {5, {"self", "lines", "template_is_inline", "add_part", "add_lines"}};
static NODE *func__string_template_to_string_2;
static void entry__string_template_to_string_2(void);
static FRAME_INFO frame__string_template_to_string_2 = {3, {"part", "lines", "template_is_inline"}};
static void cont__string_template_to_string_3(void);
static NODE *func__string_template_to_string_4;
static void entry__string_template_to_string_4(void);
static FRAME_INFO frame__string_template_to_string_4 = {2, {"lines", "part"}};
static void cont__string_template_to_string_5(void);
static NODE *func__string_template_to_string_6;
static void entry__string_template_to_string_6(void);
static FRAME_INFO frame__string_template_to_string_6 = {3, {"template_is_inline", "lines", "part"}};
static NODE *func__string_template_to_string_7;
static void entry__string_template_to_string_7(void);
static FRAME_INFO frame__string_template_to_string_7 = {2, {"lines", "part"}};
static void cont__string_template_to_string_8(void);
static void cont__string_template_to_string_9(void);
static void cont__string_template_to_string_10(void);
static NODE *func__string_template_to_string_11;
static void entry__string_template_to_string_11(void);
static FRAME_INFO frame__string_template_to_string_11 = {2, {"part", "lines"}};
static void cont__string_template_to_string_12(void);
static void cont__string_template_to_string_13(void);
static void cont__string_template_to_string_14(void);
static void cont__string_template_to_string_15(void);
static NODE *func__string_template_to_string_16;
static void entry__string_template_to_string_16(void);
static FRAME_INFO frame__string_template_to_string_16 = {2, {"lines", "part"}};
static void cont__string_template_to_string_17(void);
static void cont__string_template_to_string_18(void);
static void cont__string_template_to_string_19(void);
static void cont__string_template_to_string_20(void);
static void cont__string_template_to_string_21(void);
static void cont__string_template_to_string_22(void);
static void cont__string_template_to_string_23(void);
static NODE *func__string_template_to_string_24;
static void entry__string_template_to_string_24(void);
static FRAME_INFO frame__string_template_to_string_24 = {2, {"lines", "part"}};
static void cont__string_template_to_string_25(void);
static NODE *func__string_template_to_string_26;
static void entry__string_template_to_string_26(void);
static FRAME_INFO frame__string_template_to_string_26 = {3, {"more_lines", "lines", "template_is_inline"}};
static void cont__string_template_to_string_27(void);
static NODE *func__string_template_to_string_28;
static void entry__string_template_to_string_28(void);
static FRAME_INFO frame__string_template_to_string_28 = {2, {"lines", "more_lines"}};
static NODE *func__string_template_to_string_29;
static void entry__string_template_to_string_29(void);
static FRAME_INFO frame__string_template_to_string_29 = {3, {"template_is_inline", "more_lines", "lines"}};
static NODE *func__string_template_to_string_30;
static void entry__string_template_to_string_30(void);
static FRAME_INFO frame__string_template_to_string_30 = {2, {"more_lines", "lines"}};
static void cont__string_template_to_string_31(void);
static void cont__string_template_to_string_32(void);
static void cont__string_template_to_string_33(void);
static void cont__string_template_to_string_34(void);
static NODE *func__string_template_to_string_35;
static void entry__string_template_to_string_35(void);
static FRAME_INFO frame__string_template_to_string_35 = {2, {"lines", "more_lines"}};
static void cont__string_template_to_string_36(void);
static void cont__string_template_to_string_37(void);
static void cont__string_template_to_string_38(void);
static void cont__string_template_to_string_39(void);
static void cont__string_template_to_string_40(void);
static void cont__string_template_to_string_41(void);
static void cont__string_template_to_string_42(void);
static void cont__string_template_to_string_43(void);
static void cont__string_template_to_string_44(void);
static void cont__string_template_to_string_45(void);
static void cont__string_template_to_string_46(void);
static void cont__string_template_to_string_47(void);
static void cont__string_template_to_string_48(void);
static NODE *func__string_template_to_string_49;
static void entry__string_template_to_string_49(void);
static FRAME_INFO frame__string_template_to_string_49 = {3, {"argument", "add_part", "add_lines"}};
static void cont__string_template_to_string_50(void);
static NODE *func__string_template_to_string_51;
static void entry__string_template_to_string_51(void);
static FRAME_INFO frame__string_template_to_string_51 = {5, {"argument", "add_part", "add_lines", "more_lines", "is_inline"}};
static void cont__string_template_to_string_52(void);
static void cont__string_template_to_string_53(void);
static NODE *func__string_template_to_string_54;
static void entry__string_template_to_string_54(void);
static FRAME_INFO frame__string_template_to_string_54 = {2, {"add_part", "more_lines"}};
static void cont__string_template_to_string_55(void);
static NODE *func__string_template_to_string_56;
static void entry__string_template_to_string_56(void);
static FRAME_INFO frame__string_template_to_string_56 = {2, {"add_lines", "more_lines"}};
static NODE *func__string_template_to_string_57;
static void entry__string_template_to_string_57(void);
static FRAME_INFO frame__string_template_to_string_57 = {3, {"return__1", "add_part", "argument"}};
static void cont__string_template_to_string_58(void);
static NODE *string__2d7981f4e5082bed;
static void cont__string_template_to_string_60(void);
static void cont__string_template_to_string_61(void);
static void cont__string_template_to_string_62(void);
static void cont__string_template_to_string_63(void);
static void cont__string_template_to_string_64(void);
static NODE *string__565ae803e8121017;
static void cont__string_template_to_string_66(void);
static NODE *func__string_template_to_string_67;
static void entry__string_template_to_string_67(void);
static FRAME_INFO frame__string_template_to_string_67 = {1, {"lines"}};
static void cont__string_template_to_string_68(void);
static void cont__string_template_to_string_69(void);
static void cont__string_template_to_string_70(void);
static void cont__string_template_to_string_71(void);
static void cont__string_template_to_string_72(void);
static void cont__string_template_to_string_73(void);
static void cont__string_template_to_string_74(void);
static NODE *func__compiler__string_literal__to_string_1;
static void entry__compiler__string_literal__to_string_1(void);
static FRAME_INFO frame__compiler__string_literal__to_string_1 = {3, {"self", "lines", "is_inline"}};
static void cont__compiler__string_literal__to_string_2(void);
static void cont__compiler__string_literal__to_string_3(void);
static NODE *func__compiler__unique_item__to_string_1;
static void entry__compiler__unique_item__to_string_1(void);
static FRAME_INFO frame__compiler__unique_item__to_string_1 = {1, {"self"}};
static NODE *string__578a5af303e9ccf;
static NODE *func__compiler__polymorphic_function__to_string_1;
static void entry__compiler__polymorphic_function__to_string_1(void);
static FRAME_INFO frame__compiler__polymorphic_function__to_string_1 = {1, {"self"}};
static void cont__compiler__polymorphic_function__to_string_2(void);
static NODE *func__compiler__polymorphic_function__to_string_3;
static void entry__compiler__polymorphic_function__to_string_3(void);
static FRAME_INFO frame__compiler__polymorphic_function__to_string_3 = {0, {}};
static NODE *string__fa732415f216be5;
static NODE *func__compiler__polymorphic_function__to_string_5;
static void entry__compiler__polymorphic_function__to_string_5(void);
static FRAME_INFO frame__compiler__polymorphic_function__to_string_5 = {0, {}};
static NODE *string__2d7981f4e6482bec;
static NODE *func__compiler__identifier__to_string_1;
static void entry__compiler__identifier__to_string_1(void);
static FRAME_INFO frame__compiler__identifier__to_string_1 = {1, {"self"}};
static NODE *func__compiler__identifier__to_string_2;
static void entry__compiler__identifier__to_string_2(void);
static FRAME_INFO frame__compiler__identifier__to_string_2 = {1, {"self"}};
static void cont__compiler__identifier__to_string_3(void);
static void cont__compiler__identifier__to_string_4(void);
static NODE *func__compiler__identifier__to_string_5;
static void entry__compiler__identifier__to_string_5(void);
static FRAME_INFO frame__compiler__identifier__to_string_5 = {1, {"self"}};
static void cont__compiler__identifier__to_string_6(void);
static void cont__compiler__identifier__to_string_7(void);
static NODE *string__2d7981f4e6d82bff;
static void cont__compiler__identifier__to_string_9(void);
static NODE *func__compiler__identifier__to_string_10;
static void entry__compiler__identifier__to_string_10(void);
static FRAME_INFO frame__compiler__identifier__to_string_10 = {1, {"self"}};
static void cont__compiler__identifier__to_string_11(void);
static NODE *func__compiler__identifier__to_string_12;
static void entry__compiler__identifier__to_string_12(void);
static FRAME_INFO frame__compiler__identifier__to_string_12 = {1, {"self"}};
static void cont__compiler__identifier__to_string_13(void);
static void cont__compiler__identifier__to_string_14(void);
static NODE *func__compiler__identifier__to_string_15;
static void entry__compiler__identifier__to_string_15(void);
static FRAME_INFO frame__compiler__identifier__to_string_15 = {1, {"self"}};
static NODE *func__compiler__identifier__to_string_16;
static void entry__compiler__identifier__to_string_16(void);
static FRAME_INFO frame__compiler__identifier__to_string_16 = {1, {"self"}};
static void cont__compiler__identifier__to_string_17(void);
static NODE *func__compiler__c_code__to_string_1;
static void entry__compiler__c_code__to_string_1(void);
static FRAME_INFO frame__compiler__c_code__to_string_1 = {1, {"self"}};
static NODE *func__compiler__c_code__to_string_2;
static void entry__compiler__c_code__to_string_2(void);
static FRAME_INFO frame__compiler__c_code__to_string_2 = {4, {"self", "buf", "indent", "indentation"}};
static void cont__compiler__c_code__to_string_3(void);
static NODE *func__compiler__c_code__to_string_4;
static void entry__compiler__c_code__to_string_4(void);
static FRAME_INFO frame__compiler__c_code__to_string_4 = {0, {}};
static void cont__compiler__c_code__to_string_5(void);
static NODE *string__2d7981f4e4d02bcf;
static void cont__compiler__c_code__to_string_7(void);
static NODE *func__compiler__c_code__to_string_8;
static void entry__compiler__c_code__to_string_8(void);
static FRAME_INFO frame__compiler__c_code__to_string_8 = {0, {}};
static void cont__compiler__c_code__to_string_9(void);
static void cont__compiler__c_code__to_string_10(void);
static void cont__compiler__c_code__to_string_11(void);
static void cont__compiler__c_code__to_string_12(void);
static void cont__compiler__c_code__to_string_13(void);
static NODE *func__compiler__c_code__to_string_14;
static void entry__compiler__c_code__to_string_14(void);
static FRAME_INFO frame__compiler__c_code__to_string_14 = {3, {"buf", "indentation", "self"}};
static void cont__compiler__c_code__to_string_15(void);
static NODE *string__4a1f55ee819ae2f7;
static void cont__compiler__c_code__to_string_17(void);
static void cont__compiler__c_code__to_string_18(void);
static void cont__compiler__c_code__to_string_19(void);
static void cont__compiler__c_code__to_string_20(void);
static void cont__compiler__c_code__to_string_21(void);
static NODE *func__compiler__c_code__to_string_22;
static void entry__compiler__c_code__to_string_22(void);
static FRAME_INFO frame__compiler__c_code__to_string_22 = {3, {"buf", "indentation", "self"}};
static void cont__compiler__c_code__to_string_23(void);
static NODE *string__5a1f552e8192b2f7;
static void cont__compiler__c_code__to_string_25(void);
static void cont__compiler__c_code__to_string_26(void);
static void cont__compiler__c_code__to_string_27(void);
static void cont__compiler__c_code__to_string_28(void);
static void cont__compiler__c_code__to_string_29(void);
static NODE *func__compiler__c_code__to_string_30;
static void entry__compiler__c_code__to_string_30(void);
static FRAME_INFO frame__compiler__c_code__to_string_30 = {3, {"buf", "indentation", "self"}};
static void cont__compiler__c_code__to_string_31(void);
static NODE *string__461f576e8192b2f7;
static void cont__compiler__c_code__to_string_33(void);
static void cont__compiler__c_code__to_string_34(void);
static void cont__compiler__c_code__to_string_35(void);
static void cont__compiler__c_code__to_string_36(void);
static void cont__compiler__c_code__to_string_37(void);
static NODE *func__compiler__c_code__to_string_38;
static void entry__compiler__c_code__to_string_38(void);
static FRAME_INFO frame__compiler__c_code__to_string_38 = {3, {"buf", "indentation", "self"}};
static void cont__compiler__c_code__to_string_39(void);
static NODE *string__6a1f526e819312f7;
static void cont__compiler__c_code__to_string_41(void);
static void cont__compiler__c_code__to_string_42(void);
static void cont__compiler__c_code__to_string_43(void);
static void cont__compiler__c_code__to_string_44(void);
static void cont__compiler__c_code__to_string_45(void);
static NODE *func__compiler__c_code__to_string_46;
static void entry__compiler__c_code__to_string_46(void);
static FRAME_INFO frame__compiler__c_code__to_string_46 = {3, {"buf", "indentation", "self"}};
static void cont__compiler__c_code__to_string_47(void);
static NODE *string__5a1f52ae819272f7;
static void cont__compiler__c_code__to_string_49(void);
static void cont__compiler__c_code__to_string_50(void);
static void cont__compiler__c_code__to_string_51(void);
static void cont__compiler__c_code__to_string_52(void);
static void cont__compiler__c_code__to_string_53(void);
static NODE *func__compiler__c_code__to_string_54;
static void entry__compiler__c_code__to_string_54(void);
static FRAME_INFO frame__compiler__c_code__to_string_54 = {1, {"self"}};
static void cont__compiler__c_code__to_string_55(void);
static NODE *string__545aebc3eac0d03b;
static void cont__compiler__c_code__to_string_57(void);
static void cont__compiler__c_code__to_string_58(void);
static void cont__compiler__c_code__to_string_59(void);
static NODE *func__compiler__c_code__to_string_60;
static void entry__compiler__c_code__to_string_60(void);
static FRAME_INFO frame__compiler__c_code__to_string_60 = {3, {"buf", "indentation", "self"}};
static void cont__compiler__c_code__to_string_61(void);
static NODE *string__ad7409db1592f0da;
static void cont__compiler__c_code__to_string_63(void);
static void cont__compiler__c_code__to_string_64(void);
static void cont__compiler__c_code__to_string_65(void);
static void cont__compiler__c_code__to_string_66(void);
static NODE *func__compiler__c_code__to_string_67;
static void entry__compiler__c_code__to_string_67(void);
static FRAME_INFO frame__compiler__c_code__to_string_67 = {3, {"argument", "buf", "indentation"}};
static NODE *string__3f7af391278ba7e1;
static void cont__compiler__c_code__to_string_69(void);
static void cont__compiler__c_code__to_string_70(void);
static void cont__compiler__c_code__to_string_71(void);
static void cont__compiler__c_code__to_string_72(void);
static void cont__compiler__c_code__to_string_73(void);
static NODE *func__compiler__c_code__to_string_74;
static void entry__compiler__c_code__to_string_74(void);
static FRAME_INFO frame__compiler__c_code__to_string_74 = {3, {"buf", "self", "indentation"}};
static void cont__compiler__c_code__to_string_75(void);
static void cont__compiler__c_code__to_string_76(void);
static NODE *func__compiler__c_code__to_string_77;
static void entry__compiler__c_code__to_string_77(void);
static FRAME_INFO frame__compiler__c_code__to_string_77 = {3, {"remark_line", "buf", "indentation"}};
static NODE *string__2d7981f4e6702bea;
static void cont__compiler__c_code__to_string_79(void);
static void cont__compiler__c_code__to_string_80(void);
static void cont__compiler__c_code__to_string_81(void);
static void cont__compiler__c_code__to_string_82(void);
static NODE *func__compiler__c_code__to_string_83;
static void entry__compiler__c_code__to_string_83(void);
static FRAME_INFO frame__compiler__c_code__to_string_83 = {3, {"buf", "self", "indentation"}};
static void cont__compiler__c_code__to_string_84(void);
static void cont__compiler__c_code__to_string_85(void);
static NODE *func__compiler__c_code__to_string_86;
static void entry__compiler__c_code__to_string_86(void);
static FRAME_INFO frame__compiler__c_code__to_string_86 = {1, {"buf"}};
static void cont__compiler__c_code__to_string_87(void);
static void cont__compiler__c_code__to_string_88(void);
static void cont__compiler__c_code__to_string_89(void);
static NODE *func__compiler__c_code__to_string_90;
static void entry__compiler__c_code__to_string_90(void);
static FRAME_INFO frame__compiler__c_code__to_string_90 = {3, {"line", "buf", "indentation"}};
static void cont__compiler__c_code__to_string_91(void);
static void cont__compiler__c_code__to_string_92(void);
static void cont__compiler__c_code__to_string_93(void);
static void cont__compiler__c_code__to_string_94(void);
static void cont__compiler__c_code__to_string_95(void);
static NODE *func__compiler__c_code__to_string_96;
static void entry__compiler__c_code__to_string_96(void);
static FRAME_INFO frame__compiler__c_code__to_string_96 = {0, {}};
static NODE *string__d65af883e8b9a02a;
static void cont__92_1(void);
static void cont__93_1(void);
void run__pretty_printer(void);

static CONTINUATION_INFO continuation_info[] = {
  {type__needs_parenthesis, NULL, 29, 29, 2, 18},
  {run__pretty_printer, NULL, 137, 137, 1, 35},
  {cont__92_1, NULL, 138, 138, 1, 40},
  {cont__93_1, NULL, 1059, 1059, 1, 29},
  {entry__INDENTATION__grammar__match_7, NULL, 148, 148, 7, 15},
  {cont__INDENTATION__grammar__match_8, &frame__INDENTATION__grammar__match_7, 148, 148, 7, 42},
  {cont__INDENTATION__grammar__match_9, &frame__INDENTATION__grammar__match_7, 148, 148, 7, 42},
  {cont__INDENTATION__grammar__match_10, &frame__INDENTATION__grammar__match_7, 148, 148, 7, 42},
  {entry__INDENTATION__grammar__match_3, NULL, 147, 147, 7, 15},
  {cont__INDENTATION__grammar__match_4, &frame__INDENTATION__grammar__match_3, 147, 147, 7, 37},
  {cont__INDENTATION__grammar__match_5, &frame__INDENTATION__grammar__match_3, 147, 147, 7, 37},
  {cont__INDENTATION__grammar__match_6, &frame__INDENTATION__grammar__match_3, 148, 148, 7, 42},
  {cont__INDENTATION__grammar__match_11, &frame__INDENTATION__grammar__match_3, },
  {entry__INDENTATION__grammar__match_13, NULL, 149, 149, 5, 8},
  {entry__INDENTATION__grammar__match_14, NULL, 150, 150, 5, 8},
  {entry__INDENTATION__grammar__match_1, NULL, 146, 146, 7, 35},
  {cont__INDENTATION__grammar__match_2, &frame__INDENTATION__grammar__match_1, },
  {cont__INDENTATION__grammar__match_12, &frame__INDENTATION__grammar__match_1, 144, 150, 3, 8},
  {entry__indentation_string_5, NULL, 165, 165, 5, 28},
  {cont__indentation_string_6, &frame__indentation_string_5, 166, 166, 5, 19},
  {cont__indentation_string_7, &frame__indentation_string_5, 166, 166, 19, 19},
  {entry__indentation_string_2, NULL, 164, 164, 12, 22},
  {cont__indentation_string_3, &frame__indentation_string_2, 164, 164, 12, 22},
  {cont__indentation_string_4, &frame__indentation_string_2, 164, 166, 9, 19},
  {entry__indentation_string_1, NULL, 164, 166, 3, 19},
  {cont__indentation_string_8, &frame__indentation_string_1, 167, 167, 22, 40},
  {cont__indentation_string_9, &frame__indentation_string_1, 167, 167, 3, 40},
  {entry__compiler__print_trees_2, NULL, 175, 175, 35, 45},
  {cont__compiler__print_trees_3, &frame__compiler__print_trees_2, 175, 175, 15, 45},
  {cont__compiler__print_trees_4, &frame__compiler__print_trees_2, 175, 175, 8, 47},
  {cont__compiler__print_trees_5, &frame__compiler__print_trees_2, 175, 175, 5, 47},
  {entry__compiler__print_trees_10, NULL, 192, 192, 22, 28},
  {cont__compiler__print_trees_11, &frame__compiler__print_trees_10, 192, 192, 22, 47},
  {cont__compiler__print_trees_12, &frame__compiler__print_trees_10, 192, 192, 11, 48},
  {cont__compiler__print_trees_13, &frame__compiler__print_trees_10, 193, 193, 31, 31},
  {cont__compiler__print_trees_14, &frame__compiler__print_trees_10, 193, 193, 11, 32},
  {cont__compiler__print_trees_15, &frame__compiler__print_trees_10, 194, 194, 29, 54},
  {cont__compiler__print_trees_16, &frame__compiler__print_trees_10, 194, 194, 22, 60},
  {cont__compiler__print_trees_17, &frame__compiler__print_trees_10, 194, 194, 11, 60},
  {cont__compiler__print_trees_18, &frame__compiler__print_trees_10, 194, 194, 60, 60},
  {entry__compiler__print_trees_19, NULL, 196, 196, 11, 23},
  {cont__compiler__print_trees_20, &frame__compiler__print_trees_19, 196, 196, 23, 23},
  {entry__compiler__print_trees_7, NULL, 191, 191, 9, 23},
  {cont__compiler__print_trees_8, &frame__compiler__print_trees_7, 191, 191, 9, 27},
  {cont__compiler__print_trees_9, &frame__compiler__print_trees_7, 190, 196, 7, 24},
  {entry__compiler__print_trees_25, NULL, 184, 184, 36, 74},
  {cont__compiler__print_trees_26, &frame__compiler__print_trees_25, 184, 184, 36, 74},
  {cont__compiler__print_trees_27, &frame__compiler__print_trees_25, 184, 184, 36, 74},
  {entry__compiler__print_trees_23, NULL, 184, 184, 9, 31},
  {cont__compiler__print_trees_24, &frame__compiler__print_trees_23, 184, 184, 9, 74},
  {cont__compiler__print_trees_28, &frame__compiler__print_trees_23, 184, 184, 9, 74},
  {entry__compiler__print_trees_30, NULL, 186, 186, 9, 15},
  {entry__compiler__print_trees_36, NULL, 201, 201, 28, 30},
  {cont__compiler__print_trees_37, &frame__compiler__print_trees_36, 201, 201, 18, 33},
  {cont__compiler__print_trees_38, &frame__compiler__print_trees_36, 201, 201, 9, 33},
  {cont__compiler__print_trees_39, &frame__compiler__print_trees_36, 202, 202, 9, 14},
  {cont__compiler__print_trees_40, &frame__compiler__print_trees_36, 202, 202, 14, 14},
  {entry__compiler__print_trees_33, NULL, 200, 200, 10, 15},
  {cont__compiler__print_trees_34, &frame__compiler__print_trees_33, 200, 200, 10, 25},
  {cont__compiler__print_trees_35, &frame__compiler__print_trees_33, 200, 202, 7, 14},
  {entry__compiler__print_trees_46, NULL, 210, 210, 28, 39},
  {entry__compiler__print_trees_6, NULL, 180, 180, 5, 23},
  {cont__compiler__print_trees_21, &frame__compiler__print_trees_6, 183, 183, 9, 15},
  {cont__compiler__print_trees_22, &frame__compiler__print_trees_6, 182, 184, 7, 74},
  {cont__compiler__print_trees_29, &frame__compiler__print_trees_6, 181, 186, 5, 16},
  {cont__compiler__print_trees_31, &frame__compiler__print_trees_6, 198, 198, 5, 22},
  {cont__compiler__print_trees_32, &frame__compiler__print_trees_6, 199, 202, 5, 15},
  {cont__compiler__print_trees_41, &frame__compiler__print_trees_6, 205, 205, 9, 17},
  {cont__compiler__print_trees_42, &frame__compiler__print_trees_6, 209, 209, 9, 22},
  {cont__compiler__print_trees_43, &frame__compiler__print_trees_6, },
  {cont__compiler__print_trees_44, &frame__compiler__print_trees_6, 203, 209, 5, 23},
  {cont__compiler__print_trees_45, &frame__compiler__print_trees_6, 210, 210, 5, 39},
  {entry__compiler__print_trees_1, NULL, 177, 210, 3, 39},
  {cont__compiler__print_trees_47, &frame__compiler__print_trees_1, 210, 210, 39, 39},
  {entry__line_start_remark_to_string_9, NULL, 217, 217, 5, 48},
  {cont__line_start_remark_to_string_10, &frame__line_start_remark_to_string_9, 217, 217, 48, 48},
  {entry__line_start_remark_to_string_1, NULL, 214, 214, 23, 30},
  {cont__line_start_remark_to_string_3, &frame__line_start_remark_to_string_1, 214, 214, 3, 31},
  {cont__line_start_remark_to_string_4, &frame__line_start_remark_to_string_1, 215, 215, 17, 30},
  {cont__line_start_remark_to_string_5, &frame__line_start_remark_to_string_1, 215, 215, 36, 50},
  {cont__line_start_remark_to_string_6, &frame__line_start_remark_to_string_1, 215, 215, 3, 50},
  {cont__line_start_remark_to_string_7, &frame__line_start_remark_to_string_1, 216, 216, 36, 36},
  {cont__line_start_remark_to_string_8, &frame__line_start_remark_to_string_1, 216, 217, 3, 48},
  {cont__line_start_remark_to_string_11, &frame__line_start_remark_to_string_1, 218, 218, 3, 8},
  {entry__add_remark_lines_3, NULL, 236, 236, 7, 12},
  {entry__add_remark_lines_5, NULL, 237, 237, 7, 13},
  {entry__add_remark_lines_10, NULL, 245, 245, 11, 24},
  {cont__add_remark_lines_11, &frame__add_remark_lines_10, },
  {cont__add_remark_lines_12, &frame__add_remark_lines_10, 246, 246, 11, 34},
  {cont__add_remark_lines_13, &frame__add_remark_lines_10, },
  {cont__add_remark_lines_14, &frame__add_remark_lines_10, 247, 247, 21, 35},
  {cont__add_remark_lines_15, &frame__add_remark_lines_10, 247, 247, 11, 36},
  {cont__add_remark_lines_16, &frame__add_remark_lines_10, },
  {cont__add_remark_lines_17, &frame__add_remark_lines_10, 242, 248, 7, 18},
  {cont__add_remark_lines_18, &frame__add_remark_lines_10, 242, 248, 7, 18},
  {entry__add_remark_lines_23, NULL, 252, 252, 23, 32},
  {cont__add_remark_lines_25, &frame__add_remark_lines_23, 252, 252, 23, 32},
  {cont__add_remark_lines_26, &frame__add_remark_lines_23, 252, 252, 23, 32},
  {entry__add_remark_lines_29, NULL, 253, 253, 51, 75},
  {cont__add_remark_lines_30, &frame__add_remark_lines_29, 253, 253, 32, 80},
  {cont__add_remark_lines_31, &frame__add_remark_lines_29, 253, 253, 80, 80},
  {entry__add_remark_lines_28, NULL, 253, 253, 9, 80},
  {cont__add_remark_lines_32, &frame__add_remark_lines_28, 254, 254, 9, 22},
  {cont__add_remark_lines_33, &frame__add_remark_lines_28, 254, 254, 22, 22},
  {entry__add_remark_lines_20, NULL, 252, 252, 10, 18},
  {cont__add_remark_lines_21, &frame__add_remark_lines_20, 252, 252, 10, 18},
  {cont__add_remark_lines_22, &frame__add_remark_lines_20, 252, 252, 10, 32},
  {cont__add_remark_lines_27, &frame__add_remark_lines_20, 252, 254, 7, 22},
  {cont__add_remark_lines_34, &frame__add_remark_lines_20, 255, 255, 21, 68},
  {cont__add_remark_lines_35, &frame__add_remark_lines_20, 255, 255, 10, 69},
  {cont__add_remark_lines_36, &frame__add_remark_lines_20, 255, 255, 7, 69},
  {entry__add_remark_lines_47, NULL, 264, 264, 34, 58},
  {cont__add_remark_lines_48, &frame__add_remark_lines_47, 264, 264, 64, 78},
  {cont__add_remark_lines_49, &frame__add_remark_lines_47, 264, 264, 16, 79},
  {cont__add_remark_lines_50, &frame__add_remark_lines_47, 264, 264, 13, 79},
  {entry__add_remark_lines_52, NULL, 268, 268, 45, 59},
  {cont__add_remark_lines_53, &frame__add_remark_lines_52, 268, 268, 20, 60},
  {cont__add_remark_lines_54, &frame__add_remark_lines_52, 268, 268, 17, 60},
  {entry__add_remark_lines_55, NULL, 272, 272, 21, 45},
  {cont__add_remark_lines_56, &frame__add_remark_lines_55, 275, 275, 21, 35},
  {cont__add_remark_lines_57, &frame__add_remark_lines_55, },
  {cont__add_remark_lines_58, &frame__add_remark_lines_55, 269, 275, 17, 36},
  {entry__add_remark_lines_51, NULL, 269, 275, 17, 36},
  {cont__add_remark_lines_59, &frame__add_remark_lines_51, 265, 275, 13, 38},
  {entry__add_remark_lines_45, NULL, 263, 263, 13, 22},
  {cont__add_remark_lines_46, &frame__add_remark_lines_45, 262, 275, 11, 39},
  {entry__add_remark_lines_60, NULL, 276, 276, 37, 51},
  {cont__add_remark_lines_61, &frame__add_remark_lines_60, 276, 276, 12, 52},
  {cont__add_remark_lines_62, &frame__add_remark_lines_60, 276, 276, 9, 52},
  {entry__add_remark_lines_37, NULL, 259, 259, 11, 24},
  {cont__add_remark_lines_38, &frame__add_remark_lines_37, 259, 259, 26, 49},
  {cont__add_remark_lines_39, &frame__add_remark_lines_37, 259, 259, 11, 49},
  {cont__add_remark_lines_40, &frame__add_remark_lines_37, 259, 259, 61, 75},
  {cont__add_remark_lines_41, &frame__add_remark_lines_37, 259, 259, 51, 76},
  {cont__add_remark_lines_42, &frame__add_remark_lines_37, 259, 259, 11, 76},
  {cont__add_remark_lines_43, &frame__add_remark_lines_37, 258, 260, 9, 35},
  {cont__add_remark_lines_44, &frame__add_remark_lines_37, 257, 276, 7, 52},
  {entry__add_remark_lines_1, NULL, 235, 235, 7, 15},
  {cont__add_remark_lines_2, &frame__add_remark_lines_1, 233, 237, 3, 14},
  {cont__add_remark_lines_7, &frame__add_remark_lines_1, 241, 241, 7, 29},
  {cont__add_remark_lines_8, &frame__add_remark_lines_1, 241, 241, 7, 33},
  {cont__add_remark_lines_9, &frame__add_remark_lines_1, 240, 248, 5, 19},
  {cont__add_remark_lines_19, &frame__add_remark_lines_1, 239, 276, 3, 54},
  {entry__add_statement_remark_4, NULL, 282, 282, 5, 10},
  {entry__add_statement_remark_5, NULL, 283, 283, 8, 46},
  {cont__add_statement_remark_6, &frame__add_statement_remark_5, 283, 283, 5, 46},
  {entry__add_statement_remark_1, NULL, 279, 279, 3, 37},
  {cont__add_statement_remark_2, &frame__add_statement_remark_1, 281, 281, 5, 25},
  {cont__add_statement_remark_3, &frame__add_statement_remark_1, 280, 283, 3, 46},
  {entry__add_remark_4, NULL, 289, 289, 5, 10},
  {entry__add_remark_5, NULL, 290, 290, 8, 41},
  {cont__add_remark_6, &frame__add_remark_5, 290, 290, 5, 41},
  {entry__add_remark_1, NULL, 286, 286, 3, 37},
  {cont__add_remark_2, &frame__add_remark_1, 288, 288, 5, 25},
  {cont__add_remark_3, &frame__add_remark_1, 287, 290, 3, 41},
  {entry__add_indented_remark_2, NULL, 295, 295, 5, 31},
  {cont__add_indented_remark_3, &frame__add_indented_remark_2, 296, 296, 5, 23},
  {cont__add_indented_remark_4, &frame__add_indented_remark_2, 296, 296, 23, 23},
  {entry__add_indented_remark_1, NULL, 294, 296, 3, 23},
  {entry__types__grammar_node__to_string_1, NULL, 301, 301, 41, 50},
  {entry__compiler__require_instruction__to_string_1, NULL, 308, 308, 41, 63},
  {cont__compiler__require_instruction__to_string_2, &frame__compiler__require_instruction__to_string_1, 308, 308, 29, 66},
  {cont__compiler__require_instruction__to_string_5, &frame__compiler__require_instruction__to_string_1, 308, 308, 3, 66},
  {entry__compiler__namespace_instruction__to_string_4, NULL, 316, 316, 24, 47},
  {cont__compiler__namespace_instruction__to_string_5, &frame__compiler__namespace_instruction__to_string_4, 316, 316, 54, 71},
  {cont__compiler__namespace_instruction__to_string_6, &frame__compiler__namespace_instruction__to_string_4, 316, 316, 10, 74},
  {cont__compiler__namespace_instruction__to_string_9, &frame__compiler__namespace_instruction__to_string_4, 316, 316, 7, 74},
  {entry__compiler__namespace_instruction__to_string_10, NULL, 317, 317, 24, 41},
  {cont__compiler__namespace_instruction__to_string_11, &frame__compiler__namespace_instruction__to_string_10, 317, 317, 10, 44},
  {cont__compiler__namespace_instruction__to_string_12, &frame__compiler__namespace_instruction__to_string_10, 317, 317, 7, 44},
  {entry__compiler__namespace_instruction__to_string_1, NULL, 315, 315, 7, 30},
  {cont__compiler__namespace_instruction__to_string_2, &frame__compiler__namespace_instruction__to_string_1, 315, 315, 7, 41},
  {cont__compiler__namespace_instruction__to_string_3, &frame__compiler__namespace_instruction__to_string_1, 317, 317, 7, 44},
  {cont__compiler__namespace_instruction__to_string_13, &frame__compiler__namespace_instruction__to_string_1, 312, 317, 3, 45},
  {entry__compiler__using_instruction__to_string_1, NULL, 321, 321, 39, 56},
  {cont__compiler__using_instruction__to_string_2, &frame__compiler__using_instruction__to_string_1, 321, 321, 29, 59},
  {cont__compiler__using_instruction__to_string_4, &frame__compiler__using_instruction__to_string_1, 321, 321, 3, 59},
  {entry__compiler__include_instruction__to_string_1, NULL, 325, 325, 41, 63},
  {cont__compiler__include_instruction__to_string_2, &frame__compiler__include_instruction__to_string_1, 325, 325, 29, 66},
  {cont__compiler__include_instruction__to_string_4, &frame__compiler__include_instruction__to_string_1, 325, 325, 3, 66},
  {entry__compiler__link_instruction__to_string_1, NULL, 329, 329, 38, 60},
  {cont__compiler__link_instruction__to_string_2, &frame__compiler__link_instruction__to_string_1, 329, 329, 29, 63},
  {cont__compiler__link_instruction__to_string_4, &frame__compiler__link_instruction__to_string_1, 329, 329, 3, 63},
  {entry__compiler__data_instruction__to_string_1, NULL, 333, 333, 38, 60},
  {cont__compiler__data_instruction__to_string_2, &frame__compiler__data_instruction__to_string_1, 333, 333, 29, 63},
  {cont__compiler__data_instruction__to_string_4, &frame__compiler__data_instruction__to_string_1, 333, 333, 3, 63},
  {entry__compiler__remark_statement__to_string_6, NULL, 342, 342, 43, 52},
  {entry__compiler__remark_statement__to_string_3, NULL, 342, 342, 10, 24},
  {cont__compiler__remark_statement__to_string_4, &frame__compiler__remark_statement__to_string_3, 342, 342, 10, 41},
  {cont__compiler__remark_statement__to_string_5, &frame__compiler__remark_statement__to_string_3, 342, 342, 7, 52},
  {entry__compiler__remark_statement__to_string_16, NULL, 347, 347, 11, 25},
  {cont__compiler__remark_statement__to_string_17, &frame__compiler__remark_statement__to_string_16, 347, 347, 11, 28},
  {cont__compiler__remark_statement__to_string_18, &frame__compiler__remark_statement__to_string_16, 347, 347, 11, 35},
  {cont__compiler__remark_statement__to_string_19, &frame__compiler__remark_statement__to_string_16, 347, 347, 11, 35},
  {cont__compiler__remark_statement__to_string_20, &frame__compiler__remark_statement__to_string_16, 347, 347, 11, 35},
  {entry__compiler__remark_statement__to_string_11, NULL, 346, 346, 11, 25},
  {cont__compiler__remark_statement__to_string_12, &frame__compiler__remark_statement__to_string_11, 346, 346, 11, 28},
  {cont__compiler__remark_statement__to_string_13, &frame__compiler__remark_statement__to_string_11, 346, 346, 11, 35},
  {cont__compiler__remark_statement__to_string_14, &frame__compiler__remark_statement__to_string_11, 346, 346, 11, 35},
  {cont__compiler__remark_statement__to_string_15, &frame__compiler__remark_statement__to_string_11, 347, 347, 11, 35},
  {cont__compiler__remark_statement__to_string_21, &frame__compiler__remark_statement__to_string_11, },
  {entry__compiler__remark_statement__to_string_23, NULL, 348, 348, 9, 25},
  {entry__compiler__remark_statement__to_string_7, NULL, 345, 345, 11, 25},
  {cont__compiler__remark_statement__to_string_8, &frame__compiler__remark_statement__to_string_7, 345, 345, 11, 31},
  {cont__compiler__remark_statement__to_string_9, &frame__compiler__remark_statement__to_string_7, 345, 345, 11, 31},
  {cont__compiler__remark_statement__to_string_10, &frame__compiler__remark_statement__to_string_7, },
  {cont__compiler__remark_statement__to_string_22, &frame__compiler__remark_statement__to_string_7, 343, 348, 7, 25},
  {entry__compiler__remark_statement__to_string_27, NULL, 349, 349, 39, 47},
  {entry__compiler__remark_statement__to_string_24, NULL, 349, 349, 10, 32},
  {cont__compiler__remark_statement__to_string_25, &frame__compiler__remark_statement__to_string_24, 349, 349, 10, 37},
  {cont__compiler__remark_statement__to_string_26, &frame__compiler__remark_statement__to_string_24, 349, 349, 7, 47},
  {entry__compiler__remark_statement__to_string_29, NULL, 350, 350, 15, 23},
  {entry__compiler__remark_statement__to_string_28, NULL, 350, 350, 7, 23},
  {entry__compiler__remark_statement__to_string_42, NULL, 356, 356, 36, 49},
  {cont__compiler__remark_statement__to_string_43, &frame__compiler__remark_statement__to_string_42, 356, 356, 22, 54},
  {cont__compiler__remark_statement__to_string_44, &frame__compiler__remark_statement__to_string_42, 356, 356, 54, 54},
  {entry__compiler__remark_statement__to_string_38, NULL, 355, 355, 7, 22},
  {cont__compiler__remark_statement__to_string_39, &frame__compiler__remark_statement__to_string_38, 356, 356, 10, 19},
  {cont__compiler__remark_statement__to_string_40, &frame__compiler__remark_statement__to_string_38, 356, 356, 10, 19},
  {cont__compiler__remark_statement__to_string_41, &frame__compiler__remark_statement__to_string_38, 356, 356, 7, 54},
  {entry__compiler__remark_statement__to_string_35, NULL, 353, 353, 5, 31},
  {cont__compiler__remark_statement__to_string_36, &frame__compiler__remark_statement__to_string_35, 354, 354, 38, 38},
  {cont__compiler__remark_statement__to_string_37, &frame__compiler__remark_statement__to_string_35, 354, 356, 5, 54},
  {entry__compiler__remark_statement__to_string_1, NULL, 339, 339, 3, 37},
  {cont__compiler__remark_statement__to_string_2, &frame__compiler__remark_statement__to_string_1, 340, 350, 3, 24},
  {cont__compiler__remark_statement__to_string_30, &frame__compiler__remark_statement__to_string_1, 351, 351, 20, 34},
  {cont__compiler__remark_statement__to_string_31, &frame__compiler__remark_statement__to_string_1, 351, 351, 3, 35},
  {cont__compiler__remark_statement__to_string_32, &frame__compiler__remark_statement__to_string_1, 352, 352, 6, 28},
  {cont__compiler__remark_statement__to_string_33, &frame__compiler__remark_statement__to_string_1, 352, 352, 6, 32},
  {cont__compiler__remark_statement__to_string_34, &frame__compiler__remark_statement__to_string_1, 352, 356, 3, 55},
  {cont__compiler__remark_statement__to_string_45, &frame__compiler__remark_statement__to_string_1, 357, 357, 3, 8},
  {entry__compiler__body__to_string_10, NULL, 372, 372, 7, 25},
  {cont__compiler__body__to_string_11, &frame__compiler__body__to_string_10, 372, 372, 7, 28},
  {cont__compiler__body__to_string_12, &frame__compiler__body__to_string_10, 372, 372, 7, 40},
  {cont__compiler__body__to_string_13, &frame__compiler__body__to_string_10, 372, 372, 7, 40},
  {entry__compiler__body__to_string_6, NULL, 371, 371, 17, 35},
  {cont__compiler__body__to_string_7, &frame__compiler__body__to_string_6, 371, 371, 7, 36},
  {cont__compiler__body__to_string_8, &frame__compiler__body__to_string_6, 371, 371, 7, 41},
  {cont__compiler__body__to_string_9, &frame__compiler__body__to_string_6, 372, 372, 7, 40},
  {cont__compiler__body__to_string_14, &frame__compiler__body__to_string_6, },
  {entry__compiler__body__to_string_21, NULL, 376, 376, 43, 63},
  {cont__compiler__body__to_string_22, &frame__compiler__body__to_string_21, 376, 376, 43, 63},
  {entry__compiler__body__to_string_24, NULL, 377, 377, 26, 39},
  {cont__compiler__body__to_string_25, &frame__compiler__body__to_string_24, 377, 377, 12, 44},
  {cont__compiler__body__to_string_26, &frame__compiler__body__to_string_24, 377, 377, 9, 44},
  {entry__compiler__body__to_string_27, NULL, 378, 378, 9, 14},
  {entry__compiler__body__to_string_16, NULL, 374, 374, 12, 30},
  {cont__compiler__body__to_string_17, &frame__compiler__body__to_string_16, 374, 374, 12, 33},
  {cont__compiler__body__to_string_18, &frame__compiler__body__to_string_16, 374, 374, 7, 43},
  {cont__compiler__body__to_string_19, &frame__compiler__body__to_string_16, 376, 376, 9, 38},
  {cont__compiler__body__to_string_20, &frame__compiler__body__to_string_16, 376, 376, 9, 63},
  {cont__compiler__body__to_string_23, &frame__compiler__body__to_string_16, 375, 378, 7, 14},
  {entry__compiler__body__to_string_31, NULL, 385, 385, 20, 20},
  {entry__compiler__body__to_string_32, NULL, 387, 387, 32, 45},
  {cont__compiler__body__to_string_33, &frame__compiler__body__to_string_32, 387, 387, 13, 50},
  {cont__compiler__body__to_string_34, &frame__compiler__body__to_string_32, 388, 388, 13, 26},
  {cont__compiler__body__to_string_35, &frame__compiler__body__to_string_32, 388, 388, 26, 26},
  {entry__compiler__body__to_string_29, NULL, 384, 384, 11, 39},
  {cont__compiler__body__to_string_30, &frame__compiler__body__to_string_29, 383, 388, 9, 27},
  {entry__compiler__body__to_string_38, NULL, 394, 394, 36, 54},
  {cont__compiler__body__to_string_39, &frame__compiler__body__to_string_38, 394, 394, 13, 54},
  {cont__compiler__body__to_string_40, &frame__compiler__body__to_string_38, 394, 394, 54, 54},
  {entry__compiler__body__to_string_41, NULL, 396, 396, 13, 36},
  {cont__compiler__body__to_string_42, &frame__compiler__body__to_string_41, 396, 396, 36, 36},
  {entry__compiler__body__to_string_48, NULL, 401, 401, 31, 31},
  {entry__compiler__body__to_string_53, NULL, 405, 405, 36, 49},
  {cont__compiler__body__to_string_54, &frame__compiler__body__to_string_53, 405, 405, 17, 65},
  {cont__compiler__body__to_string_55, &frame__compiler__body__to_string_53, 406, 406, 17, 30},
  {cont__compiler__body__to_string_56, &frame__compiler__body__to_string_53, 406, 406, 30, 30},
  {entry__compiler__body__to_string_57, NULL, 408, 408, 17, 41},
  {entry__compiler__body__to_string_49, NULL, 404, 404, 15, 42},
  {cont__compiler__body__to_string_50, &frame__compiler__body__to_string_49, 404, 404, 15, 56},
  {cont__compiler__body__to_string_51, &frame__compiler__body__to_string_49, 404, 404, 15, 56},
  {cont__compiler__body__to_string_52, &frame__compiler__body__to_string_49, 403, 408, 13, 42},
  {entry__compiler__body__to_string_36, NULL, 392, 396, 9, 37},
  {cont__compiler__body__to_string_43, &frame__compiler__body__to_string_36, 397, 397, 9, 32},
  {cont__compiler__body__to_string_44, &frame__compiler__body__to_string_36, 398, 398, 9, 56},
  {cont__compiler__body__to_string_45, &frame__compiler__body__to_string_36, 400, 400, 11, 60},
  {cont__compiler__body__to_string_46, &frame__compiler__body__to_string_36, 400, 400, 11, 60},
  {cont__compiler__body__to_string_47, &frame__compiler__body__to_string_36, 399, 408, 9, 44},
  {entry__compiler__body__to_string_63, NULL, 414, 414, 39, 72},
  {cont__compiler__body__to_string_64, &frame__compiler__body__to_string_63, 414, 414, 72, 72},
  {entry__compiler__body__to_string_74, NULL, 421, 421, 15, 35},
  {cont__compiler__body__to_string_75, &frame__compiler__body__to_string_74, 421, 421, 35, 35},
  {entry__compiler__body__to_string_76, NULL, 423, 423, 15, 66},
  {cont__compiler__body__to_string_77, &frame__compiler__body__to_string_76, 423, 423, 66, 66},
  {entry__compiler__body__to_string_70, NULL, 418, 418, 11, 30},
  {cont__compiler__body__to_string_71, &frame__compiler__body__to_string_70, 420, 420, 13, 24},
  {cont__compiler__body__to_string_72, &frame__compiler__body__to_string_70, 420, 420, 13, 34},
  {cont__compiler__body__to_string_73, &frame__compiler__body__to_string_70, 419, 423, 11, 67},
  {entry__compiler__body__to_string_58, NULL, 411, 411, 9, 37},
  {cont__compiler__body__to_string_59, &frame__compiler__body__to_string_58, 412, 412, 39, 46},
  {cont__compiler__body__to_string_60, &frame__compiler__body__to_string_58, 412, 412, 9, 47},
  {cont__compiler__body__to_string_61, &frame__compiler__body__to_string_58, 414, 414, 16, 36},
  {cont__compiler__body__to_string_62, &frame__compiler__body__to_string_58, 414, 414, 9, 72},
  {cont__compiler__body__to_string_65, &frame__compiler__body__to_string_58, 415, 415, 9, 24},
  {cont__compiler__body__to_string_66, &frame__compiler__body__to_string_58, 416, 416, 23, 36},
  {cont__compiler__body__to_string_67, &frame__compiler__body__to_string_58, 416, 416, 9, 40},
  {cont__compiler__body__to_string_69, &frame__compiler__body__to_string_58, 417, 423, 9, 68},
  {cont__compiler__body__to_string_78, &frame__compiler__body__to_string_58, 424, 424, 30, 43},
  {cont__compiler__body__to_string_79, &frame__compiler__body__to_string_58, 424, 424, 9, 47},
  {cont__compiler__body__to_string_80, &frame__compiler__body__to_string_58, },
  {entry__compiler__body__to_string_83, NULL, 428, 428, 11, 39},
  {entry__compiler__body__to_string_94, NULL, 441, 441, 27, 53},
  {cont__compiler__body__to_string_95, &frame__compiler__body__to_string_94, 441, 441, 27, 64},
  {cont__compiler__body__to_string_96, &frame__compiler__body__to_string_94, 441, 441, 27, 64},
  {entry__compiler__body__to_string_90, NULL, 440, 440, 27, 54},
  {cont__compiler__body__to_string_91, &frame__compiler__body__to_string_90, 440, 440, 27, 70},
  {cont__compiler__body__to_string_92, &frame__compiler__body__to_string_90, 440, 440, 27, 70},
  {cont__compiler__body__to_string_93, &frame__compiler__body__to_string_90, 439, 441, 25, 64},
  {cont__compiler__body__to_string_97, &frame__compiler__body__to_string_90, 438, 441, 23, 65},
  {entry__compiler__body__to_string_89, NULL, },
  {cont__compiler__body__to_string_98, &frame__compiler__body__to_string_89, },
  {cont__compiler__body__to_string_99, &frame__compiler__body__to_string_89, },
  {entry__compiler__body__to_string_102, NULL, 444, 444, 22, 47},
  {cont__compiler__body__to_string_103, &frame__compiler__body__to_string_102, 444, 444, 22, 56},
  {cont__compiler__body__to_string_104, &frame__compiler__body__to_string_102, 444, 444, 19, 56},
  {entry__compiler__body__to_string_101, NULL, },
  {cont__compiler__body__to_string_105, &frame__compiler__body__to_string_101, },
  {entry__compiler__body__to_string_86, NULL, 434, 434, 17, 37},
  {cont__compiler__body__to_string_87, &frame__compiler__body__to_string_86, 434, 434, 17, 42},
  {cont__compiler__body__to_string_88, &frame__compiler__body__to_string_86, 433, 441, 15, 69},
  {cont__compiler__body__to_string_100, &frame__compiler__body__to_string_86, },
  {cont__compiler__body__to_string_106, &frame__compiler__body__to_string_86, },
  {entry__compiler__body__to_string_108, NULL, 448, 448, 15, 38},
  {entry__compiler__body__to_string_109, NULL, 450, 450, 15, 39},
  {entry__compiler__body__to_string_84, NULL, 432, 432, 15, 35},
  {cont__compiler__body__to_string_85, &frame__compiler__body__to_string_84, 430, 444, 11, 59},
  {cont__compiler__body__to_string_107, &frame__compiler__body__to_string_84, 446, 450, 11, 40},
  {entry__compiler__body__to_string_113, NULL, 457, 458, 13, 17},
  {cont__compiler__body__to_string_115, &frame__compiler__body__to_string_113, 458, 458, 18, 18},
  {entry__compiler__body__to_string_125, NULL, 473, 473, 21, 59},
  {cont__compiler__body__to_string_126, &frame__compiler__body__to_string_125, 473, 473, 21, 59},
  {cont__compiler__body__to_string_127, &frame__compiler__body__to_string_125, 473, 473, 21, 59},
  {entry__compiler__body__to_string_123, NULL, 472, 472, 21, 43},
  {cont__compiler__body__to_string_124, &frame__compiler__body__to_string_123, 471, 473, 19, 59},
  {cont__compiler__body__to_string_128, &frame__compiler__body__to_string_123, 471, 473, 19, 59},
  {entry__compiler__body__to_string_130, NULL, 475, 475, 19, 33},
  {cont__compiler__body__to_string_131, &frame__compiler__body__to_string_130, 475, 475, 33, 33},
  {entry__compiler__body__to_string_138, NULL, 482, 482, 21, 34},
  {cont__compiler__body__to_string_139, &frame__compiler__body__to_string_138, 482, 482, 21, 36},
  {cont__compiler__body__to_string_140, &frame__compiler__body__to_string_138, 482, 482, 38, 51},
  {cont__compiler__body__to_string_141, &frame__compiler__body__to_string_138, 482, 482, 21, 51},
  {cont__compiler__body__to_string_142, &frame__compiler__body__to_string_138, 481, 483, 19, 51},
  {cont__compiler__body__to_string_143, &frame__compiler__body__to_string_138, 481, 483, 19, 51},
  {entry__compiler__body__to_string_136, NULL, 480, 480, 19, 39},
  {cont__compiler__body__to_string_137, &frame__compiler__body__to_string_136, 481, 483, 19, 51},
  {cont__compiler__body__to_string_144, &frame__compiler__body__to_string_136, },
  {entry__compiler__body__to_string_134, NULL, 479, 479, 19, 39},
  {cont__compiler__body__to_string_135, &frame__compiler__body__to_string_134, },
  {cont__compiler__body__to_string_145, &frame__compiler__body__to_string_134, },
  {entry__compiler__body__to_string_147, NULL, 485, 485, 19, 54},
  {cont__compiler__body__to_string_148, &frame__compiler__body__to_string_147, 485, 485, 54, 54},
  {entry__compiler__body__to_string_149, NULL, 487, 487, 19, 39},
  {cont__compiler__body__to_string_150, &frame__compiler__body__to_string_149, 487, 487, 39, 39},
  {entry__compiler__body__to_string_120, NULL, 467, 467, 15, 38},
  {cont__compiler__body__to_string_121, &frame__compiler__body__to_string_120, 470, 470, 19, 25},
  {cont__compiler__body__to_string_122, &frame__compiler__body__to_string_120, 469, 473, 17, 60},
  {cont__compiler__body__to_string_129, &frame__compiler__body__to_string_120, 468, 475, 15, 34},
  {cont__compiler__body__to_string_132, &frame__compiler__body__to_string_120, 478, 478, 19, 23},
  {cont__compiler__body__to_string_133, &frame__compiler__body__to_string_120, },
  {cont__compiler__body__to_string_146, &frame__compiler__body__to_string_120, 476, 487, 15, 40},
  {entry__compiler__body__to_string_116, NULL, 461, 461, 13, 43},
  {cont__compiler__body__to_string_117, &frame__compiler__body__to_string_116, 462, 462, 13, 36},
  {cont__compiler__body__to_string_118, &frame__compiler__body__to_string_116, 464, 464, 22, 40},
  {cont__compiler__body__to_string_119, &frame__compiler__body__to_string_116, 464, 487, 13, 41},
  {cont__compiler__body__to_string_151, &frame__compiler__body__to_string_116, 487, 487, 41, 41},
  {entry__compiler__body__to_string_111, NULL, 454, 454, 9, 35},
  {cont__compiler__body__to_string_112, &frame__compiler__body__to_string_111, 455, 487, 9, 43},
  {cont__compiler__body__to_string_152, &frame__compiler__body__to_string_111, 487, 487, 43, 43},
  {entry__compiler__body__to_string_28, NULL, 427, 427, 9, 29},
  {cont__compiler__body__to_string_81, &frame__compiler__body__to_string_28, 427, 427, 9, 34},
  {cont__compiler__body__to_string_82, &frame__compiler__body__to_string_28, 426, 450, 7, 42},
  {cont__compiler__body__to_string_110, &frame__compiler__body__to_string_28, 452, 487, 7, 44},
  {cont__compiler__body__to_string_153, &frame__compiler__body__to_string_28, 488, 488, 7, 12},
  {entry__compiler__body__to_string_1, NULL, 366, 366, 3, 37},
  {cont__compiler__body__to_string_2, &frame__compiler__body__to_string_1, 367, 367, 3, 33},
  {cont__compiler__body__to_string_3, &frame__compiler__body__to_string_1, 370, 370, 7, 27},
  {cont__compiler__body__to_string_4, &frame__compiler__body__to_string_1, 370, 370, 7, 32},
  {cont__compiler__body__to_string_5, &frame__compiler__body__to_string_1, },
  {cont__compiler__body__to_string_15, &frame__compiler__body__to_string_1, 368, 488, 3, 13},
  {entry__argument_to_string_6, NULL, 501, 501, 11, 38},
  {cont__argument_to_string_7, &frame__argument_to_string_6, 501, 501, 11, 38},
  {entry__argument_to_string_4, NULL, 500, 500, 11, 38},
  {cont__argument_to_string_5, &frame__argument_to_string_4, 501, 501, 11, 38},
  {cont__argument_to_string_8, &frame__argument_to_string_4, },
  {entry__argument_to_string_10, NULL, 503, 503, 9, 16},
  {entry__argument_to_string_11, NULL, 502, 502, 9, 20},
  {entry__argument_to_string_19, NULL, 509, 509, 11, 34},
  {cont__argument_to_string_20, &frame__argument_to_string_19, 509, 509, 34, 34},
  {entry__argument_to_string_16, NULL, 508, 508, 12, 34},
  {cont__argument_to_string_17, &frame__argument_to_string_16, 508, 508, 12, 55},
  {cont__argument_to_string_18, &frame__argument_to_string_16, 508, 509, 9, 34},
  {cont__argument_to_string_21, &frame__argument_to_string_16, 510, 510, 9, 21},
  {cont__argument_to_string_22, &frame__argument_to_string_16, 510, 510, 21, 21},
  {entry__argument_to_string_14, NULL, 507, 507, 10, 37},
  {cont__argument_to_string_15, &frame__argument_to_string_14, 507, 510, 7, 21},
  {entry__argument_to_string_28, NULL, 513, 513, 11, 34},
  {cont__argument_to_string_29, &frame__argument_to_string_28, 513, 513, 34, 34},
  {entry__argument_to_string_25, NULL, 512, 512, 12, 34},
  {cont__argument_to_string_26, &frame__argument_to_string_25, 512, 512, 12, 55},
  {cont__argument_to_string_27, &frame__argument_to_string_25, 512, 513, 9, 34},
  {cont__argument_to_string_30, &frame__argument_to_string_25, 514, 514, 9, 21},
  {cont__argument_to_string_31, &frame__argument_to_string_25, 514, 514, 21, 21},
  {entry__argument_to_string_23, NULL, 511, 511, 10, 37},
  {cont__argument_to_string_24, &frame__argument_to_string_23, 511, 514, 7, 21},
  {entry__argument_to_string_38, NULL, 517, 517, 56, 71},
  {cont__argument_to_string_39, &frame__argument_to_string_38, 517, 517, 56, 71},
  {cont__argument_to_string_40, &frame__argument_to_string_38, 517, 517, 56, 71},
  {entry__argument_to_string_35, NULL, 517, 517, 36, 51},
  {cont__argument_to_string_36, &frame__argument_to_string_35, 517, 517, 36, 51},
  {cont__argument_to_string_37, &frame__argument_to_string_35, 517, 517, 36, 71},
  {cont__argument_to_string_41, &frame__argument_to_string_35, 517, 517, 36, 71},
  {entry__argument_to_string_45, NULL, 521, 521, 14, 28},
  {cont__argument_to_string_46, &frame__argument_to_string_45, 521, 521, 11, 28},
  {entry__argument_to_string_47, NULL, 522, 522, 14, 28},
  {cont__argument_to_string_48, &frame__argument_to_string_47, 522, 522, 11, 28},
  {entry__argument_to_string_43, NULL, 520, 520, 11, 46},
  {cont__argument_to_string_44, &frame__argument_to_string_43, 522, 522, 11, 28},
  {cont__argument_to_string_49, &frame__argument_to_string_43, 518, 522, 7, 29},
  {entry__argument_to_string_50, NULL, 523, 523, 7, 12},
  {entry__argument_to_string_2, NULL, 499, 499, 11, 35},
  {cont__argument_to_string_3, &frame__argument_to_string_2, },
  {cont__argument_to_string_9, &frame__argument_to_string_2, 496, 503, 5, 17},
  {cont__argument_to_string_12, &frame__argument_to_string_2, 505, 505, 5, 28},
  {cont__argument_to_string_13, &frame__argument_to_string_2, 506, 514, 5, 22},
  {cont__argument_to_string_32, &frame__argument_to_string_2, 515, 515, 5, 21},
  {cont__argument_to_string_33, &frame__argument_to_string_2, 517, 517, 7, 31},
  {cont__argument_to_string_34, &frame__argument_to_string_2, 517, 517, 7, 71},
  {cont__argument_to_string_42, &frame__argument_to_string_2, 516, 523, 5, 12},
  {cont__argument_to_string_51, &frame__argument_to_string_2, 523, 523, 12, 12},
  {entry__argument_to_string_1, NULL, 495, 523, 3, 13},
  {entry__arguments_to_string_8, NULL, 592, 592, 47, 52},
  {cont__arguments_to_string_9, &frame__arguments_to_string_8, 592, 592, 47, 62},
  {cont__arguments_to_string_10, &frame__arguments_to_string_8, 592, 592, 47, 62},
  {entry__arguments_to_string_5, NULL, 592, 592, 30, 35},
  {cont__arguments_to_string_6, &frame__arguments_to_string_5, 592, 592, 30, 42},
  {cont__arguments_to_string_7, &frame__arguments_to_string_5, 592, 592, 30, 62},
  {cont__arguments_to_string_11, &frame__arguments_to_string_5, 592, 592, 30, 62},
  {entry__arguments_to_string_13, NULL, 592, 592, 65, 77},
  {cont__arguments_to_string_14, &frame__arguments_to_string_13, 592, 592, 77, 77},
  {entry__arguments_to_string_20, NULL, 594, 594, 49, 69},
  {cont__arguments_to_string_21, &frame__arguments_to_string_20, 594, 594, 45, 70},
  {cont__arguments_to_string_22, &frame__arguments_to_string_20, 594, 594, 45, 70},
  {entry__arguments_to_string_17, NULL, 594, 594, 20, 40},
  {cont__arguments_to_string_19, &frame__arguments_to_string_17, 594, 594, 20, 70},
  {cont__arguments_to_string_23, &frame__arguments_to_string_17, 594, 594, 20, 70},
  {entry__arguments_to_string_25, NULL, 595, 595, 11, 23},
  {cont__arguments_to_string_26, &frame__arguments_to_string_25, 596, 596, 11, 25},
  {cont__arguments_to_string_27, &frame__arguments_to_string_25, 597, 597, 11, 23},
  {cont__arguments_to_string_28, &frame__arguments_to_string_25, 597, 597, 23, 23},
  {entry__arguments_to_string_29, NULL, 599, 599, 11, 25},
  {cont__arguments_to_string_30, &frame__arguments_to_string_29, 599, 599, 25, 25},
  {entry__arguments_to_string_3, NULL, 592, 592, 14, 25},
  {cont__arguments_to_string_4, &frame__arguments_to_string_3, 592, 592, 14, 62},
  {cont__arguments_to_string_12, &frame__arguments_to_string_3, 592, 592, 7, 77},
  {cont__arguments_to_string_15, &frame__arguments_to_string_3, 594, 594, 9, 15},
  {cont__arguments_to_string_16, &frame__arguments_to_string_3, 594, 594, 9, 70},
  {cont__arguments_to_string_24, &frame__arguments_to_string_3, 593, 599, 7, 26},
  {entry__arguments_to_string_2, NULL, 591, 599, 5, 27},
  {entry__arguments_to_string_50, NULL, 618, 618, 17, 26},
  {entry__arguments_to_string_51, NULL, 619, 619, 17, 27},
  {entry__arguments_to_string_43, NULL, 615, 615, 33, 37},
  {cont__arguments_to_string_44, &frame__arguments_to_string_43, 615, 615, 25, 38},
  {cont__arguments_to_string_45, &frame__arguments_to_string_43, 615, 615, 15, 39},
  {cont__arguments_to_string_46, &frame__arguments_to_string_43, },
  {cont__arguments_to_string_47, &frame__arguments_to_string_43, 617, 617, 17, 22},
  {cont__arguments_to_string_48, &frame__arguments_to_string_43, 617, 617, 17, 29},
  {cont__arguments_to_string_49, &frame__arguments_to_string_43, },
  {cont__arguments_to_string_52, &frame__arguments_to_string_43, },
  {cont__arguments_to_string_53, &frame__arguments_to_string_43, 620, 620, 38, 38},
  {cont__arguments_to_string_54, &frame__arguments_to_string_43, 620, 620, 25, 39},
  {cont__arguments_to_string_55, &frame__arguments_to_string_43, 620, 620, 25, 62},
  {cont__arguments_to_string_56, &frame__arguments_to_string_43, 620, 620, 15, 63},
  {cont__arguments_to_string_57, &frame__arguments_to_string_43, },
  {cont__arguments_to_string_58, &frame__arguments_to_string_43, 612, 621, 11, 22},
  {cont__arguments_to_string_59, &frame__arguments_to_string_43, 612, 621, 11, 22},
  {cont__arguments_to_string_60, &frame__arguments_to_string_43, 612, 621, 11, 22},
  {entry__arguments_to_string_38, NULL, 611, 611, 23, 27},
  {cont__arguments_to_string_39, &frame__arguments_to_string_38, 611, 611, 15, 28},
  {cont__arguments_to_string_40, &frame__arguments_to_string_38, 611, 611, 15, 46},
  {cont__arguments_to_string_41, &frame__arguments_to_string_38, 611, 611, 11, 47},
  {cont__arguments_to_string_42, &frame__arguments_to_string_38, 612, 621, 11, 22},
  {cont__arguments_to_string_61, &frame__arguments_to_string_38, },
  {entry__arguments_to_string_34, NULL, 610, 610, 50, 66},
  {cont__arguments_to_string_35, &frame__arguments_to_string_34, 610, 610, 29, 66},
  {cont__arguments_to_string_36, &frame__arguments_to_string_34, 610, 610, 11, 66},
  {cont__arguments_to_string_37, &frame__arguments_to_string_34, },
  {cont__arguments_to_string_62, &frame__arguments_to_string_34, },
  {entry__arguments_to_string_67, NULL, 623, 623, 34, 46},
  {cont__arguments_to_string_68, &frame__arguments_to_string_67, 623, 623, 46, 46},
  {entry__arguments_to_string_64, NULL, 623, 623, 14, 19},
  {cont__arguments_to_string_65, &frame__arguments_to_string_64, 623, 623, 14, 31},
  {cont__arguments_to_string_66, &frame__arguments_to_string_64, 623, 623, 11, 46},
  {cont__arguments_to_string_69, &frame__arguments_to_string_64, 624, 624, 36, 36},
  {cont__arguments_to_string_70, &frame__arguments_to_string_64, 624, 624, 23, 37},
  {cont__arguments_to_string_71, &frame__arguments_to_string_64, 624, 624, 11, 37},
  {cont__arguments_to_string_72, &frame__arguments_to_string_64, 625, 625, 47, 47},
  {entry__arguments_to_string_75, NULL, 627, 627, 29, 34},
  {cont__arguments_to_string_76, &frame__arguments_to_string_75, 627, 627, 29, 41},
  {cont__arguments_to_string_77, &frame__arguments_to_string_75, 627, 627, 29, 41},
  {entry__arguments_to_string_79, NULL, 627, 627, 44, 59},
  {cont__arguments_to_string_80, &frame__arguments_to_string_79, 627, 627, 59, 59},
  {entry__arguments_to_string_84, NULL, 629, 629, 13, 28},
  {cont__arguments_to_string_85, &frame__arguments_to_string_84, 630, 630, 13, 35},
  {cont__arguments_to_string_86, &frame__arguments_to_string_84, 630, 630, 35, 35},
  {entry__arguments_to_string_90, NULL, 632, 632, 25, 30},
  {cont__arguments_to_string_91, &frame__arguments_to_string_90, 632, 632, 25, 37},
  {cont__arguments_to_string_92, &frame__arguments_to_string_90, 632, 632, 25, 37},
  {entry__arguments_to_string_94, NULL, 632, 632, 40, 55},
  {cont__arguments_to_string_95, &frame__arguments_to_string_94, 632, 632, 55, 55},
  {entry__arguments_to_string_108, NULL, 638, 638, 19, 39},
  {cont__arguments_to_string_109, &frame__arguments_to_string_108, 638, 638, 15, 40},
  {cont__arguments_to_string_110, &frame__arguments_to_string_108, 638, 638, 15, 40},
  {entry__arguments_to_string_104, NULL, 637, 637, 19, 47},
  {cont__arguments_to_string_106, &frame__arguments_to_string_104, 637, 637, 15, 48},
  {cont__arguments_to_string_107, &frame__arguments_to_string_104, 638, 638, 15, 40},
  {cont__arguments_to_string_111, &frame__arguments_to_string_104, },
  {entry__arguments_to_string_100, NULL, 636, 636, 15, 20},
  {cont__arguments_to_string_101, &frame__arguments_to_string_100, 636, 636, 15, 27},
  {cont__arguments_to_string_102, &frame__arguments_to_string_100, 636, 636, 15, 27},
  {cont__arguments_to_string_103, &frame__arguments_to_string_100, },
  {cont__arguments_to_string_112, &frame__arguments_to_string_100, },
  {entry__arguments_to_string_73, NULL, 627, 627, 14, 24},
  {cont__arguments_to_string_74, &frame__arguments_to_string_73, 627, 627, 14, 41},
  {cont__arguments_to_string_78, &frame__arguments_to_string_73, 627, 627, 11, 59},
  {cont__arguments_to_string_81, &frame__arguments_to_string_73, 628, 628, 18, 23},
  {cont__arguments_to_string_82, &frame__arguments_to_string_73, 628, 628, 18, 33},
  {cont__arguments_to_string_83, &frame__arguments_to_string_73, 628, 630, 11, 35},
  {cont__arguments_to_string_87, &frame__arguments_to_string_73, 631, 631, 11, 25},
  {cont__arguments_to_string_88, &frame__arguments_to_string_73, 632, 632, 14, 20},
  {cont__arguments_to_string_89, &frame__arguments_to_string_73, 632, 632, 14, 37},
  {cont__arguments_to_string_93, &frame__arguments_to_string_73, 632, 632, 11, 55},
  {cont__arguments_to_string_96, &frame__arguments_to_string_73, 635, 635, 15, 20},
  {cont__arguments_to_string_97, &frame__arguments_to_string_73, 635, 635, 15, 27},
  {cont__arguments_to_string_98, &frame__arguments_to_string_73, 635, 635, 15, 27},
  {cont__arguments_to_string_99, &frame__arguments_to_string_73, 633, 638, 11, 41},
  {cont__arguments_to_string_113, &frame__arguments_to_string_73, 638, 638, 42, 42},
  {entry__arguments_to_string_33, NULL, },
  {cont__arguments_to_string_63, &frame__arguments_to_string_33, 607, 638, 7, 43},
  {entry__arguments_to_string_31, NULL, 602, 602, 5, 42},
  {cont__arguments_to_string_32, &frame__arguments_to_string_31, 604, 638, 5, 44},
  {entry__arguments_to_string_116, NULL, 534, 534, 26, 34},
  {entry__arguments_to_string_123, NULL, 545, 545, 25, 36},
  {cont__arguments_to_string_124, &frame__arguments_to_string_123, 545, 545, 25, 63},
  {cont__arguments_to_string_125, &frame__arguments_to_string_123, 545, 545, 25, 63},
  {entry__arguments_to_string_129, NULL, 546, 546, 25, 51},
  {cont__arguments_to_string_130, &frame__arguments_to_string_129, 546, 546, 25, 51},
  {entry__arguments_to_string_137, NULL, 548, 548, 22, 39},
  {cont__arguments_to_string_138, &frame__arguments_to_string_137, 548, 548, 44, 44},
  {cont__arguments_to_string_139, &frame__arguments_to_string_137, 548, 548, 16, 45},
  {cont__arguments_to_string_140, &frame__arguments_to_string_137, 548, 548, 9, 56},
  {cont__arguments_to_string_141, &frame__arguments_to_string_137, 548, 548, 9, 56},
  {entry__arguments_to_string_132, NULL, 547, 547, 22, 39},
  {cont__arguments_to_string_133, &frame__arguments_to_string_132, 547, 547, 44, 44},
  {cont__arguments_to_string_134, &frame__arguments_to_string_132, 547, 547, 16, 45},
  {cont__arguments_to_string_135, &frame__arguments_to_string_132, 547, 547, 9, 58},
  {cont__arguments_to_string_136, &frame__arguments_to_string_132, 548, 548, 9, 56},
  {cont__arguments_to_string_142, &frame__arguments_to_string_132, },
  {entry__arguments_to_string_127, NULL, 546, 546, 9, 20},
  {cont__arguments_to_string_128, &frame__arguments_to_string_127, 546, 546, 9, 51},
  {cont__arguments_to_string_131, &frame__arguments_to_string_127, },
  {cont__arguments_to_string_143, &frame__arguments_to_string_127, },
  {entry__arguments_to_string_121, NULL, 545, 545, 9, 20},
  {cont__arguments_to_string_122, &frame__arguments_to_string_121, 545, 545, 9, 63},
  {cont__arguments_to_string_126, &frame__arguments_to_string_121, },
  {cont__arguments_to_string_144, &frame__arguments_to_string_121, },
  {entry__arguments_to_string_152, NULL, 557, 557, 11, 36},
  {cont__arguments_to_string_153, &frame__arguments_to_string_152, 557, 557, 11, 36},
  {entry__arguments_to_string_150, NULL, 556, 556, 11, 39},
  {cont__arguments_to_string_151, &frame__arguments_to_string_150, 557, 557, 11, 36},
  {cont__arguments_to_string_154, &frame__arguments_to_string_150, },
  {entry__arguments_to_string_148, NULL, 555, 555, 11, 18},
  {cont__arguments_to_string_149, &frame__arguments_to_string_148, },
  {cont__arguments_to_string_155, &frame__arguments_to_string_148, },
  {entry__arguments_to_string_157, NULL, 558, 558, 12, 38},
  {cont__arguments_to_string_158, &frame__arguments_to_string_157, 558, 558, 9, 38},
  {entry__arguments_to_string_159, NULL, 559, 559, 9, 12},
  {entry__arguments_to_string_165, NULL, 564, 564, 28, 33},
  {cont__arguments_to_string_166, &frame__arguments_to_string_165, 564, 564, 28, 43},
  {cont__arguments_to_string_167, &frame__arguments_to_string_165, 564, 564, 28, 43},
  {entry__arguments_to_string_173, NULL, 566, 566, 41, 60},
  {cont__arguments_to_string_174, &frame__arguments_to_string_173, 566, 566, 41, 60},
  {entry__arguments_to_string_171, NULL, 566, 566, 29, 36},
  {cont__arguments_to_string_172, &frame__arguments_to_string_171, 566, 566, 29, 60},
  {cont__arguments_to_string_175, &frame__arguments_to_string_171, 566, 566, 29, 60},
  {entry__arguments_to_string_177, NULL, 567, 567, 36, 36},
  {entry__arguments_to_string_178, NULL, 569, 569, 41, 41},
  {entry__arguments_to_string_169, NULL, 566, 566, 13, 24},
  {cont__arguments_to_string_170, &frame__arguments_to_string_169, 566, 566, 13, 60},
  {cont__arguments_to_string_176, &frame__arguments_to_string_169, 565, 569, 11, 42},
  {entry__arguments_to_string_163, NULL, 564, 564, 12, 23},
  {cont__arguments_to_string_164, &frame__arguments_to_string_163, 564, 564, 12, 43},
  {cont__arguments_to_string_168, &frame__arguments_to_string_163, 564, 569, 9, 43},
  {entry__arguments_to_string_183, NULL, 573, 573, 32, 38},
  {cont__arguments_to_string_184, &frame__arguments_to_string_183, 573, 573, 32, 38},
  {entry__arguments_to_string_186, NULL, 573, 573, 41, 76},
  {cont__arguments_to_string_187, &frame__arguments_to_string_186, 573, 573, 76, 76},
  {entry__arguments_to_string_192, NULL, 575, 575, 39, 78},
  {cont__arguments_to_string_193, &frame__arguments_to_string_192, 575, 575, 78, 78},
  {entry__arguments_to_string_196, NULL, 576, 576, 74, 74},
  {entry__arguments_to_string_181, NULL, 573, 573, 16, 27},
  {cont__arguments_to_string_182, &frame__arguments_to_string_181, 573, 573, 16, 38},
  {cont__arguments_to_string_185, &frame__arguments_to_string_181, 573, 573, 13, 76},
  {cont__arguments_to_string_188, &frame__arguments_to_string_181, 574, 574, 32, 45},
  {cont__arguments_to_string_189, &frame__arguments_to_string_181, 574, 574, 13, 45},
  {cont__arguments_to_string_190, &frame__arguments_to_string_181, 575, 575, 16, 36},
  {cont__arguments_to_string_191, &frame__arguments_to_string_181, 575, 575, 13, 78},
  {cont__arguments_to_string_194, &frame__arguments_to_string_181, 576, 576, 16, 45},
  {cont__arguments_to_string_195, &frame__arguments_to_string_181, 576, 576, 13, 74},
  {entry__arguments_to_string_199, NULL, 578, 578, 33, 39},
  {cont__arguments_to_string_200, &frame__arguments_to_string_199, 578, 578, 33, 39},
  {entry__arguments_to_string_202, NULL, 578, 578, 45, 50},
  {cont__arguments_to_string_203, &frame__arguments_to_string_202, 578, 578, 45, 57},
  {cont__arguments_to_string_204, &frame__arguments_to_string_202, 578, 578, 45, 57},
  {cont__arguments_to_string_205, &frame__arguments_to_string_202, 578, 578, 45, 57},
  {entry__arguments_to_string_207, NULL, 579, 579, 15, 50},
  {cont__arguments_to_string_208, &frame__arguments_to_string_207, 579, 579, 50, 50},
  {entry__arguments_to_string_215, NULL, 583, 583, 33, 52},
  {cont__arguments_to_string_216, &frame__arguments_to_string_215, 583, 583, 33, 52},
  {entry__arguments_to_string_218, NULL, 584, 584, 40, 40},
  {entry__arguments_to_string_219, NULL, 586, 586, 45, 45},
  {entry__arguments_to_string_213, NULL, 583, 583, 17, 28},
  {cont__arguments_to_string_214, &frame__arguments_to_string_213, 583, 583, 17, 52},
  {cont__arguments_to_string_217, &frame__arguments_to_string_213, 582, 586, 15, 46},
  {entry__arguments_to_string_197, NULL, 578, 578, 17, 28},
  {cont__arguments_to_string_198, &frame__arguments_to_string_197, 578, 578, 17, 39},
  {cont__arguments_to_string_201, &frame__arguments_to_string_197, 578, 578, 17, 57},
  {cont__arguments_to_string_206, &frame__arguments_to_string_197, 578, 579, 13, 50},
  {cont__arguments_to_string_209, &frame__arguments_to_string_197, 580, 580, 32, 45},
  {cont__arguments_to_string_210, &frame__arguments_to_string_197, 580, 580, 13, 45},
  {cont__arguments_to_string_211, &frame__arguments_to_string_197, 581, 581, 16, 45},
  {cont__arguments_to_string_212, &frame__arguments_to_string_197, 581, 586, 13, 47},
  {entry__arguments_to_string_179, NULL, 572, 572, 11, 17},
  {cont__arguments_to_string_180, &frame__arguments_to_string_179, 571, 586, 9, 49},
  {entry__arguments_to_string_146, NULL, 554, 554, 11, 22},
  {cont__arguments_to_string_147, &frame__arguments_to_string_146, },
  {cont__arguments_to_string_156, &frame__arguments_to_string_146, 551, 559, 5, 13},
  {cont__arguments_to_string_160, &frame__arguments_to_string_146, 561, 561, 5, 37},
  {cont__arguments_to_string_161, &frame__arguments_to_string_146, 563, 563, 7, 27},
  {cont__arguments_to_string_162, &frame__arguments_to_string_146, 562, 586, 5, 51},
  {cont__arguments_to_string_220, &frame__arguments_to_string_146, 587, 587, 5, 21},
  {cont__arguments_to_string_221, &frame__arguments_to_string_146, },
  {entry__arguments_to_string_225, NULL, 651, 651, 39, 60},
  {cont__arguments_to_string_226, &frame__arguments_to_string_225, 651, 651, 32, 77},
  {cont__arguments_to_string_227, &frame__arguments_to_string_225, 651, 651, 28, 78},
  {cont__arguments_to_string_228, &frame__arguments_to_string_225, 651, 651, 28, 78},
  {entry__arguments_to_string_230, NULL, 652, 652, 13, 37},
  {entry__arguments_to_string_231, NULL, 654, 654, 13, 43},
  {entry__arguments_to_string_224, NULL, 651, 651, 11, 78},
  {cont__arguments_to_string_229, &frame__arguments_to_string_224, 650, 654, 9, 44},
  {entry__arguments_to_string_244, NULL, 667, 667, 15, 20},
  {entry__arguments_to_string_245, NULL, 669, 669, 15, 20},
  {entry__arguments_to_string_246, NULL, 671, 671, 15, 20},
  {entry__arguments_to_string_247, NULL, 673, 673, 15, 20},
  {entry__arguments_to_string_248, NULL, 675, 675, 15, 20},
  {entry__arguments_to_string_249, NULL, 677, 677, 15, 20},
  {entry__arguments_to_string_250, NULL, 679, 679, 15, 20},
  {entry__arguments_to_string_251, NULL, 680, 680, 15, 20},
  {entry__arguments_to_string_235, NULL, 666, 666, 20, 48},
  {cont__arguments_to_string_236, &frame__arguments_to_string_235, 666, 666, 15, 48},
  {cont__arguments_to_string_237, &frame__arguments_to_string_235, 668, 668, 15, 22},
  {cont__arguments_to_string_238, &frame__arguments_to_string_235, 672, 672, 51, 63},
  {cont__arguments_to_string_239, &frame__arguments_to_string_235, 672, 672, 26, 64},
  {cont__arguments_to_string_240, &frame__arguments_to_string_235, 672, 672, 15, 64},
  {cont__arguments_to_string_241, &frame__arguments_to_string_235, 674, 674, 25, 58},
  {cont__arguments_to_string_242, &frame__arguments_to_string_235, 674, 674, 15, 58},
  {cont__arguments_to_string_243, &frame__arguments_to_string_235, },
  {cont__arguments_to_string_252, &frame__arguments_to_string_235, 661, 680, 11, 21},
  {cont__arguments_to_string_253, &frame__arguments_to_string_235, 680, 680, 22, 22},
  {entry__arguments_to_string_279, NULL, 690, 690, 47, 49},
  {cont__arguments_to_string_280, &frame__arguments_to_string_279, 690, 690, 51, 62},
  {cont__arguments_to_string_281, &frame__arguments_to_string_279, 690, 690, 31, 62},
  {entry__arguments_to_string_283, NULL, 692, 692, 49, 57},
  {cont__arguments_to_string_284, &frame__arguments_to_string_283, 692, 692, 49, 59},
  {cont__arguments_to_string_285, &frame__arguments_to_string_283, 692, 692, 23, 59},
  {cont__arguments_to_string_286, &frame__arguments_to_string_283, 693, 693, 23, 37},
  {cont__arguments_to_string_287, &frame__arguments_to_string_283, 693, 693, 37, 37},
  {entry__arguments_to_string_291, NULL, 694, 694, 32, 58},
  {entry__arguments_to_string_277, NULL, 690, 690, 24, 28},
  {cont__arguments_to_string_278, &frame__arguments_to_string_277, 690, 690, 21, 62},
  {cont__arguments_to_string_282, &frame__arguments_to_string_277, 691, 693, 21, 37},
  {cont__arguments_to_string_288, &frame__arguments_to_string_277, 694, 694, 24, 29},
  {cont__arguments_to_string_289, &frame__arguments_to_string_277, 694, 694, 24, 29},
  {cont__arguments_to_string_290, &frame__arguments_to_string_277, 694, 694, 21, 58},
  {cont__arguments_to_string_292, &frame__arguments_to_string_277, 695, 695, 21, 24},
  {entry__arguments_to_string_270, NULL, 688, 688, 19, 39},
  {cont__arguments_to_string_271, &frame__arguments_to_string_270, 689, 689, 40, 57},
  {cont__arguments_to_string_272, &frame__arguments_to_string_270, 689, 689, 38, 57},
  {cont__arguments_to_string_273, &frame__arguments_to_string_270, 689, 689, 38, 59},
  {cont__arguments_to_string_274, &frame__arguments_to_string_270, 689, 689, 22, 60},
  {cont__arguments_to_string_275, &frame__arguments_to_string_270, 689, 689, 22, 71},
  {cont__arguments_to_string_276, &frame__arguments_to_string_270, 689, 695, 19, 24},
  {entry__arguments_to_string_262, NULL, 685, 685, 38, 46},
  {cont__arguments_to_string_263, &frame__arguments_to_string_262, 685, 685, 38, 48},
  {cont__arguments_to_string_264, &frame__arguments_to_string_262, 685, 685, 17, 49},
  {cont__arguments_to_string_265, &frame__arguments_to_string_262, 686, 686, 22, 24},
  {cont__arguments_to_string_266, &frame__arguments_to_string_262, 686, 686, 22, 26},
  {cont__arguments_to_string_267, &frame__arguments_to_string_262, 686, 686, 17, 40},
  {cont__arguments_to_string_268, &frame__arguments_to_string_262, 687, 687, 20, 26},
  {cont__arguments_to_string_269, &frame__arguments_to_string_262, 687, 695, 17, 25},
  {entry__arguments_to_string_257, NULL, 684, 684, 18, 26},
  {cont__arguments_to_string_258, &frame__arguments_to_string_257, 684, 684, 18, 28},
  {cont__arguments_to_string_259, &frame__arguments_to_string_257, 684, 684, 18, 33},
  {cont__arguments_to_string_260, &frame__arguments_to_string_257, 684, 684, 18, 33},
  {cont__arguments_to_string_261, &frame__arguments_to_string_257, 684, 695, 15, 26},
  {entry__arguments_to_string_256, NULL, 683, 695, 13, 27},
  {entry__arguments_to_string_255, NULL, 682, 695, 11, 28},
  {entry__arguments_to_string_234, NULL, 660, 680, 9, 22},
  {cont__arguments_to_string_254, &frame__arguments_to_string_234, 681, 695, 9, 29},
  {entry__arguments_to_string_296, NULL, 699, 699, 22, 41},
  {cont__arguments_to_string_297, &frame__arguments_to_string_296, 699, 699, 15, 54},
  {cont__arguments_to_string_298, &frame__arguments_to_string_296, 699, 699, 11, 55},
  {cont__arguments_to_string_299, &frame__arguments_to_string_296, 699, 699, 11, 55},
  {entry__arguments_to_string_301, NULL, 701, 701, 29, 40},
  {cont__arguments_to_string_302, &frame__arguments_to_string_301, 701, 701, 11, 40},
  {cont__arguments_to_string_303, &frame__arguments_to_string_301, 702, 702, 11, 37},
  {entry__arguments_to_string_304, NULL, 704, 704, 11, 27},
  {entry__arguments_to_string_223, NULL, 656, 656, 10, 15},
  {cont__arguments_to_string_232, &frame__arguments_to_string_223, 656, 656, 10, 15},
  {cont__arguments_to_string_233, &frame__arguments_to_string_223, 656, 695, 7, 30},
  {cont__arguments_to_string_293, &frame__arguments_to_string_223, 698, 698, 11, 22},
  {cont__arguments_to_string_294, &frame__arguments_to_string_223, 698, 698, 11, 34},
  {cont__arguments_to_string_295, &frame__arguments_to_string_223, 697, 699, 9, 55},
  {cont__arguments_to_string_300, &frame__arguments_to_string_223, 696, 704, 7, 28},
  {cont__arguments_to_string_305, &frame__arguments_to_string_223, 704, 704, 28, 28},
  {entry__arguments_to_string_307, NULL, 713, 713, 31, 33},
  {cont__arguments_to_string_308, &frame__arguments_to_string_307, 713, 713, 11, 33},
  {cont__arguments_to_string_309, &frame__arguments_to_string_307, 715, 715, 11, 37},
  {entry__arguments_to_string_310, NULL, 717, 717, 11, 31},
  {entry__arguments_to_string_306, NULL, 711, 717, 7, 32},
  {entry__arguments_to_string_317, NULL, 718, 718, 53, 53},
  {cont__arguments_to_string_318, &frame__arguments_to_string_317, 718, 718, 42, 54},
  {cont__arguments_to_string_319, &frame__arguments_to_string_317, 718, 718, 42, 66},
  {cont__arguments_to_string_320, &frame__arguments_to_string_317, 718, 718, 42, 66},
  {entry__arguments_to_string_313, NULL, 718, 718, 22, 27},
  {cont__arguments_to_string_314, &frame__arguments_to_string_313, 718, 718, 22, 37},
  {cont__arguments_to_string_315, &frame__arguments_to_string_313, 718, 718, 22, 37},
  {cont__arguments_to_string_316, &frame__arguments_to_string_313, 718, 718, 22, 66},
  {cont__arguments_to_string_321, &frame__arguments_to_string_313, 718, 718, 22, 66},
  {entry__arguments_to_string_323, NULL, 719, 719, 24, 48},
  {cont__arguments_to_string_324, &frame__arguments_to_string_323, 719, 719, 5, 53},
  {cont__arguments_to_string_325, &frame__arguments_to_string_323, 719, 719, 53, 53},
  {entry__arguments_to_string_333, NULL, 721, 721, 54, 59},
  {cont__arguments_to_string_334, &frame__arguments_to_string_333, 721, 721, 54, 69},
  {cont__arguments_to_string_335, &frame__arguments_to_string_333, 721, 721, 54, 69},
  {entry__arguments_to_string_330, NULL, 721, 721, 37, 42},
  {cont__arguments_to_string_331, &frame__arguments_to_string_330, 721, 721, 37, 49},
  {cont__arguments_to_string_332, &frame__arguments_to_string_330, 721, 721, 37, 69},
  {cont__arguments_to_string_336, &frame__arguments_to_string_330, 721, 721, 37, 69},
  {entry__arguments_to_string_328, NULL, 721, 721, 21, 32},
  {cont__arguments_to_string_329, &frame__arguments_to_string_328, 721, 721, 21, 69},
  {cont__arguments_to_string_337, &frame__arguments_to_string_328, 721, 721, 21, 69},
  {entry__arguments_to_string_339, NULL, 722, 722, 5, 10},
  {entry__arguments_to_string_340, NULL, 723, 723, 8, 19},
  {cont__arguments_to_string_341, &frame__arguments_to_string_340, 723, 723, 5, 19},
  {entry__arguments_to_string_1, NULL, 533, 533, 3, 31},
  {cont__arguments_to_string_114, &frame__arguments_to_string_1, 534, 534, 6, 23},
  {cont__arguments_to_string_115, &frame__arguments_to_string_1, 534, 534, 3, 34},
  {cont__arguments_to_string_117, &frame__arguments_to_string_1, 536, 536, 3, 25},
  {cont__arguments_to_string_118, &frame__arguments_to_string_1, 543, 543, 7, 29},
  {cont__arguments_to_string_119, &frame__arguments_to_string_1, 543, 543, 7, 29},
  {cont__arguments_to_string_120, &frame__arguments_to_string_1, 541, 548, 3, 58},
  {cont__arguments_to_string_145, &frame__arguments_to_string_1, 550, 587, 3, 21},
  {cont__arguments_to_string_222, &frame__arguments_to_string_1, 640, 717, 3, 34},
  {cont__arguments_to_string_311, &frame__arguments_to_string_1, 718, 718, 6, 17},
  {cont__arguments_to_string_312, &frame__arguments_to_string_1, 718, 718, 6, 66},
  {cont__arguments_to_string_322, &frame__arguments_to_string_1, 718, 719, 3, 53},
  {cont__arguments_to_string_326, &frame__arguments_to_string_1, 721, 721, 5, 16},
  {cont__arguments_to_string_327, &frame__arguments_to_string_1, 721, 721, 5, 69},
  {cont__arguments_to_string_338, &frame__arguments_to_string_1, 720, 723, 3, 19},
  {cont__arguments_to_string_342, &frame__arguments_to_string_1, 723, 723, 19, 19},
  {entry__compiler__call__to_string_5, NULL, 733, 733, 11, 19},
  {entry__compiler__call__to_string_6, NULL, 734, 734, 14, 21},
  {cont__compiler__call__to_string_7, &frame__compiler__call__to_string_6, 734, 734, 11, 21},
  {entry__compiler__call__to_string_3, NULL, 732, 732, 11, 45},
  {cont__compiler__call__to_string_4, &frame__compiler__call__to_string_3, 730, 734, 7, 22},
  {cont__compiler__call__to_string_8, &frame__compiler__call__to_string_3, 736, 736, 34, 50},
  {cont__compiler__call__to_string_9, &frame__compiler__call__to_string_3, 736, 736, 7, 59},
  {cont__compiler__call__to_string_10, &frame__compiler__call__to_string_3, 737, 737, 7, 73},
  {cont__compiler__call__to_string_11, &frame__compiler__call__to_string_3, 738, 738, 10, 31},
  {cont__compiler__call__to_string_12, &frame__compiler__call__to_string_3, 738, 738, 7, 31},
  {entry__compiler__call__to_string_29, NULL, 753, 753, 56, 56},
  {entry__compiler__call__to_string_27, NULL, 753, 753, 18, 33},
  {cont__compiler__call__to_string_28, &frame__compiler__call__to_string_27, 753, 753, 15, 56},
  {entry__compiler__call__to_string_32, NULL, 754, 754, 72, 72},
  {entry__compiler__call__to_string_30, NULL, 754, 754, 18, 49},
  {cont__compiler__call__to_string_31, &frame__compiler__call__to_string_30, 754, 754, 15, 72},
  {entry__compiler__call__to_string_35, NULL, 756, 756, 51, 51},
  {entry__compiler__call__to_string_33, NULL, 755, 755, 18, 58},
  {cont__compiler__call__to_string_34, &frame__compiler__call__to_string_33, 755, 756, 15, 51},
  {entry__compiler__call__to_string_17, NULL, 747, 747, 22, 39},
  {cont__compiler__call__to_string_18, &frame__compiler__call__to_string_17, 747, 747, 13, 42},
  {cont__compiler__call__to_string_19, &frame__compiler__call__to_string_17, 748, 748, 20, 36},
  {cont__compiler__call__to_string_20, &frame__compiler__call__to_string_17, 748, 748, 41, 41},
  {cont__compiler__call__to_string_21, &frame__compiler__call__to_string_17, 748, 748, 13, 41},
  {cont__compiler__call__to_string_22, &frame__compiler__call__to_string_17, 749, 749, 13, 57},
  {cont__compiler__call__to_string_23, &frame__compiler__call__to_string_17, 750, 750, 13, 39},
  {cont__compiler__call__to_string_24, &frame__compiler__call__to_string_17, 751, 751, 21, 38},
  {cont__compiler__call__to_string_25, &frame__compiler__call__to_string_17, 751, 751, 13, 41},
  {cont__compiler__call__to_string_26, &frame__compiler__call__to_string_17, 752, 756, 13, 52},
  {entry__compiler__call__to_string_36, NULL, 758, 758, 22, 37},
  {cont__compiler__call__to_string_37, &frame__compiler__call__to_string_36, 758, 758, 13, 47},
  {cont__compiler__call__to_string_38, &frame__compiler__call__to_string_36, 758, 758, 47, 47},
  {entry__compiler__call__to_string_15, NULL, 746, 746, 11, 31},
  {cont__compiler__call__to_string_16, &frame__compiler__call__to_string_15, 745, 758, 9, 48},
  {cont__compiler__call__to_string_39, &frame__compiler__call__to_string_15, 758, 758, 48, 48},
  {entry__compiler__call__to_string_45, NULL, 761, 761, 34, 60},
  {cont__compiler__call__to_string_46, &frame__compiler__call__to_string_45, 761, 761, 34, 60},
  {entry__compiler__call__to_string_48, NULL, 762, 762, 29, 29},
  {entry__compiler__call__to_string_13, NULL, 740, 740, 7, 33},
  {cont__compiler__call__to_string_14, &frame__compiler__call__to_string_13, 743, 758, 7, 49},
  {cont__compiler__call__to_string_40, &frame__compiler__call__to_string_13, 759, 759, 34, 50},
  {cont__compiler__call__to_string_41, &frame__compiler__call__to_string_13, 759, 759, 52, 69},
  {cont__compiler__call__to_string_42, &frame__compiler__call__to_string_13, 759, 759, 7, 69},
  {cont__compiler__call__to_string_43, &frame__compiler__call__to_string_13, 760, 760, 7, 73},
  {cont__compiler__call__to_string_44, &frame__compiler__call__to_string_13, 761, 761, 10, 60},
  {cont__compiler__call__to_string_47, &frame__compiler__call__to_string_13, 761, 762, 7, 29},
  {cont__compiler__call__to_string_49, &frame__compiler__call__to_string_13, 763, 763, 10, 34},
  {cont__compiler__call__to_string_50, &frame__compiler__call__to_string_13, 763, 763, 7, 34},
  {entry__compiler__call__to_string_1, NULL, 729, 729, 5, 20},
  {cont__compiler__call__to_string_2, &frame__compiler__call__to_string_1, 728, 763, 3, 35},
  {entry__definition_to_string_4, NULL, 767, 767, 63, 79},
  {cont__definition_to_string_6, &frame__definition_to_string_4, 767, 767, 79, 79},
  {entry__definition_to_string_16, NULL, 771, 771, 59, 71},
  {cont__definition_to_string_17, &frame__definition_to_string_16, 771, 771, 71, 71},
  {entry__definition_to_string_24, NULL, 776, 776, 33, 60},
  {cont__definition_to_string_25, &frame__definition_to_string_24, 776, 776, 13, 60},
  {cont__definition_to_string_26, &frame__definition_to_string_24, 776, 776, 60, 60},
  {entry__definition_to_string_27, NULL, 778, 778, 13, 25},
  {cont__definition_to_string_28, &frame__definition_to_string_27, 778, 778, 25, 25},
  {entry__definition_to_string_21, NULL, 775, 775, 11, 38},
  {cont__definition_to_string_22, &frame__definition_to_string_21, 775, 775, 11, 49},
  {cont__definition_to_string_23, &frame__definition_to_string_21, 774, 778, 9, 26},
  {entry__definition_to_string_19, NULL, 773, 773, 10, 39},
  {cont__definition_to_string_20, &frame__definition_to_string_19, 773, 778, 7, 27},
  {entry__definition_to_string_31, NULL, 779, 779, 42, 54},
  {cont__definition_to_string_32, &frame__definition_to_string_31, 779, 779, 54, 54},
  {entry__definition_to_string_29, NULL, 779, 779, 10, 39},
  {cont__definition_to_string_30, &frame__definition_to_string_29, 779, 779, 7, 54},
  {entry__definition_to_string_13, NULL, 771, 771, 8, 36},
  {cont__definition_to_string_14, &frame__definition_to_string_13, 771, 771, 8, 56},
  {cont__definition_to_string_15, &frame__definition_to_string_13, 771, 771, 5, 71},
  {cont__definition_to_string_18, &frame__definition_to_string_13, 772, 779, 5, 54},
  {entry__definition_to_string_1, NULL, 767, 767, 6, 34},
  {cont__definition_to_string_2, &frame__definition_to_string_1, 767, 767, 6, 60},
  {cont__definition_to_string_3, &frame__definition_to_string_1, 767, 767, 3, 79},
  {cont__definition_to_string_7, &frame__definition_to_string_1, 768, 768, 3, 20},
  {cont__definition_to_string_8, &frame__definition_to_string_1, 769, 769, 15, 39},
  {cont__definition_to_string_9, &frame__definition_to_string_1, 769, 769, 15, 49},
  {cont__definition_to_string_10, &frame__definition_to_string_1, 769, 769, 3, 49},
  {cont__definition_to_string_11, &frame__definition_to_string_1, 770, 770, 6, 30},
  {cont__definition_to_string_12, &frame__definition_to_string_1, 770, 779, 3, 55},
  {cont__definition_to_string_33, &frame__definition_to_string_1, 780, 780, 3, 8},
  {entry__compiler__define_static_single__to_string_4, NULL, 790, 790, 7, 11},
  {entry__compiler__define_static_single__to_string_5, NULL, 791, 791, 7, 12},
  {entry__compiler__define_static_single__to_string_10, NULL, 796, 796, 25, 42},
  {cont__compiler__define_static_single__to_string_11, &frame__compiler__define_static_single__to_string_10, 796, 796, 7, 42},
  {cont__compiler__define_static_single__to_string_12, &frame__compiler__define_static_single__to_string_10, 796, 796, 42, 42},
  {entry__compiler__define_static_single__to_string_17, NULL, 799, 799, 55, 72},
  {cont__compiler__define_static_single__to_string_18, &frame__compiler__define_static_single__to_string_17, 799, 799, 41, 72},
  {cont__compiler__define_static_single__to_string_19, &frame__compiler__define_static_single__to_string_17, 799, 799, 72, 72},
  {entry__compiler__define_static_single__to_string_13, NULL, 798, 798, 7, 19},
  {cont__compiler__define_static_single__to_string_14, &frame__compiler__define_static_single__to_string_13, 799, 799, 10, 27},
  {cont__compiler__define_static_single__to_string_15, &frame__compiler__define_static_single__to_string_13, 799, 799, 10, 38},
  {cont__compiler__define_static_single__to_string_16, &frame__compiler__define_static_single__to_string_13, 799, 799, 7, 72},
  {entry__compiler__define_static_single__to_string_1, NULL, 788, 788, 7, 29},
  {cont__compiler__define_static_single__to_string_2, &frame__compiler__define_static_single__to_string_1, 789, 789, 7, 60},
  {cont__compiler__define_static_single__to_string_3, &frame__compiler__define_static_single__to_string_1, 786, 791, 3, 13},
  {cont__compiler__define_static_single__to_string_7, &frame__compiler__define_static_single__to_string_1, 793, 793, 3, 40},
  {cont__compiler__define_static_single__to_string_8, &frame__compiler__define_static_single__to_string_1, 794, 794, 8, 30},
  {cont__compiler__define_static_single__to_string_9, &frame__compiler__define_static_single__to_string_1, 794, 799, 3, 73},
  {cont__compiler__define_static_single__to_string_20, &frame__compiler__define_static_single__to_string_1, 800, 800, 3, 30},
  {entry__compiler__define_static_multi__to_string_4, NULL, 810, 810, 7, 12},
  {entry__compiler__define_static_multi__to_string_5, NULL, 812, 812, 7, 12},
  {entry__compiler__define_static_multi__to_string_7, NULL, 814, 814, 7, 12},
  {entry__compiler__define_static_multi__to_string_9, NULL, 815, 815, 7, 13},
  {entry__compiler__define_static_multi__to_string_1, NULL, 808, 808, 7, 29},
  {cont__compiler__define_static_multi__to_string_2, &frame__compiler__define_static_multi__to_string_1, 809, 809, 7, 60},
  {cont__compiler__define_static_multi__to_string_3, &frame__compiler__define_static_multi__to_string_1, 806, 815, 3, 14},
  {cont__compiler__define_static_multi__to_string_11, &frame__compiler__define_static_multi__to_string_1, 817, 817, 28, 60},
  {cont__compiler__define_static_multi__to_string_12, &frame__compiler__define_static_multi__to_string_1, 817, 817, 3, 60},
  {entry__compiler__define_dynamic_single__to_string_1, NULL, 822, 822, 52, 80},
  {entry__compiler__define_dynamic_multi__to_string_1, NULL, 827, 827, 51, 80},
  {entry__precedence_of_3, NULL, 834, 834, 42, 59},
  {cont__precedence_of_4, &frame__precedence_of_3, 834, 834, 32, 60},
  {cont__precedence_of_5, &frame__precedence_of_3, 834, 834, 32, 65},
  {cont__precedence_of_6, &frame__precedence_of_3, 834, 834, 32, 65},
  {entry__precedence_of_11, NULL, 837, 837, 31, 46},
  {cont__precedence_of_12, &frame__precedence_of_11, 837, 837, 23, 47},
  {cont__precedence_of_13, &frame__precedence_of_11, 837, 837, 12, 48},
  {cont__precedence_of_14, &frame__precedence_of_11, 837, 837, 9, 48},
  {entry__precedence_of_17, NULL, 841, 841, 13, 31},
  {entry__precedence_of_18, NULL, 842, 842, 13, 33},
  {entry__precedence_of_15, NULL, 840, 840, 13, 37},
  {cont__precedence_of_16, &frame__precedence_of_15, 839, 842, 11, 33},
  {entry__precedence_of_8, NULL, 836, 836, 9, 24},
  {cont__precedence_of_9, &frame__precedence_of_8, 836, 836, 9, 46},
  {cont__precedence_of_10, &frame__precedence_of_8, 835, 842, 7, 35},
  {entry__precedence_of_19, NULL, 843, 843, 5, 25},
  {entry__precedence_of_1, NULL, 834, 834, 5, 27},
  {cont__precedence_of_2, &frame__precedence_of_1, 834, 834, 5, 65},
  {cont__precedence_of_7, &frame__precedence_of_1, 833, 843, 3, 25},
  {entry__operator_of_7, NULL, 850, 850, 7, 22},
  {cont__operator_of_8, &frame__operator_of_7, 850, 850, 7, 44},
  {cont__operator_of_9, &frame__operator_of_7, 850, 850, 7, 44},
  {entry__operator_of_3, NULL, 849, 849, 17, 34},
  {cont__operator_of_4, &frame__operator_of_3, 849, 849, 7, 35},
  {cont__operator_of_5, &frame__operator_of_3, 849, 849, 7, 40},
  {cont__operator_of_6, &frame__operator_of_3, 850, 850, 7, 44},
  {cont__operator_of_10, &frame__operator_of_3, },
  {entry__operator_of_12, NULL, 851, 851, 8, 23},
  {cont__operator_of_13, &frame__operator_of_12, 851, 851, 8, 33},
  {cont__operator_of_14, &frame__operator_of_12, 851, 851, 5, 33},
  {entry__operator_of_15, NULL, 852, 852, 5, 16},
  {entry__operator_of_1, NULL, 848, 848, 7, 29},
  {cont__operator_of_2, &frame__operator_of_1, },
  {cont__operator_of_11, &frame__operator_of_1, 846, 852, 3, 16},
  {entry__compiler__function_call__to_string_10, NULL, 879, 879, 24, 37},
  {cont__compiler__function_call__to_string_11, &frame__compiler__function_call__to_string_10, 879, 879, 10, 70},
  {cont__compiler__function_call__to_string_12, &frame__compiler__function_call__to_string_10, 879, 879, 7, 70},
  {entry__compiler__function_call__to_string_13, NULL, 880, 880, 10, 56},
  {cont__compiler__function_call__to_string_14, &frame__compiler__function_call__to_string_13, 880, 880, 7, 56},
  {entry__compiler__function_call__to_string_2, NULL, 869, 869, 5, 31},
  {cont__compiler__function_call__to_string_3, &frame__compiler__function_call__to_string_2, 875, 875, 9, 25},
  {cont__compiler__function_call__to_string_4, &frame__compiler__function_call__to_string_2, 875, 875, 27, 51},
  {cont__compiler__function_call__to_string_5, &frame__compiler__function_call__to_string_2, 875, 875, 9, 51},
  {cont__compiler__function_call__to_string_6, &frame__compiler__function_call__to_string_2, 875, 875, 9, 53},
  {cont__compiler__function_call__to_string_7, &frame__compiler__function_call__to_string_2, 871, 875, 5, 54},
  {cont__compiler__function_call__to_string_8, &frame__compiler__function_call__to_string_2, 878, 878, 7, 40},
  {cont__compiler__function_call__to_string_9, &frame__compiler__function_call__to_string_2, 877, 880, 5, 56},
  {cont__compiler__function_call__to_string_15, &frame__compiler__function_call__to_string_2, 880, 880, 56, 56},
  {entry__compiler__function_call__to_string_18, NULL, 865, 865, 19, 34},
  {cont__compiler__function_call__to_string_19, &frame__compiler__function_call__to_string_18, 865, 865, 9, 34},
  {cont__compiler__function_call__to_string_20, &frame__compiler__function_call__to_string_18, 865, 865, 34, 34},
  {entry__compiler__function_call__to_string_21, NULL, 866, 866, 7, 18},
  {entry__compiler__function_call__to_string_29, NULL, 889, 889, 12, 46},
  {cont__compiler__function_call__to_string_30, &frame__compiler__function_call__to_string_29, 889, 889, 9, 46},
  {entry__compiler__function_call__to_string_31, NULL, 890, 890, 12, 31},
  {cont__compiler__function_call__to_string_32, &frame__compiler__function_call__to_string_31, 890, 890, 9, 31},
  {entry__compiler__function_call__to_string_26, NULL, 886, 886, 7, 28},
  {cont__compiler__function_call__to_string_27, &frame__compiler__function_call__to_string_26, 888, 888, 9, 33},
  {cont__compiler__function_call__to_string_28, &frame__compiler__function_call__to_string_26, 887, 890, 7, 31},
  {cont__compiler__function_call__to_string_33, &frame__compiler__function_call__to_string_26, 890, 890, 31, 31},
  {entry__compiler__function_call__to_string_24, NULL, 884, 884, 8, 34},
  {cont__compiler__function_call__to_string_25, &frame__compiler__function_call__to_string_24, 884, 890, 5, 32},
  {entry__compiler__function_call__to_string_40, NULL, 894, 894, 9, 42},
  {cont__compiler__function_call__to_string_41, &frame__compiler__function_call__to_string_40, 894, 894, 42, 42},
  {entry__compiler__function_call__to_string_36, NULL, 892, 892, 7, 29},
  {cont__compiler__function_call__to_string_37, &frame__compiler__function_call__to_string_36, 893, 893, 10, 32},
  {cont__compiler__function_call__to_string_38, &frame__compiler__function_call__to_string_36, 893, 893, 10, 53},
  {cont__compiler__function_call__to_string_39, &frame__compiler__function_call__to_string_36, 893, 894, 7, 42},
  {cont__compiler__function_call__to_string_42, &frame__compiler__function_call__to_string_36, 895, 895, 10, 44},
  {cont__compiler__function_call__to_string_43, &frame__compiler__function_call__to_string_36, 895, 895, 7, 44},
  {entry__compiler__function_call__to_string_34, NULL, 891, 891, 8, 34},
  {cont__compiler__function_call__to_string_35, &frame__compiler__function_call__to_string_34, 891, 895, 5, 44},
  {entry__compiler__function_call__to_string_56, NULL, 904, 904, 13, 38},
  {cont__compiler__function_call__to_string_57, &frame__compiler__function_call__to_string_56, 904, 904, 38, 38},
  {entry__compiler__function_call__to_string_62, NULL, 906, 906, 13, 40},
  {cont__compiler__function_call__to_string_63, &frame__compiler__function_call__to_string_62, 906, 906, 40, 40},
  {entry__compiler__function_call__to_string_74, NULL, 910, 910, 16, 58},
  {cont__compiler__function_call__to_string_77, &frame__compiler__function_call__to_string_74, 910, 910, 13, 58},
  {entry__compiler__function_call__to_string_49, NULL, 899, 899, 11, 37},
  {cont__compiler__function_call__to_string_50, &frame__compiler__function_call__to_string_49, 900, 900, 11, 38},
  {cont__compiler__function_call__to_string_51, &frame__compiler__function_call__to_string_49, 901, 901, 11, 40},
  {cont__compiler__function_call__to_string_52, &frame__compiler__function_call__to_string_49, 902, 902, 11, 42},
  {cont__compiler__function_call__to_string_53, &frame__compiler__function_call__to_string_49, 903, 903, 14, 41},
  {cont__compiler__function_call__to_string_54, &frame__compiler__function_call__to_string_49, 903, 903, 14, 60},
  {cont__compiler__function_call__to_string_55, &frame__compiler__function_call__to_string_49, 903, 904, 11, 38},
  {cont__compiler__function_call__to_string_58, &frame__compiler__function_call__to_string_49, 905, 905, 14, 42},
  {cont__compiler__function_call__to_string_59, &frame__compiler__function_call__to_string_49, 905, 905, 14, 62},
  {cont__compiler__function_call__to_string_60, &frame__compiler__function_call__to_string_49, 905, 905, 14, 62},
  {cont__compiler__function_call__to_string_61, &frame__compiler__function_call__to_string_49, 905, 906, 11, 40},
  {cont__compiler__function_call__to_string_64, &frame__compiler__function_call__to_string_49, 907, 907, 19, 33},
  {cont__compiler__function_call__to_string_65, &frame__compiler__function_call__to_string_49, 907, 907, 35, 59},
  {cont__compiler__function_call__to_string_66, &frame__compiler__function_call__to_string_49, 907, 907, 19, 59},
  {cont__compiler__function_call__to_string_67, &frame__compiler__function_call__to_string_49, 907, 907, 61, 76},
  {cont__compiler__function_call__to_string_68, &frame__compiler__function_call__to_string_49, 907, 907, 19, 76},
  {cont__compiler__function_call__to_string_69, &frame__compiler__function_call__to_string_49, 907, 907, 11, 78},
  {cont__compiler__function_call__to_string_70, &frame__compiler__function_call__to_string_49, 909, 909, 13, 36},
  {cont__compiler__function_call__to_string_71, &frame__compiler__function_call__to_string_49, 909, 909, 13, 50},
  {cont__compiler__function_call__to_string_72, &frame__compiler__function_call__to_string_49, 909, 909, 13, 50},
  {cont__compiler__function_call__to_string_73, &frame__compiler__function_call__to_string_49, 908, 911, 11, 24},
  {entry__compiler__function_call__to_string_47, NULL, 898, 898, 12, 36},
  {cont__compiler__function_call__to_string_48, &frame__compiler__function_call__to_string_47, 898, 911, 9, 25},
  {entry__compiler__function_call__to_string_80, NULL, 912, 912, 41, 71},
  {cont__compiler__function_call__to_string_81, &frame__compiler__function_call__to_string_80, 912, 912, 38, 71},
  {entry__compiler__function_call__to_string_78, NULL, 912, 912, 12, 36},
  {cont__compiler__function_call__to_string_79, &frame__compiler__function_call__to_string_78, 912, 912, 9, 71},
  {entry__compiler__function_call__to_string_105, NULL, 922, 922, 21, 32},
  {cont__compiler__function_call__to_string_106, &frame__compiler__function_call__to_string_105, 922, 922, 13, 33},
  {cont__compiler__function_call__to_string_107, &frame__compiler__function_call__to_string_105, 922, 922, 13, 43},
  {cont__compiler__function_call__to_string_109, &frame__compiler__function_call__to_string_105, 922, 922, 13, 43},
  {entry__compiler__function_call__to_string_101, NULL, 921, 921, 26, 37},
  {cont__compiler__function_call__to_string_102, &frame__compiler__function_call__to_string_101, 921, 921, 13, 38},
  {cont__compiler__function_call__to_string_103, &frame__compiler__function_call__to_string_101, 921, 921, 13, 47},
  {cont__compiler__function_call__to_string_104, &frame__compiler__function_call__to_string_101, 922, 922, 13, 43},
  {cont__compiler__function_call__to_string_110, &frame__compiler__function_call__to_string_101, },
  {entry__compiler__function_call__to_string_98, NULL, 920, 920, 13, 24},
  {cont__compiler__function_call__to_string_99, &frame__compiler__function_call__to_string_98, 920, 920, 13, 41},
  {cont__compiler__function_call__to_string_100, &frame__compiler__function_call__to_string_98, },
  {cont__compiler__function_call__to_string_111, &frame__compiler__function_call__to_string_98, },
  {entry__compiler__function_call__to_string_95, NULL, 919, 919, 13, 24},
  {cont__compiler__function_call__to_string_96, &frame__compiler__function_call__to_string_95, 919, 919, 13, 41},
  {cont__compiler__function_call__to_string_97, &frame__compiler__function_call__to_string_95, },
  {cont__compiler__function_call__to_string_112, &frame__compiler__function_call__to_string_95, },
  {entry__compiler__function_call__to_string_92, NULL, 918, 918, 13, 32},
  {cont__compiler__function_call__to_string_93, &frame__compiler__function_call__to_string_92, 918, 918, 13, 37},
  {cont__compiler__function_call__to_string_94, &frame__compiler__function_call__to_string_92, },
  {cont__compiler__function_call__to_string_113, &frame__compiler__function_call__to_string_92, },
  {entry__compiler__function_call__to_string_88, NULL, 917, 917, 13, 28},
  {cont__compiler__function_call__to_string_89, &frame__compiler__function_call__to_string_88, 917, 917, 13, 48},
  {cont__compiler__function_call__to_string_91, &frame__compiler__function_call__to_string_88, },
  {cont__compiler__function_call__to_string_114, &frame__compiler__function_call__to_string_88, },
  {entry__compiler__function_call__to_string_84, NULL, 916, 916, 13, 33},
  {cont__compiler__function_call__to_string_85, &frame__compiler__function_call__to_string_84, 916, 916, 13, 42},
  {cont__compiler__function_call__to_string_87, &frame__compiler__function_call__to_string_84, },
  {cont__compiler__function_call__to_string_115, &frame__compiler__function_call__to_string_84, },
  {entry__compiler__function_call__to_string_117, NULL, 923, 923, 19, 30},
  {cont__compiler__function_call__to_string_118, &frame__compiler__function_call__to_string_117, 923, 923, 14, 32},
  {cont__compiler__function_call__to_string_120, &frame__compiler__function_call__to_string_117, 923, 923, 11, 32},
  {entry__compiler__function_call__to_string_82, NULL, 915, 915, 13, 36},
  {cont__compiler__function_call__to_string_83, &frame__compiler__function_call__to_string_82, },
  {cont__compiler__function_call__to_string_116, &frame__compiler__function_call__to_string_82, 913, 923, 9, 32},
  {entry__compiler__function_call__to_string_121, NULL, 924, 924, 9, 28},
  {entry__compiler__function_call__to_string_46, NULL, 897, 924, 7, 28},
  {entry__compiler__function_call__to_string_44, NULL, 896, 896, 8, 41},
  {cont__compiler__function_call__to_string_45, &frame__compiler__function_call__to_string_44, 896, 924, 5, 29},
  {entry__compiler__function_call__to_string_131, NULL, 932, 932, 16, 54},
  {cont__compiler__function_call__to_string_132, &frame__compiler__function_call__to_string_131, 932, 932, 13, 54},
  {entry__compiler__function_call__to_string_133, NULL, 933, 933, 16, 46},
  {cont__compiler__function_call__to_string_134, &frame__compiler__function_call__to_string_133, 933, 933, 13, 46},
  {entry__compiler__function_call__to_string_127, NULL, 929, 929, 11, 32},
  {cont__compiler__function_call__to_string_128, &frame__compiler__function_call__to_string_127, 931, 931, 13, 35},
  {cont__compiler__function_call__to_string_129, &frame__compiler__function_call__to_string_127, 931, 931, 13, 56},
  {cont__compiler__function_call__to_string_130, &frame__compiler__function_call__to_string_127, 930, 933, 11, 46},
  {entry__compiler__function_call__to_string_141, NULL, 944, 944, 15, 45},
  {entry__compiler__function_call__to_string_142, NULL, 945, 945, 15, 46},
  {entry__compiler__function_call__to_string_136, NULL, 941, 941, 13, 31},
  {cont__compiler__function_call__to_string_137, &frame__compiler__function_call__to_string_136, 943, 943, 15, 33},
  {cont__compiler__function_call__to_string_138, &frame__compiler__function_call__to_string_136, 943, 943, 15, 41},
  {cont__compiler__function_call__to_string_139, &frame__compiler__function_call__to_string_136, 943, 943, 15, 41},
  {cont__compiler__function_call__to_string_140, &frame__compiler__function_call__to_string_136, 942, 945, 13, 46},
  {entry__compiler__function_call__to_string_147, NULL, 951, 951, 15, 45},
  {entry__compiler__function_call__to_string_148, NULL, 952, 952, 15, 46},
  {entry__compiler__function_call__to_string_143, NULL, 948, 948, 13, 31},
  {cont__compiler__function_call__to_string_144, &frame__compiler__function_call__to_string_143, 950, 950, 15, 33},
  {cont__compiler__function_call__to_string_145, &frame__compiler__function_call__to_string_143, 950, 950, 15, 40},
  {cont__compiler__function_call__to_string_146, &frame__compiler__function_call__to_string_143, 949, 952, 13, 46},
  {entry__compiler__function_call__to_string_159, NULL, 959, 959, 17, 49},
  {cont__compiler__function_call__to_string_160, &frame__compiler__function_call__to_string_159, 960, 960, 43, 58},
  {cont__compiler__function_call__to_string_161, &frame__compiler__function_call__to_string_159, 960, 960, 30, 59},
  {cont__compiler__function_call__to_string_162, &frame__compiler__function_call__to_string_159, 960, 960, 17, 59},
  {cont__compiler__function_call__to_string_163, &frame__compiler__function_call__to_string_159, 961, 961, 17, 38},
  {cont__compiler__function_call__to_string_164, &frame__compiler__function_call__to_string_159, 961, 961, 38, 38},
  {entry__compiler__function_call__to_string_156, NULL, 958, 958, 24, 40},
  {cont__compiler__function_call__to_string_157, &frame__compiler__function_call__to_string_156, 958, 958, 24, 58},
  {cont__compiler__function_call__to_string_158, &frame__compiler__function_call__to_string_156, 958, 961, 21, 38},
  {entry__compiler__function_call__to_string_153, NULL, 957, 957, 28, 46},
  {cont__compiler__function_call__to_string_154, &frame__compiler__function_call__to_string_153, 957, 957, 15, 46},
  {cont__compiler__function_call__to_string_155, &frame__compiler__function_call__to_string_153, 958, 961, 15, 38},
  {cont__compiler__function_call__to_string_165, &frame__compiler__function_call__to_string_153, 962, 962, 28, 45},
  {cont__compiler__function_call__to_string_166, &frame__compiler__function_call__to_string_153, 962, 962, 15, 45},
  {cont__compiler__function_call__to_string_167, &frame__compiler__function_call__to_string_153, 962, 962, 45, 45},
  {entry__compiler__function_call__to_string_174, NULL, 966, 966, 17, 51},
  {cont__compiler__function_call__to_string_175, &frame__compiler__function_call__to_string_174, 967, 967, 44, 60},
  {cont__compiler__function_call__to_string_176, &frame__compiler__function_call__to_string_174, 967, 967, 31, 61},
  {cont__compiler__function_call__to_string_177, &frame__compiler__function_call__to_string_174, 967, 967, 17, 61},
  {cont__compiler__function_call__to_string_178, &frame__compiler__function_call__to_string_174, 968, 968, 17, 40},
  {cont__compiler__function_call__to_string_179, &frame__compiler__function_call__to_string_174, 968, 968, 40, 40},
  {entry__compiler__function_call__to_string_171, NULL, 965, 965, 24, 41},
  {cont__compiler__function_call__to_string_172, &frame__compiler__function_call__to_string_171, 965, 965, 24, 59},
  {cont__compiler__function_call__to_string_173, &frame__compiler__function_call__to_string_171, 965, 968, 21, 40},
  {entry__compiler__function_call__to_string_168, NULL, 964, 964, 29, 46},
  {cont__compiler__function_call__to_string_169, &frame__compiler__function_call__to_string_168, 964, 964, 15, 46},
  {cont__compiler__function_call__to_string_170, &frame__compiler__function_call__to_string_168, 965, 968, 15, 40},
  {cont__compiler__function_call__to_string_180, &frame__compiler__function_call__to_string_168, 969, 969, 29, 47},
  {cont__compiler__function_call__to_string_181, &frame__compiler__function_call__to_string_168, 969, 969, 15, 47},
  {cont__compiler__function_call__to_string_182, &frame__compiler__function_call__to_string_168, 969, 969, 47, 47},
  {entry__compiler__function_call__to_string_188, NULL, 976, 976, 17, 21},
  {entry__compiler__function_call__to_string_193, NULL, 978, 978, 41, 59},
  {cont__compiler__function_call__to_string_194, &frame__compiler__function_call__to_string_193, 978, 978, 59, 59},
  {entry__compiler__function_call__to_string_185, NULL, 974, 974, 18, 23},
  {cont__compiler__function_call__to_string_186, &frame__compiler__function_call__to_string_185, 974, 974, 18, 33},
  {cont__compiler__function_call__to_string_187, &frame__compiler__function_call__to_string_185, 974, 976, 15, 21},
  {cont__compiler__function_call__to_string_189, &frame__compiler__function_call__to_string_185, 977, 977, 33, 46},
  {cont__compiler__function_call__to_string_190, &frame__compiler__function_call__to_string_185, 977, 977, 15, 46},
  {cont__compiler__function_call__to_string_191, &frame__compiler__function_call__to_string_185, 978, 978, 18, 38},
  {cont__compiler__function_call__to_string_192, &frame__compiler__function_call__to_string_185, 978, 978, 15, 59},
  {entry__compiler__function_call__to_string_184, NULL, 973, 978, 13, 59},
  {cont__compiler__function_call__to_string_195, &frame__compiler__function_call__to_string_184, 978, 978, 59, 59},
  {entry__compiler__function_call__to_string_204, NULL, 984, 984, 17, 33},
  {entry__compiler__function_call__to_string_205, NULL, 986, 986, 20, 45},
  {cont__compiler__function_call__to_string_206, &frame__compiler__function_call__to_string_205, 986, 986, 17, 45},
  {entry__compiler__function_call__to_string_207, NULL, 987, 987, 20, 49},
  {cont__compiler__function_call__to_string_208, &frame__compiler__function_call__to_string_207, 987, 987, 17, 49},
  {entry__compiler__function_call__to_string_218, NULL, 989, 989, 70, 70},
  {entry__compiler__function_call__to_string_198, NULL, 983, 983, 17, 34},
  {cont__compiler__function_call__to_string_203, &frame__compiler__function_call__to_string_198, 980, 987, 13, 50},
  {cont__compiler__function_call__to_string_210, &frame__compiler__function_call__to_string_198, 988, 988, 32, 49},
  {cont__compiler__function_call__to_string_211, &frame__compiler__function_call__to_string_198, 988, 988, 32, 51},
  {cont__compiler__function_call__to_string_212, &frame__compiler__function_call__to_string_198, 988, 988, 54, 78},
  {cont__compiler__function_call__to_string_213, &frame__compiler__function_call__to_string_198, 988, 988, 32, 78},
  {cont__compiler__function_call__to_string_214, &frame__compiler__function_call__to_string_198, 988, 988, 13, 78},
  {cont__compiler__function_call__to_string_215, &frame__compiler__function_call__to_string_198, 989, 989, 16, 33},
  {cont__compiler__function_call__to_string_216, &frame__compiler__function_call__to_string_198, 989, 989, 16, 46},
  {cont__compiler__function_call__to_string_217, &frame__compiler__function_call__to_string_198, 989, 989, 13, 70},
  {entry__compiler__function_call__to_string_224, NULL, 995, 995, 45, 57},
  {cont__compiler__function_call__to_string_225, &frame__compiler__function_call__to_string_224, 995, 995, 57, 57},
  {entry__compiler__function_call__to_string_229, NULL, 997, 997, 45, 57},
  {cont__compiler__function_call__to_string_230, &frame__compiler__function_call__to_string_229, 997, 997, 57, 57},
  {entry__compiler__function_call__to_string_222, NULL, 995, 995, 22, 42},
  {cont__compiler__function_call__to_string_223, &frame__compiler__function_call__to_string_222, 995, 995, 19, 57},
  {cont__compiler__function_call__to_string_226, &frame__compiler__function_call__to_string_222, 996, 996, 19, 33},
  {cont__compiler__function_call__to_string_227, &frame__compiler__function_call__to_string_222, 997, 997, 22, 42},
  {cont__compiler__function_call__to_string_228, &frame__compiler__function_call__to_string_222, 997, 997, 19, 57},
  {entry__compiler__function_call__to_string_231, NULL, 999, 999, 19, 44},
  {cont__compiler__function_call__to_string_232, &frame__compiler__function_call__to_string_231, 999, 999, 44, 44},
  {entry__compiler__function_call__to_string_221, NULL, 993, 999, 15, 45},
  {entry__compiler__function_call__to_string_234, NULL, 1001, 1001, 65, 65},
  {entry__compiler__function_call__to_string_243, NULL, 1006, 1006, 19, 34},
  {cont__compiler__function_call__to_string_244, &frame__compiler__function_call__to_string_243, 1007, 1007, 19, 41},
  {cont__compiler__function_call__to_string_245, &frame__compiler__function_call__to_string_243, 1007, 1007, 41, 41},
  {entry__compiler__function_call__to_string_240, NULL, 1005, 1005, 24, 29},
  {cont__compiler__function_call__to_string_241, &frame__compiler__function_call__to_string_240, 1005, 1005, 24, 39},
  {cont__compiler__function_call__to_string_242, &frame__compiler__function_call__to_string_240, 1005, 1007, 17, 41},
  {cont__compiler__function_call__to_string_246, &frame__compiler__function_call__to_string_240, 1008, 1008, 17, 31},
  {cont__compiler__function_call__to_string_247, &frame__compiler__function_call__to_string_240, 1008, 1008, 31, 31},
  {entry__compiler__function_call__to_string_233, NULL, 1001, 1001, 15, 65},
  {cont__compiler__function_call__to_string_236, &frame__compiler__function_call__to_string_233, 1002, 1002, 15, 52},
  {cont__compiler__function_call__to_string_237, &frame__compiler__function_call__to_string_233, 1003, 1003, 34, 47},
  {cont__compiler__function_call__to_string_238, &frame__compiler__function_call__to_string_233, 1003, 1003, 15, 63},
  {cont__compiler__function_call__to_string_239, &frame__compiler__function_call__to_string_233, 1004, 1008, 15, 31},
  {entry__compiler__function_call__to_string_135, NULL, 936, 936, 11, 42},
  {cont__compiler__function_call__to_string_149, &frame__compiler__function_call__to_string_135, 937, 937, 11, 29},
  {cont__compiler__function_call__to_string_150, &frame__compiler__function_call__to_string_135, 938, 938, 11, 30},
  {cont__compiler__function_call__to_string_151, &frame__compiler__function_call__to_string_135, 956, 956, 13, 36},
  {cont__compiler__function_call__to_string_152, &frame__compiler__function_call__to_string_135, 955, 969, 11, 48},
  {cont__compiler__function_call__to_string_183, &frame__compiler__function_call__to_string_135, 972, 978, 11, 60},
  {cont__compiler__function_call__to_string_196, &frame__compiler__function_call__to_string_135, 979, 979, 14, 35},
  {cont__compiler__function_call__to_string_197, &frame__compiler__function_call__to_string_135, 979, 989, 11, 70},
  {cont__compiler__function_call__to_string_219, &frame__compiler__function_call__to_string_135, 992, 992, 13, 34},
  {cont__compiler__function_call__to_string_220, &frame__compiler__function_call__to_string_135, 991, 1008, 11, 33},
  {cont__compiler__function_call__to_string_248, &frame__compiler__function_call__to_string_135, 1009, 1009, 11, 16},
  {entry__compiler__function_call__to_string_123, NULL, 926, 926, 7, 33},
  {cont__compiler__function_call__to_string_124, &frame__compiler__function_call__to_string_123, 928, 928, 9, 28},
  {cont__compiler__function_call__to_string_125, &frame__compiler__function_call__to_string_123, 928, 928, 9, 33},
  {cont__compiler__function_call__to_string_126, &frame__compiler__function_call__to_string_123, 927, 1009, 7, 17},
  {cont__compiler__function_call__to_string_249, &frame__compiler__function_call__to_string_123, 1009, 1009, 17, 17},
  {entry__compiler__function_call__to_string_122, NULL, 925, 1009, 5, 18},
  {entry__compiler__function_call__to_string_1, NULL, 859, 859, 3, 27},
  {cont__compiler__function_call__to_string_16, &frame__compiler__function_call__to_string_1, 863, 863, 7, 24},
  {cont__compiler__function_call__to_string_17, &frame__compiler__function_call__to_string_1, 861, 866, 3, 19},
  {cont__compiler__function_call__to_string_22, &frame__compiler__function_call__to_string_1, 882, 882, 3, 31},
  {cont__compiler__function_call__to_string_23, &frame__compiler__function_call__to_string_1, 883, 1009, 3, 19},
  {entry__compiler__remark_argument__to_string_12, NULL, 1022, 1022, 9, 52},
  {cont__compiler__remark_argument__to_string_13, &frame__compiler__remark_argument__to_string_12, 1022, 1022, 52, 52},
  {entry__compiler__remark_argument__to_string_5, NULL, 1019, 1019, 27, 45},
  {cont__compiler__remark_argument__to_string_6, &frame__compiler__remark_argument__to_string_5, 1019, 1019, 7, 46},
  {cont__compiler__remark_argument__to_string_7, &frame__compiler__remark_argument__to_string_5, 1020, 1020, 21, 45},
  {cont__compiler__remark_argument__to_string_8, &frame__compiler__remark_argument__to_string_5, 1020, 1020, 51, 65},
  {cont__compiler__remark_argument__to_string_9, &frame__compiler__remark_argument__to_string_5, 1020, 1020, 7, 65},
  {cont__compiler__remark_argument__to_string_10, &frame__compiler__remark_argument__to_string_5, 1021, 1021, 40, 40},
  {cont__compiler__remark_argument__to_string_11, &frame__compiler__remark_argument__to_string_5, 1021, 1022, 7, 52},
  {cont__compiler__remark_argument__to_string_14, &frame__compiler__remark_argument__to_string_5, 1023, 1023, 7, 12},
  {entry__compiler__remark_argument__to_string_15, NULL, 1024, 1024, 12, 26},
  {cont__compiler__remark_argument__to_string_16, &frame__compiler__remark_argument__to_string_15, 1024, 1024, 8, 28},
  {cont__compiler__remark_argument__to_string_17, &frame__compiler__remark_argument__to_string_15, 1024, 1024, 5, 28},
  {entry__compiler__remark_argument__to_string_1, NULL, 1015, 1015, 3, 37},
  {cont__compiler__remark_argument__to_string_2, &frame__compiler__remark_argument__to_string_1, 1017, 1017, 5, 27},
  {cont__compiler__remark_argument__to_string_3, &frame__compiler__remark_argument__to_string_1, 1017, 1017, 5, 31},
  {cont__compiler__remark_argument__to_string_4, &frame__compiler__remark_argument__to_string_1, 1016, 1024, 3, 28},
  {entry__compiler__backquoted__to_string_1, NULL, 1029, 1029, 55, 73},
  {cont__compiler__backquoted__to_string_2, &frame__compiler__backquoted__to_string_1, 1029, 1029, 44, 74},
  {cont__compiler__backquoted__to_string_3, &frame__compiler__backquoted__to_string_1, 1029, 1029, 41, 74},
  {entry__pair_to_string_15, NULL, 1044, 1044, 24, 37},
  {cont__pair_to_string_16, &frame__pair_to_string_15, 1044, 1044, 10, 43},
  {cont__pair_to_string_17, &frame__pair_to_string_15, 1044, 1044, 7, 43},
  {entry__pair_to_string_18, NULL, 1045, 1045, 7, 13},
  {entry__pair_to_string_2, NULL, 1037, 1037, 5, 31},
  {cont__pair_to_string_3, &frame__pair_to_string_2, 1038, 1038, 31, 49},
  {cont__pair_to_string_4, &frame__pair_to_string_2, 1038, 1038, 17, 53},
  {cont__pair_to_string_5, &frame__pair_to_string_2, 1038, 1038, 5, 63},
  {cont__pair_to_string_6, &frame__pair_to_string_2, 1039, 1039, 32, 48},
  {cont__pair_to_string_7, &frame__pair_to_string_2, 1039, 1039, 51, 71},
  {cont__pair_to_string_8, &frame__pair_to_string_2, 1039, 1039, 51, 73},
  {cont__pair_to_string_9, &frame__pair_to_string_2, 1039, 1039, 5, 74},
  {cont__pair_to_string_10, &frame__pair_to_string_2, 1040, 1040, 5, 71},
  {cont__pair_to_string_11, &frame__pair_to_string_2, 1041, 1041, 5, 45},
  {cont__pair_to_string_12, &frame__pair_to_string_2, 1043, 1043, 7, 18},
  {cont__pair_to_string_13, &frame__pair_to_string_2, 1043, 1043, 7, 28},
  {cont__pair_to_string_14, &frame__pair_to_string_2, 1042, 1045, 5, 13},
  {cont__pair_to_string_19, &frame__pair_to_string_2, 1045, 1045, 13, 13},
  {entry__pair_to_string_1, NULL, 1036, 1045, 3, 14},
  {entry__compiler__attribute_value_pair__to_string_1, NULL, 1047, 1047, 51, 73},
  {entry__compiler__attribute_function_pair__to_string_1, NULL, 1049, 1049, 54, 76},
  {entry__compiler__numeric_literal__to_string_1, NULL, 1054, 1054, 49, 68},
  {cont__compiler__numeric_literal__to_string_2, &frame__compiler__numeric_literal__to_string_1, 1054, 1054, 46, 68},
  {entry__create_character_table_4, NULL, 1064, 1064, 26, 40},
  {cont__create_character_table_5, &frame__create_character_table_4, 1064, 1064, 26, 40},
  {entry__create_character_table_7, NULL, 1064, 1064, 43, 65},
  {cont__create_character_table_8, &frame__create_character_table_7, 1064, 1064, 70, 70},
  {entry__create_character_table_2, NULL, 1064, 1064, 8, 21},
  {cont__create_character_table_3, &frame__create_character_table_2, 1064, 1064, 8, 40},
  {cont__create_character_table_6, &frame__create_character_table_2, 1064, 1064, 5, 70},
  {entry__create_character_table_1, NULL, 1063, 1064, 3, 70},
  {cont__create_character_table_9, &frame__create_character_table_1, 1068, 1068, 3, 25},
  {cont__create_character_table_10, &frame__create_character_table_1, 1068, 1068, 35, 35},
  {entry__escaped_character_2, NULL, 1078, 1078, 44, 57},
  {cont__escaped_character_3, &frame__escaped_character_2, 1078, 1078, 40, 58},
  {cont__escaped_character_4, &frame__escaped_character_2, 1078, 1078, 26, 63},
  {cont__escaped_character_6, &frame__escaped_character_2, 1078, 1078, 23, 63},
  {entry__escaped_character_7, NULL, 1082, 1082, 8, 27},
  {cont__escaped_character_8, &frame__escaped_character_7, 1082, 1082, 5, 27},
  {entry__escaped_character_15, NULL, 1093, 1093, 16, 36},
  {cont__escaped_character_16, &frame__escaped_character_15, 1093, 1093, 13, 36},
  {entry__escaped_character_18, NULL, 1090, 1090, 13, 21},
  {entry__escaped_character_21, NULL, 1092, 1092, 13, 18},
  {entry__escaped_character_14, NULL, 1088, 1093, 11, 36},
  {entry__escaped_character_28, NULL, 1096, 1096, 52, 66},
  {cont__escaped_character_29, &frame__escaped_character_28, 1096, 1096, 52, 66},
  {cont__escaped_character_30, &frame__escaped_character_28, 1096, 1096, 52, 66},
  {entry__escaped_character_25, NULL, 1096, 1096, 33, 47},
  {cont__escaped_character_26, &frame__escaped_character_25, 1096, 1096, 33, 47},
  {cont__escaped_character_27, &frame__escaped_character_25, 1096, 1096, 33, 66},
  {cont__escaped_character_31, &frame__escaped_character_25, 1096, 1096, 33, 66},
  {entry__escaped_character_33, NULL, 1097, 1097, 16, 35},
  {cont__escaped_character_34, &frame__escaped_character_33, 1097, 1097, 13, 35},
  {entry__escaped_character_35, NULL, 1098, 1098, 16, 28},
  {cont__escaped_character_36, &frame__escaped_character_35, 1098, 1098, 13, 28},
  {entry__escaped_character_22, NULL, 1096, 1096, 13, 28},
  {cont__escaped_character_23, &frame__escaped_character_22, 1096, 1096, 13, 28},
  {cont__escaped_character_24, &frame__escaped_character_22, 1096, 1096, 13, 66},
  {cont__escaped_character_32, &frame__escaped_character_22, 1095, 1098, 11, 28},
  {entry__escaped_character_9, NULL, 1084, 1084, 14, 41},
  {cont__escaped_character_10, &frame__escaped_character_9, 1084, 1084, 7, 64},
  {cont__escaped_character_11, &frame__escaped_character_9, 1085, 1085, 7, 34},
  {cont__escaped_character_12, &frame__escaped_character_9, 1087, 1087, 9, 23},
  {cont__escaped_character_13, &frame__escaped_character_9, 1086, 1098, 7, 30},
  {entry__escaped_character_1, NULL, 1080, 1098, 3, 32},
  {entry__compiler__character_literal__to_string_1, NULL, 1103, 1103, 23, 42},
  {cont__compiler__character_literal__to_string_2, &frame__compiler__character_literal__to_string_1, 1103, 1103, 44, 70},
  {cont__compiler__character_literal__to_string_3, &frame__compiler__character_literal__to_string_1, 1103, 1103, 5, 71},
  {cont__compiler__character_literal__to_string_4, &frame__compiler__character_literal__to_string_1, 1101, 1104, 3, 12},
  {entry__analyze_string_literal_3, NULL, 1118, 1118, 5, 19},
  {cont__analyze_string_literal_4, &frame__analyze_string_literal_3, 1119, 1119, 5, 10},
  {entry__analyze_string_literal_8, NULL, 1123, 1123, 29, 43},
  {cont__analyze_string_literal_9, &frame__analyze_string_literal_8, 1123, 1123, 17, 44},
  {cont__analyze_string_literal_11, &frame__analyze_string_literal_8, 1123, 1123, 5, 45},
  {cont__analyze_string_literal_12, &frame__analyze_string_literal_8, 1124, 1124, 5, 10},
  {entry__analyze_string_literal_15, NULL, 1126, 1126, 52, 66},
  {cont__analyze_string_literal_16, &frame__analyze_string_literal_15, 1126, 1126, 52, 71},
  {cont__analyze_string_literal_17, &frame__analyze_string_literal_15, 1126, 1126, 52, 71},
  {cont__analyze_string_literal_18, &frame__analyze_string_literal_15, 1126, 1126, 52, 71},
  {entry__analyze_string_literal_25, NULL, 1138, 1138, 13, 32},
  {cont__analyze_string_literal_26, &frame__analyze_string_literal_25, 1138, 1138, 32, 32},
  {entry__analyze_string_literal_27, NULL, 1140, 1140, 13, 28},
  {cont__analyze_string_literal_28, &frame__analyze_string_literal_27, 1141, 1141, 20, 20},
  {entry__analyze_string_literal_21, NULL, 1133, 1133, 35, 39},
  {cont__analyze_string_literal_22, &frame__analyze_string_literal_21, 1133, 1133, 22, 40},
  {cont__analyze_string_literal_23, &frame__analyze_string_literal_21, 1133, 1133, 9, 40},
  {cont__analyze_string_literal_24, &frame__analyze_string_literal_21, 1134, 1141, 9, 21},
  {cont__analyze_string_literal_29, &frame__analyze_string_literal_21, 1142, 1142, 9, 16},
  {cont__analyze_string_literal_30, &frame__analyze_string_literal_21, 1142, 1142, 16, 16},
  {entry__analyze_string_literal_32, NULL, 1146, 1146, 39, 43},
  {cont__analyze_string_literal_33, &frame__analyze_string_literal_32, 1146, 1146, 26, 44},
  {cont__analyze_string_literal_34, &frame__analyze_string_literal_32, 1146, 1146, 13, 44},
  {cont__analyze_string_literal_35, &frame__analyze_string_literal_32, 1150, 1150, 13, 34},
  {cont__analyze_string_literal_37, &frame__analyze_string_literal_32, 1151, 1151, 13, 20},
  {cont__analyze_string_literal_38, &frame__analyze_string_literal_32, 1151, 1151, 20, 20},
  {entry__analyze_string_literal_39, NULL, 1153, 1153, 28, 28},
  {entry__analyze_string_literal_31, NULL, 1144, 1153, 9, 29},
  {entry__analyze_string_literal_40, NULL, 1155, 1155, 35, 39},
  {cont__analyze_string_literal_41, &frame__analyze_string_literal_40, 1155, 1155, 22, 40},
  {cont__analyze_string_literal_42, &frame__analyze_string_literal_40, 1155, 1155, 9, 40},
  {cont__analyze_string_literal_43, &frame__analyze_string_literal_40, 1156, 1156, 9, 27},
  {cont__analyze_string_literal_44, &frame__analyze_string_literal_40, 1157, 1157, 9, 16},
  {cont__analyze_string_literal_45, &frame__analyze_string_literal_40, 1157, 1157, 16, 16},
  {entry__analyze_string_literal_50, NULL, 1162, 1162, 37, 41},
  {cont__analyze_string_literal_51, &frame__analyze_string_literal_50, 1162, 1162, 24, 42},
  {cont__analyze_string_literal_52, &frame__analyze_string_literal_50, 1162, 1162, 11, 42},
  {cont__analyze_string_literal_53, &frame__analyze_string_literal_50, 1163, 1163, 11, 30},
  {cont__analyze_string_literal_54, &frame__analyze_string_literal_50, 1164, 1164, 11, 18},
  {cont__analyze_string_literal_55, &frame__analyze_string_literal_50, 1164, 1164, 18, 18},
  {entry__analyze_string_literal_46, NULL, 1160, 1160, 9, 39},
  {cont__analyze_string_literal_47, &frame__analyze_string_literal_46, 1161, 1161, 12, 29},
  {cont__analyze_string_literal_48, &frame__analyze_string_literal_46, 1161, 1161, 12, 33},
  {cont__analyze_string_literal_49, &frame__analyze_string_literal_46, 1161, 1164, 9, 18},
  {entry__analyze_string_literal_20, NULL, 1130, 1164, 5, 20},
  {entry__analyze_string_literal_61, NULL, 1170, 1170, 22, 22},
  {entry__analyze_string_literal_67, NULL, 1179, 1179, 13, 16},
  {entry__analyze_string_literal_68, NULL, 1180, 1180, 13, 16},
  {entry__analyze_string_literal_72, NULL, 1182, 1182, 32, 46},
  {cont__analyze_string_literal_73, &frame__analyze_string_literal_72, 1182, 1182, 32, 48},
  {cont__analyze_string_literal_74, &frame__analyze_string_literal_72, 1182, 1182, 32, 61},
  {cont__analyze_string_literal_75, &frame__analyze_string_literal_72, 1182, 1182, 32, 61},
  {cont__analyze_string_literal_76, &frame__analyze_string_literal_72, 1182, 1182, 32, 61},
  {entry__analyze_string_literal_78, NULL, 1182, 1182, 79, 79},
  {entry__analyze_string_literal_80, NULL, 1185, 1185, 11, 26},
  {cont__analyze_string_literal_81, &frame__analyze_string_literal_80, 1185, 1185, 26, 26},
  {entry__analyze_string_literal_82, NULL, 1187, 1187, 23, 39},
  {cont__analyze_string_literal_83, &frame__analyze_string_literal_82, 1187, 1187, 11, 39},
  {cont__analyze_string_literal_84, &frame__analyze_string_literal_82, 1187, 1187, 39, 39},
  {entry__analyze_string_literal_62, NULL, 1176, 1176, 15, 42},
  {cont__analyze_string_literal_63, &frame__analyze_string_literal_62, 1176, 1176, 11, 46},
  {cont__analyze_string_literal_64, &frame__analyze_string_literal_62, 1178, 1178, 13, 42},
  {cont__analyze_string_literal_65, &frame__analyze_string_literal_62, 1178, 1178, 13, 42},
  {cont__analyze_string_literal_66, &frame__analyze_string_literal_62, },
  {cont__analyze_string_literal_69, &frame__analyze_string_literal_62, 1174, 1180, 7, 18},
  {cont__analyze_string_literal_70, &frame__analyze_string_literal_62, 1182, 1182, 14, 27},
  {cont__analyze_string_literal_71, &frame__analyze_string_literal_62, 1182, 1182, 14, 61},
  {cont__analyze_string_literal_77, &frame__analyze_string_literal_62, 1182, 1182, 7, 79},
  {cont__analyze_string_literal_79, &frame__analyze_string_literal_62, 1183, 1187, 7, 40},
  {entry__analyze_string_literal_1, NULL, 1117, 1117, 6, 15},
  {cont__analyze_string_literal_2, &frame__analyze_string_literal_1, 1117, 1119, 3, 10},
  {cont__analyze_string_literal_5, &frame__analyze_string_literal_1, 1120, 1120, 21, 32},
  {cont__analyze_string_literal_6, &frame__analyze_string_literal_1, 1120, 1120, 6, 32},
  {cont__analyze_string_literal_7, &frame__analyze_string_literal_1, 1120, 1124, 3, 10},
  {cont__analyze_string_literal_13, &frame__analyze_string_literal_1, 1126, 1126, 25, 47},
  {cont__analyze_string_literal_14, &frame__analyze_string_literal_1, 1126, 1126, 3, 71},
  {cont__analyze_string_literal_19, &frame__analyze_string_literal_1, 1129, 1164, 3, 21},
  {cont__analyze_string_literal_56, &frame__analyze_string_literal_1, 1165, 1165, 30, 30},
  {cont__analyze_string_literal_57, &frame__analyze_string_literal_1, 1165, 1165, 16, 31},
  {cont__analyze_string_literal_58, &frame__analyze_string_literal_1, 1165, 1165, 3, 31},
  {cont__analyze_string_literal_59, &frame__analyze_string_literal_1, 1167, 1167, 5, 14},
  {cont__analyze_string_literal_60, &frame__analyze_string_literal_1, 1166, 1187, 3, 42},
  {cont__analyze_string_literal_85, &frame__analyze_string_literal_1, 1187, 1187, 42, 42},
  {entry__print_string_literal_10, NULL, 1193, 1193, 15, 22},
  {cont__print_string_literal_11, &frame__print_string_literal_10, 1193, 1193, 9, 27},
  {cont__print_string_literal_12, &frame__print_string_literal_10, 1193, 1193, 14, 22},
  {cont__print_string_literal_13, &frame__print_string_literal_10, 1194, 1194, 24, 24},
  {entry__print_string_literal_4, NULL, 1192, 1192, 34, 61},
  {cont__print_string_literal_5, &frame__print_string_literal_4, 1192, 1192, 20, 27},
  {cont__print_string_literal_6, &frame__print_string_literal_4, 1192, 1192, 10, 28},
  {cont__print_string_literal_7, &frame__print_string_literal_4, 1192, 1192, 10, 30},
  {cont__print_string_literal_8, &frame__print_string_literal_4, 1192, 1192, 10, 61},
  {cont__print_string_literal_9, &frame__print_string_literal_4, 1192, 1194, 7, 24},
  {entry__print_string_literal_2, NULL, 1191, 1191, 12, 34},
  {cont__print_string_literal_3, &frame__print_string_literal_2, 1191, 1194, 5, 25},
  {entry__print_string_literal_15, NULL, 1197, 1197, 24, 31},
  {cont__print_string_literal_16, &frame__print_string_literal_15, 1197, 1197, 8, 41},
  {cont__print_string_literal_17, &frame__print_string_literal_15, 1197, 1197, 5, 41},
  {entry__print_string_literal_23, NULL, 1204, 1204, 13, 16},
  {entry__print_string_literal_24, NULL, 1205, 1205, 13, 16},
  {entry__print_string_literal_34, NULL, 1214, 1214, 26, 32},
  {cont__print_string_literal_35, &frame__print_string_literal_34, 1214, 1214, 26, 39},
  {cont__print_string_literal_36, &frame__print_string_literal_34, 1214, 1214, 26, 39},
  {cont__print_string_literal_37, &frame__print_string_literal_34, 1214, 1214, 26, 39},
  {entry__print_string_literal_39, NULL, 1214, 1214, 66, 66},
  {entry__print_string_literal_50, NULL, 1222, 1222, 17, 28},
  {cont__print_string_literal_51, &frame__print_string_literal_50, 1223, 1223, 17, 24},
  {cont__print_string_literal_52, &frame__print_string_literal_50, 1223, 1223, 24, 24},
  {entry__print_string_literal_46, NULL, 1220, 1220, 15, 22},
  {cont__print_string_literal_47, &frame__print_string_literal_46, 1221, 1221, 18, 26},
  {cont__print_string_literal_48, &frame__print_string_literal_46, 1221, 1221, 18, 34},
  {cont__print_string_literal_49, &frame__print_string_literal_46, 1221, 1223, 15, 24},
  {cont__print_string_literal_53, &frame__print_string_literal_46, 1224, 1224, 18, 26},
  {cont__print_string_literal_54, &frame__print_string_literal_46, 1224, 1224, 18, 38},
  {cont__print_string_literal_55, &frame__print_string_literal_46, 1224, 1224, 18, 38},
  {cont__print_string_literal_56, &frame__print_string_literal_46, 1224, 1224, 15, 38},
  {entry__print_string_literal_45, NULL, 1219, 1224, 13, 38},
  {entry__print_string_literal_62, NULL, 1230, 1230, 17, 31},
  {cont__print_string_literal_63, &frame__print_string_literal_62, 1231, 1231, 17, 24},
  {cont__print_string_literal_64, &frame__print_string_literal_62, 1231, 1231, 24, 24},
  {entry__print_string_literal_68, NULL, 1233, 1233, 17, 39},
  {cont__print_string_literal_69, &frame__print_string_literal_68, 1234, 1234, 17, 24},
  {cont__print_string_literal_70, &frame__print_string_literal_68, 1234, 1234, 24, 24},
  {entry__print_string_literal_58, NULL, 1228, 1228, 15, 22},
  {cont__print_string_literal_59, &frame__print_string_literal_58, 1229, 1229, 18, 26},
  {cont__print_string_literal_60, &frame__print_string_literal_58, 1229, 1229, 18, 33},
  {cont__print_string_literal_61, &frame__print_string_literal_58, 1229, 1231, 15, 24},
  {cont__print_string_literal_65, &frame__print_string_literal_58, 1232, 1232, 18, 26},
  {cont__print_string_literal_66, &frame__print_string_literal_58, 1232, 1232, 18, 38},
  {cont__print_string_literal_67, &frame__print_string_literal_58, 1232, 1234, 15, 24},
  {cont__print_string_literal_71, &frame__print_string_literal_58, 1235, 1235, 18, 26},
  {cont__print_string_literal_72, &frame__print_string_literal_58, 1235, 1235, 18, 33},
  {cont__print_string_literal_73, &frame__print_string_literal_58, 1235, 1235, 18, 33},
  {cont__print_string_literal_74, &frame__print_string_literal_58, 1235, 1235, 15, 33},
  {entry__print_string_literal_57, NULL, 1227, 1235, 13, 33},
  {entry__print_string_literal_82, NULL, 1242, 1242, 19, 33},
  {entry__print_string_literal_88, NULL, 1244, 1244, 46, 53},
  {cont__print_string_literal_89, &frame__print_string_literal_88, 1244, 1244, 53, 53},
  {entry__print_string_literal_84, NULL, 1244, 1244, 28, 36},
  {cont__print_string_literal_85, &frame__print_string_literal_84, 1244, 1244, 28, 43},
  {cont__print_string_literal_86, &frame__print_string_literal_84, 1244, 1244, 28, 43},
  {cont__print_string_literal_87, &frame__print_string_literal_84, 1244, 1244, 25, 53},
  {entry__print_string_literal_83, NULL, 1244, 1244, 19, 53},
  {entry__print_string_literal_79, NULL, 1241, 1241, 17, 25},
  {cont__print_string_literal_80, &frame__print_string_literal_79, 1241, 1241, 17, 32},
  {cont__print_string_literal_81, &frame__print_string_literal_79, 1240, 1244, 15, 54},
  {entry__print_string_literal_75, NULL, 1238, 1238, 13, 20},
  {cont__print_string_literal_76, &frame__print_string_literal_75, 1239, 1239, 20, 28},
  {cont__print_string_literal_77, &frame__print_string_literal_75, 1239, 1239, 20, 36},
  {cont__print_string_literal_78, &frame__print_string_literal_75, 1239, 1244, 13, 55},
  {entry__print_string_literal_95, NULL, 1253, 1253, 35, 35},
  {entry__print_string_literal_102, NULL, 1259, 1259, 45, 53},
  {cont__print_string_literal_103, &frame__print_string_literal_102, 1259, 1259, 45, 60},
  {cont__print_string_literal_104, &frame__print_string_literal_102, 1259, 1259, 45, 60},
  {entry__print_string_literal_106, NULL, 1260, 1260, 43, 43},
  {entry__print_string_literal_100, NULL, 1259, 1259, 26, 40},
  {cont__print_string_literal_101, &frame__print_string_literal_100, 1259, 1259, 26, 60},
  {cont__print_string_literal_105, &frame__print_string_literal_100, 1259, 1260, 23, 43},
  {entry__print_string_literal_109, NULL, 1261, 1261, 73, 73},
  {entry__print_string_literal_107, NULL, 1261, 1261, 26, 52},
  {cont__print_string_literal_108, &frame__print_string_literal_107, 1261, 1261, 23, 73},
  {entry__print_string_literal_98, NULL, 1257, 1257, 21, 32},
  {cont__print_string_literal_99, &frame__print_string_literal_98, 1258, 1261, 21, 73},
  {entry__print_string_literal_110, NULL, 1263, 1263, 39, 39},
  {entry__print_string_literal_96, NULL, 1256, 1256, 19, 29},
  {cont__print_string_literal_97, &frame__print_string_literal_96, 1255, 1263, 17, 40},
  {entry__print_string_literal_92, NULL, 1250, 1250, 13, 26},
  {cont__print_string_literal_93, &frame__print_string_literal_92, 1252, 1252, 15, 24},
  {cont__print_string_literal_94, &frame__print_string_literal_92, 1251, 1263, 13, 42},
  {cont__print_string_literal_111, &frame__print_string_literal_92, 1264, 1264, 13, 20},
  {cont__print_string_literal_112, &frame__print_string_literal_92, 1264, 1264, 20, 20},
  {entry__print_string_literal_90, NULL, 1249, 1249, 20, 34},
  {cont__print_string_literal_91, &frame__print_string_literal_90, 1249, 1264, 17, 20},
  {entry__print_string_literal_115, NULL, 1265, 1265, 72, 72},
  {entry__print_string_literal_44, NULL, 1249, 1264, 11, 20},
  {cont__print_string_literal_113, &frame__print_string_literal_44, 1265, 1265, 14, 40},
  {cont__print_string_literal_114, &frame__print_string_literal_44, 1265, 1265, 11, 72},
  {cont__print_string_literal_116, &frame__print_string_literal_44, 1266, 1266, 34, 61},
  {cont__print_string_literal_117, &frame__print_string_literal_44, 1266, 1266, 29, 67},
  {cont__print_string_literal_118, &frame__print_string_literal_44, 1266, 1266, 11, 67},
  {cont__print_string_literal_119, &frame__print_string_literal_44, 1267, 1267, 23, 38},
  {cont__print_string_literal_120, &frame__print_string_literal_44, 1267, 1267, 41, 41},
  {cont__print_string_literal_121, &frame__print_string_literal_44, 1267, 1267, 11, 41},
  {cont__print_string_literal_122, &frame__print_string_literal_44, 1267, 1267, 41, 41},
  {entry__print_string_literal_41, NULL, 1215, 1215, 18, 32},
  {cont__print_string_literal_42, &frame__print_string_literal_41, 1215, 1215, 18, 44},
  {cont__print_string_literal_43, &frame__print_string_literal_41, 1215, 1267, 15, 41},
  {entry__print_string_literal_31, NULL, 1214, 1214, 12, 21},
  {cont__print_string_literal_32, &frame__print_string_literal_31, 1214, 1214, 12, 21},
  {cont__print_string_literal_33, &frame__print_string_literal_31, 1214, 1214, 12, 39},
  {cont__print_string_literal_38, &frame__print_string_literal_31, 1214, 1214, 9, 66},
  {cont__print_string_literal_40, &frame__print_string_literal_31, 1215, 1267, 9, 41},
  {cont__print_string_literal_123, &frame__print_string_literal_31, 1268, 1268, 9, 30},
  {cont__print_string_literal_124, &frame__print_string_literal_31, 1268, 1268, 30, 30},
  {entry__print_string_literal_126, NULL, 1275, 1275, 9, 23},
  {cont__print_string_literal_128, &frame__print_string_literal_126, 1275, 1275, 23, 23},
  {entry__print_string_literal_133, NULL, 1281, 1281, 17, 17},
  {cont__print_string_literal_134, &frame__print_string_literal_133, 1281, 1281, 9, 18},
  {cont__print_string_literal_136, &frame__print_string_literal_133, 1281, 1281, 24, 24},
  {entry__print_string_literal_140, NULL, 1286, 1286, 23, 23},
  {entry__print_string_literal_142, NULL, 1288, 1288, 30, 43},
  {cont__print_string_literal_143, &frame__print_string_literal_142, 1288, 1288, 11, 53},
  {cont__print_string_literal_144, &frame__print_string_literal_142, 1289, 1289, 11, 24},
  {cont__print_string_literal_145, &frame__print_string_literal_142, 1289, 1289, 24, 24},
  {entry__print_string_literal_151, NULL, 1294, 1294, 11, 33},
  {cont__print_string_literal_152, &frame__print_string_literal_151, 1295, 1295, 11, 26},
  {cont__print_string_literal_153, &frame__print_string_literal_151, 1295, 1295, 26, 26},
  {entry__print_string_literal_148, NULL, 1292, 1292, 9, 24},
  {cont__print_string_literal_149, &frame__print_string_literal_148, 1293, 1293, 16, 25},
  {cont__print_string_literal_150, &frame__print_string_literal_148, 1293, 1295, 9, 26},
  {entry__print_string_literal_18, NULL, 1201, 1201, 15, 42},
  {cont__print_string_literal_19, &frame__print_string_literal_18, 1201, 1201, 11, 46},
  {cont__print_string_literal_20, &frame__print_string_literal_18, 1203, 1203, 13, 42},
  {cont__print_string_literal_21, &frame__print_string_literal_18, 1203, 1203, 13, 42},
  {cont__print_string_literal_22, &frame__print_string_literal_18, },
  {cont__print_string_literal_25, &frame__print_string_literal_18, 1199, 1205, 7, 18},
  {cont__print_string_literal_26, &frame__print_string_literal_18, 1207, 1207, 35, 35},
  {cont__print_string_literal_27, &frame__print_string_literal_18, 1207, 1207, 28, 36},
  {cont__print_string_literal_28, &frame__print_string_literal_18, 1207, 1207, 28, 42},
  {cont__print_string_literal_29, &frame__print_string_literal_18, 1207, 1210, 7, 32},
  {cont__print_string_literal_30, &frame__print_string_literal_18, 1213, 1268, 7, 30},
  {cont__print_string_literal_125, &frame__print_string_literal_18, 1270, 1275, 7, 23},
  {cont__print_string_literal_129, &frame__print_string_literal_18, 1276, 1276, 17, 17},
  {cont__print_string_literal_130, &frame__print_string_literal_18, 1276, 1276, 10, 18},
  {cont__print_string_literal_131, &frame__print_string_literal_18, 1276, 1276, 10, 24},
  {cont__print_string_literal_132, &frame__print_string_literal_18, 1276, 1281, 7, 24},
  {cont__print_string_literal_137, &frame__print_string_literal_18, 1285, 1285, 9, 38},
  {cont__print_string_literal_138, &frame__print_string_literal_18, 1285, 1285, 9, 38},
  {cont__print_string_literal_139, &frame__print_string_literal_18, 1284, 1289, 7, 25},
  {cont__print_string_literal_146, &frame__print_string_literal_18, 1290, 1290, 7, 33},
  {cont__print_string_literal_147, &frame__print_string_literal_18, 1291, 1295, 7, 27},
  {cont__print_string_literal_154, &frame__print_string_literal_18, 1296, 1296, 7, 12},
  {entry__print_string_literal_1, NULL, 1190, 1194, 3, 26},
  {cont__print_string_literal_14, &frame__print_string_literal_1, 1195, 1296, 3, 13},
  {entry__string_template_to_string_4, NULL, 1305, 1305, 9, 71},
  {cont__string_template_to_string_5, &frame__string_template_to_string_4, 1305, 1305, 71, 71},
  {entry__string_template_to_string_7, NULL, 1309, 1309, 21, 28},
  {cont__string_template_to_string_8, &frame__string_template_to_string_7, 1309, 1309, 13, 63},
  {cont__string_template_to_string_9, &frame__string_template_to_string_7, 1309, 1309, 20, 28},
  {cont__string_template_to_string_10, &frame__string_template_to_string_7, 1309, 1309, 63, 63},
  {entry__string_template_to_string_16, NULL, 1318, 1318, 48, 48},
  {cont__string_template_to_string_17, &frame__string_template_to_string_16, 1318, 1318, 41, 49},
  {cont__string_template_to_string_18, &frame__string_template_to_string_16, 1318, 1318, 54, 54},
  {cont__string_template_to_string_19, &frame__string_template_to_string_16, 1318, 1318, 35, 55},
  {cont__string_template_to_string_20, &frame__string_template_to_string_16, 1318, 1318, 17, 61},
  {cont__string_template_to_string_21, &frame__string_template_to_string_16, 1318, 1318, 25, 25},
  {cont__string_template_to_string_22, &frame__string_template_to_string_16, 1318, 1318, 17, 26},
  {cont__string_template_to_string_23, &frame__string_template_to_string_16, 1318, 1318, 61, 61},
  {entry__string_template_to_string_24, NULL, 1322, 1322, 17, 32},
  {cont__string_template_to_string_25, &frame__string_template_to_string_24, 1322, 1322, 32, 32},
  {entry__string_template_to_string_11, NULL, 1311, 1311, 13, 77},
  {cont__string_template_to_string_12, &frame__string_template_to_string_11, 1313, 1313, 22, 22},
  {cont__string_template_to_string_13, &frame__string_template_to_string_11, 1313, 1313, 15, 23},
  {cont__string_template_to_string_14, &frame__string_template_to_string_11, 1313, 1313, 15, 41},
  {cont__string_template_to_string_15, &frame__string_template_to_string_11, 1312, 1322, 13, 33},
  {entry__string_template_to_string_6, NULL, 1307, 1322, 9, 35},
  {entry__string_template_to_string_2, NULL, 1304, 1304, 7, 20},
  {cont__string_template_to_string_3, &frame__string_template_to_string_2, 1303, 1322, 5, 37},
  {entry__string_template_to_string_28, NULL, 1327, 1327, 25, 25},
  {entry__string_template_to_string_30, NULL, 1333, 1333, 35, 42},
  {cont__string_template_to_string_31, &frame__string_template_to_string_30, 1333, 1333, 44, 56},
  {cont__string_template_to_string_32, &frame__string_template_to_string_30, 1333, 1333, 13, 57},
  {cont__string_template_to_string_33, &frame__string_template_to_string_30, 1333, 1333, 13, 26},
  {cont__string_template_to_string_34, &frame__string_template_to_string_30, 1334, 1334, 29, 29},
  {entry__string_template_to_string_35, NULL, 1345, 1345, 44, 44},
  {cont__string_template_to_string_36, &frame__string_template_to_string_35, 1345, 1345, 37, 45},
  {cont__string_template_to_string_37, &frame__string_template_to_string_35, 1345, 1345, 50, 50},
  {cont__string_template_to_string_38, &frame__string_template_to_string_35, 1345, 1345, 31, 51},
  {cont__string_template_to_string_39, &frame__string_template_to_string_35, 1345, 1345, 53, 65},
  {cont__string_template_to_string_40, &frame__string_template_to_string_35, 1345, 1345, 13, 66},
  {cont__string_template_to_string_41, &frame__string_template_to_string_35, 1345, 1345, 21, 21},
  {cont__string_template_to_string_42, &frame__string_template_to_string_35, 1345, 1345, 13, 22},
  {cont__string_template_to_string_43, &frame__string_template_to_string_35, 1346, 1346, 47, 47},
  {cont__string_template_to_string_44, &frame__string_template_to_string_35, 1346, 1346, 27, 48},
  {cont__string_template_to_string_45, &frame__string_template_to_string_35, 1346, 1346, 13, 48},
  {cont__string_template_to_string_46, &frame__string_template_to_string_35, 1346, 1346, 48, 48},
  {entry__string_template_to_string_29, NULL, 1329, 1346, 9, 49},
  {entry__string_template_to_string_26, NULL, 1326, 1326, 7, 20},
  {cont__string_template_to_string_27, &frame__string_template_to_string_26, 1325, 1346, 5, 51},
  {cont__string_template_to_string_47, &frame__string_template_to_string_26, 1347, 1347, 29, 29},
  {entry__string_template_to_string_54, NULL, 1357, 1357, 22, 34},
  {cont__string_template_to_string_55, &frame__string_template_to_string_54, 1357, 1357, 13, 34},
  {entry__string_template_to_string_56, NULL, 1359, 1359, 13, 32},
  {entry__string_template_to_string_51, NULL, 1354, 1354, 55, 77},
  {cont__string_template_to_string_52, &frame__string_template_to_string_51, 1354, 1354, 9, 77},
  {cont__string_template_to_string_53, &frame__string_template_to_string_51, 1355, 1359, 9, 33},
  {entry__string_template_to_string_57, NULL, 1362, 1362, 31, 48},
  {cont__string_template_to_string_58, &frame__string_template_to_string_57, 1362, 1362, 18, 53},
  {cont__string_template_to_string_60, &frame__string_template_to_string_57, 1362, 1362, 9, 53},
  {cont__string_template_to_string_61, &frame__string_template_to_string_57, 1362, 1362, 53, 53},
  {entry__string_template_to_string_49, NULL, 1353, 1353, 7, 34},
  {cont__string_template_to_string_50, &frame__string_template_to_string_49, 1352, 1362, 5, 54},
  {entry__string_template_to_string_67, NULL, 1363, 1363, 54, 54},
  {cont__string_template_to_string_68, &frame__string_template_to_string_67, 1363, 1363, 47, 55},
  {cont__string_template_to_string_69, &frame__string_template_to_string_67, 1363, 1363, 60, 60},
  {cont__string_template_to_string_70, &frame__string_template_to_string_67, 1363, 1363, 40, 78},
  {cont__string_template_to_string_71, &frame__string_template_to_string_67, 1363, 1363, 54, 54},
  {cont__string_template_to_string_72, &frame__string_template_to_string_67, 1363, 1363, 46, 55},
  {cont__string_template_to_string_73, &frame__string_template_to_string_67, 1363, 1363, 78, 78},
  {entry__string_template_to_string_1, NULL, 1351, 1351, 12, 29},
  {cont__string_template_to_string_48, &frame__string_template_to_string_1, 1351, 1362, 3, 55},
  {cont__string_template_to_string_62, &frame__string_template_to_string_1, 1363, 1363, 13, 13},
  {cont__string_template_to_string_63, &frame__string_template_to_string_1, 1363, 1363, 6, 14},
  {cont__string_template_to_string_64, &frame__string_template_to_string_1, 1363, 1363, 6, 37},
  {cont__string_template_to_string_66, &frame__string_template_to_string_1, 1363, 1363, 3, 78},
  {cont__string_template_to_string_74, &frame__string_template_to_string_1, 1364, 1364, 3, 47},
  {entry__compiler__string_literal__to_string_1, NULL, 1367, 1367, 44, 62},
  {cont__compiler__string_literal__to_string_2, &frame__compiler__string_literal__to_string_1, 1367, 1367, 3, 62},
  {cont__compiler__string_literal__to_string_3, &frame__compiler__string_literal__to_string_1, 1368, 1368, 3, 38},
  {entry__compiler__unique_item__to_string_1, NULL, 1373, 1373, 43, 48},
  {entry__compiler__polymorphic_function__to_string_3, NULL, 1381, 1381, 5, 12},
  {entry__compiler__polymorphic_function__to_string_5, NULL, 1382, 1382, 5, 11},
  {entry__compiler__polymorphic_function__to_string_1, NULL, 1380, 1380, 5, 20},
  {cont__compiler__polymorphic_function__to_string_2, &frame__compiler__polymorphic_function__to_string_1, 1379, 1382, 3, 11},
  {entry__compiler__identifier__to_string_5, NULL, 1391, 1391, 17, 34},
  {cont__compiler__identifier__to_string_6, &frame__compiler__identifier__to_string_5, 1391, 1391, 41, 53},
  {cont__compiler__identifier__to_string_7, &frame__compiler__identifier__to_string_5, 1391, 1391, 10, 54},
  {cont__compiler__identifier__to_string_9, &frame__compiler__identifier__to_string_5, 1391, 1391, 7, 54},
  {entry__compiler__identifier__to_string_2, NULL, 1390, 1390, 7, 24},
  {cont__compiler__identifier__to_string_3, &frame__compiler__identifier__to_string_2, 1390, 1390, 7, 35},
  {cont__compiler__identifier__to_string_4, &frame__compiler__identifier__to_string_2, 1389, 1391, 5, 54},
  {entry__compiler__identifier__to_string_12, NULL, 1392, 1392, 39, 51},
  {cont__compiler__identifier__to_string_13, &frame__compiler__identifier__to_string_12, 1392, 1392, 28, 52},
  {cont__compiler__identifier__to_string_14, &frame__compiler__identifier__to_string_12, 1392, 1392, 25, 52},
  {entry__compiler__identifier__to_string_10, NULL, 1392, 1392, 8, 23},
  {cont__compiler__identifier__to_string_11, &frame__compiler__identifier__to_string_10, 1392, 1392, 5, 52},
  {entry__compiler__identifier__to_string_16, NULL, 1393, 1393, 16, 28},
  {cont__compiler__identifier__to_string_17, &frame__compiler__identifier__to_string_16, 1393, 1393, 13, 28},
  {entry__compiler__identifier__to_string_15, NULL, 1393, 1393, 5, 28},
  {entry__compiler__identifier__to_string_1, NULL, 1388, 1393, 3, 28},
  {entry__compiler__c_code__to_string_4, NULL, 1407, 1407, 28, 52},
  {cont__compiler__c_code__to_string_5, &frame__compiler__c_code__to_string_4, 1407, 1407, 14, 61},
  {cont__compiler__c_code__to_string_7, &frame__compiler__c_code__to_string_4, 1407, 1407, 11, 61},
  {entry__compiler__c_code__to_string_8, NULL, 1408, 1408, 11, 20},
  {entry__compiler__c_code__to_string_14, NULL, 1413, 1413, 46, 58},
  {cont__compiler__c_code__to_string_15, &frame__compiler__c_code__to_string_14, 1413, 1413, 37, 61},
  {cont__compiler__c_code__to_string_17, &frame__compiler__c_code__to_string_14, 1413, 1413, 9, 61},
  {cont__compiler__c_code__to_string_18, &frame__compiler__c_code__to_string_14, 1413, 1413, 61, 61},
  {entry__compiler__c_code__to_string_22, NULL, 1415, 1415, 46, 64},
  {cont__compiler__c_code__to_string_23, &frame__compiler__c_code__to_string_22, 1415, 1415, 37, 67},
  {cont__compiler__c_code__to_string_25, &frame__compiler__c_code__to_string_22, 1415, 1415, 9, 67},
  {cont__compiler__c_code__to_string_26, &frame__compiler__c_code__to_string_22, 1415, 1415, 67, 67},
  {entry__compiler__c_code__to_string_30, NULL, 1417, 1417, 46, 58},
  {cont__compiler__c_code__to_string_31, &frame__compiler__c_code__to_string_30, 1417, 1417, 37, 61},
  {cont__compiler__c_code__to_string_33, &frame__compiler__c_code__to_string_30, 1417, 1417, 9, 61},
  {cont__compiler__c_code__to_string_34, &frame__compiler__c_code__to_string_30, 1417, 1417, 61, 61},
  {entry__compiler__c_code__to_string_38, NULL, 1419, 1419, 46, 64},
  {cont__compiler__c_code__to_string_39, &frame__compiler__c_code__to_string_38, 1419, 1419, 37, 67},
  {cont__compiler__c_code__to_string_41, &frame__compiler__c_code__to_string_38, 1419, 1419, 9, 67},
  {cont__compiler__c_code__to_string_42, &frame__compiler__c_code__to_string_38, 1419, 1419, 67, 67},
  {entry__compiler__c_code__to_string_46, NULL, 1421, 1421, 46, 58},
  {cont__compiler__c_code__to_string_47, &frame__compiler__c_code__to_string_46, 1421, 1421, 37, 61},
  {cont__compiler__c_code__to_string_49, &frame__compiler__c_code__to_string_46, 1421, 1421, 9, 61},
  {cont__compiler__c_code__to_string_50, &frame__compiler__c_code__to_string_46, 1421, 1421, 61, 61},
  {entry__compiler__c_code__to_string_54, NULL, 1422, 1422, 39, 52},
  {cont__compiler__c_code__to_string_55, &frame__compiler__c_code__to_string_54, 1422, 1422, 39, 63},
  {cont__compiler__c_code__to_string_57, &frame__compiler__c_code__to_string_54, 1422, 1422, 39, 63},
  {cont__compiler__c_code__to_string_58, &frame__compiler__c_code__to_string_54, 1422, 1422, 39, 63},
  {entry__compiler__c_code__to_string_60, NULL, 1423, 1423, 47, 60},
  {cont__compiler__c_code__to_string_61, &frame__compiler__c_code__to_string_60, 1423, 1423, 37, 63},
  {cont__compiler__c_code__to_string_63, &frame__compiler__c_code__to_string_60, 1423, 1423, 9, 63},
  {cont__compiler__c_code__to_string_64, &frame__compiler__c_code__to_string_60, 1423, 1423, 63, 63},
  {entry__compiler__c_code__to_string_67, NULL, 1425, 1425, 37, 60},
  {cont__compiler__c_code__to_string_69, &frame__compiler__c_code__to_string_67, 1425, 1425, 9, 60},
  {cont__compiler__c_code__to_string_70, &frame__compiler__c_code__to_string_67, 1425, 1425, 60, 60},
  {entry__compiler__c_code__to_string_77, NULL, 1429, 1429, 11, 54},
  {cont__compiler__c_code__to_string_79, &frame__compiler__c_code__to_string_77, 1429, 1429, 54, 54},
  {entry__compiler__c_code__to_string_74, NULL, 1427, 1427, 9, 24},
  {cont__compiler__c_code__to_string_75, &frame__compiler__c_code__to_string_74, 1428, 1428, 18, 38},
  {cont__compiler__c_code__to_string_76, &frame__compiler__c_code__to_string_74, 1428, 1429, 9, 54},
  {entry__compiler__c_code__to_string_86, NULL, 1431, 1431, 32, 46},
  {cont__compiler__c_code__to_string_87, &frame__compiler__c_code__to_string_86, 1431, 1431, 46, 46},
  {entry__compiler__c_code__to_string_90, NULL, 1432, 1432, 47, 78},
  {cont__compiler__c_code__to_string_91, &frame__compiler__c_code__to_string_90, 1432, 1432, 78, 78},
  {entry__compiler__c_code__to_string_83, NULL, 1431, 1431, 12, 25},
  {cont__compiler__c_code__to_string_84, &frame__compiler__c_code__to_string_83, 1431, 1431, 12, 29},
  {cont__compiler__c_code__to_string_85, &frame__compiler__c_code__to_string_83, 1431, 1431, 9, 46},
  {cont__compiler__c_code__to_string_88, &frame__compiler__c_code__to_string_83, 1432, 1432, 23, 37},
  {cont__compiler__c_code__to_string_89, &frame__compiler__c_code__to_string_83, 1432, 1432, 9, 78},
  {entry__compiler__c_code__to_string_2, NULL, 1406, 1406, 11, 31},
  {cont__compiler__c_code__to_string_3, &frame__compiler__c_code__to_string_2, 1404, 1408, 7, 21},
  {cont__compiler__c_code__to_string_9, &frame__compiler__c_code__to_string_2, 1410, 1410, 7, 33},
  {cont__compiler__c_code__to_string_10, &frame__compiler__c_code__to_string_2, 1411, 1411, 7, 33},
  {cont__compiler__c_code__to_string_11, &frame__compiler__c_code__to_string_2, 1412, 1412, 10, 22},
  {cont__compiler__c_code__to_string_12, &frame__compiler__c_code__to_string_2, 1412, 1412, 10, 33},
  {cont__compiler__c_code__to_string_13, &frame__compiler__c_code__to_string_2, 1412, 1413, 7, 61},
  {cont__compiler__c_code__to_string_19, &frame__compiler__c_code__to_string_2, 1414, 1414, 10, 28},
  {cont__compiler__c_code__to_string_20, &frame__compiler__c_code__to_string_2, 1414, 1414, 10, 39},
  {cont__compiler__c_code__to_string_21, &frame__compiler__c_code__to_string_2, 1414, 1415, 7, 67},
  {cont__compiler__c_code__to_string_27, &frame__compiler__c_code__to_string_2, 1416, 1416, 10, 22},
  {cont__compiler__c_code__to_string_28, &frame__compiler__c_code__to_string_2, 1416, 1416, 10, 33},
  {cont__compiler__c_code__to_string_29, &frame__compiler__c_code__to_string_2, 1416, 1417, 7, 61},
  {cont__compiler__c_code__to_string_35, &frame__compiler__c_code__to_string_2, 1418, 1418, 10, 28},
  {cont__compiler__c_code__to_string_36, &frame__compiler__c_code__to_string_2, 1418, 1418, 10, 39},
  {cont__compiler__c_code__to_string_37, &frame__compiler__c_code__to_string_2, 1418, 1419, 7, 67},
  {cont__compiler__c_code__to_string_43, &frame__compiler__c_code__to_string_2, 1420, 1420, 10, 22},
  {cont__compiler__c_code__to_string_44, &frame__compiler__c_code__to_string_2, 1420, 1420, 10, 33},
  {cont__compiler__c_code__to_string_45, &frame__compiler__c_code__to_string_2, 1420, 1421, 7, 61},
  {cont__compiler__c_code__to_string_51, &frame__compiler__c_code__to_string_2, 1422, 1422, 10, 23},
  {cont__compiler__c_code__to_string_52, &frame__compiler__c_code__to_string_2, 1422, 1422, 10, 34},
  {cont__compiler__c_code__to_string_53, &frame__compiler__c_code__to_string_2, 1422, 1422, 10, 63},
  {cont__compiler__c_code__to_string_59, &frame__compiler__c_code__to_string_2, 1422, 1423, 7, 63},
  {cont__compiler__c_code__to_string_65, &frame__compiler__c_code__to_string_2, 1424, 1424, 16, 33},
  {cont__compiler__c_code__to_string_66, &frame__compiler__c_code__to_string_2, 1424, 1425, 7, 60},
  {cont__compiler__c_code__to_string_71, &frame__compiler__c_code__to_string_2, 1426, 1426, 14, 34},
  {cont__compiler__c_code__to_string_72, &frame__compiler__c_code__to_string_2, 1426, 1426, 14, 43},
  {cont__compiler__c_code__to_string_73, &frame__compiler__c_code__to_string_2, 1426, 1429, 7, 55},
  {cont__compiler__c_code__to_string_80, &frame__compiler__c_code__to_string_2, 1430, 1430, 10, 24},
  {cont__compiler__c_code__to_string_81, &frame__compiler__c_code__to_string_2, 1430, 1430, 10, 35},
  {cont__compiler__c_code__to_string_82, &frame__compiler__c_code__to_string_2, 1430, 1432, 7, 78},
  {cont__compiler__c_code__to_string_92, &frame__compiler__c_code__to_string_2, 1433, 1433, 26, 50},
  {cont__compiler__c_code__to_string_93, &frame__compiler__c_code__to_string_2, 1433, 1433, 19, 55},
  {cont__compiler__c_code__to_string_94, &frame__compiler__c_code__to_string_2, 1433, 1433, 7, 55},
  {cont__compiler__c_code__to_string_95, &frame__compiler__c_code__to_string_2, 1434, 1434, 7, 12},
  {entry__compiler__c_code__to_string_96, NULL, 1402, 1402, 5, 14},
  {entry__compiler__c_code__to_string_1, NULL, 1400, 1434, 3, 13}
};

union NODE {
  struct {
    FUNC type;
    ATTRIBUTES *attributes;
  };
  CONTINUATION continuation;
  CLOSURE closure;
};
static void type__needs_parenthesis(void) {
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  myself = get_attribute(arguments->slots[0], poly_idx__needs_parenthesis);
  if (CONTAINS_AN_ATTRIBUTE_VALUE(myself)) {
    if (argument_count != 1) {
      if (argument_count != 2) invalid_arguments_error();
      NODE *attr = arguments->slots[1];
      NODE *temp = clone_object_and_attributes(arguments->slots[0]);
      update_start_p = node_p;
      set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, attr);
      arguments = node_p;
      argument_count = 1;
      arguments->slots[0] = temp;
    } else {
      arguments = node_p;
      arguments->slots[0] = RETRIEVE_ATTRIBUTE_VALUE(myself);
    }
    func = frame->cont;
    frame->cont = invalid_continuation;
  } else {
    func = myself->type;
  }
}
static NODE *character__9;
static NODE *number__6;
static NODE *character__35;
static NODE *character__38;
static NODE *character__47;
static NODE *character__94;
static NODE *number__80;
static NODE *character__160;
static NODE *character__96;
static NODE *character__99;
static NODE *character__688;
static NODE *character__63;
static NODE *character__10;
static NODE *number__999999;
static NODE *character__109;
static NODE *character__58;
static NODE *number__0;
static NODE *number__3;
static NODE *number__4;
static NODE *character__37;
static NODE *character__95;
static NODE *number__0x80;
static NODE *character__33;
static NODE *number__8;
static NODE *character__64;
static NODE *character__98;
static NODE *character__40;
static NODE *character__111;
static NODE *character__34;
static NODE *character__36;
static NODE *character__39;
static NODE *character__105;
static NODE *character__32;
static NODE *character__125;
static NODE *character__115;
static NODE *character__41;
static NODE *character__59;
static NODE *number__1;
static NODE *number__0x9f;
static NODE *character__46;
static NODE *number__2;
static NODE *number__20;
static NODE *character__42;
static NODE *character__128;
static NODE *character__79;
static NODE *character__114;

static const char *used_namespaces[] = {
  "std",
  "compiler",
  "node",
  NULL
};

static MODULE_INFO module_info = {
  NULL,
  "pretty_printer",
  continuation_info,
  sizeof(continuation_info)/sizeof(CONTINUATION_INFO),
  (NODE **)&var,
  var_names,
  sizeof(var_names)/sizeof(const char *),
  used_namespaces,
  {DEBUG_FILENAME("pretty_printer.sim")}
};

/******
C O D E
******/

static int already_run = false;

EXPORT void run__pretty_printer(void) {
  if (already_run) {
    func = frame->cont;
    frame->cont = invalid_continuation;
    return;
  }
  already_run = true;
  allocate_initialized_frame_gc(0, 0);
  // 77: %compiler::hide_body_statements false
  // 78:   # replaces all statements of a body with a single ellipsis ("...")
  initialize_maybe_future(get__compiler__hide_body_statements(), get__false());
  // 137: $INDENTATION_MARKER character(0x80)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0x80;
  result_count = 1;
  myself = get__character();
  func = myself->type;
  frame->cont = cont__92_1;
}
static void cont__92_1(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(var._INDENTATION_MARKER, arguments->slots[0]);
  // 138: $INDENTATION_MARKER_HIGH character(0x9f)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0x9f;
  result_count = 1;
  myself = get__character();
  func = myself->type;
  frame->cont = cont__93_1;
}
static void cont__93_1(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(var._INDENTATION_MARKER_HIGH, arguments->slots[0]);
  // 139: $INDENTATION types::grammar_object
  initialize_maybe_future(var._INDENTATION, get__types__grammar_object());
  // 152: %%statement_tag undefined
  // 153:   #
  // 154:     if a statement sets a tag then it will be surrounded by blank lines;
  // 155:     two consecutive lines with the same tag (with the exception of <ALWAYS>)
  // 156:     will not be separated by a blank line
  set__statement_tag(get__undefined());
  // 158: %spaces std::spaces
  initialize_maybe_future(get__spaces(), get__std__spaces());
  // 1059: $$character_to_name undefined
  var._character_to_name = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__INDENTATION__grammar__match_13(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 149: -> 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__INDENTATION__grammar__match_14(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 150: -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__INDENTATION__grammar__match_1(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // self: 0
  // stream: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 146: stream .has_minimum_length. 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* stream */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__has_minimum_length();
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_2;
}
static void cont__INDENTATION__grammar__match_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__3 */ = create_closure(entry__INDENTATION__grammar__match_3, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_12;
}
static void entry__INDENTATION__grammar__match_3(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // stream: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* stream */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 147: stream(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* stream */;
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_4;
}
static void cont__INDENTATION__grammar__match_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 147: stream(1) >= INDENTATION_MARKER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = var._INDENTATION_MARKER;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_5;
}
static void cont__INDENTATION__grammar__match_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 147: stream(1) >= INDENTATION_MARKER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_6;
}
static void cont__INDENTATION__grammar__match_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 148: stream(1) <= INDENTATION_MARKER_HIGH
  frame->slots[5] /* temp__5 */ = create_closure(entry__INDENTATION__grammar__match_7, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_11;
}
static void entry__INDENTATION__grammar__match_7(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // stream: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* stream */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 148: stream(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* stream */;
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_8;
}
static void cont__INDENTATION__grammar__match_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 148: stream(1) <= INDENTATION_MARKER_HIGH
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = var._INDENTATION_MARKER_HIGH;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_9;
}
static void cont__INDENTATION__grammar__match_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 148: stream(1) <= INDENTATION_MARKER_HIGH
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__INDENTATION__grammar__match_10;
}
static void cont__INDENTATION__grammar__match_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 148: stream(1) <= INDENTATION_MARKER_HIGH
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__INDENTATION__grammar__match_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__INDENTATION__grammar__match_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 144: if
  // 145:   &&
  // 146:     stream .has_minimum_length. 1
  // 147:     stream(1) >= INDENTATION_MARKER
  // 148:     stream(1) <= INDENTATION_MARKER_HIGH
  // 149:   -> 1
  // 150:   -> 0
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = func__INDENTATION__grammar__match_13;
  arguments->slots[2] = func__INDENTATION__grammar__match_14;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__indentation_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // indent: 0
  // indentation: 1
  frame->slots[1] /* indentation */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* indent */ = create_cell_with_contents(arguments->slots[0]);
  // 163: $$indentation ""
  ((CELL *)frame->slots[1])->contents /* indentation */ = empty_string;
  // 164: ... -> indent >= 8:
  // 165:   push &indentation '@ht;'
  // 166:   minus &indent 8
  frame->slots[2] /* temp__1 */ = create_closure(entry__indentation_string_2, 0);
  // 164: while -> indent >= 8:
  // 165:   push &indentation '@ht;'
  // 166:   minus &indent 8
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__indentation_string_8;
}
static void entry__indentation_string_5(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // indentation: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* indentation */
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 165: push &indentation '@ht;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indentation */;
  arguments->slots[1] = character__9;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__indentation_string_6;
}
static void cont__indentation_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* indentation */ = arguments->slots[0];
  // 166: minus &indent 8
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__8;
  result_count = 1;
  myself = get__minus();
  func = myself->type;
  frame->cont = cont__indentation_string_7;
}
static void cont__indentation_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__indentation_string_2(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // indent: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 164: ... indent >= 8
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  arguments->slots[1] = number__8;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__indentation_string_3;
}
static void cont__indentation_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 164: ... indent >= 8
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__indentation_string_4;
}
static void cont__indentation_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 164: ... :
  // 165:   push &indentation '@ht;'
  // 166:   minus &indent 8
  frame->slots[4] /* temp__3 */ = create_closure(entry__indentation_string_5, 0);
  // 164: ... -> indent >= 8:
  // 165:   push &indentation '@ht;'
  // 166:   minus &indent 8
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__indentation_string_8(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 167: ... std::spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__std__spaces();
  func = myself->type;
  frame->cont = cont__indentation_string_9;
}
static void cont__indentation_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 167: append indentation std::spaces(indent)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indentation */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__append();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__print_trees_1(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // trees: 0
  // return__1: 1
  frame->slots[1] /* return__1 */ = create_continuation();
  // _define %spaces 
  // : (indent)
  //   std::shift_right !temp__3 indent 1
  //   std::plus !temp__2 INDENTATION_MARKER temp__3
  //   string !temp__1 temp__2
  //   -> temp__1
  define__spaces(func__compiler__print_trees_2);
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 177: for_each trees: (idx tree)
  // 178:   $previous_statement_tag statement_tag
  // 179:   !statement_tag undefined
  // 180:   $str tree.to_string
  // 181:   if
  // 182:     &&
  // 183:       idx > 1
  // 184:       statement_tag == ALWAYS || previous_statement_tag != statement_tag
  // 185:     :
  // 186:       writeln
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* trees */;
  arguments->slots[1] = func__compiler__print_trees_6;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_47;
}
static void entry__compiler__print_trees_46(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // line: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 210: ... writeln line
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__print_trees_2(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // indent: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 175: ... indent >> 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__shift_right();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_3;
}
static void cont__compiler__print_trees_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 175: ... INDENTATION_MARKER+(indent >> 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = var._INDENTATION_MARKER;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_4;
}
static void cont__compiler__print_trees_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 175: ... string(INDENTATION_MARKER+(indent >> 1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_5;
}
static void cont__compiler__print_trees_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 175: -> string(INDENTATION_MARKER+(indent >> 1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__print_trees_6(void) {
  allocate_initialized_frame_gc(2, 10);
  // slot allocations:
  // idx: 0
  // tree: 1
  // previous_statement_tag: 2
  // str: 3
  // lines: 4
  // add_line: 5
  // n: 6
  frame->slots[5] /* add_line */ = create_future();
  frame->slots[2] /* previous_statement_tag */ = create_future();
  frame->slots[3] /* str */ = create_future();
  frame->slots[4] /* lines */ = create_cell();
  frame->slots[6] /* n */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 189: ... : (line)
  // 190:   if
  // 191:     length_of(line) > 1:
  // 192:       $indent 2*(line(1)-INDENTATION_MARKER)
  // 193:       $text range(line 2 -1)
  // 194:       put &lines string(indentation_string(indent) text)
  // 195:     :
  // 196:       put &lines ""
  frame->slots[7] /* temp__1 */ = create_closure(entry__compiler__print_trees_7, 1);
  // 189: $add_line: (line)
  // 190:   if
  // 191:     length_of(line) > 1:
  // 192:       $indent 2*(line(1)-INDENTATION_MARKER)
  // 193:       $text range(line 2 -1)
  // 194:       put &lines string(indentation_string(indent) text)
  // 195:     :
  // 196:       put &lines ""
  initialize_future(frame->slots[5] /* add_line */, frame->slots[7] /* temp__1 */);
  // 178: $previous_statement_tag statement_tag
  initialize_future(frame->slots[2] /* previous_statement_tag */, get__statement_tag());
  // 179: !statement_tag undefined
  set__statement_tag(get__undefined());
  // 180: $str tree.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* tree */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_21;
}
static void entry__compiler__print_trees_10(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // lines: 1
  // indent: 2
  // text: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] /* indent */ = create_future();
  frame->slots[3] /* text */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 192: ... line(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* line */;
  func = myself->type;
  frame->cont = cont__compiler__print_trees_11;
}
static void cont__compiler__print_trees_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 192: ... line(1)-INDENTATION_MARKER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = var._INDENTATION_MARKER;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_12;
}
static void cont__compiler__print_trees_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 192: $indent 2*(line(1)-INDENTATION_MARKER)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__std__times();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_13;
}
static void cont__compiler__print_trees_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* indent */, arguments->slots[0]);
  // 193: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_14;
}
static void cont__compiler__print_trees_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 193: $text range(line 2 -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_15;
}
static void cont__compiler__print_trees_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* text */, arguments->slots[0]);
  // 194: ... indentation_string(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* indent */;
  result_count = 1;
  myself = var._indentation_string;
  func = myself->type;
  frame->cont = cont__compiler__print_trees_16;
}
static void cont__compiler__print_trees_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 194: ... string(indentation_string(indent) text)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* text */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_17;
}
static void cont__compiler__print_trees_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 194: put &lines string(indentation_string(indent) text)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_18;
}
static void cont__compiler__print_trees_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__print_trees_19(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 196: put &lines ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_20;
}
static void cont__compiler__print_trees_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__print_trees_7(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // lines: 1
  frame->slots[1] = myself->closure.frame->slots[4]; /* lines */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 191: length_of(line)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_8;
}
static void cont__compiler__print_trees_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 191: length_of(line) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_9;
}
static void cont__compiler__print_trees_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 191: ... :
  // 192:   $indent 2*(line(1)-INDENTATION_MARKER)
  // 193:   $text range(line 2 -1)
  // 194:   put &lines string(indentation_string(indent) text)
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__print_trees_10, 0);
  // 195: :
  // 196:   put &lines ""
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__print_trees_19, 0);
  // 190: if
  // 191:   length_of(line) > 1:
  // 192:     $indent 2*(line(1)-INDENTATION_MARKER)
  // 193:     $text range(line 2 -1)
  // 194:     put &lines string(indentation_string(indent) text)
  // 195:   :
  // 196:     put &lines ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__print_trees_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* str */, arguments->slots[0]);
  // 183: idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_22;
}
static void cont__compiler__print_trees_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 184: statement_tag == ALWAYS || previous_statement_tag != statement_tag
  frame->slots[9] /* temp__3 */ = create_closure(entry__compiler__print_trees_23, 0);
  // 182: &&
  // 183:   idx > 1
  // 184:   statement_tag == ALWAYS || previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_29;
}
static void entry__compiler__print_trees_23(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 184: statement_tag == ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__statement_tag();
  arguments->slots[1] = var._ALWAYS;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_24;
}
static void cont__compiler__print_trees_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 184: ... previous_statement_tag != statement_tag
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__print_trees_25, 0);
  // 184: statement_tag == ALWAYS || previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_28;
}
static void entry__compiler__print_trees_25(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 184: ... previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* previous_statement_tag */;
  arguments->slots[1] = get__statement_tag();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_26;
}
static void cont__compiler__print_trees_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 184: ... previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_27;
}
static void cont__compiler__print_trees_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 184: ... previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__print_trees_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 184: statement_tag == ALWAYS || previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__print_trees_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 181: if
  // 182:   &&
  // 183:     idx > 1
  // 184:     statement_tag == ALWAYS || previous_statement_tag != statement_tag
  // 185:   :
  // 186:     writeln
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = func__compiler__print_trees_30;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_31;
}
static void entry__compiler__print_trees_30(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 186: writeln
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = get__writeln();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__print_trees_31(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 187: $$lines empty_list
  ((CELL *)frame->slots[4])->contents /* lines */ = get__empty_list();
  // 198: $$n length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_32;
}
static void cont__compiler__print_trees_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* n */ = arguments->slots[0];
  // 199: ... : (i)
  // 200:   if str(i) == '@nl;':
  // 201:     add_line range(str i+1 n)
  // 202:     !n i-1
  frame->slots[7] /* temp__1 */ = create_closure(entry__compiler__print_trees_33, 1);
  // 199: from_down_to n 1: (i)
  // 200:   if str(i) == '@nl;':
  // 201:     add_line range(str i+1 n)
  // 202:     !n i-1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* n */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__from_down_to();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_41;
}
static void entry__compiler__print_trees_36(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // add_line: 0
  // str: 1
  // i: 2
  // n: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* add_line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  frame->slots[2] = myself->closure.frame->slots[0]; /* i */
  frame->slots[3] = myself->closure.frame->slots[3]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 201: ... i+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* i */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_37;
}
static void cont__compiler__print_trees_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 201: ... range(str i+1 n)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* str */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = ((CELL *)frame->slots[3])->contents /* n */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_38;
}
static void cont__compiler__print_trees_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 201: add_line range(str i+1 n)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = frame->slots[0] /* add_line */;
  func = myself->type;
  frame->cont = cont__compiler__print_trees_39;
}
static void cont__compiler__print_trees_39(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 202: !n i-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* i */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_40;
}
static void cont__compiler__print_trees_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* n */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__print_trees_33(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // i: 0
  // str: 1
  // add_line: 2
  // n: 3
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  frame->slots[2] = myself->closure.frame->slots[5]; /* add_line */
  frame->slots[3] = myself->closure.frame->slots[6]; /* n */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 200: ... str(i)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* i */;
  result_count = 1;
  myself = frame->slots[1] /* str */;
  func = myself->type;
  frame->cont = cont__compiler__print_trees_34;
}
static void cont__compiler__print_trees_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 200: ... str(i) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_35;
}
static void cont__compiler__print_trees_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 200: ... :
  // 201:   add_line range(str i+1 n)
  // 202:   !n i-1
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__print_trees_36, 0);
  // 200: if str(i) == '@nl;':
  // 201:   add_line range(str i+1 n)
  // 202:   !n i-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__print_trees_41(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 205: spaces(0)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_42;
}
static void cont__compiler__print_trees_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 209: range(str 1 n)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* str */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = ((CELL *)frame->slots[6])->contents /* n */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_43;
}
static void cont__compiler__print_trees_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__print_trees_44;
}
static void cont__compiler__print_trees_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 203: add_line
  // 204:   string
  // 205:     spaces(0)
  // 206:     
  // 207:     # add a zero indent for the first line of a tree
  // 208:     
  // 209:     range(str 1 n)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = frame->slots[5] /* add_line */;
  func = myself->type;
  frame->cont = cont__compiler__print_trees_45;
}
static void cont__compiler__print_trees_45(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 210: for_each lines: (line) writeln line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* lines */;
  arguments->slots[1] = func__compiler__print_trees_46;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__print_trees_47(void) {
  myself = frame->slots[1] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__line_start_remark_to_string_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // remark_lines: 0
  // indent: 1
  // buf: 2
  // indentation: 3
  frame->slots[2] /* buf */ = create_cell();
  frame->slots[3] /* indentation */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 213: $$buf "@nl;"
  ((CELL *)frame->slots[2])->contents /* buf */ = string__578a5af303e9ceb;
  // 214: ... indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_3;
}
static void cont__line_start_remark_to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 214: $indentation spaces(indent+2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_4;
}
static void cont__line_start_remark_to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* indentation */, arguments->slots[0]);
  // 215: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_5;
}
static void cont__line_start_remark_to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 215: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_6;
}
static void cont__line_start_remark_to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 215: write_to &buf spaces(indent) '#' remark_lines(1)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = character__35;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_7;
}
static void cont__line_start_remark_to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 216: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_8;
}
static void cont__line_start_remark_to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 216: ... : (remark_line)
  // 217:   write_to &buf '@nl;' indentation remark_line
  frame->slots[5] /* temp__2 */ = create_closure(entry__line_start_remark_to_string_9, 1);
  // 216: for_each_from_to remark_lines 2 -1: (remark_line)
  // 217:   write_to &buf '@nl;' indentation remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  arguments->slots[3] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__for_each_from_to();
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_11;
}
static void entry__line_start_remark_to_string_9(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // remark_line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 217: write_to &buf '@nl;' indentation remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[2] /* indentation */;
  arguments->slots[3] = frame->slots[0] /* remark_line */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__line_start_remark_to_string_10;
}
static void cont__line_start_remark_to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__line_start_remark_to_string_11(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 218: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_lines_47(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 264: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__add_remark_lines_48;
}
static void cont__add_remark_lines_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 264: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__add_remark_lines_49;
}
static void cont__add_remark_lines_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 264: ... string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  arguments->slots[3] = character__35;
  arguments->slots[4] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__add_remark_lines_50;
}
static void cont__add_remark_lines_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 264: -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_lines_51(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // is_a_statement: 0
  // str: 1
  // remark_prefix: 2
  // remark_lines: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* is_a_statement */
  frame->slots[1] = myself->closure.frame->slots[0]; /* str */
  frame->slots[2] = myself->closure.frame->slots[3]; /* remark_prefix */
  frame->slots[3] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 268: -> string(str remark_prefix remark_lines(1))
  frame->slots[5] /* temp__2 */ = create_closure(entry__add_remark_lines_52, 0);
  // 269: ->
  // 270:   string
  // 271:     '@nl;'
  // 272:     spaces(expression_indent)
  // 273:     str
  // 274:     remark_prefix
  // 275:     remark_lines(1)
  frame->slots[6] /* temp__3 */ = create_closure(entry__add_remark_lines_55, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* is_a_statement */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__add_remark_lines_59;
}
static void entry__add_remark_lines_52(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[3]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 268: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__add_remark_lines_53;
}
static void cont__add_remark_lines_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 268: ... string(str remark_prefix remark_lines(1))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_prefix */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__add_remark_lines_54;
}
static void cont__add_remark_lines_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 268: -> string(str remark_prefix remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_lines_55(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[3]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 272: spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__add_remark_lines_56;
}
static void cont__add_remark_lines_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 275: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__add_remark_lines_57;
}
static void cont__add_remark_lines_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[0] /* str */;
  arguments->slots[3] = frame->slots[1] /* remark_prefix */;
  arguments->slots[4] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__add_remark_lines_58;
}
static void cont__add_remark_lines_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 269: ->
  // 270:   string
  // 271:     '@nl;'
  // 272:     spaces(expression_indent)
  // 273:     str
  // 274:     remark_prefix
  // 275:     remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__add_remark_lines_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 265: ->
  // 266:   if
  // 267:     is_a_statement
  // 268:     -> string(str remark_prefix remark_lines(1))
  // 269:     ->
  // 270:       string
  // 271:         '@nl;'
  // 272:         spaces(expression_indent)
  // 273:         str
  // 274:         remark_prefix
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_lines_45(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  // is_a_statement: 2
  // remark_prefix: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[2] = myself->closure.frame->slots[3]; /* is_a_statement */
  frame->slots[3] = myself->closure.frame->slots[1]; /* remark_prefix */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 263: str == ":"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__578a5af303e9cdb;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__add_remark_lines_46;
}
static void cont__add_remark_lines_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 264: -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  frame->slots[5] /* temp__2 */ = create_closure(entry__add_remark_lines_47, 0);
  // 265: ->
  // 266:   if
  // 267:     is_a_statement
  // 268:     -> string(str remark_prefix remark_lines(1))
  // 269:     ->
  // 270:       string
  // 271:         '@nl;'
  // 272:         spaces(expression_indent)
  // 273:         str
  // 274:         remark_prefix
  // ...
  frame->slots[6] /* temp__3 */ = create_closure(entry__add_remark_lines_51, 0);
  // 262: if
  // 263:   str == ":"
  // 264:   -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 265:   ->
  // 266:     if
  // 267:       is_a_statement
  // 268:       -> string(str remark_prefix remark_lines(1))
  // 269:       ->
  // 270:         string
  // 271:           '@nl;'
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__add_remark_lines_60(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[1]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 276: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__add_remark_lines_61;
}
static void cont__add_remark_lines_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 276: ... string(str remark_prefix remark_lines(1))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_prefix */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__add_remark_lines_62;
}
static void cont__add_remark_lines_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 276: -> string(str remark_prefix remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_lines_20(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // str: 0
  // is_a_statement: 1
  // remark_lines: 2
  // indent: 3
  // buf: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* is_a_statement */
  frame->slots[2] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[3] /* indent */ = create_cell();
  frame->slots[4] /* buf */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 250: $$indent expression_indent
  ((CELL *)frame->slots[3])->contents /* indent */ = get__expression_indent();
  // 251: $$buf str
  ((CELL *)frame->slots[4])->contents /* buf */ = frame->slots[0] /* str */;
  // 252: ... str != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__add_remark_lines_21;
}
static void cont__add_remark_lines_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 252: ... str != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__add_remark_lines_22;
}
static void cont__add_remark_lines_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 252: ... str != ":"
  frame->slots[8] /* temp__4 */ = create_closure(entry__add_remark_lines_23, 0);
  // 252: ... str != "" && str != ":"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__add_remark_lines_27;
}
static void entry__add_remark_lines_23(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 252: ... str != ":"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__578a5af303e9cdb;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__add_remark_lines_25;
}
static void cont__add_remark_lines_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 252: ... str != ":"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__add_remark_lines_26;
}
static void cont__add_remark_lines_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 252: ... str != ":"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__add_remark_lines_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 252: ... :
  // 253:   unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  // 254:   plus &indent 2
  frame->slots[9] /* temp__5 */ = create_closure(entry__add_remark_lines_28, 0);
  // 252: if str != "" && str != ":":
  // 253:   unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  // 254:   plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__add_remark_lines_34;
}
static void entry__add_remark_lines_28(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // is_a_statement: 0
  // buf: 1
  // str: 2
  // indent: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* is_a_statement */
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  frame->slots[3] = myself->closure.frame->slots[3]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 253: ... : !buf string('@nl;' spaces(expression_indent) str)
  frame->slots[4] /* temp__1 */ = create_closure(entry__add_remark_lines_29, 0);
  // 253: unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* is_a_statement */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__add_remark_lines_32;
}
static void entry__add_remark_lines_29(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 253: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__add_remark_lines_30;
}
static void cont__add_remark_lines_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 253: ... !buf string('@nl;' spaces(expression_indent) str)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__add_remark_lines_31;
}
static void cont__add_remark_lines_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__add_remark_lines_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 254: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__add_remark_lines_33;
}
static void cont__add_remark_lines_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__add_remark_lines_34(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 255: ... line_start_remark_to_string(remark_lines indent)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* remark_lines */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* indent */;
  result_count = 1;
  myself = var._line_start_remark_to_string;
  func = myself->type;
  frame->cont = cont__add_remark_lines_35;
}
static void cont__add_remark_lines_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 255: ... append(buf line_start_remark_to_string(remark_lines indent))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__add_remark_lines_36;
}
static void cont__add_remark_lines_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 255: -> append(buf line_start_remark_to_string(remark_lines indent))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_lines_37(void) {
  allocate_initialized_frame_gc(4, 13);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  // is_a_statement: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[3]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[3] = myself->closure.frame->slots[2]; /* is_a_statement */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 259: length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__add_remark_lines_38;
}
static void cont__add_remark_lines_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  // 259: ... length_of(remark_prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__add_remark_lines_39;
}
static void cont__add_remark_lines_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__5 */ = arguments->slots[0];
  // 259: length_of(str)+length_of(remark_prefix)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__add_remark_lines_40;
}
static void cont__add_remark_lines_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 259: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__add_remark_lines_41;
}
static void cont__add_remark_lines_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__7 */ = arguments->slots[0];
  // 259: ... length_of(remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__7 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__add_remark_lines_42;
}
static void cont__add_remark_lines_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__6 */ = arguments->slots[0];
  // 259: length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = frame->slots[9] /* temp__6 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__add_remark_lines_43;
}
static void cont__add_remark_lines_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 258: >
  // 259:   length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  // 260:   line_end_expression_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__add_remark_lines_44;
}
static void cont__add_remark_lines_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 261: :
  // 262:   if
  // 263:     str == ":"
  // 264:     -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 265:     ->
  // 266:       if
  // 267:         is_a_statement
  // 268:         -> string(str remark_prefix remark_lines(1))
  // 269:         ->
  // 270:           string
  // ...
  frame->slots[11] /* temp__8 */ = create_closure(entry__add_remark_lines_45, 0);
  // 276: -> string(str remark_prefix remark_lines(1))
  frame->slots[12] /* temp__9 */ = create_closure(entry__add_remark_lines_60, 0);
  // 257: if
  // 258:   >
  // 259:     length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  // 260:     line_end_expression_width
  // 261:   :
  // 262:     if
  // 263:       str == ":"
  // 264:       -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 265:       ->
  // 266:         if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__8 */;
  arguments->slots[2] = frame->slots[12] /* temp__9 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__add_remark_lines_1(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  // is_a_statement: 2
  // remark_prefix: 3
  frame->slots[3] /* remark_prefix */ = create_future();
  if (argument_count < 2) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[2] /* is_a_statement */ = arguments->slots[2];
    case 2:;
  }
  switch(argument_count) {
    case 2: frame->slots[2] /* is_a_statement */ = get__false();
  }
  // 235: str == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__add_remark_lines_2;
}
static void cont__add_remark_lines_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 233: $remark_prefix
  // 234:   if
  // 235:     str == ""
  // 236:     -> "#"
  // 237:     -> " #"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = func__add_remark_lines_3;
  arguments->slots[2] = func__add_remark_lines_5;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__add_remark_lines_7;
}
static void entry__add_remark_lines_3(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 236: -> "#"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_lines_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 237: -> " #"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6082be6;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__add_remark_lines_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* remark_prefix */, arguments->slots[0]);
  // 241: length_of(remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__add_remark_lines_8;
}
static void cont__add_remark_lines_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 241: length_of(remark_lines) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__add_remark_lines_9;
}
static void cont__add_remark_lines_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 242: >
  // 243:   +
  // 244:     expression_indent
  // 245:     length_of(str)
  // 246:     length_of(remark_prefix)
  // 247:     length_of(remark_lines(1))
  // 248:   line_width
  frame->slots[7] /* temp__4 */ = create_closure(entry__add_remark_lines_10, 0);
  // 240: ||
  // 241:   length_of(remark_lines) > 1
  // 242:   >
  // 243:     +
  // 244:       expression_indent
  // 245:       length_of(str)
  // 246:       length_of(remark_prefix)
  // 247:       length_of(remark_lines(1))
  // 248:     line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__add_remark_lines_19;
}
static void entry__add_remark_lines_10(void) {
  allocate_initialized_frame_gc(3, 11);
  // slot allocations:
  // str: 0
  // remark_prefix: 1
  // remark_lines: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  frame->slots[1] = myself->closure.frame->slots[3]; /* remark_prefix */
  frame->slots[2] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 245: length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__add_remark_lines_11;
}
static void cont__add_remark_lines_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__add_remark_lines_12;
}
static void cont__add_remark_lines_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 246: length_of(remark_prefix)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_prefix */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__add_remark_lines_13;
}
static void cont__add_remark_lines_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__6 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  arguments->slots[1] = frame->slots[8] /* temp__6 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__add_remark_lines_14;
}
static void cont__add_remark_lines_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 247: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__add_remark_lines_15;
}
static void cont__add_remark_lines_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__8 */ = arguments->slots[0];
  // 247: length_of(remark_lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__8 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__add_remark_lines_16;
}
static void cont__add_remark_lines_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__7 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[9] /* temp__7 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__add_remark_lines_17;
}
static void cont__add_remark_lines_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 242: >
  // 243:   +
  // 244:     expression_indent
  // 245:     length_of(str)
  // 246:     length_of(remark_prefix)
  // 247:     length_of(remark_lines(1))
  // 248:   line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__add_remark_lines_18;
}
static void cont__add_remark_lines_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 242: >
  // 243:   +
  // 244:     expression_indent
  // 245:     length_of(str)
  // 246:     length_of(remark_prefix)
  // 247:     length_of(remark_lines(1))
  // 248:   line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__add_remark_lines_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 249: :
  // 250:   $$indent expression_indent
  // 251:   $$buf str
  // 252:   if str != "" && str != ":":
  // 253:     unless is_a_statement: !buf string('@nl;' spaces(expression_indent) str)
  // 254:     plus &indent 2
  // 255:   -> append(buf line_start_remark_to_string(remark_lines indent))
  frame->slots[8] /* temp__5 */ = create_closure(entry__add_remark_lines_20, 0);
  // 256: :
  // 257:   if
  // 258:     >
  // 259:       length_of(str)+length_of(remark_prefix)+length_of(remark_lines(1))
  // 260:       line_end_expression_width
  // 261:     :
  // 262:       if
  // 263:         str == ":"
  // 264:         -> string(str '@nl;' spaces(expression_indent) '#' remark_lines(1))
  // 265:         ->
  // ...
  frame->slots[9] /* temp__6 */ = create_closure(entry__add_remark_lines_37, 0);
  // 239: if
  // 240:   ||
  // 241:     length_of(remark_lines) > 1
  // 242:     >
  // 243:       +
  // 244:         expression_indent
  // 245:         length_of(str)
  // 246:         length_of(remark_prefix)
  // 247:         length_of(remark_lines(1))
  // 248:       line_width
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  arguments->slots[2] = frame->slots[9] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__add_statement_remark_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 282: -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_statement_remark_5(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 283: ... add_remark_lines(str remark_lines true)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  arguments->slots[2] = get__true();
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__add_statement_remark_6;
}
static void cont__add_statement_remark_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 283: -> add_remark_lines(str remark_lines true)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_statement_remark_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // self: 0
  // str: 1
  // remark_lines: 2
  frame->slots[2] /* remark_lines */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 279: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__add_statement_remark_2;
}
static void cont__add_statement_remark_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* remark_lines */, arguments->slots[0]);
  // 281: remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__add_statement_remark_3;
}
static void cont__add_statement_remark_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 282: -> str
  frame->slots[4] /* temp__2 */ = create_closure(entry__add_statement_remark_4, 0);
  // 283: -> add_remark_lines(str remark_lines true)
  frame->slots[5] /* temp__3 */ = create_closure(entry__add_statement_remark_5, 0);
  // 280: if
  // 281:   remark_lines.is_empty
  // 282:   -> str
  // 283:   -> add_remark_lines(str remark_lines true)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__add_remark_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 289: -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_5(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // str: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 290: ... add_remark_lines(str remark_lines)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__add_remark_6;
}
static void cont__add_remark_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 290: -> add_remark_lines(str remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__add_remark_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // self: 0
  // str: 1
  // remark_lines: 2
  frame->slots[2] /* remark_lines */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 286: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__add_remark_2;
}
static void cont__add_remark_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* remark_lines */, arguments->slots[0]);
  // 288: remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__add_remark_3;
}
static void cont__add_remark_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 289: -> str
  frame->slots[4] /* temp__2 */ = create_closure(entry__add_remark_4, 0);
  // 290: -> add_remark_lines(str remark_lines)
  frame->slots[5] /* temp__3 */ = create_closure(entry__add_remark_5, 0);
  // 287: if
  // 288:   remark_lines.is_empty
  // 289:   -> str
  // 290:   -> add_remark_lines(str remark_lines)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__add_indented_remark_2(void) {
  allocate_initialized_frame_gc(4, 4);
  // slot allocations:
  // return__1: 0
  // indent: 1
  // self: 2
  // str: 3
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[1]; /* str */
  define__expression_indent(create_future());
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 295: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__add_indented_remark_3;
}
static void cont__add_indented_remark_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 296: add_remark self str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  arguments->slots[1] = frame->slots[3] /* str */;
  result_count = frame->caller_result_count;
  myself = var._add_remark;
  func = myself->type;
  frame->cont = cont__add_indented_remark_4;
}
static void cont__add_indented_remark_4(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__add_indented_remark_1(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // self: 0
  // str: 1
  // indent: 2
  // _define $indent expression_indent
  frame->slots[2] /* indent */ = get__expression_indent();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 294: ... :
  // 295:   %expression_indent indent+2
  // 296:   add_remark self str
  frame->slots[3] /* temp__1 */ = create_closure(entry__add_indented_remark_2, 0);
  // 294: do:
  // 295:   %expression_indent indent+2
  // 296:   add_remark self str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__types__grammar_node__to_string_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 301: ... -> "<???>"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__f45afcc3e835d069;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__require_instruction__to_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 307: !statement_tag REQUIRE
  set__statement_tag(var._REQUIRE);
  // 308: ... node::filename_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filename_of();
  func = myself->type;
  frame->cont = cont__compiler__require_instruction__to_string_2;
}
static void cont__compiler__require_instruction__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 308: ... "<require @(node::filename_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__7ca422245e2a26c5;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__require_instruction__to_string_5;
}
static void cont__compiler__require_instruction__to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 308: add_statement_remark self "<require @(node::filename_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_statement_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__namespace_instruction__to_string_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 311: !statement_tag NAMESPACE
  set__statement_tag(var._NAMESPACE);
  // 315: namespace_alias_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_alias_of();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_2;
}
static void cont__compiler__namespace_instruction__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 315: namespace_alias_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_3;
}
static void cont__compiler__namespace_instruction__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 316: -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  frame->slots[4] /* temp__4 */ = create_closure(entry__compiler__namespace_instruction__to_string_4, 0);
  // 317: -> "<namespace @(namespace_of(self))>"
  frame->slots[5] /* temp__5 */ = create_closure(entry__compiler__namespace_instruction__to_string_10, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  arguments->slots[2] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_13;
}
static void entry__compiler__namespace_instruction__to_string_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 316: ... namespace_alias_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_alias_of();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_5;
}
static void cont__compiler__namespace_instruction__to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 316: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_6;
}
static void cont__compiler__namespace_instruction__to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 316: ... "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = string__82c941922e20aab7;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__fa730415fc16bec;
  arguments->slots[3] = frame->slots[3] /* temp__3 */;
  arguments->slots[4] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_9;
}
static void cont__compiler__namespace_instruction__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 316: -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__namespace_instruction__to_string_10(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 317: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_11;
}
static void cont__compiler__namespace_instruction__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 317: ... "<namespace @(namespace_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__82c941922e20aab7;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__namespace_instruction__to_string_12;
}
static void cont__compiler__namespace_instruction__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 317: -> "<namespace @(namespace_of(self))>"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__namespace_instruction__to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 312: add_statement_remark
  // 313:   self
  // 314:   if
  // 315:     namespace_alias_of(self).is_defined
  // 316:     -> "<namespace @(namespace_alias_of(self)) = @(namespace_of(self))>"
  // 317:     -> "<namespace @(namespace_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_statement_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__using_instruction__to_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 320: !statement_tag USING
  set__statement_tag(var._USING);
  // 321: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__using_instruction__to_string_2;
}
static void cont__compiler__using_instruction__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 321: ... "<using @(namespace_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__a1740e581583f0da;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__using_instruction__to_string_4;
}
static void cont__compiler__using_instruction__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 321: add_statement_remark self "<using @(namespace_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_statement_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__include_instruction__to_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 324: !statement_tag INCLUDE
  set__statement_tag(var._INCLUDE);
  // 325: ... node::filename_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filename_of();
  func = myself->type;
  frame->cont = cont__compiler__include_instruction__to_string_2;
}
static void cont__compiler__include_instruction__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 325: ... "<include @(node::filename_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__448827ad5e2bb5a5;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__include_instruction__to_string_4;
}
static void cont__compiler__include_instruction__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 325: add_statement_remark self "<include @(node::filename_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_statement_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__link_instruction__to_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 328: !statement_tag LINK
  set__statement_tag(var._LINK);
  // 329: ... node::filename_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filename_of();
  func = myself->type;
  frame->cont = cont__compiler__link_instruction__to_string_2;
}
static void cont__compiler__link_instruction__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 329: ... "<link @(node::filename_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__4a1f55ee81e292f7;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__link_instruction__to_string_4;
}
static void cont__compiler__link_instruction__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 329: add_statement_remark self "<link @(node::filename_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_statement_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__data_instruction__to_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 332: !statement_tag DATA
  set__statement_tag(var._DATA);
  // 333: ... node::filemask_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__filemask_of();
  func = myself->type;
  frame->cont = cont__compiler__data_instruction__to_string_2;
}
static void cont__compiler__data_instruction__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 333: ... "<data @(node::filemask_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__5a1f536e81b212f7;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__data_instruction__to_string_4;
}
static void cont__compiler__data_instruction__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 333: add_statement_remark self "<data @(node::filemask_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_statement_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__remark_statement__to_string_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // remark_lines: 1
  // buf: 2
  frame->slots[1] /* remark_lines */ = create_future();
  frame->slots[2] /* buf */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 339: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_2;
}
static void cont__compiler__remark_statement__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* remark_lines */, arguments->slots[0]);
  // 342: -> remark_lines(1) .has_prefix. '!' -> SHEBANG
  frame->slots[3] /* temp__1 */ = create_closure(entry__compiler__remark_statement__to_string_3, 0);
  // 343: ->
  // 344:   &&
  // 345:     remark_lines(1) != ""
  // 346:     remark_lines(1)(1) != ' '
  // 347:     remark_lines(1)(1) != '#'
  // 348:   -> CODE_EXCLUSION
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__remark_statement__to_string_7, 0);
  // 349: -> length_of(remark_lines) == 1 -> REMARK
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__remark_statement__to_string_24, 0);
  // 340: !statement_tag
  // 341:   cond
  // 342:     -> remark_lines(1) .has_prefix. '!' -> SHEBANG
  // 343:     ->
  // 344:       &&
  // 345:         remark_lines(1) != ""
  // 346:         remark_lines(1)(1) != ' '
  // 347:         remark_lines(1)(1) != '#'
  // 348:       -> CODE_EXCLUSION
  // 349:     -> length_of(remark_lines) == 1 -> REMARK
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  arguments->slots[3] = func__compiler__remark_statement__to_string_28;
  result_count = 1;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_30;
}
static void entry__compiler__remark_statement__to_string_29(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 350: ... -> ALWAYS
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._ALWAYS;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_27(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 349: ... -> REMARK
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._REMARK;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_23(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 348: -> CODE_EXCLUSION
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._CODE_EXCLUSION;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_6(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 342: ... -> SHEBANG
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._SHEBANG;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_3(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 342: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_4;
}
static void cont__compiler__remark_statement__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 342: ... remark_lines(1) .has_prefix. '!'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__33;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_5;
}
static void cont__compiler__remark_statement__to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 342: -> remark_lines(1) .has_prefix. '!' -> SHEBANG
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__remark_statement__to_string_6;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_7(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 345: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_8;
}
static void cont__compiler__remark_statement__to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 345: remark_lines(1) != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_9;
}
static void cont__compiler__remark_statement__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 345: remark_lines(1) != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_10;
}
static void cont__compiler__remark_statement__to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__5 */ = create_closure(entry__compiler__remark_statement__to_string_11, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_22;
}
static void entry__compiler__remark_statement__to_string_11(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 346: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_12;
}
static void cont__compiler__remark_statement__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 346: remark_lines(1)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[5] /* temp__5 */;
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_13;
}
static void cont__compiler__remark_statement__to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 346: remark_lines(1)(1) != ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_14;
}
static void cont__compiler__remark_statement__to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 346: remark_lines(1)(1) != ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_15;
}
static void cont__compiler__remark_statement__to_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 347: remark_lines(1)(1) != '#'
  frame->slots[6] /* temp__6 */ = create_closure(entry__compiler__remark_statement__to_string_16, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_21;
}
static void entry__compiler__remark_statement__to_string_16(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 347: remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_17;
}
static void cont__compiler__remark_statement__to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 347: remark_lines(1)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__4 */;
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_18;
}
static void cont__compiler__remark_statement__to_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 347: remark_lines(1)(1) != '#'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__35;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_19;
}
static void cont__compiler__remark_statement__to_string_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 347: remark_lines(1)(1) != '#'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_20;
}
static void cont__compiler__remark_statement__to_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 347: remark_lines(1)(1) != '#'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__remark_statement__to_string_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__remark_statement__to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 343: ->
  // 344:   &&
  // 345:     remark_lines(1) != ""
  // 346:     remark_lines(1)(1) != ' '
  // 347:     remark_lines(1)(1) != '#'
  // 348:   -> CODE_EXCLUSION
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__remark_statement__to_string_23;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_24(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 349: ... length_of(remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_25;
}
static void cont__compiler__remark_statement__to_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 349: ... length_of(remark_lines) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_26;
}
static void cont__compiler__remark_statement__to_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 349: -> length_of(remark_lines) == 1 -> REMARK
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__remark_statement__to_string_27;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_28(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 350: -> true -> ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = func__compiler__remark_statement__to_string_29;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__remark_statement__to_string_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  set__statement_tag(arguments->slots[0]);
  // 351: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_31;
}
static void cont__compiler__remark_statement__to_string_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 351: $$buf string('#' remark_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__35;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_32;
}
static void cont__compiler__remark_statement__to_string_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 352: ... length_of(remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_33;
}
static void cont__compiler__remark_statement__to_string_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 352: ... length_of(remark_lines) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_34;
}
static void cont__compiler__remark_statement__to_string_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 352: ... :
  // 353:   $indent expression_indent+2
  // 354:   for_each_from_to remark_lines 2 -1: (line)
  // 355:     push &buf '@nl;'
  // 356:     if line != "": write_to &buf spaces(indent) line
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__remark_statement__to_string_35, 0);
  // 352: if length_of(remark_lines) > 1:
  // 353:   $indent expression_indent+2
  // 354:   for_each_from_to remark_lines 2 -1: (line)
  // 355:     push &buf '@nl;'
  // 356:     if line != "": write_to &buf spaces(indent) line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_45;
}
static void entry__compiler__remark_statement__to_string_42(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // buf: 0
  // indent: 1
  // line: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 356: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_43;
}
static void cont__compiler__remark_statement__to_string_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 356: ... write_to &buf spaces(indent) line
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[2] /* line */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_44;
}
static void cont__compiler__remark_statement__to_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_statement__to_string_38(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // line: 0
  // buf: 1
  // indent: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 355: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_39;
}
static void cont__compiler__remark_statement__to_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 356: ... line != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_40;
}
static void cont__compiler__remark_statement__to_string_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 356: ... line != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_41;
}
static void cont__compiler__remark_statement__to_string_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 356: ... : write_to &buf spaces(indent) line
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__remark_statement__to_string_42, 0);
  // 356: if line != "": write_to &buf spaces(indent) line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__remark_statement__to_string_35(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // remark_lines: 0
  // buf: 1
  // indent: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[2] /* indent */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 353: $indent expression_indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_36;
}
static void cont__compiler__remark_statement__to_string_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* indent */, arguments->slots[0]);
  // 354: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__remark_statement__to_string_37;
}
static void cont__compiler__remark_statement__to_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 354: ... : (line)
  // 355:   push &buf '@nl;'
  // 356:   if line != "": write_to &buf spaces(indent) line
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__remark_statement__to_string_38, 1);
  // 354: for_each_from_to remark_lines 2 -1: (line)
  // 355:   push &buf '@nl;'
  // 356:   if line != "": write_to &buf spaces(indent) line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  arguments->slots[3] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_from_to();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__remark_statement__to_string_45(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 357: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_24(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // indent: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 377: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_25;
}
static void cont__compiler__body__to_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 377: ... string('@nl;' spaces(indent) str)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_26;
}
static void cont__compiler__body__to_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 377: -> string('@nl;' spaces(indent) str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_27(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 378: -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_16(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // self: 0
  // indent: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] /* str */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 374: ... statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_17;
}
static void cont__compiler__body__to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 374: ... statements_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__2 */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_18;
}
static void cont__compiler__body__to_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 374: $str statements_of(self)(1).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_19;
}
static void cont__compiler__body__to_string_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* str */, arguments->slots[0]);
  // 376: line_end_expression_width == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_20;
}
static void cont__compiler__body__to_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 376: ... str .contains. '@nl;'
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_string_21, 0);
  // 376: line_end_expression_width == 0 && str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_23;
}
static void entry__compiler__body__to_string_21(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 376: ... str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_22;
}
static void cont__compiler__body__to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 376: ... str .contains. '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 377: -> string('@nl;' spaces(indent) str)
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__body__to_string_24, 0);
  // 378: -> str
  frame->slots[7] /* temp__5 */ = create_closure(entry__compiler__body__to_string_27, 0);
  // 375: if
  // 376:   line_end_expression_width == 0 && str .contains. '@nl;'
  // 377:   -> string('@nl;' spaces(indent) str)
  // 378:   -> str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_28(void) {
  allocate_initialized_frame_gc(4, 13);
  // slot allocations:
  // indent: 0
  // parameters: 1
  // remark_lines: 2
  // self: 3
  // buf: 4
  // check_for_line_end_expression: 5
  // handle_simple_parameters: 6
  // handle_complex_parameters: 7
  // outer_line_end_expression_width: 8
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[3]; /* parameters */
  frame->slots[2] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[3] = myself->closure.frame->slots[0]; /* self */
  frame->slots[5] /* check_for_line_end_expression */ = create_future();
  frame->slots[6] /* handle_simple_parameters */ = create_future();
  frame->slots[7] /* handle_complex_parameters */ = create_future();
  frame->slots[4] /* buf */ = create_cell();
  // _define $outer_line_end_expression_width line_end_expression_width
  frame->slots[8] /* outer_line_end_expression_width */ = get__line_end_expression_width();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 382: ... :
  // 383:   if
  // 384:     line_end_expression_width > 0:
  // 385:       !buf ":"
  // 386:     :
  // 387:       !buf string("@nl;" spaces(indent) ':')
  // 388:       plus &indent 2
  frame->slots[9] /* temp__1 */ = create_closure(entry__compiler__body__to_string_29, 0);
  // 382: $check_for_line_end_expression:
  // 383:   if
  // 384:     line_end_expression_width > 0:
  // 385:       !buf ":"
  // 386:     :
  // 387:       !buf string("@nl;" spaces(indent) ':')
  // 388:       plus &indent 2
  initialize_future(frame->slots[5] /* check_for_line_end_expression */, frame->slots[9] /* temp__1 */);
  // 390: ... :
  // 391:   $$parameter_text ": ("
  // 392:   for_each
  // 393:     parameters: (parameter)
  // 394:       append &parameter_text parameter.to_string
  // 395:     :
  // 396:       push &parameter_text ' '
  // 397:   push &parameter_text ')'
  // 398:   $parameter_text_length length_of(parameter_text)
  // 399:   if
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__compiler__body__to_string_36, 0);
  // 390: $handle_simple_parameters:
  // 391:   $$parameter_text ": ("
  // 392:   for_each
  // 393:     parameters: (parameter)
  // 394:       append &parameter_text parameter.to_string
  // 395:     :
  // 396:       push &parameter_text ' '
  // 397:   push &parameter_text ')'
  // 398:   $parameter_text_length length_of(parameter_text)
  // 399:   if
  // ...
  initialize_future(frame->slots[6] /* handle_simple_parameters */, frame->slots[9] /* temp__1 */);
  // 410: ... :
  // 411:   check_for_line_end_expression
  // 412:   $parameter_indentation spaces(indent+2)
  // 413:   %expression_indent indent
  // 414:   unless remark_lines.is_empty: add_remark_lines &buf remark_lines
  // 415:   push &buf '@nl;'
  // 416:   write_to &buf spaces(indent) "("
  // 417:   for_each parameters: ($parameter)
  // 418:     to_string &parameter
  // 419:     if
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__compiler__body__to_string_58, 0);
  // 410: $handle_complex_parameters:
  // 411:   check_for_line_end_expression
  // 412:   $parameter_indentation spaces(indent+2)
  // 413:   %expression_indent indent
  // 414:   unless remark_lines.is_empty: add_remark_lines &buf remark_lines
  // 415:   push &buf '@nl;'
  // 416:   write_to &buf spaces(indent) "("
  // 417:   for_each parameters: ($parameter)
  // 418:     to_string &parameter
  // 419:     if
  // ...
  initialize_future(frame->slots[7] /* handle_complex_parameters */, frame->slots[9] /* temp__1 */);
  // 380: $$buf undefined
  ((CELL *)frame->slots[4])->contents /* buf */ = get__undefined();
  // 427: length_of(parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* parameters */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_81;
}
static void entry__compiler__body__to_string_53(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // buf: 0
  // indent: 1
  // parameter_text: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[3]; /* parameter_text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 405: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_54;
}
static void cont__compiler__body__to_string_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 405: !buf string("@nl;" spaces(indent) parameter_text)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9ceb;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[2])->contents /* parameter_text */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_55;
}
static void cont__compiler__body__to_string_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 406: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_56;
}
static void cont__compiler__body__to_string_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_57(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // handle_complex_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* handle_complex_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 408: handle_complex_parameters
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* handle_complex_parameters */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_48(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // parameter_text: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[4]; /* parameter_text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 401: !buf parameter_text
  ((CELL *)frame->slots[0])->contents /* buf */ = ((CELL *)frame->slots[1])->contents /* parameter_text */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_49(void) {
  allocate_initialized_frame_gc(5, 10);
  // slot allocations:
  // indent: 0
  // parameter_text_length: 1
  // buf: 2
  // parameter_text: 3
  // handle_complex_parameters: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[5]; /* parameter_text_length */
  frame->slots[2] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[4]; /* parameter_text */
  frame->slots[4] = myself->closure.frame->slots[3]; /* handle_complex_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 404: indent+parameter_text_length
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* indent */;
  arguments->slots[1] = frame->slots[1] /* parameter_text_length */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_50;
}
static void cont__compiler__body__to_string_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 404: indent+parameter_text_length <= line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_51;
}
static void cont__compiler__body__to_string_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 404: indent+parameter_text_length <= line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_52;
}
static void cont__compiler__body__to_string_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 404: ... :
  // 405:   !buf string("@nl;" spaces(indent) parameter_text)
  // 406:   plus &indent 2
  frame->slots[8] /* temp__4 */ = create_closure(entry__compiler__body__to_string_53, 0);
  // 407: :
  // 408:   handle_complex_parameters
  frame->slots[9] /* temp__5 */ = create_closure(entry__compiler__body__to_string_57, 0);
  // 403: if
  // 404:   indent+parameter_text_length <= line_width:
  // 405:     !buf string("@nl;" spaces(indent) parameter_text)
  // 406:     plus &indent 2
  // 407:   :
  // 408:     handle_complex_parameters
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  arguments->slots[2] = frame->slots[9] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_31(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 385: !buf ":"
  ((CELL *)frame->slots[0])->contents /* buf */ = string__578a5af303e9cdb;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_32(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 387: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_33;
}
static void cont__compiler__body__to_string_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 387: !buf string("@nl;" spaces(indent) ':')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9ceb;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = character__58;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_34;
}
static void cont__compiler__body__to_string_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 388: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_35;
}
static void cont__compiler__body__to_string_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_29(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // buf: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 384: line_end_expression_width > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = get__line_end_expression_width();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_30;
}
static void cont__compiler__body__to_string_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 384: ... :
  // 385:   !buf ":"
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__body__to_string_31, 0);
  // 386: :
  // 387:   !buf string("@nl;" spaces(indent) ':')
  // 388:   plus &indent 2
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__body__to_string_32, 0);
  // 383: if
  // 384:   line_end_expression_width > 0:
  // 385:     !buf ":"
  // 386:   :
  // 387:     !buf string("@nl;" spaces(indent) ':')
  // 388:     plus &indent 2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_36(void) {
  allocate_initialized_frame_gc(4, 10);
  // slot allocations:
  // parameters: 0
  // buf: 1
  // indent: 2
  // handle_complex_parameters: 3
  // parameter_text: 4
  // parameter_text_length: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* parameters */
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[7]; /* handle_complex_parameters */
  frame->slots[4] /* parameter_text */ = create_cell();
  frame->slots[5] /* parameter_text_length */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 391: $$parameter_text ": ("
  ((CELL *)frame->slots[4])->contents /* parameter_text */ = string__fa736c15f296be4;
  // 393: ... : (parameter)
  // 394:   append &parameter_text parameter.to_string
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__body__to_string_38, 1);
  // 395: :
  // 396:   push &parameter_text ' '
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__body__to_string_41, 0);
  // 392: for_each
  // 393:   parameters: (parameter)
  // 394:     append &parameter_text parameter.to_string
  // 395:   :
  // 396:     push &parameter_text ' '
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_43;
}
static void entry__compiler__body__to_string_38(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // parameter: 0
  // parameter_text: 1
  frame->slots[1] = myself->closure.frame->slots[4]; /* parameter_text */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 394: ... parameter.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_39;
}
static void cont__compiler__body__to_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 394: append &parameter_text parameter.to_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* parameter_text */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_40;
}
static void cont__compiler__body__to_string_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* parameter_text */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_41(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // parameter_text: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* parameter_text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 396: push &parameter_text ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* parameter_text */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_42;
}
static void cont__compiler__body__to_string_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* parameter_text */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_43(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 397: push &parameter_text ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* parameter_text */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_44;
}
static void cont__compiler__body__to_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* parameter_text */ = arguments->slots[0];
  // 398: $parameter_text_length length_of(parameter_text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* parameter_text */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_45;
}
static void cont__compiler__body__to_string_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* parameter_text_length */, arguments->slots[0]);
  // 400: parameter_text_length <= line_end_expression_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = frame->slots[5] /* parameter_text_length */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_46;
}
static void cont__compiler__body__to_string_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 400: parameter_text_length <= line_end_expression_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_47;
}
static void cont__compiler__body__to_string_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 400: ... :
  // 401:   !buf parameter_text
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__body__to_string_48, 0);
  // 402: :
  // 403:   if
  // 404:     indent+parameter_text_length <= line_width:
  // 405:       !buf string("@nl;" spaces(indent) parameter_text)
  // 406:       plus &indent 2
  // 407:     :
  // 408:       handle_complex_parameters
  frame->slots[9] /* temp__4 */ = create_closure(entry__compiler__body__to_string_49, 0);
  // 399: if
  // 400:   parameter_text_length <= line_end_expression_width:
  // 401:     !buf parameter_text
  // 402:   :
  // 403:     if
  // 404:       indent+parameter_text_length <= line_width:
  // 405:         !buf string("@nl;" spaces(indent) parameter_text)
  // 406:         plus &indent 2
  // 407:       :
  // 408:         handle_complex_parameters
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_58(void) {
  allocate_initialized_frame_gc(6, 9);
  // slot allocations:
  // return__1: 0
  // check_for_line_end_expression: 1
  // indent: 2
  // remark_lines: 3
  // buf: 4
  // parameters: 5
  // parameter_indentation: 6
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[5]; /* check_for_line_end_expression */
  frame->slots[2] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[4] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[5] = myself->closure.frame->slots[1]; /* parameters */
  frame->slots[6] /* parameter_indentation */ = create_future();
  // _define %expression_indent indent
  define__expression_indent(create_future());
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 411: check_for_line_end_expression
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[1] /* check_for_line_end_expression */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_59;
}
static void cont__compiler__body__to_string_59(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 412: ... indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_60;
}
static void cont__compiler__body__to_string_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 412: $parameter_indentation spaces(indent+2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_61;
}
static void cont__compiler__body__to_string_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* parameter_indentation */, arguments->slots[0]);
  // 413: %expression_indent indent
  initialize_maybe_future(get__expression_indent(), ((CELL *)frame->slots[2])->contents /* indent */);
  // 414: ... remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_62;
}
static void cont__compiler__body__to_string_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 414: ... : add_remark_lines &buf remark_lines
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__body__to_string_63, 0);
  // 414: unless remark_lines.is_empty: add_remark_lines &buf remark_lines
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_65;
}
static void entry__compiler__body__to_string_63(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // remark_lines: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 414: ... add_remark_lines &buf remark_lines
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = var._add_remark_lines;
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_64;
}
static void cont__compiler__body__to_string_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_65(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 415: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_66;
}
static void cont__compiler__body__to_string_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* buf */ = arguments->slots[0];
  // 416: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_67;
}
static void cont__compiler__body__to_string_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 416: write_to &buf spaces(indent) "("
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  arguments->slots[2] = string__578a5af303e9cc9;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_69;
}
static void cont__compiler__body__to_string_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* buf */ = arguments->slots[0];
  // 417: ... : ($parameter)
  // 418:   to_string &parameter
  // 419:   if
  // 420:     parameter(1) == '@nl;':
  // 421:       append &buf parameter
  // 422:     :
  // 423:       write_to &buf '@nl;' parameter_indentation parameter
  frame->slots[7] /* temp__1 */ = create_closure(entry__compiler__body__to_string_70, 1);
  // 417: for_each parameters: ($parameter)
  // 418:   to_string &parameter
  // 419:   if
  // 420:     parameter(1) == '@nl;':
  // 421:       append &buf parameter
  // 422:     :
  // 423:       write_to &buf '@nl;' parameter_indentation parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* parameters */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_78;
}
static void entry__compiler__body__to_string_74(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // parameter: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 421: append &buf parameter
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* parameter */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_75;
}
static void cont__compiler__body__to_string_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_76(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // buf: 0
  // parameter_indentation: 1
  // parameter: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* parameter_indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 423: write_to &buf '@nl;' parameter_indentation parameter
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[1] /* parameter_indentation */;
  arguments->slots[3] = ((CELL *)frame->slots[2])->contents /* parameter */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_77;
}
static void cont__compiler__body__to_string_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_70(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // parameter: 0
  // buf: 1
  // parameter_indentation: 2
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[6]; /* parameter_indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* parameter */ = create_cell_with_contents(arguments->slots[0]);
  // 418: to_string &parameter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* parameter */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_71;
}
static void cont__compiler__body__to_string_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* parameter */ = arguments->slots[0];
  // 420: parameter(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* parameter */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_72;
}
static void cont__compiler__body__to_string_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 420: parameter(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_73;
}
static void cont__compiler__body__to_string_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 420: ... :
  // 421:   append &buf parameter
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_string_74, 0);
  // 422: :
  // 423:   write_to &buf '@nl;' parameter_indentation parameter
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__body__to_string_76, 0);
  // 419: if
  // 420:   parameter(1) == '@nl;':
  // 421:     append &buf parameter
  // 422:   :
  // 423:     write_to &buf '@nl;' parameter_indentation parameter
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_string_78(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 424: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_79;
}
static void cont__compiler__body__to_string_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 424: write_to &buf '@nl;' spaces(indent) ')'
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  arguments->slots[3] = character__41;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_80;
}
static void cont__compiler__body__to_string_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[4])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 427: length_of(parameters) == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_82;
}
static void cont__compiler__body__to_string_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 427: ... :
  // 428:   check_for_line_end_expression
  frame->slots[11] /* temp__3 */ = create_closure(entry__compiler__body__to_string_83, 0);
  // 429: :
  // 430:   $has_simple_parameters
  // 431:     &&
  // 432:       remark_lines.is_empty
  // 433:       ||
  // 434:         length_of(parameters) == 1
  // 435:         not
  // 436:           any_of
  // 437:             parameters: (parameter)
  // 438:               ->
  // ...
  frame->slots[12] /* temp__4 */ = create_closure(entry__compiler__body__to_string_84, 0);
  // 426: if
  // 427:   length_of(parameters) == 0:
  // 428:     check_for_line_end_expression
  // 429:   :
  // 430:     $has_simple_parameters
  // 431:       &&
  // 432:         remark_lines.is_empty
  // 433:         ||
  // 434:           length_of(parameters) == 1
  // 435:           not
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__3 */;
  arguments->slots[2] = frame->slots[12] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_110;
}
static void entry__compiler__body__to_string_108(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // handle_simple_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* handle_simple_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 448: handle_simple_parameters
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* handle_simple_parameters */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_109(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // handle_complex_parameters: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* handle_complex_parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 450: handle_complex_parameters
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* handle_complex_parameters */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_83(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // check_for_line_end_expression: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* check_for_line_end_expression */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 428: check_for_line_end_expression
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* check_for_line_end_expression */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__body__to_string_84(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // remark_lines: 0
  // parameters: 1
  // handle_simple_parameters: 2
  // handle_complex_parameters: 3
  // has_simple_parameters: 4
  frame->slots[0] = myself->closure.frame->slots[2]; /* remark_lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* parameters */
  frame->slots[2] = myself->closure.frame->slots[6]; /* handle_simple_parameters */
  frame->slots[3] = myself->closure.frame->slots[7]; /* handle_complex_parameters */
  frame->slots[4] /* has_simple_parameters */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 432: remark_lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_85;
}
static void cont__compiler__body__to_string_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__body__to_string_86, 0);
  // 430: $has_simple_parameters
  // 431:   &&
  // 432:     remark_lines.is_empty
  // 433:     ||
  // 434:       length_of(parameters) == 1
  // 435:       not
  // 436:         any_of
  // 437:           parameters: (parameter)
  // 438:             ->
  // 439:               ||
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_107;
}
static void entry__compiler__body__to_string_86(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // parameters: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 434: length_of(parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_87;
}
static void cont__compiler__body__to_string_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 434: length_of(parameters) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_88;
}
static void cont__compiler__body__to_string_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  frame->slots[5] /* temp__5 */ = create_closure(entry__compiler__body__to_string_89, 0);
  // 433: ||
  // 434:   length_of(parameters) == 1
  // 435:   not
  // 436:     any_of
  // 437:       parameters: (parameter)
  // 438:         ->
  // 439:           ||
  // 440:             parameter_kind_of(parameter) != IN_PARAMETER
  // 441:             default_value_of(parameter).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_100;
}
static void entry__compiler__body__to_string_89(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // parameters: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  arguments->slots[1] = func__compiler__body__to_string_90;
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_98;
}
static void entry__compiler__body__to_string_90(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // parameter: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 440: parameter_kind_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_91;
}
static void cont__compiler__body__to_string_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 440: parameter_kind_of(parameter) != IN_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = get__IN_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_92;
}
static void cont__compiler__body__to_string_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 440: parameter_kind_of(parameter) != IN_PARAMETER
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_93;
}
static void cont__compiler__body__to_string_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 441: default_value_of(parameter).is_defined
  frame->slots[5] /* temp__5 */ = create_closure(entry__compiler__body__to_string_94, 0);
  // 439: ||
  // 440:   parameter_kind_of(parameter) != IN_PARAMETER
  // 441:   default_value_of(parameter).is_defined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_97;
}
static void entry__compiler__body__to_string_94(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // parameter: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameter */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 441: default_value_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_95;
}
static void cont__compiler__body__to_string_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 441: default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_96;
}
static void cont__compiler__body__to_string_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 441: default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 438: ->
  // 439:   ||
  // 440:     parameter_kind_of(parameter) != IN_PARAMETER
  // 441:     default_value_of(parameter).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_99;
}
static void cont__compiler__body__to_string_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_100(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[6] /* temp__6 */ = create_closure(entry__compiler__body__to_string_101, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_106;
}
static void entry__compiler__body__to_string_101(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // parameters: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* parameters */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameters */;
  arguments->slots[1] = func__compiler__body__to_string_102;
  result_count = 1;
  myself = get__all_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_105;
}
static void entry__compiler__body__to_string_102(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // parameter: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 444: ... remark_lines_of(parameter)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* parameter */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_103;
}
static void cont__compiler__body__to_string_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 444: ... remark_lines_of(parameter).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_104;
}
static void cont__compiler__body__to_string_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 444: -> remark_lines_of(parameter).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* has_simple_parameters */, arguments->slots[0]);
  // 447: ... :
  // 448:   handle_simple_parameters
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__body__to_string_108, 0);
  // 449: :
  // 450:   handle_complex_parameters
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__body__to_string_109, 0);
  // 446: if
  // 447:   has_simple_parameters:
  // 448:     handle_simple_parameters
  // 449:   :
  // 450:     handle_complex_parameters
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* has_simple_parameters */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_string_110(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 452: ... :
  // 453:   %expression_indent indent
  // 454:   $indentation spaces(indent)
  // 455:   if
  // 456:     hide_body_statements:
  // 457:       write_to &buf '@nl;' indentation "
  // 458:         ...
  // 459:     :
  // 460:       %line_end_expression_width 0
  // 461:       $statements statements_of(self)
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__compiler__body__to_string_111, 0);
  // 452: do:
  // 453:   %expression_indent indent
  // 454:   $indentation spaces(indent)
  // 455:   if
  // 456:     hide_body_statements:
  // 457:       write_to &buf '@nl;' indentation "
  // 458:         ...
  // 459:     :
  // 460:       %line_end_expression_width 0
  // 461:       $statements statements_of(self)
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_153;
}
static void entry__compiler__body__to_string_111(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // return__3: 0
  // indent: 1
  // buf: 2
  // self: 3
  // outer_line_end_expression_width: 4
  // indentation: 5
  frame->slots[0] /* return__3 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[3]; /* self */
  frame->slots[4] = myself->closure.frame->slots[8]; /* outer_line_end_expression_width */
  // _define %expression_indent indent
  define__expression_indent(create_future());
  frame->slots[5] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 453: %expression_indent indent
  initialize_maybe_future(get__expression_indent(), ((CELL *)frame->slots[1])->contents /* indent */);
  // 454: $indentation spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_112;
}
static void cont__compiler__body__to_string_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* indentation */, arguments->slots[0]);
  // 456: ... :
  // 457:   write_to &buf '@nl;' indentation "
  // 458:     ...
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__body__to_string_113, 0);
  // 459: :
  // 460:   %line_end_expression_width 0
  // 461:   $statements statements_of(self)
  // 462:   $n length_of(statements)
  // 463:   %%statement_tag undefined
  // 464:   for_each statements_of(self): (idx statement)
  // 465:     $previous_statement_tag statement_tag
  // 466:     !statement_tag undefined
  // 467:     $str statement.to_string
  // 468:     if
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__body__to_string_116, 0);
  // 455: if
  // 456:   hide_body_statements:
  // 457:     write_to &buf '@nl;' indentation "
  // 458:       ...
  // 459:   :
  // 460:     %line_end_expression_width 0
  // 461:     $statements statements_of(self)
  // 462:     $n length_of(statements)
  // 463:     %%statement_tag undefined
  // 464:     for_each statements_of(self): (idx statement)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__hide_body_statements();
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_152;
}
static void entry__compiler__body__to_string_113(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 457: write_to &buf '@nl;' indentation "
  // 458:   ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[1] /* indentation */;
  arguments->slots[3] = string__9e0afacb5f107d33;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_115;
}
static void cont__compiler__body__to_string_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_116(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // return__2: 0
  // self: 1
  // buf: 2
  // outer_line_end_expression_width: 3
  // indentation: 4
  // statements: 5
  // n: 6
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[3]; /* self */
  frame->slots[2] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[4]; /* outer_line_end_expression_width */
  frame->slots[4] = myself->closure.frame->slots[5]; /* indentation */
  // _define %line_end_expression_width 0
  define__line_end_expression_width(number__0);
  frame->slots[5] /* statements */ = create_future();
  frame->slots[6] /* n */ = create_future();
  define__statement_tag(undefined);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 461: $statements statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_117;
}
static void cont__compiler__body__to_string_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* statements */, arguments->slots[0]);
  // 462: $n length_of(statements)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* statements */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_118;
}
static void cont__compiler__body__to_string_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* n */, arguments->slots[0]);
  // 463: %%statement_tag undefined
  set__statement_tag(get__undefined());
  // 464: ... statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_119;
}
static void cont__compiler__body__to_string_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 464: ... : (idx statement)
  // 465:   $previous_statement_tag statement_tag
  // 466:   !statement_tag undefined
  // 467:   $str statement.to_string
  // 468:   if
  // 469:     &&
  // 470:       idx > 1
  // 471:       ||
  // 472:         statement_tag == ALWAYS
  // 473:         previous_statement_tag != statement_tag
  // ...
  frame->slots[8] /* temp__2 */ = create_closure(entry__compiler__body__to_string_120, 2);
  // 464: for_each statements_of(self): (idx statement)
  // 465:   $previous_statement_tag statement_tag
  // 466:   !statement_tag undefined
  // 467:   $str statement.to_string
  // 468:   if
  // 469:     &&
  // 470:       idx > 1
  // 471:       ||
  // 472:         statement_tag == ALWAYS
  // 473:         previous_statement_tag != statement_tag
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_151;
}
static void entry__compiler__body__to_string_147(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[7]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 485: write_to &buf '@nl;' indentation str
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[1] /* indentation */;
  arguments->slots[3] = frame->slots[2] /* str */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_148;
}
static void cont__compiler__body__to_string_148(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_149(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[7]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 487: write_to &buf ' ' str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__32;
  arguments->slots[2] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_150;
}
static void cont__compiler__body__to_string_150(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_120(void) {
  allocate_initialized_frame_gc(6, 13);
  // slot allocations:
  // idx: 0
  // statement: 1
  // buf: 2
  // n: 3
  // outer_line_end_expression_width: 4
  // indentation: 5
  // previous_statement_tag: 6
  // str: 7
  frame->slots[2] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[6]; /* n */
  frame->slots[4] = myself->closure.frame->slots[3]; /* outer_line_end_expression_width */
  frame->slots[5] = myself->closure.frame->slots[4]; /* indentation */
  frame->slots[6] /* previous_statement_tag */ = create_future();
  frame->slots[7] /* str */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 465: $previous_statement_tag statement_tag
  initialize_future(frame->slots[6] /* previous_statement_tag */, get__statement_tag());
  // 466: !statement_tag undefined
  set__statement_tag(get__undefined());
  // 467: $str statement.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* statement */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_121;
}
static void cont__compiler__body__to_string_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* str */, arguments->slots[0]);
  // 470: idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_122;
}
static void cont__compiler__body__to_string_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 471: ||
  // 472:   statement_tag == ALWAYS
  // 473:   previous_statement_tag != statement_tag
  frame->slots[10] /* temp__3 */ = create_closure(entry__compiler__body__to_string_123, 0);
  // 469: &&
  // 470:   idx > 1
  // 471:   ||
  // 472:     statement_tag == ALWAYS
  // 473:     previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_129;
}
static void entry__compiler__body__to_string_123(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 472: statement_tag == ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__statement_tag();
  arguments->slots[1] = var._ALWAYS;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_124;
}
static void cont__compiler__body__to_string_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 473: previous_statement_tag != statement_tag
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__body__to_string_125, 0);
  // 471: ||
  // 472:   statement_tag == ALWAYS
  // 473:   previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_128;
}
static void entry__compiler__body__to_string_125(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // previous_statement_tag: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* previous_statement_tag */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 473: previous_statement_tag != statement_tag
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* previous_statement_tag */;
  arguments->slots[1] = get__statement_tag();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_126;
}
static void cont__compiler__body__to_string_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 473: previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_127;
}
static void cont__compiler__body__to_string_127(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 473: previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 471: ||
  // 472:   statement_tag == ALWAYS
  // 473:   previous_statement_tag != statement_tag
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 474: :
  // 475:   writeln_to &buf
  frame->slots[11] /* temp__4 */ = create_closure(entry__compiler__body__to_string_130, 0);
  // 468: if
  // 469:   &&
  // 470:     idx > 1
  // 471:     ||
  // 472:       statement_tag == ALWAYS
  // 473:       previous_statement_tag != statement_tag
  // 474:   :
  // 475:     writeln_to &buf
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_132;
}
static void entry__compiler__body__to_string_130(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 475: writeln_to &buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_131;
}
static void cont__compiler__body__to_string_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_132(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 478: n > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* n */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_133;
}
static void cont__compiler__body__to_string_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  frame->slots[10] /* temp__3 */ = create_closure(entry__compiler__body__to_string_134, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_146;
}
static void entry__compiler__body__to_string_134(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // buf: 0
  // str: 1
  // outer_line_end_expression_width: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[7]; /* str */
  frame->slots[2] = myself->closure.frame->slots[4]; /* outer_line_end_expression_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 479: buf .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_135;
}
static void cont__compiler__body__to_string_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_string_136, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_145;
}
static void entry__compiler__body__to_string_136(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // outer_line_end_expression_width: 1
  // buf: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[2]; /* outer_line_end_expression_width */
  frame->slots[2] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 480: str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_137;
}
static void cont__compiler__body__to_string_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 481: >
  // 482:   length_of(buf)+1+length_of(str)
  // 483:   outer_line_end_expression_width
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__body__to_string_138, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_144;
}
static void entry__compiler__body__to_string_138(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // outer_line_end_expression_width: 0
  // buf: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* outer_line_end_expression_width */
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 482: length_of(buf)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_139;
}
static void cont__compiler__body__to_string_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 482: length_of(buf)+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_140;
}
static void cont__compiler__body__to_string_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 482: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_141;
}
static void cont__compiler__body__to_string_141(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  // 482: length_of(buf)+1+length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_142;
}
static void cont__compiler__body__to_string_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 481: >
  // 482:   length_of(buf)+1+length_of(str)
  // 483:   outer_line_end_expression_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* outer_line_end_expression_width */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_143;
}
static void cont__compiler__body__to_string_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 481: >
  // 482:   length_of(buf)+1+length_of(str)
  // 483:   outer_line_end_expression_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_146(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 484: :
  // 485:   write_to &buf '@nl;' indentation str
  frame->slots[11] /* temp__4 */ = create_closure(entry__compiler__body__to_string_147, 0);
  // 486: :
  // 487:   write_to &buf ' ' str
  frame->slots[12] /* temp__5 */ = create_closure(entry__compiler__body__to_string_149, 0);
  // 476: if
  // 477:   ||
  // 478:     n > 1
  // 479:     buf .contains. '@nl;'
  // 480:     str .contains. '@nl;'
  // 481:     >
  // 482:       length_of(buf)+1+length_of(str)
  // 483:       outer_line_end_expression_width
  // 484:   :
  // 485:     write_to &buf '@nl;' indentation str
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  arguments->slots[2] = frame->slots[12] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__body__to_string_151(void) {
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_152(void) {
  myself = frame->slots[0] /* return__3 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_153(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 488: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__body__to_string_1(void) {
  allocate_initialized_frame_gc(1, 10);
  // slot allocations:
  // self: 0
  // indent: 1
  // remark_lines: 2
  // parameters: 3
  frame->slots[1] /* indent */ = create_cell();
  frame->slots[2] /* remark_lines */ = create_future();
  frame->slots[3] /* parameters */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 365: $$indent expression_indent
  ((CELL *)frame->slots[1])->contents /* indent */ = get__expression_indent();
  // 366: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_2;
}
static void cont__compiler__body__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* remark_lines */, arguments->slots[0]);
  // 367: $parameters parameters_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__parameters_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_3;
}
static void cont__compiler__body__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* parameters */, arguments->slots[0]);
  // 370: length_of(parameters)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* parameters */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_4;
}
static void cont__compiler__body__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 370: length_of(parameters) == 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = number__0;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_5;
}
static void cont__compiler__body__to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__body__to_string_6, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_15;
}
static void entry__compiler__body__to_string_6(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 371: ... statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_7;
}
static void cont__compiler__body__to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 371: length_of(statements_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_8;
}
static void cont__compiler__body__to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 371: length_of(statements_of(self)) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_9;
}
static void cont__compiler__body__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 372: statements_of(self)(1).is_a_return
  frame->slots[5] /* temp__5 */ = create_closure(entry__compiler__body__to_string_10, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_14;
}
static void entry__compiler__body__to_string_10(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 372: statements_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__statements_of();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_11;
}
static void cont__compiler__body__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 372: statements_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[3] /* temp__3 */;
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_12;
}
static void cont__compiler__body__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 372: statements_of(self)(1).is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_a_return();
  func = myself->type;
  frame->cont = cont__compiler__body__to_string_13;
}
static void cont__compiler__body__to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 372: statements_of(self)(1).is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__body__to_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 373: :
  // 374:   $str statements_of(self)(1).to_string
  // 375:   if
  // 376:     line_end_expression_width == 0 && str .contains. '@nl;'
  // 377:     -> string('@nl;' spaces(indent) str)
  // 378:     -> str
  frame->slots[8] /* temp__5 */ = create_closure(entry__compiler__body__to_string_16, 0);
  // 379: :
  // 380:   $$buf undefined
  // 381:   
  // 382:   $check_for_line_end_expression:
  // 383:     if
  // 384:       line_end_expression_width > 0:
  // 385:         !buf ":"
  // 386:       :
  // 387:         !buf string("@nl;" spaces(indent) ':')
  // 388:         plus &indent 2
  // ...
  frame->slots[9] /* temp__6 */ = create_closure(entry__compiler__body__to_string_28, 0);
  // 368: if
  // 369:   &&
  // 370:     length_of(parameters) == 0
  // 371:     length_of(statements_of(self)) == 1
  // 372:     statements_of(self)(1).is_a_return
  // 373:   :
  // 374:     $str statements_of(self)(1).to_string
  // 375:     if
  // 376:       line_end_expression_width == 0 && str .contains. '@nl;'
  // 377:       -> string('@nl;' spaces(indent) str)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  arguments->slots[2] = frame->slots[9] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__argument_to_string_2(void) {
  allocate_initialized_frame_gc(3, 10);
  // slot allocations:
  // return__1: 0
  // argument: 1
  // width: 2
  // str: 3
  // first_chr: 4
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[2] = myself->closure.frame->slots[1]; /* width */
  define__line_width(create_future());
  frame->slots[3] /* str */ = create_cell();
  frame->slots[4] /* first_chr */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 499: argument.is_a_destination
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__is_a_destination();
  func = myself->type;
  frame->cont = cont__argument_to_string_3;
}
static void cont__argument_to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__3 */ = create_closure(entry__argument_to_string_4, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__argument_to_string_9;
}
static void entry__argument_to_string_4(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 500: argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__argument_to_string_5;
}
static void cont__argument_to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 501: argument.is_an_optional_item
  frame->slots[3] /* temp__3 */ = create_closure(entry__argument_to_string_6, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__argument_to_string_8;
}
static void entry__argument_to_string_6(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 501: argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__argument_to_string_7;
}
static void cont__argument_to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 501: argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 503: -> width
  frame->slots[8] /* temp__4 */ = create_closure(entry__argument_to_string_10, 0);
  // 496: %line_width
  // 497:   if
  // 498:     ||
  // 499:       argument.is_a_destination
  // 500:       argument.is_an_expanded_item
  // 501:       argument.is_an_optional_item
  // 502:     -> UNLIMITED
  // 503:     -> width
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = func__argument_to_string_11;
  arguments->slots[2] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__argument_to_string_12;
}
static void entry__argument_to_string_10(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // width: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 503: -> width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* width */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__argument_to_string_11(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 502: -> UNLIMITED
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._UNLIMITED;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_width(), arguments->slots[0]);
  // 505: $$str argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__argument_to_string_13;
}
static void cont__argument_to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* str */ = arguments->slots[0];
  // 507: -> argument.is_an_expanded_item:
  // 508:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 509:     !str string('(' str ')')
  // 510:   push &str '*'
  frame->slots[5] /* temp__1 */ = create_closure(entry__argument_to_string_14, 0);
  // 511: -> argument.is_an_optional_item:
  // 512:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 513:     !str string('(' str ')')
  // 514:   push &str '?'
  frame->slots[6] /* temp__2 */ = create_closure(entry__argument_to_string_23, 0);
  // 506: cond
  // 507:   -> argument.is_an_expanded_item:
  // 508:     if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 509:       !str string('(' str ')')
  // 510:     push &str '*'
  // 511:   -> argument.is_an_optional_item:
  // 512:     if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 513:       !str string('(' str ')')
  // 514:     push &str '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 0;
  myself = get__cond();
  func = myself->type;
  frame->cont = cont__argument_to_string_32;
}
static void entry__argument_to_string_25(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 512: ... precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__argument_to_string_26;
}
static void cont__argument_to_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 512: ... precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__argument_to_string_27;
}
static void cont__argument_to_string_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 512: ... :
  // 513:   !str string('(' str ')')
  frame->slots[4] /* temp__3 */ = create_closure(entry__argument_to_string_28, 0);
  // 512: if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 513:   !str string('(' str ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__argument_to_string_30;
}
static void entry__argument_to_string_28(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 513: !str string('(' str ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* str */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__argument_to_string_29;
}
static void cont__argument_to_string_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_30(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 514: push &str '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* str */;
  arguments->slots[1] = character__63;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__argument_to_string_31;
}
static void cont__argument_to_string_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__argument_to_string_16(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 508: ... precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__argument_to_string_17;
}
static void cont__argument_to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 508: ... precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__argument_to_string_18;
}
static void cont__argument_to_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 508: ... :
  // 509:   !str string('(' str ')')
  frame->slots[4] /* temp__3 */ = create_closure(entry__argument_to_string_19, 0);
  // 508: if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 509:   !str string('(' str ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__argument_to_string_21;
}
static void entry__argument_to_string_19(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 509: !str string('(' str ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* str */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__argument_to_string_20;
}
static void cont__argument_to_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_21(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 510: push &str '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* str */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__argument_to_string_22;
}
static void cont__argument_to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* str */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__argument_to_string_14(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 507: ... argument.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__argument_to_string_15;
}
static void cont__argument_to_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 507: ... :
  // 508:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 509:     !str string('(' str ')')
  // 510:   push &str '*'
  frame->slots[3] /* temp__2 */ = create_closure(entry__argument_to_string_16, 0);
  // 507: -> argument.is_an_expanded_item:
  // 508:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 509:     !str string('(' str ')')
  // 510:   push &str '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__argument_to_string_23(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 511: ... argument.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__argument_to_string_24;
}
static void cont__argument_to_string_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 511: ... :
  // 512:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 513:     !str string('(' str ')')
  // 514:   push &str '?'
  frame->slots[3] /* temp__2 */ = create_closure(entry__argument_to_string_25, 0);
  // 511: -> argument.is_an_optional_item:
  // 512:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 513:     !str string('(' str ')')
  // 514:   push &str '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_32(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 515: $first_chr str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[3])->contents /* str */;
  func = myself->type;
  frame->cont = cont__argument_to_string_33;
}
static void cont__argument_to_string_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* first_chr */, arguments->slots[0]);
  // 517: argument.is_a_destination
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__is_a_destination();
  func = myself->type;
  frame->cont = cont__argument_to_string_34;
}
static void cont__argument_to_string_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 517: ... first_chr != '$' && first_chr != '%'
  frame->slots[7] /* temp__3 */ = create_closure(entry__argument_to_string_35, 0);
  // 517: argument.is_a_destination && first_chr != '$' && first_chr != '%'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__argument_to_string_42;
}
static void entry__argument_to_string_35(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // first_chr: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* first_chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 517: ... first_chr != '$'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* first_chr */;
  arguments->slots[1] = character__36;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__argument_to_string_36;
}
static void cont__argument_to_string_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 517: ... first_chr != '$'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__argument_to_string_37;
}
static void cont__argument_to_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 517: ... first_chr != '%'
  frame->slots[4] /* temp__4 */ = create_closure(entry__argument_to_string_38, 0);
  // 517: ... first_chr != '$' && first_chr != '%'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__argument_to_string_41;
}
static void entry__argument_to_string_38(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // first_chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* first_chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 517: ... first_chr != '%'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* first_chr */;
  arguments->slots[1] = character__37;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__argument_to_string_39;
}
static void cont__argument_to_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 517: ... first_chr != '%'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__argument_to_string_40;
}
static void cont__argument_to_string_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 517: ... first_chr != '%'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 517: ... first_chr != '$' && first_chr != '%'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 518: ->
  // 519:   if
  // 520:     argument.is_an_input_output_argument
  // 521:     -> string('&' str)
  // 522:     -> string('!' str)
  frame->slots[8] /* temp__4 */ = create_closure(entry__argument_to_string_43, 0);
  // 523: -> str
  frame->slots[9] /* temp__5 */ = create_closure(entry__argument_to_string_50, 0);
  // 516: if
  // 517:   argument.is_a_destination && first_chr != '$' && first_chr != '%'
  // 518:   ->
  // 519:     if
  // 520:       argument.is_an_input_output_argument
  // 521:       -> string('&' str)
  // 522:       -> string('!' str)
  // 523:   -> str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  arguments->slots[2] = frame->slots[9] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__argument_to_string_51;
}
static void entry__argument_to_string_43(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // argument: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 520: argument.is_an_input_output_argument
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_an_input_output_argument();
  func = myself->type;
  frame->cont = cont__argument_to_string_44;
}
static void cont__argument_to_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 521: -> string('&' str)
  frame->slots[4] /* temp__3 */ = create_closure(entry__argument_to_string_45, 0);
  // 522: -> string('!' str)
  frame->slots[5] /* temp__4 */ = create_closure(entry__argument_to_string_47, 0);
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__argument_to_string_49;
}
static void entry__argument_to_string_45(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 521: ... string('&' str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__38;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* str */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__argument_to_string_46;
}
static void cont__argument_to_string_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 521: -> string('&' str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__argument_to_string_47(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 522: ... string('!' str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__33;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* str */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__argument_to_string_48;
}
static void cont__argument_to_string_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 522: -> string('!' str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 518: ->
  // 519:   if
  // 520:     argument.is_an_input_output_argument
  // 521:     -> string('&' str)
  // 522:     -> string('!' str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__argument_to_string_50(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 523: -> str
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* str */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__argument_to_string_51(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__argument_to_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // argument: 0
  // width: 1
  // _define $width line_width
  frame->slots[1] /* width */ = get__line_width();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 494: $width line_width
  initialize_maybe_future(frame->slots[1] /* width */, get__line_width());
  // 495: ... :
  // 496:   %line_width
  // 497:     if
  // 498:       ||
  // 499:         argument.is_a_destination
  // 500:         argument.is_an_expanded_item
  // 501:         argument.is_an_optional_item
  // 502:       -> UNLIMITED
  // 503:       -> width
  // 504:   
  // ...
  frame->slots[2] /* temp__1 */ = create_closure(entry__argument_to_string_2, 0);
  // 495: do:
  // 496:   %line_width
  // 497:     if
  // 498:       ||
  // 499:         argument.is_a_destination
  // 500:         argument.is_an_expanded_item
  // 501:         argument.is_an_optional_item
  // 502:       -> UNLIMITED
  // 503:       -> width
  // 504:   
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_1(void) {
  allocate_initialized_frame_gc(4, 20);
  // slot allocations:
  // self: 0
  // mode: 1
  // available_width: 2
  // return: 3
  // line_end_width: 4
  // arguments: 5
  // first: 6
  // n: 7
  // total_length: 8
  // strings: 9
  // has_final_remark: 10
  // do_use_multiple_lines: 11
  // buf: 12
  // print_on_one_line: 13
  // print_on_multiple_lines: 14
  frame->slots[3] /* return */ = create_continuation();
  frame->slots[13] /* print_on_one_line */ = create_future();
  frame->slots[14] /* print_on_multiple_lines */ = create_future();
  // _define $line_end_width line_end_expression_width
  frame->slots[4] /* line_end_width */ = get__line_end_expression_width();
  frame->slots[5] /* arguments */ = create_future();
  frame->slots[6] /* first */ = create_cell();
  frame->slots[7] /* n */ = create_future();
  frame->slots[8] /* total_length */ = create_cell();
  frame->slots[9] /* strings */ = create_cell();
  frame->slots[10] /* has_final_remark */ = create_cell();
  frame->slots[11] /* do_use_multiple_lines */ = create_cell();
  frame->slots[12] /* buf */ = create_cell();
  if (argument_count != 3) {
    invalid_arguments_error();
    return;
  }
  // 590: ... : (from to)
  // 591:   for_each_from_to strings from to: (idx str)
  // 592:     unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  // 593:     if
  // 594:       idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 595:         push &buf '('
  // 596:         append &buf str
  // 597:         push &buf ')'
  // 598:       :
  // 599:         append &buf str
  frame->slots[15] /* temp__1 */ = create_closure(entry__arguments_to_string_2, 2);
  // 590: $print_on_one_line: (from to)
  // 591:   for_each_from_to strings from to: (idx str)
  // 592:     unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  // 593:     if
  // 594:       idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 595:         push &buf '('
  // 596:         append &buf str
  // 597:         push &buf ')'
  // 598:       :
  // 599:         append &buf str
  initialize_future(frame->slots[13] /* print_on_one_line */, frame->slots[15] /* temp__1 */);
  // 601: ... : (from to)
  // 602:   $indentation spaces(expression_indent)
  // 603:   $$line_end_conversion_is_allowed false
  // 604:   for_each_from_to strings from to: (idx str)
  // 605:     # check for possible "line-end-form conversion"
  // 606:     
  // 607:     if
  // 608:       &&
  // 609:         line_end_conversion_is_allowed
  // 610:         str .has_prefix. ('@nl;', INDENTATION, alt(':' '@quot;'))
  // ...
  frame->slots[15] /* temp__1 */ = create_closure(entry__arguments_to_string_31, 2);
  // 601: $print_on_multiple_lines: (from to)
  // 602:   $indentation spaces(expression_indent)
  // 603:   $$line_end_conversion_is_allowed false
  // 604:   for_each_from_to strings from to: (idx str)
  // 605:     # check for possible "line-end-form conversion"
  // 606:     
  // 607:     if
  // 608:       &&
  // 609:         line_end_conversion_is_allowed
  // 610:         str .has_prefix. ('@nl;', INDENTATION, alt(':' '@quot;'))
  // ...
  initialize_future(frame->slots[14] /* print_on_multiple_lines */, frame->slots[15] /* temp__1 */);
  // 533: $arguments arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_114;
}
static void entry__arguments_to_string_64(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // buf: 1
  // line_end_conversion_is_allowed: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* line_end_conversion_is_allowed */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 623: ... str(3)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__3;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_65;
}
static void cont__arguments_to_string_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 623: ... str(3) == '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_66;
}
static void cont__arguments_to_string_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 623: ... : push &buf ' '
  frame->slots[5] /* temp__3 */ = create_closure(entry__arguments_to_string_67, 0);
  // 623: if str(3) == '@quot;': push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_69;
}
static void entry__arguments_to_string_67(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 623: ... push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_68;
}
static void cont__arguments_to_string_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_69(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 624: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__arguments_to_string_70;
}
static void cont__arguments_to_string_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 624: ... range(str 3 -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = number__3;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_71;
}
static void cont__arguments_to_string_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 624: append &buf range(str 3 -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__arguments_to_string_72;
}
static void cont__arguments_to_string_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 625: !line_end_conversion_is_allowed false
  ((CELL *)frame->slots[2])->contents /* line_end_conversion_is_allowed */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_73(void) {
  allocate_initialized_frame_gc(7, 11);
  // slot allocations:
  // first: 0
  // idx: 1
  // str: 2
  // buf: 3
  // indentation: 4
  // n: 5
  // line_end_conversion_is_allowed: 6
  frame->slots[0] = myself->closure.frame->slots[5]; /* first */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[1]; /* str */
  frame->slots[3] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[4] = myself->closure.frame->slots[6]; /* indentation */
  frame->slots[5] = myself->closure.frame->slots[7]; /* n */
  frame->slots[6] = myself->closure.frame->slots[2]; /* line_end_conversion_is_allowed */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 627: ... idx > first
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* first */;
  arguments->slots[1] = frame->slots[1] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_74;
}
static void cont__arguments_to_string_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 627: ... str(1) == '#'
  frame->slots[9] /* temp__3 */ = create_closure(entry__arguments_to_string_75, 0);
  // 627: ... idx > first && str(1) == '#'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_78;
}
static void entry__arguments_to_string_75(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 627: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_76;
}
static void cont__arguments_to_string_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 627: ... str(1) == '#'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__35;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_77;
}
static void cont__arguments_to_string_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 627: ... str(1) == '#'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 627: ... : push &buf '@nl;'
  frame->slots[10] /* temp__4 */ = create_closure(entry__arguments_to_string_79, 0);
  // 627: if idx > first && str(1) == '#': push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_81;
}
static void entry__arguments_to_string_79(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 627: ... push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_80;
}
static void cont__arguments_to_string_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_81(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 628: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_82;
}
static void cont__arguments_to_string_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 628: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_83;
}
static void cont__arguments_to_string_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 628: ... :
  // 629:   push &buf '@nl;'
  // 630:   append &buf indentation
  frame->slots[9] /* temp__3 */ = create_closure(entry__arguments_to_string_84, 0);
  // 628: unless str(1) == '@nl;':
  // 629:   push &buf '@nl;'
  // 630:   append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__arguments_to_string_87;
}
static void entry__arguments_to_string_84(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[4]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 629: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_85;
}
static void cont__arguments_to_string_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 630: append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__arguments_to_string_86;
}
static void cont__arguments_to_string_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_87(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 631: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__arguments_to_string_88;
}
static void cont__arguments_to_string_88(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* buf */ = arguments->slots[0];
  // 632: ... idx < n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* idx */;
  arguments->slots[1] = frame->slots[5] /* n */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_89;
}
static void cont__arguments_to_string_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 632: ... str(1) == '#'
  frame->slots[9] /* temp__3 */ = create_closure(entry__arguments_to_string_90, 0);
  // 632: ... idx < n && str(1) == '#'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_93;
}
static void entry__arguments_to_string_90(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 632: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_91;
}
static void cont__arguments_to_string_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 632: ... str(1) == '#'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__35;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_92;
}
static void cont__arguments_to_string_92(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 632: ... str(1) == '#'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 632: ... : push &buf '@nl;'
  frame->slots[10] /* temp__4 */ = create_closure(entry__arguments_to_string_94, 0);
  // 632: if idx < n && str(1) == '#': push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_96;
}
static void entry__arguments_to_string_94(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 632: ... push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_95;
}
static void cont__arguments_to_string_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_96(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 635: str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_97;
}
static void cont__arguments_to_string_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 635: str(1) != ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_98;
}
static void cont__arguments_to_string_98(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 635: str(1) != ':'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_99;
}
static void cont__arguments_to_string_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  frame->slots[10] /* temp__4 */ = create_closure(entry__arguments_to_string_100, 0);
  // 633: !line_end_conversion_is_allowed
  // 634:   &&
  // 635:     str(1) != ':'
  // 636:     str(1) != '#'
  // 637:     not(str .has_prefix. "@quot;@nl;")
  // 638:     not(str .has_prefix. "->")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_113;
}
static void entry__arguments_to_string_100(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 636: str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_101;
}
static void cont__arguments_to_string_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 636: str(1) != '#'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = character__35;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_102;
}
static void cont__arguments_to_string_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 636: str(1) != '#'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_103;
}
static void cont__arguments_to_string_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__5 */ = create_closure(entry__arguments_to_string_104, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_112;
}
static void entry__arguments_to_string_104(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 637: ... str .has_prefix. "@quot;@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__2d7981f4e6182bcf;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__arguments_to_string_106;
}
static void cont__arguments_to_string_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 637: not(str .has_prefix. "@quot;@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_107;
}
static void cont__arguments_to_string_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 638: not(str .has_prefix. "->")
  frame->slots[4] /* temp__4 */ = create_closure(entry__arguments_to_string_108, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_111;
}
static void entry__arguments_to_string_108(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 638: ... str .has_prefix. "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__2d7981f4e6602bfb;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__arguments_to_string_109;
}
static void cont__arguments_to_string_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 638: not(str .has_prefix. "->")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_110;
}
static void cont__arguments_to_string_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 638: not(str .has_prefix. "->")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* line_end_conversion_is_allowed */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_33(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // idx: 0
  // str: 1
  // line_end_conversion_is_allowed: 2
  // strings: 3
  // buf: 4
  // first: 5
  // indentation: 6
  // n: 7
  frame->slots[2] = myself->closure.frame->slots[7]; /* line_end_conversion_is_allowed */
  frame->slots[3] = myself->closure.frame->slots[2]; /* strings */
  frame->slots[4] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[5] = myself->closure.frame->slots[4]; /* first */
  frame->slots[6] = myself->closure.frame->slots[6]; /* indentation */
  frame->slots[7] = myself->closure.frame->slots[5]; /* n */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = create_closure(entry__arguments_to_string_34, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* line_end_conversion_is_allowed */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_63;
}
static void entry__arguments_to_string_34(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // str: 0
  // strings: 1
  // idx: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  frame->slots[1] = myself->closure.frame->slots[3]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[0]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 610: ... alt(':' '@quot;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__58;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__arguments_to_string_35;
}
static void cont__arguments_to_string_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 610: ... '@nl;', INDENTATION, alt(':' '@quot;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = var._INDENTATION;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__arguments_to_string_36;
}
static void cont__arguments_to_string_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 610: str .has_prefix. ('@nl;', INDENTATION, alt(':' '@quot;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__arguments_to_string_37;
}
static void cont__arguments_to_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__5 */ = create_closure(entry__arguments_to_string_38, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_62;
}
static void entry__arguments_to_string_38(void) {
  allocate_initialized_frame_gc(3, 9);
  // slot allocations:
  // strings: 0
  // idx: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[2]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 611: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_39;
}
static void cont__arguments_to_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  // 611: ... strings(idx-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_40;
}
static void cont__arguments_to_string_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 611: ... strings(idx-1) .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__arguments_to_string_41;
}
static void cont__arguments_to_string_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 611: not(strings(idx-1) .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_42;
}
static void cont__arguments_to_string_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 612: <=
  // 613:   +
  // 614:     expression_indent
  // 615:     length_of(strings(idx-1))
  // 616:     if
  // 617:       str(3) == ':'
  // 618:       -> 1 # ':'
  // 619:       -> 2 # ' "'
  // 620:     length_of(range(str 3 -1) .truncate_from. '@nl;')
  // 621:   line_width
  frame->slots[8] /* temp__6 */ = create_closure(entry__arguments_to_string_43, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__6 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_61;
}
static void entry__arguments_to_string_43(void) {
  allocate_initialized_frame_gc(3, 18);
  // slot allocations:
  // strings: 0
  // idx: 1
  // str: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[1]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 615: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_44;
}
static void cont__arguments_to_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__8 */ = arguments->slots[0];
  // 615: ... strings(idx-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__8 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* strings */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_45;
}
static void cont__arguments_to_string_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__7 */ = arguments->slots[0];
  // 615: length_of(strings(idx-1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__7 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_46;
}
static void cont__arguments_to_string_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__6 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = frame->slots[8] /* temp__6 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_47;
}
static void cont__arguments_to_string_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__5 */ = arguments->slots[0];
  // 617: str(3)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__3;
  result_count = 1;
  myself = frame->slots[2] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_48;
}
static void cont__arguments_to_string_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__11 */ = arguments->slots[0];
  // 617: str(3) == ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__11 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_49;
}
static void cont__arguments_to_string_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__10 */ = arguments->slots[0];
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__10 */;
  arguments->slots[1] = func__arguments_to_string_50;
  arguments->slots[2] = func__arguments_to_string_51;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_52;
}
static void entry__arguments_to_string_50(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 618: -> 1 # ':'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_51(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 619: -> 2 # ' "'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__9 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__5 */;
  arguments->slots[1] = frame->slots[11] /* temp__9 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_53;
}
static void cont__arguments_to_string_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__4 */ = arguments->slots[0];
  // 620: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__arguments_to_string_54;
}
static void cont__arguments_to_string_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[17] /* temp__15 */ = arguments->slots[0];
  // 620: ... range(str 3 -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  arguments->slots[1] = number__3;
  arguments->slots[2] = frame->slots[17] /* temp__15 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_55;
}
static void cont__arguments_to_string_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[16] /* temp__14 */ = arguments->slots[0];
  // 620: ... range(str 3 -1) .truncate_from. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* temp__14 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__truncate_from();
  func = myself->type;
  frame->cont = cont__arguments_to_string_56;
}
static void cont__arguments_to_string_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__13 */ = arguments->slots[0];
  // 620: length_of(range(str 3 -1) .truncate_from. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__13 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_57;
}
static void cont__arguments_to_string_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__12 */ = arguments->slots[0];
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__4 */;
  arguments->slots[1] = frame->slots[14] /* temp__12 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_58;
}
static void cont__arguments_to_string_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 612: <=
  // 613:   +
  // 614:     expression_indent
  // 615:     length_of(strings(idx-1))
  // 616:     if
  // 617:       str(3) == ':'
  // 618:       -> 1 # ':'
  // 619:       -> 2 # ' "'
  // 620:     length_of(range(str 3 -1) .truncate_from. '@nl;')
  // 621:   line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_59;
}
static void cont__arguments_to_string_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 612: <=
  // 613:   +
  // 614:     expression_indent
  // 615:     length_of(strings(idx-1))
  // 616:     if
  // 617:       str(3) == ':'
  // 618:       -> 1 # ':'
  // 619:       -> 2 # ' "'
  // 620:     length_of(range(str 3 -1) .truncate_from. '@nl;')
  // 621:   line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_60;
}
static void cont__arguments_to_string_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 612: <=
  // 613:   +
  // 614:     expression_indent
  // 615:     length_of(strings(idx-1))
  // 616:     if
  // 617:       str(3) == ':'
  // 618:       -> 1 # ':'
  // 619:       -> 2 # ' "'
  // 620:     length_of(range(str 3 -1) .truncate_from. '@nl;')
  // 621:   line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_62(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 622: :
  // 623:   if str(3) == '@quot;': push &buf ' '
  // 624:   append &buf range(str 3 -1)
  // 625:   !line_end_conversion_is_allowed false
  frame->slots[10] /* temp__3 */ = create_closure(entry__arguments_to_string_64, 0);
  // 626: :
  // 627:   if idx > first && str(1) == '#': push &buf '@nl;'
  // 628:   unless str(1) == '@nl;':
  // 629:     push &buf '@nl;'
  // 630:     append &buf indentation
  // 631:   append &buf str
  // 632:   if idx < n && str(1) == '#': push &buf '@nl;'
  // 633:   !line_end_conversion_is_allowed
  // 634:     &&
  // 635:       str(1) != ':'
  // ...
  frame->slots[11] /* temp__4 */ = create_closure(entry__arguments_to_string_73, 0);
  // 607: if
  // 608:   &&
  // 609:     line_end_conversion_is_allowed
  // 610:     str .has_prefix. ('@nl;', INDENTATION, alt(':' '@quot;'))
  // 611:     not(strings(idx-1) .contains. '@nl;')
  // 612:     <=
  // 613:       +
  // 614:         expression_indent
  // 615:         length_of(strings(idx-1))
  // 616:         if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  arguments->slots[2] = frame->slots[11] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_25(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 595: push &buf '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_26;
}
static void cont__arguments_to_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 596: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__arguments_to_string_27;
}
static void cont__arguments_to_string_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 597: push &buf ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_28;
}
static void cont__arguments_to_string_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_29(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // str: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 599: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__arguments_to_string_30;
}
static void cont__arguments_to_string_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_3(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // idx: 0
  // str: 1
  // buf: 2
  // n: 3
  frame->slots[2] = myself->closure.frame->slots[3]; /* buf */
  frame->slots[3] = myself->closure.frame->slots[4]; /* n */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 592: ... buf.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__arguments_to_string_4;
}
static void cont__arguments_to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 592: ... str(1) == ':' || str(1) == '@nl;'
  frame->slots[6] /* temp__3 */ = create_closure(entry__arguments_to_string_5, 0);
  // 592: ... buf.is_empty || str(1) == ':' || str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_12;
}
static void entry__arguments_to_string_5(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 592: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_6;
}
static void cont__arguments_to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 592: ... str(1) == ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_7;
}
static void cont__arguments_to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 592: ... str(1) == '@nl;'
  frame->slots[4] /* temp__4 */ = create_closure(entry__arguments_to_string_8, 0);
  // 592: ... str(1) == ':' || str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_11;
}
static void entry__arguments_to_string_8(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 592: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_9;
}
static void cont__arguments_to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 592: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_10;
}
static void cont__arguments_to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 592: ... str(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 592: ... str(1) == ':' || str(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 592: ... : push &buf ' '
  frame->slots[7] /* temp__4 */ = create_closure(entry__arguments_to_string_13, 0);
  // 592: unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__arguments_to_string_15;
}
static void entry__arguments_to_string_13(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 592: ... push &buf ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_14;
}
static void cont__arguments_to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_15(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 594: idx < n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[3] /* n */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_16;
}
static void cont__arguments_to_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 594: ... str .has_prefix. "->" && not(str .contains. '@nl;')
  frame->slots[6] /* temp__3 */ = create_closure(entry__arguments_to_string_17, 0);
  // 594: idx < n && str .has_prefix. "->" && not(str .contains. '@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_24;
}
static void entry__arguments_to_string_17(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 594: ... str .has_prefix. "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = string__2d7981f4e6602bfb;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__arguments_to_string_19;
}
static void cont__arguments_to_string_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 594: ... not(str .contains. '@nl;')
  frame->slots[3] /* temp__3 */ = create_closure(entry__arguments_to_string_20, 0);
  // 594: ... str .has_prefix. "->" && not(str .contains. '@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_23;
}
static void entry__arguments_to_string_20(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 594: ... str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__arguments_to_string_21;
}
static void cont__arguments_to_string_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 594: ... not(str .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_22;
}
static void cont__arguments_to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 594: ... not(str .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 594: ... str .has_prefix. "->" && not(str .contains. '@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 594: ... :
  // 595:   push &buf '('
  // 596:   append &buf str
  // 597:   push &buf ')'
  frame->slots[7] /* temp__4 */ = create_closure(entry__arguments_to_string_25, 0);
  // 598: :
  // 599:   append &buf str
  frame->slots[8] /* temp__5 */ = create_closure(entry__arguments_to_string_29, 0);
  // 593: if
  // 594:   idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 595:     push &buf '('
  // 596:     append &buf str
  // 597:     push &buf ')'
  // 598:   :
  // 599:     append &buf str
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_2(void) {
  allocate_initialized_frame_gc(5, 6);
  // slot allocations:
  // from: 0
  // to: 1
  // strings: 2
  // buf: 3
  // n: 4
  frame->slots[2] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[3] = myself->closure.frame->slots[12]; /* buf */
  frame->slots[4] = myself->closure.frame->slots[7]; /* n */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 591: ... : (idx str)
  // 592:   unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  // 593:   if
  // 594:     idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 595:       push &buf '('
  // 596:       append &buf str
  // 597:       push &buf ')'
  // 598:     :
  // 599:       append &buf str
  frame->slots[5] /* temp__1 */ = create_closure(entry__arguments_to_string_3, 2);
  // 591: for_each_from_to strings from to: (idx str)
  // 592:   unless buf.is_empty || str(1) == ':' || str(1) == '@nl;': push &buf ' '
  // 593:   if
  // 594:     idx < n && str .has_prefix. "->" && not(str .contains. '@nl;'):
  // 595:       push &buf '('
  // 596:       append &buf str
  // 597:       push &buf ')'
  // 598:     :
  // 599:       append &buf str
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* strings */;
  arguments->slots[1] = frame->slots[0] /* from */;
  arguments->slots[2] = frame->slots[1] /* to */;
  arguments->slots[3] = frame->slots[5] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_from_to();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_31(void) {
  allocate_initialized_frame_gc(6, 9);
  // slot allocations:
  // from: 0
  // to: 1
  // strings: 2
  // buf: 3
  // first: 4
  // n: 5
  // indentation: 6
  // line_end_conversion_is_allowed: 7
  frame->slots[2] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[3] = myself->closure.frame->slots[12]; /* buf */
  frame->slots[4] = myself->closure.frame->slots[6]; /* first */
  frame->slots[5] = myself->closure.frame->slots[7]; /* n */
  frame->slots[6] /* indentation */ = create_future();
  frame->slots[7] /* line_end_conversion_is_allowed */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 602: $indentation spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__arguments_to_string_32;
}
static void cont__arguments_to_string_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* indentation */, arguments->slots[0]);
  // 603: $$line_end_conversion_is_allowed false
  ((CELL *)frame->slots[7])->contents /* line_end_conversion_is_allowed */ = get__false();
  // 604: ... : (idx str)
  // 605:   # check for possible "line-end-form conversion"
  // 606:   
  // 607:   if
  // 608:     &&
  // 609:       line_end_conversion_is_allowed
  // 610:       str .has_prefix. ('@nl;', INDENTATION, alt(':' '@quot;'))
  // 611:       not(strings(idx-1) .contains. '@nl;')
  // 612:       <=
  // 613:         +
  // ...
  frame->slots[8] /* temp__1 */ = create_closure(entry__arguments_to_string_33, 2);
  // 604: for_each_from_to strings from to: (idx str)
  // 605:   # check for possible "line-end-form conversion"
  // 606:   
  // 607:   if
  // 608:     &&
  // 609:       line_end_conversion_is_allowed
  // 610:       str .has_prefix. ('@nl;', INDENTATION, alt(':' '@quot;'))
  // 611:       not(strings(idx-1) .contains. '@nl;')
  // 612:       <=
  // 613:         +
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* strings */;
  arguments->slots[1] = frame->slots[0] /* from */;
  arguments->slots[2] = frame->slots[1] /* to */;
  arguments->slots[3] = frame->slots[8] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_from_to();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* arguments */, arguments->slots[0]);
  // 534: ... arguments.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* arguments */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__arguments_to_string_115;
}
static void cont__arguments_to_string_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  // 534: ... : return ""
  frame->slots[16] /* temp__2 */ = create_closure(entry__arguments_to_string_116, 0);
  // 534: if arguments.is_empty: return ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[16] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_117;
}
static void entry__arguments_to_string_116(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // return: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 534: ... return ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_117(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 535: $$first 1
  ((CELL *)frame->slots[6])->contents /* first */ = number__1;
  // 536: $n length_of(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_118;
}
static void cont__arguments_to_string_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* n */, arguments->slots[0]);
  // 537: $$total_length 0
  ((CELL *)frame->slots[8])->contents /* total_length */ = number__0;
  // 538: $$strings empty_list
  ((CELL *)frame->slots[9])->contents /* strings */ = get__empty_list();
  // 539: $$has_final_remark false
  ((CELL *)frame->slots[10])->contents /* has_final_remark */ = get__false();
  // 543: line_width != UNLIMITED
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = var._UNLIMITED;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_119;
}
static void cont__arguments_to_string_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[16] /* temp__2 */ = arguments->slots[0];
  // 543: line_width != UNLIMITED
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_120;
}
static void cont__arguments_to_string_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  frame->slots[17] /* temp__3 */ = create_closure(entry__arguments_to_string_121, 0);
  // 541: $$do_use_multiple_lines
  // 542:   &&
  // 543:     line_width != UNLIMITED
  // 544:     ||
  // 545:       mode == PROC && arguments(1).is_an_attribute_value_pair
  // 546:       mode == FUNC && any_of(arguments is_a_body)
  // 547:       any_of(range(arguments_of(self) 1 -2) is_a_remark)
  // 548:       any_of(range(arguments_of(self) 1 -2) is_a_body)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[17] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_145;
}
static void entry__arguments_to_string_121(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // mode: 0
  // arguments: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 545: mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_122;
}
static void cont__arguments_to_string_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 545: ... arguments(1).is_an_attribute_value_pair
  frame->slots[6] /* temp__4 */ = create_closure(entry__arguments_to_string_123, 0);
  // 545: mode == PROC && arguments(1).is_an_attribute_value_pair
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_126;
}
static void entry__arguments_to_string_123(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 545: ... arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_124;
}
static void cont__arguments_to_string_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 545: ... arguments(1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_attribute_value_pair();
  func = myself->type;
  frame->cont = cont__arguments_to_string_125;
}
static void cont__arguments_to_string_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 545: ... arguments(1).is_an_attribute_value_pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__5 */ = create_closure(entry__arguments_to_string_127, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_144;
}
static void entry__arguments_to_string_127(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // mode: 0
  // arguments: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 546: mode == FUNC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._FUNC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_128;
}
static void cont__arguments_to_string_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 546: ... any_of(arguments is_a_body)
  frame->slots[6] /* temp__4 */ = create_closure(entry__arguments_to_string_129, 0);
  // 546: mode == FUNC && any_of(arguments is_a_body)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_131;
}
static void entry__arguments_to_string_129(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 546: ... any_of(arguments is_a_body)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = get__is_a_body();
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_130;
}
static void cont__arguments_to_string_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 546: ... any_of(arguments is_a_body)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__5 */ = create_closure(entry__arguments_to_string_132, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__5 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_143;
}
static void entry__arguments_to_string_132(void) {
  allocate_initialized_frame_gc(1, 7);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 547: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_133;
}
static void cont__arguments_to_string_133(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 547: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__arguments_to_string_134;
}
static void cont__arguments_to_string_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 547: ... range(arguments_of(self) 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_135;
}
static void cont__arguments_to_string_135(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 547: any_of(range(arguments_of(self) 1 -2) is_a_remark)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = get__is_a_remark();
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_136;
}
static void cont__arguments_to_string_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 548: any_of(range(arguments_of(self) 1 -2) is_a_body)
  frame->slots[6] /* temp__6 */ = create_closure(entry__arguments_to_string_137, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__6 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_142;
}
static void entry__arguments_to_string_137(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 548: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_138;
}
static void cont__arguments_to_string_138(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 548: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__arguments_to_string_139;
}
static void cont__arguments_to_string_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 548: ... range(arguments_of(self) 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_140;
}
static void cont__arguments_to_string_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 548: any_of(range(arguments_of(self) 1 -2) is_a_body)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = get__is_a_body();
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_141;
}
static void cont__arguments_to_string_141(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 548: any_of(range(arguments_of(self) 1 -2) is_a_body)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_142(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[11])->contents /* do_use_multiple_lines */ = arguments->slots[0];
  // 550: ... : (idx argument)
  // 551:   %line_end_expression_width
  // 552:     if
  // 553:       &&
  // 554:         mode == PROC
  // 555:         idx == n
  // 556:         total_length < line_end_width
  // 557:         not(do_use_multiple_lines)
  // 558:       -> line_end_width-total_length
  // 559:       -> 0
  // ...
  frame->slots[15] /* temp__1 */ = create_closure(entry__arguments_to_string_146, 2);
  // 550: for_each arguments: (idx argument)
  // 551:   %line_end_expression_width
  // 552:     if
  // 553:       &&
  // 554:         mode == PROC
  // 555:         idx == n
  // 556:         total_length < line_end_width
  // 557:         not(do_use_multiple_lines)
  // 558:       -> line_end_width-total_length
  // 559:       -> 0
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* arguments */;
  arguments->slots[1] = frame->slots[15] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__arguments_to_string_222;
}
static void entry__arguments_to_string_146(void) {
  allocate_initialized_frame_gc(11, 16);
  // slot allocations:
  // idx: 0
  // argument: 1
  // return__1: 2
  // mode: 3
  // n: 4
  // total_length: 5
  // line_end_width: 6
  // do_use_multiple_lines: 7
  // has_final_remark: 8
  // available_width: 9
  // strings: 10
  // str: 11
  frame->slots[2] /* return__1 */ = create_continuation();
  frame->slots[3] = myself->closure.frame->slots[1]; /* mode */
  frame->slots[4] = myself->closure.frame->slots[7]; /* n */
  frame->slots[5] = myself->closure.frame->slots[8]; /* total_length */
  frame->slots[6] = myself->closure.frame->slots[4]; /* line_end_width */
  frame->slots[7] = myself->closure.frame->slots[11]; /* do_use_multiple_lines */
  frame->slots[8] = myself->closure.frame->slots[10]; /* has_final_remark */
  frame->slots[9] = myself->closure.frame->slots[2]; /* available_width */
  frame->slots[10] = myself->closure.frame->slots[9]; /* strings */
  define__line_end_expression_width(create_future());
  frame->slots[11] /* str */ = create_future();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 554: mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_147;
}
static void cont__arguments_to_string_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__2 */ = arguments->slots[0];
  frame->slots[14] /* temp__3 */ = create_closure(entry__arguments_to_string_148, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__2 */;
  arguments->slots[1] = frame->slots[14] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_156;
}
static void entry__arguments_to_string_148(void) {
  allocate_initialized_frame_gc(5, 8);
  // slot allocations:
  // idx: 0
  // n: 1
  // total_length: 2
  // line_end_width: 3
  // do_use_multiple_lines: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[4]; /* n */
  frame->slots[2] = myself->closure.frame->slots[5]; /* total_length */
  frame->slots[3] = myself->closure.frame->slots[6]; /* line_end_width */
  frame->slots[4] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 555: idx == n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[1] /* n */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_149;
}
static void cont__arguments_to_string_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  frame->slots[7] /* temp__3 */ = create_closure(entry__arguments_to_string_150, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_155;
}
static void entry__arguments_to_string_150(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // total_length: 0
  // line_end_width: 1
  // do_use_multiple_lines: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_length */
  frame->slots[1] = myself->closure.frame->slots[3]; /* line_end_width */
  frame->slots[2] = myself->closure.frame->slots[4]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 556: total_length < line_end_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  arguments->slots[1] = frame->slots[1] /* line_end_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_151;
}
static void cont__arguments_to_string_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 557: not(do_use_multiple_lines)
  frame->slots[5] /* temp__3 */ = create_closure(entry__arguments_to_string_152, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_154;
}
static void entry__arguments_to_string_152(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 557: not(do_use_multiple_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_153;
}
static void cont__arguments_to_string_153(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 557: not(do_use_multiple_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_155(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_156(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__1 */ = arguments->slots[0];
  // 558: -> line_end_width-total_length
  frame->slots[15] /* temp__4 */ = create_closure(entry__arguments_to_string_157, 0);
  // 551: %line_end_expression_width
  // 552:   if
  // 553:     &&
  // 554:       mode == PROC
  // 555:       idx == n
  // 556:       total_length < line_end_width
  // 557:       not(do_use_multiple_lines)
  // 558:     -> line_end_width-total_length
  // 559:     -> 0
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__1 */;
  arguments->slots[1] = frame->slots[15] /* temp__4 */;
  arguments->slots[2] = func__arguments_to_string_159;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_160;
}
static void entry__arguments_to_string_157(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // line_end_width: 0
  // total_length: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* line_end_width */
  frame->slots[1] = myself->closure.frame->slots[5]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 558: ... line_end_width-total_length
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line_end_width */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* total_length */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_158;
}
static void cont__arguments_to_string_158(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 558: -> line_end_width-total_length
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_159(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 559: -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_160(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 561: $str argument_to_string(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = var._argument_to_string;
  func = myself->type;
  frame->cont = cont__arguments_to_string_161;
}
static void cont__arguments_to_string_161(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[11] /* str */, arguments->slots[0]);
  // 563: str .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* str */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__arguments_to_string_162;
}
static void cont__arguments_to_string_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__1 */ = arguments->slots[0];
  // 563: ... :
  // 564:   if mode == FUNC || str(1) == '@nl;':
  // 565:     if
  // 566:       mode == PROC && idx == n && argument.is_a_remark:
  // 567:         !has_final_remark true
  // 568:       :
  // 569:         !do_use_multiple_lines true
  frame->slots[13] /* temp__2 */ = create_closure(entry__arguments_to_string_163, 0);
  // 570: :
  // 571:   if
  // 572:     idx < n:
  // 573:       if mode == PROC || idx > 1: inc &total_length # separating space
  // 574:       plus &total_length length_of(str)
  // 575:       if str .has_prefix. "->": plus &total_length 2 # needs parentheses
  // 576:       if total_length > available_width: !do_use_multiple_lines true
  // 577:     :
  // 578:       if (mode == PROC || idx > 1) && str(1) != ':':
  // 579:         inc &total_length # separating space
  // ...
  frame->slots[14] /* temp__3 */ = create_closure(entry__arguments_to_string_179, 0);
  // 562: if
  // 563:   str .contains. '@nl;':
  // 564:     if mode == FUNC || str(1) == '@nl;':
  // 565:       if
  // 566:         mode == PROC && idx == n && argument.is_a_remark:
  // 567:           !has_final_remark true
  // 568:         :
  // 569:           !do_use_multiple_lines true
  // 570:   :
  // 571:     if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__1 */;
  arguments->slots[1] = frame->slots[13] /* temp__2 */;
  arguments->slots[2] = frame->slots[14] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_220;
}
static void entry__arguments_to_string_218(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_final_remark: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* has_final_remark */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 584: !has_final_remark true
  ((CELL *)frame->slots[0])->contents /* has_final_remark */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_219(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 586: !do_use_multiple_lines true
  ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_213(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // mode: 0
  // argument: 1
  // has_final_remark: 2
  // do_use_multiple_lines: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[5]; /* argument */
  frame->slots[2] = myself->closure.frame->slots[6]; /* has_final_remark */
  frame->slots[3] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 583: mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_214;
}
static void cont__arguments_to_string_214(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 583: ... argument.is_a_remark
  frame->slots[6] /* temp__3 */ = create_closure(entry__arguments_to_string_215, 0);
  // 583: mode == PROC && argument.is_a_remark
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_217;
}
static void entry__arguments_to_string_215(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 583: ... argument.is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_a_remark();
  func = myself->type;
  frame->cont = cont__arguments_to_string_216;
}
static void cont__arguments_to_string_216(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 583: ... argument.is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_217(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 583: ... :
  // 584:   !has_final_remark true
  frame->slots[7] /* temp__4 */ = create_closure(entry__arguments_to_string_218, 0);
  // 585: :
  // 586:   !do_use_multiple_lines true
  frame->slots[8] /* temp__5 */ = create_closure(entry__arguments_to_string_219, 0);
  // 582: if
  // 583:   mode == PROC && argument.is_a_remark:
  // 584:     !has_final_remark true
  // 585:   :
  // 586:     !do_use_multiple_lines true
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  arguments->slots[2] = frame->slots[8] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_196(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 576: ... !do_use_multiple_lines true
  ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_181(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // mode: 0
  // idx: 1
  // total_length: 2
  // str: 3
  // available_width: 4
  // do_use_multiple_lines: 5
  frame->slots[0] = myself->closure.frame->slots[2]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[3]; /* total_length */
  frame->slots[3] = myself->closure.frame->slots[4]; /* str */
  frame->slots[4] = myself->closure.frame->slots[5]; /* available_width */
  frame->slots[5] = myself->closure.frame->slots[6]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 573: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_182;
}
static void cont__arguments_to_string_182(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 573: ... idx > 1
  frame->slots[8] /* temp__3 */ = create_closure(entry__arguments_to_string_183, 0);
  // 573: ... mode == PROC || idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_185;
}
static void entry__arguments_to_string_183(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // idx: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 573: ... idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_184;
}
static void cont__arguments_to_string_184(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 573: ... idx > 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_185(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 573: ... : inc &total_length # separating space
  frame->slots[9] /* temp__4 */ = create_closure(entry__arguments_to_string_186, 0);
  // 573: if mode == PROC || idx > 1: inc &total_length # separating space
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_188;
}
static void entry__arguments_to_string_186(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_length: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 573: ... inc &total_length # separating space
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__arguments_to_string_187;
}
static void cont__arguments_to_string_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_length */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_188(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 574: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_189;
}
static void cont__arguments_to_string_189(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 574: plus &total_length length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_length */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_190;
}
static void cont__arguments_to_string_190(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* total_length */ = arguments->slots[0];
  // 575: ... str .has_prefix. "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* str */;
  arguments->slots[1] = string__2d7981f4e6602bfb;
  result_count = 1;
  myself = get__has_prefix();
  func = myself->type;
  frame->cont = cont__arguments_to_string_191;
}
static void cont__arguments_to_string_191(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 575: ... : plus &total_length 2 # needs parentheses
  frame->slots[7] /* temp__2 */ = create_closure(entry__arguments_to_string_192, 0);
  // 575: if str .has_prefix. "->": plus &total_length 2 # needs parentheses
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_194;
}
static void entry__arguments_to_string_192(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_length: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 575: ... plus &total_length 2 # needs parentheses
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_193;
}
static void cont__arguments_to_string_193(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_length */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_194(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 576: ... total_length > available_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* available_width */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_length */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_195;
}
static void cont__arguments_to_string_195(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 576: ... : !do_use_multiple_lines true
  frame->slots[7] /* temp__2 */ = create_closure(entry__arguments_to_string_196, 0);
  // 576: if total_length > available_width: !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_197(void) {
  allocate_initialized_frame_gc(8, 14);
  // slot allocations:
  // mode: 0
  // idx: 1
  // str: 2
  // total_length: 3
  // available_width: 4
  // argument: 5
  // has_final_remark: 6
  // do_use_multiple_lines: 7
  frame->slots[0] = myself->closure.frame->slots[2]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[4]; /* str */
  frame->slots[3] = myself->closure.frame->slots[3]; /* total_length */
  frame->slots[4] = myself->closure.frame->slots[5]; /* available_width */
  frame->slots[5] = myself->closure.frame->slots[7]; /* argument */
  frame->slots[6] = myself->closure.frame->slots[8]; /* has_final_remark */
  frame->slots[7] = myself->closure.frame->slots[6]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 578: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_198;
}
static void cont__arguments_to_string_198(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 578: ... idx > 1
  frame->slots[11] /* temp__4 */ = create_closure(entry__arguments_to_string_199, 0);
  // 578: ... mode == PROC || idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__3 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_201;
}
static void entry__arguments_to_string_199(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // idx: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 578: ... idx > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* idx */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_200;
}
static void cont__arguments_to_string_200(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 578: ... idx > 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_201(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 578: ... str(1) != ':'
  frame->slots[12] /* temp__5 */ = create_closure(entry__arguments_to_string_202, 0);
  // 578: ... mode == PROC || idx > 1) && str(1) != ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[12] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_206;
}
static void entry__arguments_to_string_202(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 578: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_203;
}
static void cont__arguments_to_string_203(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 578: ... str(1) != ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_204;
}
static void cont__arguments_to_string_204(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 578: ... str(1) != ':'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_205;
}
static void cont__arguments_to_string_205(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 578: ... str(1) != ':'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_206(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 578: ... :
  // 579:   inc &total_length # separating space
  frame->slots[13] /* temp__6 */ = create_closure(entry__arguments_to_string_207, 0);
  // 578: if (mode == PROC || idx > 1) && str(1) != ':':
  // 579:   inc &total_length # separating space
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[13] /* temp__6 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_209;
}
static void entry__arguments_to_string_207(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_length: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* total_length */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 579: inc &total_length # separating space
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_length */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__arguments_to_string_208;
}
static void cont__arguments_to_string_208(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_length */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_209(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 580: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_210;
}
static void cont__arguments_to_string_210(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 580: plus &total_length length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* total_length */;
  arguments->slots[1] = frame->slots[8] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_211;
}
static void cont__arguments_to_string_211(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* total_length */ = arguments->slots[0];
  // 581: ... total_length > available_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* available_width */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* total_length */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_212;
}
static void cont__arguments_to_string_212(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 581: ... :
  // 582:   if
  // 583:     mode == PROC && argument.is_a_remark:
  // 584:       !has_final_remark true
  // 585:     :
  // 586:       !do_use_multiple_lines true
  frame->slots[9] /* temp__2 */ = create_closure(entry__arguments_to_string_213, 0);
  // 581: if total_length > available_width:
  // 582:   if
  // 583:     mode == PROC && argument.is_a_remark:
  // 584:       !has_final_remark true
  // 585:     :
  // 586:       !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_177(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_final_remark: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* has_final_remark */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 567: !has_final_remark true
  ((CELL *)frame->slots[0])->contents /* has_final_remark */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_178(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // do_use_multiple_lines: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 569: !do_use_multiple_lines true
  ((CELL *)frame->slots[0])->contents /* do_use_multiple_lines */ = get__true();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_169(void) {
  allocate_initialized_frame_gc(6, 11);
  // slot allocations:
  // mode: 0
  // idx: 1
  // n: 2
  // argument: 3
  // has_final_remark: 4
  // do_use_multiple_lines: 5
  frame->slots[0] = myself->closure.frame->slots[0]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[2]; /* idx */
  frame->slots[2] = myself->closure.frame->slots[3]; /* n */
  frame->slots[3] = myself->closure.frame->slots[4]; /* argument */
  frame->slots[4] = myself->closure.frame->slots[5]; /* has_final_remark */
  frame->slots[5] = myself->closure.frame->slots[6]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 566: mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_170;
}
static void cont__arguments_to_string_170(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 566: ... idx == n && argument.is_a_remark
  frame->slots[8] /* temp__3 */ = create_closure(entry__arguments_to_string_171, 0);
  // 566: mode == PROC && idx == n && argument.is_a_remark
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_176;
}
static void entry__arguments_to_string_171(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // idx: 0
  // n: 1
  // argument: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[2]; /* n */
  frame->slots[2] = myself->closure.frame->slots[3]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 566: ... idx == n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[1] /* n */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_172;
}
static void cont__arguments_to_string_172(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 566: ... argument.is_a_remark
  frame->slots[5] /* temp__3 */ = create_closure(entry__arguments_to_string_173, 0);
  // 566: ... idx == n && argument.is_a_remark
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_175;
}
static void entry__arguments_to_string_173(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 566: ... argument.is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_a_remark();
  func = myself->type;
  frame->cont = cont__arguments_to_string_174;
}
static void cont__arguments_to_string_174(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 566: ... argument.is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_175(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 566: ... idx == n && argument.is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_176(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 566: ... :
  // 567:   !has_final_remark true
  frame->slots[9] /* temp__4 */ = create_closure(entry__arguments_to_string_177, 0);
  // 568: :
  // 569:   !do_use_multiple_lines true
  frame->slots[10] /* temp__5 */ = create_closure(entry__arguments_to_string_178, 0);
  // 565: if
  // 566:   mode == PROC && idx == n && argument.is_a_remark:
  // 567:     !has_final_remark true
  // 568:   :
  // 569:     !do_use_multiple_lines true
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__4 */;
  arguments->slots[2] = frame->slots[10] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_163(void) {
  allocate_initialized_frame_gc(7, 11);
  // slot allocations:
  // mode: 0
  // str: 1
  // idx: 2
  // n: 3
  // argument: 4
  // has_final_remark: 5
  // do_use_multiple_lines: 6
  frame->slots[0] = myself->closure.frame->slots[3]; /* mode */
  frame->slots[1] = myself->closure.frame->slots[11]; /* str */
  frame->slots[2] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[3] = myself->closure.frame->slots[4]; /* n */
  frame->slots[4] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[5] = myself->closure.frame->slots[8]; /* has_final_remark */
  frame->slots[6] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 564: ... mode == FUNC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* mode */;
  arguments->slots[1] = var._FUNC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_164;
}
static void cont__arguments_to_string_164(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 564: ... str(1) == '@nl;'
  frame->slots[9] /* temp__3 */ = create_closure(entry__arguments_to_string_165, 0);
  // 564: ... mode == FUNC || str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_168;
}
static void entry__arguments_to_string_165(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 564: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_166;
}
static void cont__arguments_to_string_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 564: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_167;
}
static void cont__arguments_to_string_167(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 564: ... str(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_168(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 564: ... :
  // 565:   if
  // 566:     mode == PROC && idx == n && argument.is_a_remark:
  // 567:       !has_final_remark true
  // 568:     :
  // 569:       !do_use_multiple_lines true
  frame->slots[10] /* temp__4 */ = create_closure(entry__arguments_to_string_169, 0);
  // 564: if mode == FUNC || str(1) == '@nl;':
  // 565:   if
  // 566:     mode == PROC && idx == n && argument.is_a_remark:
  // 567:       !has_final_remark true
  // 568:     :
  // 569:       !do_use_multiple_lines true
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_179(void) {
  allocate_initialized_frame_gc(9, 12);
  // slot allocations:
  // idx: 0
  // n: 1
  // mode: 2
  // total_length: 3
  // str: 4
  // available_width: 5
  // do_use_multiple_lines: 6
  // argument: 7
  // has_final_remark: 8
  frame->slots[0] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[1] = myself->closure.frame->slots[4]; /* n */
  frame->slots[2] = myself->closure.frame->slots[3]; /* mode */
  frame->slots[3] = myself->closure.frame->slots[5]; /* total_length */
  frame->slots[4] = myself->closure.frame->slots[11]; /* str */
  frame->slots[5] = myself->closure.frame->slots[9]; /* available_width */
  frame->slots[6] = myself->closure.frame->slots[7]; /* do_use_multiple_lines */
  frame->slots[7] = myself->closure.frame->slots[1]; /* argument */
  frame->slots[8] = myself->closure.frame->slots[8]; /* has_final_remark */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 572: idx < n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* idx */;
  arguments->slots[1] = frame->slots[1] /* n */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_180;
}
static void cont__arguments_to_string_180(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 572: ... :
  // 573:   if mode == PROC || idx > 1: inc &total_length # separating space
  // 574:   plus &total_length length_of(str)
  // 575:   if str .has_prefix. "->": plus &total_length 2 # needs parentheses
  // 576:   if total_length > available_width: !do_use_multiple_lines true
  frame->slots[10] /* temp__2 */ = create_closure(entry__arguments_to_string_181, 0);
  // 577: :
  // 578:   if (mode == PROC || idx > 1) && str(1) != ':':
  // 579:     inc &total_length # separating space
  // 580:   plus &total_length length_of(str)
  // 581:   if total_length > available_width:
  // 582:     if
  // 583:       mode == PROC && argument.is_a_remark:
  // 584:         !has_final_remark true
  // 585:       :
  // 586:         !do_use_multiple_lines true
  frame->slots[11] /* temp__3 */ = create_closure(entry__arguments_to_string_197, 0);
  // 571: if
  // 572:   idx < n:
  // 573:     if mode == PROC || idx > 1: inc &total_length # separating space
  // 574:     plus &total_length length_of(str)
  // 575:     if str .has_prefix. "->": plus &total_length 2 # needs parentheses
  // 576:     if total_length > available_width: !do_use_multiple_lines true
  // 577:   :
  // 578:     if (mode == PROC || idx > 1) && str(1) != ':':
  // 579:       inc &total_length # separating space
  // 580:     plus &total_length length_of(str)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__2 */;
  arguments->slots[2] = frame->slots[11] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_220(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 587: push &strings str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[10])->contents /* strings */;
  arguments->slots[1] = frame->slots[11] /* str */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_221;
}
static void cont__arguments_to_string_221(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[10])->contents /* strings */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  myself = frame->slots[2] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_222(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 588: $$buf ""
  ((CELL *)frame->slots[12])->contents /* buf */ = empty_string;
  // 641: ... : (-> done)
  // 642:   # spread arguments over multiple lines
  // 643:   
  // 644:   $print_strings:
  // 645:     (
  // 646:       from
  // 647:       to
  // 648:       on_first_line = false
  // 649:     )
  // 650:     if
  // ...
  frame->slots[15] /* temp__1 */ = create_closure(entry__arguments_to_string_223, 0);
  // 705: :
  // 706:   #
  // 707:     all arguments on a single line
  // 708:     there might be a line-end-expression
  // 709:     or a remark at the end
  // 710:   
  // 711:   if
  // 712:     has_final_remark:
  // 713:       print_on_one_line 1 n-1
  // 714:       !first n
  // ...
  frame->slots[16] /* temp__2 */ = create_closure(entry__arguments_to_string_306, 0);
  // 640: if
  // 641:   do_use_multiple_lines: (-> done)
  // 642:     # spread arguments over multiple lines
  // 643:     
  // 644:     $print_strings:
  // 645:       (
  // 646:         from
  // 647:         to
  // 648:         on_first_line = false
  // 649:       )
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* do_use_multiple_lines */;
  arguments->slots[1] = frame->slots[15] /* temp__1 */;
  arguments->slots[2] = frame->slots[16] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_311;
}
static void entry__arguments_to_string_307(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // print_on_one_line: 0
  // n: 1
  // first: 2
  // print_on_multiple_lines: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* print_on_one_line */
  frame->slots[1] = myself->closure.frame->slots[2]; /* n */
  frame->slots[2] = myself->closure.frame->slots[3]; /* first */
  frame->slots[3] = myself->closure.frame->slots[4]; /* print_on_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 713: ... n-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* n */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_308;
}
static void cont__arguments_to_string_308(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 713: print_on_one_line 1 n-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = frame->slots[0] /* print_on_one_line */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_309;
}
static void cont__arguments_to_string_309(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 714: !first n
  ((CELL *)frame->slots[2])->contents /* first */ = frame->slots[1] /* n */;
  // 715: print_on_multiple_lines n n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* n */;
  arguments->slots[1] = frame->slots[1] /* n */;
  result_count = frame->caller_result_count;
  myself = frame->slots[3] /* print_on_multiple_lines */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_310(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // print_on_one_line: 0
  // n: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* print_on_one_line */
  frame->slots[1] = myself->closure.frame->slots[2]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 717: print_on_one_line 1 n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[1] /* n */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* print_on_one_line */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_223(void) {
  allocate_initialized_frame_gc(7, 14);
  // slot allocations:
  // done: 0
  // strings: 1
  // print_on_one_line: 2
  // print_on_multiple_lines: 3
  // n: 4
  // mode: 5
  // arguments: 6
  // print_strings: 7
  frame->slots[0] /* done */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[13]; /* print_on_one_line */
  frame->slots[3] = myself->closure.frame->slots[14]; /* print_on_multiple_lines */
  frame->slots[4] = myself->closure.frame->slots[7]; /* n */
  frame->slots[5] = myself->closure.frame->slots[1]; /* mode */
  frame->slots[6] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[7] /* print_strings */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 644: ... :
  // 645:   (
  // 646:     from
  // 647:     to
  // 648:     on_first_line = false
  // 649:   )
  // 650:   if
  // 651:     on_first_line && not(any_of(range(strings from to) contains '@nl;')):
  // 652:       print_on_one_line from to
  // 653:     :
  // ...
  frame->slots[8] /* temp__1 */ = create_closure(entry__arguments_to_string_224, -1);
  // 644: $print_strings:
  // 645:   (
  // 646:     from
  // 647:     to
  // 648:     on_first_line = false
  // 649:   )
  // 650:   if
  // 651:     on_first_line && not(any_of(range(strings from to) contains '@nl;')):
  // 652:       print_on_one_line from to
  // 653:     :
  // ...
  initialize_future(frame->slots[7] /* print_strings */, frame->slots[8] /* temp__1 */);
  // 656: ... n >= 4
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* n */;
  arguments->slots[1] = number__4;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_232;
}
static void entry__arguments_to_string_230(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // print_on_one_line: 0
  // from: 1
  // to: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* print_on_one_line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* from */
  frame->slots[2] = myself->closure.frame->slots[1]; /* to */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 652: print_on_one_line from to
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* from */;
  arguments->slots[1] = frame->slots[2] /* to */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* print_on_one_line */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_231(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // print_on_multiple_lines: 0
  // from: 1
  // to: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* print_on_multiple_lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* from */
  frame->slots[2] = myself->closure.frame->slots[1]; /* to */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 654: print_on_multiple_lines from to
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* from */;
  arguments->slots[1] = frame->slots[2] /* to */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* print_on_multiple_lines */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_224(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // from: 0
  // to: 1
  // on_first_line: 2
  // strings: 3
  // print_on_one_line: 4
  // print_on_multiple_lines: 5
  frame->slots[3] = myself->closure.frame->slots[1]; /* strings */
  frame->slots[4] = myself->closure.frame->slots[2]; /* print_on_one_line */
  frame->slots[5] = myself->closure.frame->slots[3]; /* print_on_multiple_lines */
  if (argument_count < 2) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 3) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[2] /* on_first_line */ = arguments->slots[2];
    case 2:;
  }
  switch(argument_count) {
    case 2: frame->slots[2] /* on_first_line */ = get__false();
  }
  // 651: ... not(any_of(range(strings from to) contains '@nl;'))
  frame->slots[7] /* temp__2 */ = create_closure(entry__arguments_to_string_225, 0);
  // 651: on_first_line && not(any_of(range(strings from to) contains '@nl;'))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* on_first_line */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_229;
}
static void entry__arguments_to_string_225(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // strings: 0
  // from: 1
  // to: 2
  frame->slots[0] = myself->closure.frame->slots[3]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[0]; /* from */
  frame->slots[2] = myself->closure.frame->slots[1]; /* to */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 651: ... range(strings from to)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[1] /* from */;
  arguments->slots[2] = frame->slots[2] /* to */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_226;
}
static void cont__arguments_to_string_226(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 651: ... any_of(range(strings from to) contains '@nl;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = get__contains();
  arguments->slots[2] = character__10;
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_227;
}
static void cont__arguments_to_string_227(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 651: ... not(any_of(range(strings from to) contains '@nl;'))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_228;
}
static void cont__arguments_to_string_228(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 651: ... not(any_of(range(strings from to) contains '@nl;'))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_229(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 651: ... :
  // 652:   print_on_one_line from to
  frame->slots[8] /* temp__3 */ = create_closure(entry__arguments_to_string_230, 0);
  // 653: :
  // 654:   print_on_multiple_lines from to
  frame->slots[9] /* temp__4 */ = create_closure(entry__arguments_to_string_231, 0);
  // 650: if
  // 651:   on_first_line && not(any_of(range(strings from to) contains '@nl;')):
  // 652:     print_on_one_line from to
  // 653:   :
  // 654:     print_on_multiple_lines from to
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  arguments->slots[2] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_232(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 656: ... n >= 4
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_233;
}
static void cont__arguments_to_string_233(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 656: ... :
  // 657:   # try to find argument patterns
  // 658:   
  // 659:   $$pattern ""
  // 660:   for_each strings: (string)
  // 661:     push
  // 662:       &pattern
  // 663:       check_case
  // 664:         string
  // 665:         has_prefix
  // ...
  frame->slots[10] /* temp__3 */ = create_closure(entry__arguments_to_string_234, 0);
  // 656: if n >= 4:
  // 657:   # try to find argument patterns
  // 658:   
  // 659:   $$pattern ""
  // 660:   for_each strings: (string)
  // 661:     push
  // 662:       &pattern
  // 663:       check_case
  // 664:         string
  // 665:         has_prefix
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_293;
}
static void entry__arguments_to_string_277(void) {
  allocate_initialized_frame_gc(8, 11);
  // slot allocations:
  // s: 0
  // print_strings: 1
  // mode: 2
  // rep: 3
  // print_on_multiple_lines: 4
  // pat_len: 5
  // n: 6
  // done: 7
  frame->slots[0] = myself->closure.frame->slots[3]; /* s */
  frame->slots[1] = myself->closure.frame->slots[4]; /* print_strings */
  frame->slots[2] = myself->closure.frame->slots[5]; /* mode */
  frame->slots[3] = myself->closure.frame->slots[1]; /* rep */
  frame->slots[4] = myself->closure.frame->slots[6]; /* print_on_multiple_lines */
  frame->slots[5] = myself->closure.frame->slots[7]; /* pat_len */
  frame->slots[6] = myself->closure.frame->slots[8]; /* n */
  frame->slots[7] = myself->closure.frame->slots[9]; /* done */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 690: ... s > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* s */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_278;
}
static void cont__arguments_to_string_278(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 690: ... : print_strings 1 s-1 mode == PROC
  frame->slots[9] /* temp__2 */ = create_closure(entry__arguments_to_string_279, 0);
  // 690: if s > 1: print_strings 1 s-1 mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_282;
}
static void entry__arguments_to_string_279(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // print_strings: 0
  // s: 1
  // mode: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* print_strings */
  frame->slots[1] = myself->closure.frame->slots[0]; /* s */
  frame->slots[2] = myself->closure.frame->slots[2]; /* mode */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 690: ... s-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* s */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_280;
}
static void cont__arguments_to_string_280(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 690: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_281;
}
static void cont__arguments_to_string_281(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 690: ... print_strings 1 s-1 mode == PROC
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* print_strings */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_282(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 691: ... :
  // 692:   print_on_multiple_lines s s+pat_len-1
  // 693:   plus &s pat_len
  frame->slots[8] /* temp__1 */ = create_closure(entry__arguments_to_string_283, 0);
  // 691: repeat rep:
  // 692:   print_on_multiple_lines s s+pat_len-1
  // 693:   plus &s pat_len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* rep */;
  arguments->slots[1] = frame->slots[8] /* temp__1 */;
  result_count = 0;
  myself = get__repeat();
  func = myself->type;
  frame->cont = cont__arguments_to_string_288;
}
static void entry__arguments_to_string_283(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // print_on_multiple_lines: 0
  // s: 1
  // pat_len: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* print_on_multiple_lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* s */
  frame->slots[2] = myself->closure.frame->slots[5]; /* pat_len */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 692: ... s+pat_len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* s */;
  arguments->slots[1] = frame->slots[2] /* pat_len */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_284;
}
static void cont__arguments_to_string_284(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 692: ... s+pat_len-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_285;
}
static void cont__arguments_to_string_285(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 692: print_on_multiple_lines s s+pat_len-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* s */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 0;
  myself = frame->slots[0] /* print_on_multiple_lines */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_286;
}
static void cont__arguments_to_string_286(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 693: plus &s pat_len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* s */;
  arguments->slots[1] = frame->slots[2] /* pat_len */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_287;
}
static void cont__arguments_to_string_287(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_288(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 694: ... s <= n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* n */;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* s */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_289;
}
static void cont__arguments_to_string_289(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 694: ... s <= n
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_290;
}
static void cont__arguments_to_string_290(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 694: ... : print_on_multiple_lines s n
  frame->slots[10] /* temp__3 */ = create_closure(entry__arguments_to_string_291, 0);
  // 694: if s <= n: print_on_multiple_lines s n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_292;
}
static void entry__arguments_to_string_291(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // print_on_multiple_lines: 0
  // s: 1
  // n: 2
  frame->slots[0] = myself->closure.frame->slots[4]; /* print_on_multiple_lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* s */
  frame->slots[2] = myself->closure.frame->slots[6]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 694: ... print_on_multiple_lines s n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* s */;
  arguments->slots[1] = frame->slots[2] /* n */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* print_on_multiple_lines */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_292(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 695: done
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[7] /* done */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_270(void) {
  allocate_initialized_frame_gc(10, 17);
  // slot allocations:
  // pat: 0
  // rep: 1
  // pattern: 2
  // s: 3
  // print_strings: 4
  // mode: 5
  // print_on_multiple_lines: 6
  // pat_len: 7
  // n: 8
  // done: 9
  // rep_pat: 10
  frame->slots[0] = myself->closure.frame->slots[8]; /* pat */
  frame->slots[1] = myself->closure.frame->slots[9]; /* rep */
  frame->slots[2] = myself->closure.frame->slots[0]; /* pattern */
  frame->slots[3] = myself->closure.frame->slots[1]; /* s */
  frame->slots[4] = myself->closure.frame->slots[4]; /* print_strings */
  frame->slots[5] = myself->closure.frame->slots[5]; /* mode */
  frame->slots[6] = myself->closure.frame->slots[6]; /* print_on_multiple_lines */
  frame->slots[7] = myself->closure.frame->slots[2]; /* pat_len */
  frame->slots[8] = myself->closure.frame->slots[3]; /* n */
  frame->slots[9] = myself->closure.frame->slots[7]; /* done */
  frame->slots[10] /* rep_pat */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 688: $rep_pat dup(pat rep)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* pat */;
  arguments->slots[1] = frame->slots[1] /* rep */;
  result_count = 1;
  myself = get__dup();
  func = myself->type;
  frame->cont = cont__arguments_to_string_271;
}
static void cont__arguments_to_string_271(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[10] /* rep_pat */, arguments->slots[0]);
  // 689: ... length_of(rep_pat)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* rep_pat */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_272;
}
static void cont__arguments_to_string_272(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__5 */ = arguments->slots[0];
  // 689: ... s+length_of(rep_pat)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* s */;
  arguments->slots[1] = frame->slots[15] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_273;
}
static void cont__arguments_to_string_273(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[14] /* temp__4 */ = arguments->slots[0];
  // 689: ... s+length_of(rep_pat)-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[14] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_274;
}
static void cont__arguments_to_string_274(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__3 */ = arguments->slots[0];
  // 689: ... range(pattern s s+length_of(rep_pat)-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* pattern */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* s */;
  arguments->slots[2] = frame->slots[13] /* temp__3 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_275;
}
static void cont__arguments_to_string_275(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__2 */ = arguments->slots[0];
  // 689: ... range(pattern s s+length_of(rep_pat)-1) == rep_pat
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[12] /* temp__2 */;
  arguments->slots[1] = frame->slots[10] /* rep_pat */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_276;
}
static void cont__arguments_to_string_276(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__1 */ = arguments->slots[0];
  // 689: ... :
  // 690:   if s > 1: print_strings 1 s-1 mode == PROC
  // 691:   repeat rep:
  // 692:     print_on_multiple_lines s s+pat_len-1
  // 693:     plus &s pat_len
  // 694:   if s <= n: print_on_multiple_lines s n
  // 695:   done
  frame->slots[16] /* temp__6 */ = create_closure(entry__arguments_to_string_277, 0);
  // 689: if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:   if s > 1: print_strings 1 s-1 mode == PROC
  // 691:   repeat rep:
  // 692:     print_on_multiple_lines s s+pat_len-1
  // 693:     plus &s pat_len
  // 694:   if s <= n: print_on_multiple_lines s n
  // 695:   done
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__1 */;
  arguments->slots[1] = frame->slots[16] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_262(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // pattern: 0
  // s: 1
  // pat_len: 2
  // n: 3
  // print_strings: 4
  // mode: 5
  // print_on_multiple_lines: 6
  // done: 7
  // pat: 8
  // rep: 9
  frame->slots[0] = myself->closure.frame->slots[3]; /* pattern */
  frame->slots[1] = myself->closure.frame->slots[0]; /* s */
  frame->slots[2] = myself->closure.frame->slots[2]; /* pat_len */
  frame->slots[3] = myself->closure.frame->slots[1]; /* n */
  frame->slots[4] = myself->closure.frame->slots[4]; /* print_strings */
  frame->slots[5] = myself->closure.frame->slots[5]; /* mode */
  frame->slots[6] = myself->closure.frame->slots[6]; /* print_on_multiple_lines */
  frame->slots[7] = myself->closure.frame->slots[7]; /* done */
  frame->slots[8] /* pat */ = create_future();
  frame->slots[9] /* rep */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 685: ... s+pat_len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* s */;
  arguments->slots[1] = frame->slots[2] /* pat_len */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_263;
}
static void cont__arguments_to_string_263(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 685: ... s+pat_len-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_264;
}
static void cont__arguments_to_string_264(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 685: $pat range(pattern s s+pat_len-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pattern */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* s */;
  arguments->slots[2] = frame->slots[10] /* temp__1 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_265;
}
static void cont__arguments_to_string_265(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[8] /* pat */, arguments->slots[0]);
  // 686: ... n-s
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* n */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* s */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_266;
}
static void cont__arguments_to_string_266(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__2 */ = arguments->slots[0];
  // 686: ... n-s+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_267;
}
static void cont__arguments_to_string_267(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 686: $rep n-s+1 .div. pat_len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* pat_len */;
  result_count = 1;
  myself = get__div();
  func = myself->type;
  frame->cont = cont__arguments_to_string_268;
}
static void cont__arguments_to_string_268(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[9] /* rep */, arguments->slots[0]);
  // 687: ... rep > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[9] /* rep */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_269;
}
static void cont__arguments_to_string_269(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__1 */ = arguments->slots[0];
  // 687: ... :
  // 688:   $rep_pat dup(pat rep)
  // 689:   if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:     if s > 1: print_strings 1 s-1 mode == PROC
  // 691:     repeat rep:
  // 692:       print_on_multiple_lines s s+pat_len-1
  // 693:       plus &s pat_len
  // 694:     if s <= n: print_on_multiple_lines s n
  // 695:     done
  frame->slots[11] /* temp__2 */ = create_closure(entry__arguments_to_string_270, 0);
  // 687: if rep > 1:
  // 688:   $rep_pat dup(pat rep)
  // 689:   if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:     if s > 1: print_strings 1 s-1 mode == PROC
  // 691:     repeat rep:
  // 692:       print_on_multiple_lines s s+pat_len-1
  // 693:       plus &s pat_len
  // 694:     if s <= n: print_on_multiple_lines s n
  // 695:     done
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_257(void) {
  allocate_initialized_frame_gc(8, 13);
  // slot allocations:
  // s: 0
  // n: 1
  // pat_len: 2
  // pattern: 3
  // print_strings: 4
  // mode: 5
  // print_on_multiple_lines: 6
  // done: 7
  frame->slots[1] = myself->closure.frame->slots[1]; /* n */
  frame->slots[2] = myself->closure.frame->slots[0]; /* pat_len */
  frame->slots[3] = myself->closure.frame->slots[2]; /* pattern */
  frame->slots[4] = myself->closure.frame->slots[3]; /* print_strings */
  frame->slots[5] = myself->closure.frame->slots[4]; /* mode */
  frame->slots[6] = myself->closure.frame->slots[5]; /* print_on_multiple_lines */
  frame->slots[7] = myself->closure.frame->slots[6]; /* done */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* s */ = create_cell_with_contents(arguments->slots[0]);
  // 684: ... s+pat_len
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* s */;
  arguments->slots[1] = frame->slots[2] /* pat_len */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_258;
}
static void cont__arguments_to_string_258(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__4 */ = arguments->slots[0];
  // 684: ... s+pat_len-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__4 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__arguments_to_string_259;
}
static void cont__arguments_to_string_259(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 684: ... s+pat_len-1 <= n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* n */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__arguments_to_string_260;
}
static void cont__arguments_to_string_260(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 684: ... s+pat_len-1 <= n
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_261;
}
static void cont__arguments_to_string_261(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 684: ... :
  // 685:   $pat range(pattern s s+pat_len-1)
  // 686:   $rep n-s+1 .div. pat_len
  // 687:   if rep > 1:
  // 688:     $rep_pat dup(pat rep)
  // 689:     if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:       if s > 1: print_strings 1 s-1 mode == PROC
  // 691:       repeat rep:
  // 692:         print_on_multiple_lines s s+pat_len-1
  // 693:         plus &s pat_len
  // ...
  frame->slots[12] /* temp__5 */ = create_closure(entry__arguments_to_string_262, 0);
  // 684: if s+pat_len-1 <= n:
  // 685:   $pat range(pattern s s+pat_len-1)
  // 686:   $rep n-s+1 .div. pat_len
  // 687:   if rep > 1:
  // 688:     $rep_pat dup(pat rep)
  // 689:     if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:       if s > 1: print_strings 1 s-1 mode == PROC
  // 691:       repeat rep:
  // 692:         print_on_multiple_lines s s+pat_len-1
  // 693:         plus &s pat_len
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_256(void) {
  allocate_initialized_frame_gc(7, 8);
  // slot allocations:
  // pat_len: 0
  // n: 1
  // pattern: 2
  // print_strings: 3
  // mode: 4
  // print_on_multiple_lines: 5
  // done: 6
  frame->slots[1] = myself->closure.frame->slots[0]; /* n */
  frame->slots[2] = myself->closure.frame->slots[1]; /* pattern */
  frame->slots[3] = myself->closure.frame->slots[2]; /* print_strings */
  frame->slots[4] = myself->closure.frame->slots[3]; /* mode */
  frame->slots[5] = myself->closure.frame->slots[4]; /* print_on_multiple_lines */
  frame->slots[6] = myself->closure.frame->slots[5]; /* done */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 683: ... : ($s)
  // 684:   if s+pat_len-1 <= n:
  // 685:     $pat range(pattern s s+pat_len-1)
  // 686:     $rep n-s+1 .div. pat_len
  // 687:     if rep > 1:
  // 688:       $rep_pat dup(pat rep)
  // 689:       if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:         if s > 1: print_strings 1 s-1 mode == PROC
  // 691:         repeat rep:
  // 692:           print_on_multiple_lines s s+pat_len-1
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__arguments_to_string_257, 1);
  // 683: from_to 1 pat_len: ($s)
  // 684:   if s+pat_len-1 <= n:
  // 685:     $pat range(pattern s s+pat_len-1)
  // 686:     $rep n-s+1 .div. pat_len
  // 687:     if rep > 1:
  // 688:       $rep_pat dup(pat rep)
  // 689:       if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:         if s > 1: print_strings 1 s-1 mode == PROC
  // 691:         repeat rep:
  // 692:           print_on_multiple_lines s s+pat_len-1
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[0] /* pat_len */;
  arguments->slots[2] = frame->slots[7] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__from_to();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_255(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // n: 0
  // pattern: 1
  // print_strings: 2
  // mode: 3
  // print_on_multiple_lines: 4
  // done: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* n */
  frame->slots[1] = myself->closure.frame->slots[6]; /* pattern */
  frame->slots[2] = myself->closure.frame->slots[2]; /* print_strings */
  frame->slots[3] = myself->closure.frame->slots[3]; /* mode */
  frame->slots[4] = myself->closure.frame->slots[4]; /* print_on_multiple_lines */
  frame->slots[5] = myself->closure.frame->slots[5]; /* done */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 682: ... : (pat_len)
  // 683:   from_to 1 pat_len: ($s)
  // 684:     if s+pat_len-1 <= n:
  // 685:       $pat range(pattern s s+pat_len-1)
  // 686:       $rep n-s+1 .div. pat_len
  // 687:       if rep > 1:
  // 688:         $rep_pat dup(pat rep)
  // 689:         if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:           if s > 1: print_strings 1 s-1 mode == PROC
  // 691:           repeat rep:
  // ...
  frame->slots[6] /* temp__1 */ = create_closure(entry__arguments_to_string_256, 1);
  // 682: from_to 2 3: (pat_len)
  // 683:   from_to 1 pat_len: ($s)
  // 684:     if s+pat_len-1 <= n:
  // 685:       $pat range(pattern s s+pat_len-1)
  // 686:       $rep n-s+1 .div. pat_len
  // 687:       if rep > 1:
  // 688:         $rep_pat dup(pat rep)
  // 689:         if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:           if s > 1: print_strings 1 s-1 mode == PROC
  // 691:           repeat rep:
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = number__3;
  arguments->slots[2] = frame->slots[6] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__from_to();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_234(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // strings: 0
  // n: 1
  // print_strings: 2
  // mode: 3
  // print_on_multiple_lines: 4
  // done: 5
  // pattern: 6
  frame->slots[0] = myself->closure.frame->slots[1]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[4]; /* n */
  frame->slots[2] = myself->closure.frame->slots[7]; /* print_strings */
  frame->slots[3] = myself->closure.frame->slots[5]; /* mode */
  frame->slots[4] = myself->closure.frame->slots[3]; /* print_on_multiple_lines */
  frame->slots[5] = myself->closure.frame->slots[0]; /* done */
  frame->slots[6] /* pattern */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 659: $$pattern ""
  ((CELL *)frame->slots[6])->contents /* pattern */ = empty_string;
  // 660: ... : (string)
  // 661:   push
  // 662:     &pattern
  // 663:     check_case
  // 664:       string
  // 665:       has_prefix
  // 666:       '#', list(newline INDENTATION '#')
  // 667:       -> 'r'
  // 668:       '$', '!'
  // 669:       -> 'o'
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__arguments_to_string_235, 1);
  // 660: for_each strings: (string)
  // 661:   push
  // 662:     &pattern
  // 663:     check_case
  // 664:       string
  // 665:       has_prefix
  // 666:       '#', list(newline INDENTATION '#')
  // 667:       -> 'r'
  // 668:       '$', '!'
  // 669:       -> 'o'
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__arguments_to_string_254;
}
static void entry__arguments_to_string_235(void) {
  allocate_initialized_frame_gc(2, 11);
  // slot allocations:
  // string: 0
  // pattern: 1
  frame->slots[1] = myself->closure.frame->slots[6]; /* pattern */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 666: ... list(newline INDENTATION '#')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__newline();
  arguments->slots[1] = var._INDENTATION;
  arguments->slots[2] = character__35;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__arguments_to_string_236;
}
static void cont__arguments_to_string_236(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 666: '#', list(newline INDENTATION '#')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__35;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__arguments_to_string_237;
}
static void cont__arguments_to_string_237(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 668: '$', '!'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__36;
  arguments->slots[1] = character__33;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__arguments_to_string_238;
}
static void cont__arguments_to_string_238(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 672: ... alt(':' "->")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__58;
  arguments->slots[1] = string__2d7981f4e6602bfb;
  result_count = 1;
  myself = get__alt();
  func = myself->type;
  frame->cont = cont__arguments_to_string_239;
}
static void cont__arguments_to_string_239(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__7 */ = arguments->slots[0];
  // 672: ... list(newline INDENTATION alt(':' "->"))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__newline();
  arguments->slots[1] = var._INDENTATION;
  arguments->slots[2] = frame->slots[8] /* temp__7 */;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__arguments_to_string_240;
}
static void cont__arguments_to_string_240(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__6 */ = arguments->slots[0];
  // 672: ':', "->", list(newline INDENTATION alt(':' "->"))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__58;
  arguments->slots[1] = string__2d7981f4e6602bfb;
  arguments->slots[2] = frame->slots[7] /* temp__6 */;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__arguments_to_string_241;
}
static void cont__arguments_to_string_241(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 674: ... list(newline INDENTATION '@quot;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__newline();
  arguments->slots[1] = var._INDENTATION;
  arguments->slots[2] = character__34;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__arguments_to_string_242;
}
static void cont__arguments_to_string_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__9 */ = arguments->slots[0];
  // 674: '@quot;', list(newline INDENTATION '@quot;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__34;
  arguments->slots[1] = frame->slots[10] /* temp__9 */;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__arguments_to_string_243;
}
static void cont__arguments_to_string_243(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__8 */ = arguments->slots[0];
  argument_count = 17;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* string */;
  arguments->slots[1] = get__has_prefix();
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  arguments->slots[3] = func__arguments_to_string_244;
  arguments->slots[4] = frame->slots[5] /* temp__4 */;
  arguments->slots[5] = func__arguments_to_string_245;
  arguments->slots[6] = character__38;
  arguments->slots[7] = func__arguments_to_string_246;
  arguments->slots[8] = frame->slots[6] /* temp__5 */;
  arguments->slots[9] = func__arguments_to_string_247;
  arguments->slots[10] = frame->slots[9] /* temp__8 */;
  arguments->slots[11] = func__arguments_to_string_248;
  arguments->slots[12] = character__39;
  arguments->slots[13] = func__arguments_to_string_249;
  arguments->slots[14] = character__10;
  arguments->slots[15] = func__arguments_to_string_250;
  arguments->slots[16] = func__arguments_to_string_251;
  result_count = 1;
  myself = get__check_case();
  func = myself->type;
  frame->cont = cont__arguments_to_string_252;
}
static void entry__arguments_to_string_244(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 667: -> 'r'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__114;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_245(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 669: -> 'o'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__111;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_246(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 671: -> 'O'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__79;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_247(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 673: -> 'b'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__98;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_248(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 675: -> 's'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__115;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_249(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 677: -> 'c'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__99;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_250(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 679: -> 'm'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__109;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_251(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 680: -> 'i'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__105;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_252(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 661: push
  // 662:   &pattern
  // 663:   check_case
  // 664:     string
  // 665:     has_prefix
  // 666:     '#', list(newline INDENTATION '#')
  // 667:     -> 'r'
  // 668:     '$', '!'
  // 669:     -> 'o'
  // 670:     '&'
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pattern */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__arguments_to_string_253;
}
static void cont__arguments_to_string_253(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pattern */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_254(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 681: ... :
  // 682:   from_to 2 3: (pat_len)
  // 683:     from_to 1 pat_len: ($s)
  // 684:       if s+pat_len-1 <= n:
  // 685:         $pat range(pattern s s+pat_len-1)
  // 686:         $rep n-s+1 .div. pat_len
  // 687:         if rep > 1:
  // 688:           $rep_pat dup(pat rep)
  // 689:           if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:             if s > 1: print_strings 1 s-1 mode == PROC
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__arguments_to_string_255, 0);
  // 681: do:
  // 682:   from_to 2 3: (pat_len)
  // 683:     from_to 1 pat_len: ($s)
  // 684:       if s+pat_len-1 <= n:
  // 685:         $pat range(pattern s s+pat_len-1)
  // 686:         $rep n-s+1 .div. pat_len
  // 687:         if rep > 1:
  // 688:           $rep_pat dup(pat rep)
  // 689:           if range(pattern s s+length_of(rep_pat)-1) == rep_pat:
  // 690:             if s > 1: print_strings 1 s-1 mode == PROC
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_293(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 698: arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[6] /* arguments */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_294;
}
static void cont__arguments_to_string_294(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 698: arguments(1).is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__is_a_remark();
  func = myself->type;
  frame->cont = cont__arguments_to_string_295;
}
static void cont__arguments_to_string_295(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 699: not(any_of(range(arguments 2 n) is_a_remark))
  frame->slots[11] /* temp__4 */ = create_closure(entry__arguments_to_string_296, 0);
  // 697: &&
  // 698:   arguments(1).is_a_remark
  // 699:   not(any_of(range(arguments 2 n) is_a_remark))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_300;
}
static void entry__arguments_to_string_296(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // arguments: 0
  // n: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[4]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 699: ... range(arguments 2 n)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[1] /* n */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__arguments_to_string_297;
}
static void cont__arguments_to_string_297(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 699: ... any_of(range(arguments 2 n) is_a_remark)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = get__is_a_remark();
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__arguments_to_string_298;
}
static void cont__arguments_to_string_298(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 699: not(any_of(range(arguments 2 n) is_a_remark))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_299;
}
static void cont__arguments_to_string_299(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 699: not(any_of(range(arguments 2 n) is_a_remark))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_300(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 700: :
  // 701:   print_strings 1 1 mode == PROC
  // 702:   print_on_multiple_lines 2 n
  frame->slots[12] /* temp__5 */ = create_closure(entry__arguments_to_string_301, 0);
  // 703: :
  // 704:   print_strings 1 n
  frame->slots[13] /* temp__6 */ = create_closure(entry__arguments_to_string_304, 0);
  // 696: if
  // 697:   &&
  // 698:     arguments(1).is_a_remark
  // 699:     not(any_of(range(arguments 2 n) is_a_remark))
  // 700:   :
  // 701:     print_strings 1 1 mode == PROC
  // 702:     print_on_multiple_lines 2 n
  // 703:   :
  // 704:     print_strings 1 n
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[12] /* temp__5 */;
  arguments->slots[2] = frame->slots[13] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_305;
}
static void entry__arguments_to_string_301(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // print_strings: 0
  // mode: 1
  // print_on_multiple_lines: 2
  // n: 3
  frame->slots[0] = myself->closure.frame->slots[7]; /* print_strings */
  frame->slots[1] = myself->closure.frame->slots[5]; /* mode */
  frame->slots[2] = myself->closure.frame->slots[3]; /* print_on_multiple_lines */
  frame->slots[3] = myself->closure.frame->slots[4]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 701: ... mode == PROC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mode */;
  arguments->slots[1] = var._PROC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_302;
}
static void cont__arguments_to_string_302(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 701: print_strings 1 1 mode == PROC
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = frame->slots[0] /* print_strings */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_303;
}
static void cont__arguments_to_string_303(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 702: print_on_multiple_lines 2 n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__2;
  arguments->slots[1] = frame->slots[3] /* n */;
  result_count = frame->caller_result_count;
  myself = frame->slots[2] /* print_on_multiple_lines */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__arguments_to_string_304(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // print_strings: 0
  // n: 1
  frame->slots[0] = myself->closure.frame->slots[7]; /* print_strings */
  frame->slots[1] = myself->closure.frame->slots[4]; /* n */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 704: print_strings 1 n
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[1] /* n */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* print_strings */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_305(void) {
  myself = frame->slots[0] /* done */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_306(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // has_final_remark: 0
  // print_on_one_line: 1
  // n: 2
  // first: 3
  // print_on_multiple_lines: 4
  frame->slots[0] = myself->closure.frame->slots[10]; /* has_final_remark */
  frame->slots[1] = myself->closure.frame->slots[13]; /* print_on_one_line */
  frame->slots[2] = myself->closure.frame->slots[7]; /* n */
  frame->slots[3] = myself->closure.frame->slots[6]; /* first */
  frame->slots[4] = myself->closure.frame->slots[14]; /* print_on_multiple_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 712: ... :
  // 713:   print_on_one_line 1 n-1
  // 714:   !first n
  // 715:   print_on_multiple_lines n n
  frame->slots[5] /* temp__1 */ = create_closure(entry__arguments_to_string_307, 0);
  // 716: :
  // 717:   print_on_one_line 1 n
  frame->slots[6] /* temp__2 */ = create_closure(entry__arguments_to_string_310, 0);
  // 711: if
  // 712:   has_final_remark:
  // 713:     print_on_one_line 1 n-1
  // 714:     !first n
  // 715:     print_on_multiple_lines n n
  // 716:   :
  // 717:     print_on_one_line 1 n
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* has_final_remark */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__arguments_to_string_311(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 718: ... mode == FUNC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mode */;
  arguments->slots[1] = var._FUNC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_312;
}
static void cont__arguments_to_string_312(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[16] /* temp__2 */ = arguments->slots[0];
  // 718: ... buf(1) != '@nl;' && arguments(-1).is_a_remark
  frame->slots[17] /* temp__3 */ = create_closure(entry__arguments_to_string_313, 0);
  // 718: ... mode == FUNC && buf(1) != '@nl;' && arguments(-1).is_a_remark
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* temp__2 */;
  arguments->slots[1] = frame->slots[17] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_322;
}
static void entry__arguments_to_string_313(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // buf: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[12]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 718: ... buf(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* buf */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_314;
}
static void cont__arguments_to_string_314(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 718: ... buf(1) != '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_315;
}
static void cont__arguments_to_string_315(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 718: ... buf(1) != '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__arguments_to_string_316;
}
static void cont__arguments_to_string_316(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 718: ... arguments(-1).is_a_remark
  frame->slots[6] /* temp__5 */ = create_closure(entry__arguments_to_string_317, 0);
  // 718: ... buf(1) != '@nl;' && arguments(-1).is_a_remark
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__arguments_to_string_321;
}
static void entry__arguments_to_string_317(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 718: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__arguments_to_string_318;
}
static void cont__arguments_to_string_318(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 718: ... arguments(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_319;
}
static void cont__arguments_to_string_319(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 718: ... arguments(-1).is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_a_remark();
  func = myself->type;
  frame->cont = cont__arguments_to_string_320;
}
static void cont__arguments_to_string_320(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 718: ... arguments(-1).is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_321(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 718: ... buf(1) != '@nl;' && arguments(-1).is_a_remark
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_322(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  // 718: ... :
  // 719:   !buf string('@nl;' spaces(expression_indent) buf)
  frame->slots[18] /* temp__4 */ = create_closure(entry__arguments_to_string_323, 0);
  // 718: if mode == FUNC && buf(1) != '@nl;' && arguments(-1).is_a_remark:
  // 719:   !buf string('@nl;' spaces(expression_indent) buf)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[18] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_326;
}
static void entry__arguments_to_string_323(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[12]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 719: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__arguments_to_string_324;
}
static void cont__arguments_to_string_324(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 719: !buf string('@nl;' spaces(expression_indent) buf)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__arguments_to_string_325;
}
static void cont__arguments_to_string_325(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_326(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 721: mode == FUNC
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* mode */;
  arguments->slots[1] = var._FUNC;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_327;
}
static void cont__arguments_to_string_327(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[16] /* temp__2 */ = arguments->slots[0];
  // 721: ... buf.is_empty || buf(1) == ':' || buf(1) == '@nl;'
  frame->slots[17] /* temp__3 */ = create_closure(entry__arguments_to_string_328, 0);
  // 721: mode == FUNC || buf.is_empty || buf(1) == ':' || buf(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[16] /* temp__2 */;
  arguments->slots[1] = frame->slots[17] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_338;
}
static void entry__arguments_to_string_328(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[12]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 721: ... buf.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__arguments_to_string_329;
}
static void cont__arguments_to_string_329(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 721: ... buf(1) == ':' || buf(1) == '@nl;'
  frame->slots[3] /* temp__3 */ = create_closure(entry__arguments_to_string_330, 0);
  // 721: ... buf.is_empty || buf(1) == ':' || buf(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_337;
}
static void entry__arguments_to_string_330(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 721: ... buf(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* buf */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_331;
}
static void cont__arguments_to_string_331(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 721: ... buf(1) == ':'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__58;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_332;
}
static void cont__arguments_to_string_332(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 721: ... buf(1) == '@nl;'
  frame->slots[4] /* temp__4 */ = create_closure(entry__arguments_to_string_333, 0);
  // 721: ... buf(1) == ':' || buf(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__arguments_to_string_336;
}
static void entry__arguments_to_string_333(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 721: ... buf(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* buf */;
  func = myself->type;
  frame->cont = cont__arguments_to_string_334;
}
static void cont__arguments_to_string_334(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 721: ... buf(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__arguments_to_string_335;
}
static void cont__arguments_to_string_335(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 721: ... buf(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_336(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 721: ... buf(1) == ':' || buf(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_337(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 721: ... buf.is_empty || buf(1) == ':' || buf(1) == '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_338(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[15] /* temp__1 */ = arguments->slots[0];
  // 722: -> buf
  frame->slots[18] /* temp__4 */ = create_closure(entry__arguments_to_string_339, 0);
  // 723: -> put(buf ' ')
  frame->slots[19] /* temp__5 */ = create_closure(entry__arguments_to_string_340, 0);
  // 720: if
  // 721:   mode == FUNC || buf.is_empty || buf(1) == ':' || buf(1) == '@nl;'
  // 722:   -> buf
  // 723:   -> put(buf ' ')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[15] /* temp__1 */;
  arguments->slots[1] = frame->slots[18] /* temp__4 */;
  arguments->slots[2] = frame->slots[19] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__arguments_to_string_342;
}
static void entry__arguments_to_string_339(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[12]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 722: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__arguments_to_string_340(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[12]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 723: ... put(buf ' ')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__arguments_to_string_341;
}
static void cont__arguments_to_string_341(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 723: -> put(buf ' ')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__arguments_to_string_342(void) {
  myself = frame->slots[3] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_3(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // return__1: 0
  // outer_line_end_expression_width: 1
  // indent: 2
  // self: 3
  // arguments: 4
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* outer_line_end_expression_width */
  frame->slots[2] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[0]; /* self */
  define__expression_indent(create_future());
  define__line_end_expression_width(create_future());
  frame->slots[4] /* arguments */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 732: outer_line_end_expression_width > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = frame->slots[1] /* outer_line_end_expression_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_4;
}
static void cont__compiler__call__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 733: -> indent
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__call__to_string_5, 0);
  // 734: -> indent+2
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__call__to_string_6, 0);
  // 730: %expression_indent
  // 731:   if
  // 732:     outer_line_end_expression_width > 0
  // 733:     -> indent
  // 734:     -> indent+2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_8;
}
static void entry__compiler__call__to_string_5(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 733: -> indent
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_6(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // indent: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 734: ... indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_7;
}
static void cont__compiler__call__to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 734: -> indent+2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__call__to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 736: ... line_width-indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[2] /* indent */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_9;
}
static void cont__compiler__call__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 736: %line_end_expression_width line_width-indent-2 # "->"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_10;
}
static void cont__compiler__call__to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 737: $arguments arguments_to_string(self PROC line_end_expression_width)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* self */;
  arguments->slots[1] = var._PROC;
  arguments->slots[2] = get__line_end_expression_width();
  result_count = 1;
  myself = var._arguments_to_string;
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_11;
}
static void cont__compiler__call__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* arguments */, arguments->slots[0]);
  // 738: ... string("->" arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6602bfb;
  arguments->slots[1] = frame->slots[4] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_12;
}
static void cont__compiler__call__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 738: -> string("->" arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_13(void) {
  allocate_initialized_frame_gc(3, 8);
  // slot allocations:
  // return__3: 0
  // indent: 1
  // self: 2
  // functor: 3
  // this_is_a_definition: 4
  // arguments: 5
  frame->slots[0] /* return__3 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  define__expression_indent(create_future());
  frame->slots[3] /* functor */ = create_cell();
  frame->slots[4] /* this_is_a_definition */ = create_cell();
  define__line_end_expression_width(create_future());
  frame->slots[5] /* arguments */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 740: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_14;
}
static void cont__compiler__call__to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 741: $$functor undefined
  ((CELL *)frame->slots[3])->contents /* functor */ = get__undefined();
  // 742: $$this_is_a_definition false
  ((CELL *)frame->slots[4])->contents /* this_is_a_definition */ = get__false();
  // 743: ... :
  // 744:   %line_width UNLIMITED # force inline output
  // 745:   if
  // 746:     self.is_an_assignment:
  // 747:       !functor arguments_of(self)(1)
  // 748:       range &self.arguments_of 2 -1
  // 749:       !this_is_a_definition functor.is_a_definition
  // 750:       argument_to_string &functor
  // 751:       $source arguments_of(self)(1)
  // 752:       cond
  // ...
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__call__to_string_15, 0);
  // 743: do:
  // 744:   %line_width UNLIMITED # force inline output
  // 745:   if
  // 746:     self.is_an_assignment:
  // 747:       !functor arguments_of(self)(1)
  // 748:       range &self.arguments_of 2 -1
  // 749:       !this_is_a_definition functor.is_a_definition
  // 750:       argument_to_string &functor
  // 751:       $source arguments_of(self)(1)
  // 752:       cond
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_40;
}
static void entry__compiler__call__to_string_15(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // return__2: 0
  // self: 1
  // functor: 2
  // this_is_a_definition: 3
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor */
  frame->slots[3] = myself->closure.frame->slots[4]; /* this_is_a_definition */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 746: self.is_an_assignment
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__is_an_assignment();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_16;
}
static void cont__compiler__call__to_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 746: ... :
  // 747:   !functor arguments_of(self)(1)
  // 748:   range &self.arguments_of 2 -1
  // 749:   !this_is_a_definition functor.is_a_definition
  // 750:   argument_to_string &functor
  // 751:   $source arguments_of(self)(1)
  // 752:   cond
  // 753:     -> source.is_a_body: !statement_tag ALWAYS
  // 754:     -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  // 755:     -> source.is_a_polymorphic_function_constant:
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__call__to_string_17, 0);
  // 757: :
  // 758:   !functor functor_of(self).to_string
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__call__to_string_36, 0);
  // 745: if
  // 746:   self.is_an_assignment:
  // 747:     !functor arguments_of(self)(1)
  // 748:     range &self.arguments_of 2 -1
  // 749:     !this_is_a_definition functor.is_a_definition
  // 750:     argument_to_string &functor
  // 751:     $source arguments_of(self)(1)
  // 752:     cond
  // 753:       -> source.is_a_body: !statement_tag ALWAYS
  // 754:       -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_39;
}
static void entry__compiler__call__to_string_35(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 756: !statement_tag POLYMORPHIC_FUNCTION
  set__statement_tag(var._POLYMORPHIC_FUNCTION);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_32(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 754: ... !statement_tag UNIQUE
  set__statement_tag(var._UNIQUE);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_29(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 753: ... !statement_tag ALWAYS
  set__statement_tag(var._ALWAYS);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_27(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 753: ... source.is_a_body
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_body();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_28;
}
static void cont__compiler__call__to_string_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 753: -> source.is_a_body: !statement_tag ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__call__to_string_29;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_30(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 754: ... source.is_a_unique_item_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_unique_item_constant();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_31;
}
static void cont__compiler__call__to_string_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 754: -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__call__to_string_32;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_33(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // source: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* source */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 755: ... source.is_a_polymorphic_function_constant
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* source */;
  result_count = 1;
  myself = get__is_a_polymorphic_function_constant();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_34;
}
static void cont__compiler__call__to_string_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 755: -> source.is_a_polymorphic_function_constant:
  // 756:   !statement_tag POLYMORPHIC_FUNCTION
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__call__to_string_35;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_17(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // functor: 0
  // self: 1
  // this_is_a_definition: 2
  // source: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* this_is_a_definition */
  frame->slots[3] /* source */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 747: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_18;
}
static void cont__compiler__call__to_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 747: !functor arguments_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__1 */;
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_19;
}
static void cont__compiler__call__to_string_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* functor */ = arguments->slots[0];
  // 748: ... self.arguments_of
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_20;
}
static void cont__compiler__call__to_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 748: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_21;
}
static void cont__compiler__call__to_string_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 748: range &self.arguments_of 2 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_22;
}
static void cont__compiler__call__to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 748: ... &self.arguments_of
  {
    NODE *temp = clone_object_and_attributes(((CELL *)frame->slots[1])->contents /* self */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__arguments_of, frame->slots[6] /* temp__3 */);
    ((CELL *)frame->slots[1])->contents /* self */ = temp;

  }
  // 749: !this_is_a_definition functor.is_a_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  result_count = 1;
  myself = get__is_a_definition();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_23;
}
static void cont__compiler__call__to_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* this_is_a_definition */ = arguments->slots[0];
  // 750: argument_to_string &functor
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor */;
  result_count = 1;
  myself = var._argument_to_string;
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_24;
}
static void cont__compiler__call__to_string_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* functor */ = arguments->slots[0];
  // 751: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_25;
}
static void cont__compiler__call__to_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 751: $source arguments_of(self)(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[4] /* temp__1 */;
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_26;
}
static void cont__compiler__call__to_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* source */, arguments->slots[0]);
  // 753: -> source.is_a_body: !statement_tag ALWAYS
  frame->slots[4] /* temp__1 */ = create_closure(entry__compiler__call__to_string_27, 0);
  // 754: -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__call__to_string_30, 0);
  // 755: -> source.is_a_polymorphic_function_constant:
  // 756:   !statement_tag POLYMORPHIC_FUNCTION
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__call__to_string_33, 0);
  // 752: cond
  // 753:   -> source.is_a_body: !statement_tag ALWAYS
  // 754:   -> source.is_a_unique_item_constant: !statement_tag UNIQUE
  // 755:   -> source.is_a_polymorphic_function_constant:
  // 756:     !statement_tag POLYMORPHIC_FUNCTION
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__call__to_string_36(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 758: ... functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_37;
}
static void cont__compiler__call__to_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 758: !functor functor_of(self).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_38;
}
static void cont__compiler__call__to_string_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* functor */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__call__to_string_39(void) {
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__call__to_string_40(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 759: ... line_width-indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_41;
}
static void cont__compiler__call__to_string_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 759: ... length_of(functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* functor */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_42;
}
static void cont__compiler__call__to_string_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 759: %line_end_expression_width line_width-indent-length_of(functor)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_43;
}
static void cont__compiler__call__to_string_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 760: $arguments arguments_to_string(self PROC line_end_expression_width)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* self */;
  arguments->slots[1] = var._PROC;
  arguments->slots[2] = get__line_end_expression_width();
  result_count = 1;
  myself = var._arguments_to_string;
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_44;
}
static void cont__compiler__call__to_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* arguments */, arguments->slots[0]);
  // 761: ... arguments .contains. '@nl;'
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__call__to_string_45, 0);
  // 761: ... this_is_a_definition && arguments .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* this_is_a_definition */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_47;
}
static void entry__compiler__call__to_string_45(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 761: ... arguments .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_46;
}
static void cont__compiler__call__to_string_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 761: ... arguments .contains. '@nl;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__call__to_string_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 761: if this_is_a_definition && arguments .contains. '@nl;':
  // 762:   !statement_tag ALWAYS
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = func__compiler__call__to_string_48;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_49;
}
static void entry__compiler__call__to_string_48(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 762: !statement_tag ALWAYS
  set__statement_tag(var._ALWAYS);
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__call__to_string_49(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 763: ... string(functor arguments)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* functor */;
  arguments->slots[1] = frame->slots[5] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_50;
}
static void cont__compiler__call__to_string_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 763: -> string(functor arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  myself = frame->slots[0] /* return__3 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__call__to_string_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // indent: 1
  // outer_line_end_expression_width: 2
  // _define $indent expression_indent
  frame->slots[1] /* indent */ = get__expression_indent();
  // _define $outer_line_end_expression_width line_end_expression_width
  frame->slots[2] /* outer_line_end_expression_width */ = get__line_end_expression_width();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* self */ = create_cell_with_contents(arguments->slots[0]);
  // 729: self.is_a_return
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* self */;
  result_count = 1;
  myself = get__is_a_return();
  func = myself->type;
  frame->cont = cont__compiler__call__to_string_2;
}
static void cont__compiler__call__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 729: ... :
  // 730:   %expression_indent
  // 731:     if
  // 732:       outer_line_end_expression_width > 0
  // 733:       -> indent
  // 734:       -> indent+2
  // 735:   
  // 736:   %line_end_expression_width line_width-indent-2 # "->"
  // 737:   $arguments arguments_to_string(self PROC line_end_expression_width)
  // 738:   -> string("->" arguments)
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__call__to_string_3, 0);
  // 739: :
  // 740:   %expression_indent indent+2
  // 741:   $$functor undefined
  // 742:   $$this_is_a_definition false
  // 743:   do:
  // 744:     %line_width UNLIMITED # force inline output
  // 745:     if
  // 746:       self.is_an_assignment:
  // 747:         !functor arguments_of(self)(1)
  // 748:         range &self.arguments_of 2 -1
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__call__to_string_13, 0);
  // 728: if
  // 729:   self.is_a_return:
  // 730:     %expression_indent
  // 731:       if
  // 732:         outer_line_end_expression_width > 0
  // 733:         -> indent
  // 734:         -> indent+2
  // 735:     
  // 736:     %line_end_expression_width line_width-indent-2 # "->"
  // 737:     $arguments arguments_to_string(self PROC line_end_expression_width)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__definition_to_string_1(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // prefix: 0
  // definition: 1
  // buf: 2
  frame->slots[2] /* buf */ = create_cell();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 766: $$buf ""
  ((CELL *)frame->slots[2])->contents /* buf */ = empty_string;
  // 767: ... parameter_kind_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__definition_to_string_2;
}
static void cont__definition_to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 767: ... parameter_kind_of(definition) == CONTINUATION_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__definition_to_string_3;
}
static void cont__definition_to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 767: ... : append &buf "-> "
  frame->slots[5] /* temp__3 */ = create_closure(entry__definition_to_string_4, 0);
  // 767: if parameter_kind_of(definition) == CONTINUATION_PARAMETER: append &buf "-> "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__definition_to_string_7;
}
static void entry__definition_to_string_4(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 767: ... append &buf "-> "
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = string__fa733015fd96bec;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__definition_to_string_6;
}
static void cont__definition_to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__definition_to_string_7(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 768: append &buf prefix
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  arguments->slots[1] = frame->slots[0] /* prefix */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__definition_to_string_8;
}
static void cont__definition_to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 769: ... identifier_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__definition_to_string_9;
}
static void cont__definition_to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 769: ... identifier_of(definition).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__definition_to_string_10;
}
static void cont__definition_to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 769: append &buf identifier_of(definition).to_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__definition_to_string_11;
}
static void cont__definition_to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 770: ... definition.is_a_parameter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__is_a_parameter();
  func = myself->type;
  frame->cont = cont__definition_to_string_12;
}
static void cont__definition_to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 770: ... :
  // 771:   if parameter_kind_of(definition) == MYSELF_PARAMETER: push &buf '^'
  // 772:   cond
  // 773:     -> definition.is_an_optional_item:
  // 774:       if
  // 775:         default_value_of(definition).is_defined:
  // 776:           write_to &buf " = " default_value_of(definition)
  // 777:         :
  // 778:           push &buf '?'
  // 779:     -> definition.is_an_expanded_item: push &buf '*'
  frame->slots[4] /* temp__2 */ = create_closure(entry__definition_to_string_13, 0);
  // 770: if definition.is_a_parameter:
  // 771:   if parameter_kind_of(definition) == MYSELF_PARAMETER: push &buf '^'
  // 772:   cond
  // 773:     -> definition.is_an_optional_item:
  // 774:       if
  // 775:         default_value_of(definition).is_defined:
  // 776:           write_to &buf " = " default_value_of(definition)
  // 777:         :
  // 778:           push &buf '?'
  // 779:     -> definition.is_an_expanded_item: push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__definition_to_string_33;
}
static void entry__definition_to_string_31(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 779: ... push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__42;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__definition_to_string_32;
}
static void cont__definition_to_string_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__definition_to_string_24(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // definition: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* definition */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 776: ... default_value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* definition */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__definition_to_string_25;
}
static void cont__definition_to_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 776: write_to &buf " = " default_value_of(definition)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = string__fa730415fc16bec;
  arguments->slots[2] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__definition_to_string_26;
}
static void cont__definition_to_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__definition_to_string_27(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 778: push &buf '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__63;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__definition_to_string_28;
}
static void cont__definition_to_string_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__definition_to_string_21(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 775: default_value_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__default_value_of();
  func = myself->type;
  frame->cont = cont__definition_to_string_22;
}
static void cont__definition_to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 775: default_value_of(definition).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__definition_to_string_23;
}
static void cont__definition_to_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 775: ... :
  // 776:   write_to &buf " = " default_value_of(definition)
  frame->slots[4] /* temp__3 */ = create_closure(entry__definition_to_string_24, 0);
  // 777: :
  // 778:   push &buf '?'
  frame->slots[5] /* temp__4 */ = create_closure(entry__definition_to_string_27, 0);
  // 774: if
  // 775:   default_value_of(definition).is_defined:
  // 776:     write_to &buf " = " default_value_of(definition)
  // 777:   :
  // 778:     push &buf '?'
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__definition_to_string_19(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 773: ... definition.is_an_optional_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_an_optional_item();
  func = myself->type;
  frame->cont = cont__definition_to_string_20;
}
static void cont__definition_to_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 773: ... :
  // 774:   if
  // 775:     default_value_of(definition).is_defined:
  // 776:       write_to &buf " = " default_value_of(definition)
  // 777:     :
  // 778:       push &buf '?'
  frame->slots[3] /* temp__2 */ = create_closure(entry__definition_to_string_21, 0);
  // 773: -> definition.is_an_optional_item:
  // 774:   if
  // 775:     default_value_of(definition).is_defined:
  // 776:       write_to &buf " = " default_value_of(definition)
  // 777:     :
  // 778:       push &buf '?'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__definition_to_string_29(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 779: ... definition.is_an_expanded_item
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__is_an_expanded_item();
  func = myself->type;
  frame->cont = cont__definition_to_string_30;
}
static void cont__definition_to_string_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 779: ... : push &buf '*'
  frame->slots[3] /* temp__2 */ = create_closure(entry__definition_to_string_31, 0);
  // 779: -> definition.is_an_expanded_item: push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__definition_to_string_13(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // definition: 0
  // buf: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* definition */
  frame->slots[1] = myself->closure.frame->slots[2]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 771: ... parameter_kind_of(definition)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* definition */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__definition_to_string_14;
}
static void cont__definition_to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 771: ... parameter_kind_of(definition) == MYSELF_PARAMETER
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = get__MYSELF_PARAMETER();
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__definition_to_string_15;
}
static void cont__definition_to_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 771: ... : push &buf '^'
  frame->slots[4] /* temp__3 */ = create_closure(entry__definition_to_string_16, 0);
  // 771: if parameter_kind_of(definition) == MYSELF_PARAMETER: push &buf '^'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__definition_to_string_18;
}
static void entry__definition_to_string_16(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 771: ... push &buf '^'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__94;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__definition_to_string_17;
}
static void cont__definition_to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__definition_to_string_18(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 773: -> definition.is_an_optional_item:
  // 774:   if
  // 775:     default_value_of(definition).is_defined:
  // 776:       write_to &buf " = " default_value_of(definition)
  // 777:     :
  // 778:       push &buf '?'
  frame->slots[2] /* temp__1 */ = create_closure(entry__definition_to_string_19, 0);
  // 779: -> definition.is_an_expanded_item: push &buf '*'
  frame->slots[3] /* temp__2 */ = create_closure(entry__definition_to_string_29, 0);
  // 772: cond
  // 773:   -> definition.is_an_optional_item:
  // 774:     if
  // 775:       default_value_of(definition).is_defined:
  // 776:         write_to &buf " = " default_value_of(definition)
  // 777:       :
  // 778:         push &buf '?'
  // 779:   -> definition.is_an_expanded_item: push &buf '*'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__definition_to_string_33(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 780: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_static_single__to_string_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // prefix: 1
  // buf: 2
  frame->slots[1] /* prefix */ = create_future();
  frame->slots[2] /* buf */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 788: parameter_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_2;
}
static void cont__compiler__define_static_single__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 789: IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__IN_PARAMETER();
  arguments->slots[1] = get__MYSELF_PARAMETER();
  arguments->slots[2] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_3;
}
static void cont__compiler__define_static_single__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 786: $prefix
  // 787:   case
  // 788:     parameter_kind_of(self)
  // 789:     IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  // 790:     -> ""
  // 791:     -> "$"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = func__compiler__define_static_single__to_string_4;
  arguments->slots[3] = func__compiler__define_static_single__to_string_5;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_7;
}
static void entry__compiler__define_static_single__to_string_4(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 790: -> ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_static_single__to_string_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 791: -> "$"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc5;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_static_single__to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* prefix */, arguments->slots[0]);
  // 793: definition_to_string $$buf prefix self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._definition_to_string;
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_8;
}
static void cont__compiler__define_static_single__to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* buf */ = arguments->slots[0];
  // 794: ... attribute_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__attribute_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_9;
}
static void cont__compiler__define_static_single__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 795: ... :
  // 796:   write_to &buf '.' attribute_of(self)
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__define_static_single__to_string_10, 0);
  // 797: ... :
  // 798:   push &buf '/'
  // 799:   if attribute_of(self).is_defined: write_to &buf attribute_of(self)
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__define_static_single__to_string_13, 0);
  // 794: case attribute_kind_of(self)
  // 795:   ATTRIBUTE_KIND:
  // 796:     write_to &buf '.' attribute_of(self)
  // 797:   METHOD_KIND:
  // 798:     push &buf '/'
  // 799:     if attribute_of(self).is_defined: write_to &buf attribute_of(self)
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = get__ATTRIBUTE_KIND();
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  arguments->slots[3] = get__METHOD_KIND();
  arguments->slots[4] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_20;
}
static void entry__compiler__define_static_single__to_string_17(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[1]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 799: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_18;
}
static void cont__compiler__define_static_single__to_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 799: ... write_to &buf attribute_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_19;
}
static void cont__compiler__define_static_single__to_string_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_static_single__to_string_10(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 796: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_11;
}
static void cont__compiler__define_static_single__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 796: write_to &buf '.' attribute_of(self)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__46;
  arguments->slots[2] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_12;
}
static void cont__compiler__define_static_single__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_static_single__to_string_13(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // buf: 0
  // self: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 798: push &buf '/'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__47;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_14;
}
static void cont__compiler__define_static_single__to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 799: ... attribute_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__attribute_of();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_15;
}
static void cont__compiler__define_static_single__to_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 799: ... attribute_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__define_static_single__to_string_16;
}
static void cont__compiler__define_static_single__to_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 799: ... : write_to &buf attribute_of(self)
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__define_static_single__to_string_17, 0);
  // 799: if attribute_of(self).is_defined: write_to &buf attribute_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__define_static_single__to_string_20(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 800: add_indented_remark self buf
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* buf */;
  result_count = frame->caller_result_count;
  myself = var._add_indented_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_static_multi__to_string_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  // prefix: 1
  frame->slots[1] /* prefix */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 808: parameter_kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__parameter_kind_of();
  func = myself->type;
  frame->cont = cont__compiler__define_static_multi__to_string_2;
}
static void cont__compiler__define_static_multi__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 809: IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__IN_PARAMETER();
  arguments->slots[1] = get__MYSELF_PARAMETER();
  arguments->slots[2] = get__CONTINUATION_PARAMETER();
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__compiler__define_static_multi__to_string_3;
}
static void cont__compiler__define_static_multi__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 806: $prefix
  // 807:   case
  // 808:     parameter_kind_of(self)
  // 809:     IN_PARAMETER, MYSELF_PARAMETER, CONTINUATION_PARAMETER
  // 810:     -> "$"
  // 811:     OUT_PARAMETER
  // 812:     -> "!"
  // 813:     IN_OUT_PARAMETER
  // 814:     -> "&"
  // 815:     -> "$$"
  argument_count = 8;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = func__compiler__define_static_multi__to_string_4;
  arguments->slots[3] = get__OUT_PARAMETER();
  arguments->slots[4] = func__compiler__define_static_multi__to_string_5;
  arguments->slots[5] = get__IN_OUT_PARAMETER();
  arguments->slots[6] = func__compiler__define_static_multi__to_string_7;
  arguments->slots[7] = func__compiler__define_static_multi__to_string_9;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__define_static_multi__to_string_11;
}
static void entry__compiler__define_static_multi__to_string_4(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 810: -> "$"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc5;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_static_multi__to_string_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 812: -> "!"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_static_multi__to_string_7(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 814: -> "&"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc7;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__define_static_multi__to_string_9(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 815: -> "$$"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6282be1;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__define_static_multi__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* prefix */, arguments->slots[0]);
  // 817: ... definition_to_string(prefix self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prefix */;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._definition_to_string;
  func = myself->type;
  frame->cont = cont__compiler__define_static_multi__to_string_12;
}
static void cont__compiler__define_static_multi__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 817: add_indented_remark self definition_to_string(prefix self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = var._add_indented_remark;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_dynamic_single__to_string_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 822: ... definition_to_string "%" self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc4;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = frame->caller_result_count;
  myself = var._definition_to_string;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__define_dynamic_multi__to_string_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 827: ... definition_to_string "%%" self
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6202be0;
  arguments->slots[1] = frame->slots[0] /* self */;
  result_count = frame->caller_result_count;
  myself = var._definition_to_string;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__precedence_of_17(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 841: -> INFIX_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__INFIX_PRECEDENCE();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__precedence_of_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 842: -> HIGHEST_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__HIGHEST_PRECEDENCE();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__precedence_of_11(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 837: ... functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__precedence_of_12;
}
static void cont__precedence_of_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 837: ... name_of(functor_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__precedence_of_13;
}
static void cont__precedence_of_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 837: ... precedence(name_of(functor_of(expr)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__precedence();
  func = myself->type;
  frame->cont = cont__precedence_of_14;
}
static void cont__precedence_of_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 837: -> precedence(name_of(functor_of(expr)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__precedence_of_15(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 840: expr.is_in_infix_notation
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_in_infix_notation();
  func = myself->type;
  frame->cont = cont__precedence_of_16;
}
static void cont__precedence_of_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 839: if
  // 840:   expr.is_in_infix_notation
  // 841:   -> INFIX_PRECEDENCE
  // 842:   -> HIGHEST_PRECEDENCE
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__precedence_of_17;
  arguments->slots[2] = func__precedence_of_18;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__precedence_of_8(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 836: functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__precedence_of_9;
}
static void cont__precedence_of_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 836: functor_of(expr).is_an_operator_symbol
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_operator_symbol();
  func = myself->type;
  frame->cont = cont__precedence_of_10;
}
static void cont__precedence_of_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 837: -> precedence(name_of(functor_of(expr)))
  frame->slots[3] /* temp__3 */ = create_closure(entry__precedence_of_11, 0);
  // 838: :
  // 839:   if
  // 840:     expr.is_in_infix_notation
  // 841:     -> INFIX_PRECEDENCE
  // 842:     -> HIGHEST_PRECEDENCE
  frame->slots[4] /* temp__4 */ = create_closure(entry__precedence_of_15, 0);
  // 835: if
  // 836:   functor_of(expr).is_an_operator_symbol
  // 837:   -> precedence(name_of(functor_of(expr)))
  // 838:   :
  // 839:     if
  // 840:       expr.is_in_infix_notation
  // 841:       -> INFIX_PRECEDENCE
  // 842:       -> HIGHEST_PRECEDENCE
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  arguments->slots[2] = frame->slots[4] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__precedence_of_19(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 843: -> HIGHEST_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__HIGHEST_PRECEDENCE();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__precedence_of_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 834: expr.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__precedence_of_2;
}
static void cont__precedence_of_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 834: ... length_of(arguments_of(expr)) == 2
  frame->slots[3] /* temp__3 */ = create_closure(entry__precedence_of_3, 0);
  // 834: expr.is_a_function_call && length_of(arguments_of(expr)) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__precedence_of_7;
}
static void entry__precedence_of_3(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 834: ... arguments_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__precedence_of_4;
}
static void cont__precedence_of_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 834: ... length_of(arguments_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__precedence_of_5;
}
static void cont__precedence_of_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 834: ... length_of(arguments_of(expr)) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__precedence_of_6;
}
static void cont__precedence_of_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 834: ... length_of(arguments_of(expr)) == 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__precedence_of_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 834: ... :
  // 835:   if
  // 836:     functor_of(expr).is_an_operator_symbol
  // 837:     -> precedence(name_of(functor_of(expr)))
  // 838:     :
  // 839:       if
  // 840:         expr.is_in_infix_notation
  // 841:         -> INFIX_PRECEDENCE
  // 842:         -> HIGHEST_PRECEDENCE
  frame->slots[4] /* temp__4 */ = create_closure(entry__precedence_of_8, 0);
  // 833: if
  // 834:   expr.is_a_function_call && length_of(arguments_of(expr)) == 2:
  // 835:     if
  // 836:       functor_of(expr).is_an_operator_symbol
  // 837:       -> precedence(name_of(functor_of(expr)))
  // 838:       :
  // 839:         if
  // 840:           expr.is_in_infix_notation
  // 841:           -> INFIX_PRECEDENCE
  // 842:           -> HIGHEST_PRECEDENCE
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  arguments->slots[2] = func__precedence_of_19;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__operator_of_12(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 851: ... functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__operator_of_13;
}
static void cont__operator_of_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 851: ... functor_of(expr).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__operator_of_14;
}
static void cont__operator_of_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 851: -> functor_of(expr).to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__operator_of_15(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 852: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__operator_of_1(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // expr: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 848: expr.is_a_function_call
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__is_a_function_call();
  func = myself->type;
  frame->cont = cont__operator_of_2;
}
static void cont__operator_of_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[3] /* temp__3 */ = create_closure(entry__operator_of_3, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__operator_of_11;
}
static void entry__operator_of_3(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 849: ... arguments_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__operator_of_4;
}
static void cont__operator_of_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 849: length_of(arguments_of(expr))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__operator_of_5;
}
static void cont__operator_of_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 849: length_of(arguments_of(expr)) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__operator_of_6;
}
static void cont__operator_of_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 850: functor_of(expr).is_an_operator_symbol
  frame->slots[5] /* temp__5 */ = create_closure(entry__operator_of_7, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__operator_of_10;
}
static void entry__operator_of_7(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // expr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* expr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 850: functor_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__operator_of_8;
}
static void cont__operator_of_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 850: functor_of(expr).is_an_operator_symbol
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_an_operator_symbol();
  func = myself->type;
  frame->cont = cont__operator_of_9;
}
static void cont__operator_of_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 850: functor_of(expr).is_an_operator_symbol
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__operator_of_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__operator_of_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 851: -> functor_of(expr).to_string
  frame->slots[4] /* temp__4 */ = create_closure(entry__operator_of_12, 0);
  // 846: if
  // 847:   &&
  // 848:     expr.is_a_function_call
  // 849:     length_of(arguments_of(expr)) == 2
  // 850:     functor_of(expr).is_an_operator_symbol
  // 851:   -> functor_of(expr).to_string
  // 852:   -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  arguments->slots[2] = func__operator_of_15;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__function_call__to_string_123(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // return__5: 0
  // indent: 1
  // arguments: 2
  // functor_string: 3
  frame->slots[0] /* return__5 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[2]; /* functor_string */
  define__expression_indent(create_future());
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 926: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_124;
}
static void cont__compiler__function_call__to_string_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 928: length_of(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_125;
}
static void cont__compiler__function_call__to_string_125(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 928: length_of(arguments) == 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_126;
}
static void cont__compiler__function_call__to_string_126(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 928: ... :
  // 929:   $argument arguments(1)
  // 930:   if
  // 931:     precedence_of(argument) < HIGHEST_PRECEDENCE
  // 932:     -> string(functor_string '(' argument ')')
  // 933:     -> string(functor_string argument)
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_127, 0);
  // 934: :
  // 935:   %line_end_expression_width 0
  // 936:   $prec precedence(functor_string)
  // 937:   $$left arguments(1)
  // 938:   $$right arguments(2)
  // 939:   
  // 940:   $stringify_le: (expr)
  // 941:     $str expr.to_string
  // 942:     if
  // 943:       precedence_of(expr) <= prec
  // ...
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_135, 0);
  // 927: if
  // 928:   length_of(arguments) == 1:
  // 929:     $argument arguments(1)
  // 930:     if
  // 931:       precedence_of(argument) < HIGHEST_PRECEDENCE
  // 932:       -> string(functor_string '(' argument ')')
  // 933:       -> string(functor_string argument)
  // 934:   :
  // 935:     %line_end_expression_width 0
  // 936:     $prec precedence(functor_string)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  arguments->slots[2] = frame->slots[7] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_249;
}
static void entry__compiler__function_call__to_string_131(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor_string: 0
  // argument: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[2]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 932: ... string(functor_string '(' argument ')')
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = character__40;
  arguments->slots[2] = frame->slots[1] /* argument */;
  arguments->slots[3] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_132;
}
static void cont__compiler__function_call__to_string_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 932: -> string(functor_string '(' argument ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_133(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor_string: 0
  // argument: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[2]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 933: ... string(functor_string argument)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = frame->slots[1] /* argument */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_134;
}
static void cont__compiler__function_call__to_string_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 933: -> string(functor_string argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_127(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // arguments: 0
  // functor_string: 1
  // argument: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[2] /* argument */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 929: $argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_128;
}
static void cont__compiler__function_call__to_string_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* argument */, arguments->slots[0]);
  // 931: precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_129;
}
static void cont__compiler__function_call__to_string_129(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 931: precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_130;
}
static void cont__compiler__function_call__to_string_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 932: -> string(functor_string '(' argument ')')
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_131, 0);
  // 933: -> string(functor_string argument)
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_133, 0);
  // 930: if
  // 931:   precedence_of(argument) < HIGHEST_PRECEDENCE
  // 932:   -> string(functor_string '(' argument ')')
  // 933:   -> string(functor_string argument)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__function_call__to_string_135(void) {
  allocate_initialized_frame_gc(4, 16);
  // slot allocations:
  // return__4: 0
  // functor_string: 1
  // arguments: 2
  // indent: 3
  // prec: 4
  // left: 5
  // right: 6
  // stringify_le: 7
  // stringify_lt: 8
  // strings: 9
  // inline_functor: 10
  // total_width: 11
  // buf: 12
  frame->slots[0] /* return__4 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[7] /* stringify_le */ = create_future();
  frame->slots[8] /* stringify_lt */ = create_future();
  // _define %line_end_expression_width 0
  define__line_end_expression_width(number__0);
  frame->slots[4] /* prec */ = create_future();
  frame->slots[5] /* left */ = create_cell();
  frame->slots[6] /* right */ = create_cell();
  frame->slots[9] /* strings */ = create_cell();
  frame->slots[10] /* inline_functor */ = create_cell();
  frame->slots[11] /* total_width */ = create_cell();
  frame->slots[12] /* buf */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 940: ... : (expr)
  // 941:   $str expr.to_string
  // 942:   if
  // 943:     precedence_of(expr) <= prec
  // 944:     -> str(.needs_parenthesis true)
  // 945:     -> str(.needs_parenthesis false)
  frame->slots[13] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_136, 1);
  // 940: $stringify_le: (expr)
  // 941:   $str expr.to_string
  // 942:   if
  // 943:     precedence_of(expr) <= prec
  // 944:     -> str(.needs_parenthesis true)
  // 945:     -> str(.needs_parenthesis false)
  initialize_future(frame->slots[7] /* stringify_le */, frame->slots[13] /* temp__1 */);
  // 947: ... : (expr)
  // 948:   $str expr.to_string
  // 949:   if
  // 950:     precedence_of(expr) < prec
  // 951:     -> str(.needs_parenthesis true)
  // 952:     -> str(.needs_parenthesis false)
  frame->slots[13] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_143, 1);
  // 947: $stringify_lt: (expr)
  // 948:   $str expr.to_string
  // 949:   if
  // 950:     precedence_of(expr) < prec
  // 951:     -> str(.needs_parenthesis true)
  // 952:     -> str(.needs_parenthesis false)
  initialize_future(frame->slots[8] /* stringify_lt */, frame->slots[13] /* temp__1 */);
  // 936: $prec precedence(functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__precedence();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_149;
}
static void entry__compiler__function_call__to_string_147(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 951: ... str(.needs_parenthesis true)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__true());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 951: -> str(.needs_parenthesis true)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_148(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 952: ... str(.needs_parenthesis false)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__false());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 952: -> str(.needs_parenthesis false)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_141(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 944: ... str(.needs_parenthesis true)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__true());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 944: -> str(.needs_parenthesis true)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_142(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // str: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* str */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 945: ... str(.needs_parenthesis false)
  {
    NODE *temp = clone_object_and_attributes(frame->slots[0] /* str */);
    update_start_p = node_p;
    set_attribute_value(temp->attributes, poly_idx__needs_parenthesis, get__false());
    frame->slots[1] /* temp__1 */ = temp;

  }
  // 945: -> str(.needs_parenthesis false)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_136(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // expr: 0
  // prec: 1
  // str: 2
  frame->slots[1] = myself->closure.frame->slots[4]; /* prec */
  frame->slots[2] /* str */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 941: $str expr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_137;
}
static void cont__compiler__function_call__to_string_137(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* str */, arguments->slots[0]);
  // 943: precedence_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_138;
}
static void cont__compiler__function_call__to_string_138(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 943: precedence_of(expr) <= prec
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* prec */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_139;
}
static void cont__compiler__function_call__to_string_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 943: precedence_of(expr) <= prec
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_140;
}
static void cont__compiler__function_call__to_string_140(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 944: -> str(.needs_parenthesis true)
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_141, 0);
  // 945: -> str(.needs_parenthesis false)
  frame->slots[7] /* temp__5 */ = create_closure(entry__compiler__function_call__to_string_142, 0);
  // 942: if
  // 943:   precedence_of(expr) <= prec
  // 944:   -> str(.needs_parenthesis true)
  // 945:   -> str(.needs_parenthesis false)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__4 */;
  arguments->slots[2] = frame->slots[7] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__function_call__to_string_143(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // expr: 0
  // prec: 1
  // str: 2
  frame->slots[1] = myself->closure.frame->slots[4]; /* prec */
  frame->slots[2] /* str */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 948: $str expr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_144;
}
static void cont__compiler__function_call__to_string_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* str */, arguments->slots[0]);
  // 950: precedence_of(expr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* expr */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_145;
}
static void cont__compiler__function_call__to_string_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 950: precedence_of(expr) < prec
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = frame->slots[1] /* prec */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_146;
}
static void cont__compiler__function_call__to_string_146(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 951: -> str(.needs_parenthesis true)
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_147, 0);
  // 952: -> str(.needs_parenthesis false)
  frame->slots[6] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_148, 0);
  // 949: if
  // 950:   precedence_of(expr) < prec
  // 951:   -> str(.needs_parenthesis true)
  // 952:   -> str(.needs_parenthesis false)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__function_call__to_string_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* prec */, arguments->slots[0]);
  // 937: $$left arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[2] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_150;
}
static void cont__compiler__function_call__to_string_150(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* left */ = arguments->slots[0];
  // 938: $$right arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[2] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_151;
}
static void cont__compiler__function_call__to_string_151(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* right */ = arguments->slots[0];
  // 954: $$strings empty_list
  ((CELL *)frame->slots[9])->contents /* strings */ = get__empty_list();
  // 956: prec.is_left_associative
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* prec */;
  result_count = 1;
  myself = get__is_left_associative();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_152;
}
static void cont__compiler__function_call__to_string_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 956: ... :
  // 957:   put &strings stringify_le(right)
  // 958:   while -> operator_of(left) == functor_string:
  // 959:     $left_operands arguments_of(left)
  // 960:     put &strings stringify_le(left_operands(2))
  // 961:     !left left_operands(1)
  // 962:   put &strings stringify_lt(left)
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_153, 0);
  // 963: :
  // 964:   push &strings stringify_le(left)
  // 965:   while -> operator_of(right) == functor_string:
  // 966:     $right_operands arguments_of(right)
  // 967:     push &strings stringify_le(right_operands(1))
  // 968:     !right right_operands(2)
  // 969:   push &strings stringify_lt(right)
  frame->slots[15] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_168, 0);
  // 955: if
  // 956:   prec.is_left_associative:
  // 957:     put &strings stringify_le(right)
  // 958:     while -> operator_of(left) == functor_string:
  // 959:       $left_operands arguments_of(left)
  // 960:       put &strings stringify_le(left_operands(2))
  // 961:       !left left_operands(1)
  // 962:     put &strings stringify_lt(left)
  // 963:   :
  // 964:     push &strings stringify_le(left)
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_183;
}
static void entry__compiler__function_call__to_string_153(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // strings: 0
  // stringify_le: 1
  // right: 2
  // left: 3
  // functor_string: 4
  // stringify_lt: 5
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[7]; /* stringify_le */
  frame->slots[2] = myself->closure.frame->slots[6]; /* right */
  frame->slots[3] = myself->closure.frame->slots[5]; /* left */
  frame->slots[4] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[5] = myself->closure.frame->slots[8]; /* stringify_lt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 957: ... stringify_le(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* right */;
  result_count = 1;
  myself = frame->slots[1] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_154;
}
static void cont__compiler__function_call__to_string_154(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 957: put &strings stringify_le(right)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_155;
}
static void cont__compiler__function_call__to_string_155(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  // 958: ... -> operator_of(left) == functor_string:
  // 959:   $left_operands arguments_of(left)
  // 960:   put &strings stringify_le(left_operands(2))
  // 961:   !left left_operands(1)
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_156, 0);
  // 958: while -> operator_of(left) == functor_string:
  // 959:   $left_operands arguments_of(left)
  // 960:   put &strings stringify_le(left_operands(2))
  // 961:   !left left_operands(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_165;
}
static void entry__compiler__function_call__to_string_159(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // left: 0
  // strings: 1
  // stringify_le: 2
  // left_operands: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* left */
  frame->slots[1] = myself->closure.frame->slots[2]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[3]; /* stringify_le */
  frame->slots[3] /* left_operands */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 959: $left_operands arguments_of(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* left */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_160;
}
static void cont__compiler__function_call__to_string_160(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* left_operands */, arguments->slots[0]);
  // 960: ... left_operands(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[3] /* left_operands */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_161;
}
static void cont__compiler__function_call__to_string_161(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 960: ... stringify_le(left_operands(2))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[2] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_162;
}
static void cont__compiler__function_call__to_string_162(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 960: put &strings stringify_le(left_operands(2))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_163;
}
static void cont__compiler__function_call__to_string_163(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* strings */ = arguments->slots[0];
  // 961: !left left_operands(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[3] /* left_operands */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_164;
}
static void cont__compiler__function_call__to_string_164(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* left */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_156(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // left: 0
  // functor_string: 1
  // strings: 2
  // stringify_le: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* left */
  frame->slots[1] = myself->closure.frame->slots[4]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[3] = myself->closure.frame->slots[1]; /* stringify_le */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 958: ... operator_of(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* left */;
  result_count = 1;
  myself = var._operator_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_157;
}
static void cont__compiler__function_call__to_string_157(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 958: ... operator_of(left) == functor_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_158;
}
static void cont__compiler__function_call__to_string_158(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 958: ... :
  // 959:   $left_operands arguments_of(left)
  // 960:   put &strings stringify_le(left_operands(2))
  // 961:   !left left_operands(1)
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_159, 0);
  // 958: ... -> operator_of(left) == functor_string:
  // 959:   $left_operands arguments_of(left)
  // 960:   put &strings stringify_le(left_operands(2))
  // 961:   !left left_operands(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_165(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 962: ... stringify_lt(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* left */;
  result_count = 1;
  myself = frame->slots[5] /* stringify_lt */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_166;
}
static void cont__compiler__function_call__to_string_166(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 962: put &strings stringify_lt(left)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_167;
}
static void cont__compiler__function_call__to_string_167(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_168(void) {
  allocate_initialized_frame_gc(6, 7);
  // slot allocations:
  // strings: 0
  // stringify_le: 1
  // left: 2
  // right: 3
  // functor_string: 4
  // stringify_lt: 5
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[7]; /* stringify_le */
  frame->slots[2] = myself->closure.frame->slots[5]; /* left */
  frame->slots[3] = myself->closure.frame->slots[6]; /* right */
  frame->slots[4] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[5] = myself->closure.frame->slots[8]; /* stringify_lt */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 964: ... stringify_le(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* left */;
  result_count = 1;
  myself = frame->slots[1] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_169;
}
static void cont__compiler__function_call__to_string_169(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 964: push &strings stringify_le(left)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_170;
}
static void cont__compiler__function_call__to_string_170(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  // 965: ... -> operator_of(right) == functor_string:
  // 966:   $right_operands arguments_of(right)
  // 967:   push &strings stringify_le(right_operands(1))
  // 968:   !right right_operands(2)
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_171, 0);
  // 965: while -> operator_of(right) == functor_string:
  // 966:   $right_operands arguments_of(right)
  // 967:   push &strings stringify_le(right_operands(1))
  // 968:   !right right_operands(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_180;
}
static void entry__compiler__function_call__to_string_174(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // right: 0
  // strings: 1
  // stringify_le: 2
  // right_operands: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* right */
  frame->slots[1] = myself->closure.frame->slots[2]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[3]; /* stringify_le */
  frame->slots[3] /* right_operands */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 966: $right_operands arguments_of(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_175;
}
static void cont__compiler__function_call__to_string_175(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* right_operands */, arguments->slots[0]);
  // 967: ... right_operands(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[3] /* right_operands */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_176;
}
static void cont__compiler__function_call__to_string_176(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 967: ... stringify_le(right_operands(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = frame->slots[2] /* stringify_le */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_177;
}
static void cont__compiler__function_call__to_string_177(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 967: push &strings stringify_le(right_operands(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_178;
}
static void cont__compiler__function_call__to_string_178(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* strings */ = arguments->slots[0];
  // 968: !right right_operands(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[3] /* right_operands */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_179;
}
static void cont__compiler__function_call__to_string_179(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_171(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // right: 0
  // functor_string: 1
  // strings: 2
  // stringify_le: 3
  frame->slots[0] = myself->closure.frame->slots[3]; /* right */
  frame->slots[1] = myself->closure.frame->slots[4]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[0]; /* strings */
  frame->slots[3] = myself->closure.frame->slots[1]; /* stringify_le */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 965: ... operator_of(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* right */;
  result_count = 1;
  myself = var._operator_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_172;
}
static void cont__compiler__function_call__to_string_172(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 965: ... operator_of(right) == functor_string
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_173;
}
static void cont__compiler__function_call__to_string_173(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 965: ... :
  // 966:   $right_operands arguments_of(right)
  // 967:   push &strings stringify_le(right_operands(1))
  // 968:   !right right_operands(2)
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_174, 0);
  // 965: ... -> operator_of(right) == functor_string:
  // 966:   $right_operands arguments_of(right)
  // 967:   push &strings stringify_le(right_operands(1))
  // 968:   !right right_operands(2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_180(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 969: ... stringify_lt(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* right */;
  result_count = 1;
  myself = frame->slots[5] /* stringify_lt */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_181;
}
static void cont__compiler__function_call__to_string_181(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 969: push &strings stringify_lt(right)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_182;
}
static void cont__compiler__function_call__to_string_182(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* strings */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_183(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 970: $$inline_functor undefined
  ((CELL *)frame->slots[10])->contents /* inline_functor */ = get__undefined();
  // 971: $$total_width 0
  ((CELL *)frame->slots[11])->contents /* total_width */ = number__0;
  // 972: ... : (-> break)
  // 973:   for_each strings: (str)
  // 974:     if str(1) == '@nl;':
  // 975:       !total_width undefined
  // 976:       break
  // 977:     plus &total_width length_of(str)
  // 978:     if str.needs_parenthesis: plus &total_width 2
  frame->slots[13] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_184, 0);
  // 972: do: (-> break)
  // 973:   for_each strings: (str)
  // 974:     if str(1) == '@nl;':
  // 975:       !total_width undefined
  // 976:       break
  // 977:     plus &total_width length_of(str)
  // 978:     if str.needs_parenthesis: plus &total_width 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  result_count = 0;
  myself = get__do();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_196;
}
static void entry__compiler__function_call__to_string_184(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // break: 0
  // strings: 1
  // total_width: 2
  frame->slots[0] /* break */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[2] = myself->closure.frame->slots[11]; /* total_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 973: ... : (str)
  // 974:   if str(1) == '@nl;':
  // 975:     !total_width undefined
  // 976:     break
  // 977:   plus &total_width length_of(str)
  // 978:   if str.needs_parenthesis: plus &total_width 2
  frame->slots[3] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_185, 1);
  // 973: for_each strings: (str)
  // 974:   if str(1) == '@nl;':
  // 975:     !total_width undefined
  // 976:     break
  // 977:   plus &total_width length_of(str)
  // 978:   if str.needs_parenthesis: plus &total_width 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* strings */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_195;
}
static void entry__compiler__function_call__to_string_193(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_width: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* total_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 978: ... plus &total_width 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* total_width */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_194;
}
static void cont__compiler__function_call__to_string_194(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* total_width */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_185(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // total_width: 1
  // break: 2
  frame->slots[1] = myself->closure.frame->slots[2]; /* total_width */
  frame->slots[2] = myself->closure.frame->slots[0]; /* break */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 974: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_186;
}
static void cont__compiler__function_call__to_string_186(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 974: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_187;
}
static void cont__compiler__function_call__to_string_187(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 974: ... :
  // 975:   !total_width undefined
  // 976:   break
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_188, 0);
  // 974: if str(1) == '@nl;':
  // 975:   !total_width undefined
  // 976:   break
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_189;
}
static void entry__compiler__function_call__to_string_188(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // total_width: 0
  // break: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* total_width */
  frame->slots[1] = myself->closure.frame->slots[2]; /* break */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 975: !total_width undefined
  ((CELL *)frame->slots[0])->contents /* total_width */ = get__undefined();
  // 976: break
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* break */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__function_call__to_string_189(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 977: ... length_of(str)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_190;
}
static void cont__compiler__function_call__to_string_190(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 977: plus &total_width length_of(str)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* total_width */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_191;
}
static void cont__compiler__function_call__to_string_191(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* total_width */ = arguments->slots[0];
  // 978: ... str.needs_parenthesis
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = var._needs_parenthesis;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_192;
}
static void cont__compiler__function_call__to_string_192(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 978: ... : plus &total_width 2
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_193, 0);
  // 978: if str.needs_parenthesis: plus &total_width 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__function_call__to_string_195(void) {
  myself = frame->slots[0] /* break */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_196(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 979: ... total_width.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* total_width */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_197;
}
static void cont__compiler__function_call__to_string_197(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 979: ... :
  // 980:   !inline_functor
  // 981:     case
  // 982:       functor_string
  // 983:       "+", "-", "*", "/"
  // 984:       -> functor_string
  // 985:       ","
  // 986:       -> string(functor_string ' ')
  // 987:       -> string(' ' functor_string ' ')
  // 988:   plus &total_width (length_of(strings)-1)*length_of(inline_functor)
  // ...
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_198, 0);
  // 979: if total_width.is_defined:
  // 980:   !inline_functor
  // 981:     case
  // 982:       functor_string
  // 983:       "+", "-", "*", "/"
  // 984:       -> functor_string
  // 985:       ","
  // 986:       -> string(functor_string ' ')
  // 987:       -> string(' ' functor_string ' ')
  // 988:   plus &total_width (length_of(strings)-1)*length_of(inline_functor)
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_219;
}
static void entry__compiler__function_call__to_string_218(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // total_width: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* total_width */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 989: ... !total_width undefined
  ((CELL *)frame->slots[0])->contents /* total_width */ = get__undefined();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_198(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // inline_functor: 0
  // functor_string: 1
  // total_width: 2
  // strings: 3
  // indent: 4
  frame->slots[0] = myself->closure.frame->slots[10]; /* inline_functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[11]; /* total_width */
  frame->slots[3] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[4] = myself->closure.frame->slots[3]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 983: "+", "-", "*", "/"
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cca;
  arguments->slots[1] = string__578a5af303e9ccc;
  arguments->slots[2] = string__578a5af303e9ccb;
  arguments->slots[3] = string__578a5af303e9cce;
  result_count = 1;
  myself = get__std__sequence();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_203;
}
static void cont__compiler__function_call__to_string_203(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 984: -> functor_string
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_204, 0);
  // 986: -> string(functor_string ' ')
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_205, 0);
  // 987: -> string(' ' functor_string ' ')
  frame->slots[8] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_207, 0);
  // 980: !inline_functor
  // 981:   case
  // 982:     functor_string
  // 983:     "+", "-", "*", "/"
  // 984:     -> functor_string
  // 985:     ","
  // 986:     -> string(functor_string ' ')
  // 987:     -> string(' ' functor_string ' ')
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  arguments->slots[3] = string__578a5af303e9ccd;
  arguments->slots[4] = frame->slots[7] /* temp__3 */;
  arguments->slots[5] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_210;
}
static void entry__compiler__function_call__to_string_204(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 984: -> functor_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_205(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 986: ... string(functor_string ' ')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_206;
}
static void cont__compiler__function_call__to_string_206(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 986: -> string(functor_string ' ')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_207(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 987: ... string(' ' functor_string ' ')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[2] = character__32;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_208;
}
static void cont__compiler__function_call__to_string_208(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 987: -> string(' ' functor_string ' ')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_210(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* inline_functor */ = arguments->slots[0];
  // 988: ... length_of(strings)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* strings */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_211;
}
static void cont__compiler__function_call__to_string_211(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 988: ... length_of(strings)-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_212;
}
static void cont__compiler__function_call__to_string_212(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 988: ... length_of(inline_functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* inline_functor */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_213;
}
static void cont__compiler__function_call__to_string_213(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__4 */ = arguments->slots[0];
  // 988: ... length_of(strings)-1)*length_of(inline_functor)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__std__times();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_214;
}
static void cont__compiler__function_call__to_string_214(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 988: plus &total_width (length_of(strings)-1)*length_of(inline_functor)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* total_width */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_215;
}
static void cont__compiler__function_call__to_string_215(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* total_width */ = arguments->slots[0];
  // 989: ... indent+total_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* indent */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* total_width */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_216;
}
static void cont__compiler__function_call__to_string_216(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 989: ... indent+total_width > line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_217;
}
static void cont__compiler__function_call__to_string_217(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 989: ... : !total_width undefined
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_218, 0);
  // 989: if indent+total_width > line_width: !total_width undefined
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__function_call__to_string_219(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 990: $$buf ""
  ((CELL *)frame->slots[12])->contents /* buf */ = empty_string;
  // 992: total_width.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[11])->contents /* total_width */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_220;
}
static void cont__compiler__function_call__to_string_220(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[13] /* temp__1 */ = arguments->slots[0];
  // 992: ... :
  // 993:   for_each
  // 994:     strings: (str)
  // 995:       if str.needs_parenthesis: push &buf '('
  // 996:       append &buf str
  // 997:       if str.needs_parenthesis: push &buf ')'
  // 998:     :
  // 999:       append &buf inline_functor
  frame->slots[14] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_221, 0);
  // 1000: :
  // 1001:   case functor_string ",": !functor_string "sequence"
  // 1002:   $indentation spaces(expression_indent)
  // 1003:   !buf string('@nl;' spaces(indent) functor_string)
  // 1004:   for_each strings: (str)
  // 1005:     unless str(1) == '@nl;':
  // 1006:       push &buf '@nl;'
  // 1007:       append &buf indentation
  // 1008:     append &buf str
  frame->slots[15] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_233, 0);
  //  991: if
  //  992:   total_width.is_defined:
  //  993:     for_each
  //  994:       strings: (str)
  //  995:         if str.needs_parenthesis: push &buf '('
  //  996:         append &buf str
  //  997:         if str.needs_parenthesis: push &buf ')'
  //  998:       :
  //  999:         append &buf inline_functor
  // 1000:   :
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[13] /* temp__1 */;
  arguments->slots[1] = frame->slots[14] /* temp__2 */;
  arguments->slots[2] = frame->slots[15] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_248;
}
static void entry__compiler__function_call__to_string_240(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // str: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[4]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1005: ... str(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* str */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_241;
}
static void cont__compiler__function_call__to_string_241(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1005: ... str(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_242;
}
static void cont__compiler__function_call__to_string_242(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1005: ... :
  // 1006:   push &buf '@nl;'
  // 1007:   append &buf indentation
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_243, 0);
  // 1005: unless str(1) == '@nl;':
  // 1006:   push &buf '@nl;'
  // 1007:   append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_246;
}
static void entry__compiler__function_call__to_string_243(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // indentation: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1006: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_244;
}
static void cont__compiler__function_call__to_string_244(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1007: append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_245;
}
static void cont__compiler__function_call__to_string_245(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_246(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1008: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_247;
}
static void cont__compiler__function_call__to_string_247(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_229(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 997: ... push &buf ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_230;
}
static void cont__compiler__function_call__to_string_230(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_222(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // str: 0
  // buf: 1
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 995: ... str.needs_parenthesis
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = var._needs_parenthesis;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_223;
}
static void cont__compiler__function_call__to_string_223(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 995: ... : push &buf '('
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_224, 0);
  // 995: if str.needs_parenthesis: push &buf '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_226;
}
static void entry__compiler__function_call__to_string_224(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 995: ... push &buf '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_225;
}
static void cont__compiler__function_call__to_string_225(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_226(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 996: append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[0] /* str */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_227;
}
static void cont__compiler__function_call__to_string_227(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 997: ... str.needs_parenthesis
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* str */;
  result_count = 1;
  myself = var._needs_parenthesis;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_228;
}
static void cont__compiler__function_call__to_string_228(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 997: ... : push &buf ')'
  frame->slots[3] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_229, 0);
  // 997: if str.needs_parenthesis: push &buf ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__function_call__to_string_231(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // buf: 0
  // inline_functor: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* inline_functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 999: append &buf inline_functor
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* inline_functor */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_232;
}
static void cont__compiler__function_call__to_string_232(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_221(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // strings: 0
  // buf: 1
  // inline_functor: 2
  frame->slots[0] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[1] = myself->closure.frame->slots[12]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[10]; /* inline_functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 994: ... : (str)
  // 995:   if str.needs_parenthesis: push &buf '('
  // 996:   append &buf str
  // 997:   if str.needs_parenthesis: push &buf ')'
  frame->slots[3] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_222, 1);
  // 998: :
  // 999:   append &buf inline_functor
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_231, 0);
  // 993: for_each
  // 994:   strings: (str)
  // 995:     if str.needs_parenthesis: push &buf '('
  // 996:     append &buf str
  // 997:     if str.needs_parenthesis: push &buf ')'
  // 998:   :
  // 999:     append &buf inline_functor
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* strings */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__function_call__to_string_233(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // functor_string: 0
  // buf: 1
  // indent: 2
  // strings: 3
  // indentation: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[12]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indent */
  frame->slots[3] = myself->closure.frame->slots[9]; /* strings */
  frame->slots[4] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1001: ... : !functor_string "sequence"
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_234, 0);
  // 1001: case functor_string ",": !functor_string "sequence"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = string__578a5af303e9ccd;
  arguments->slots[2] = frame->slots[5] /* temp__1 */;
  result_count = 0;
  myself = get__case();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_236;
}
static void entry__compiler__function_call__to_string_234(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // functor_string: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1001: ... !functor_string "sequence"
  ((CELL *)frame->slots[0])->contents /* functor_string */ = string__6480ae5e84ccc225;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_236(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1002: $indentation spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_237;
}
static void cont__compiler__function_call__to_string_237(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* indentation */, arguments->slots[0]);
  // 1003: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_238;
}
static void cont__compiler__function_call__to_string_238(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1003: !buf string('@nl;' spaces(indent) functor_string)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_239;
}
static void cont__compiler__function_call__to_string_239(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1004: ... : (str)
  // 1005:   unless str(1) == '@nl;':
  // 1006:     push &buf '@nl;'
  // 1007:     append &buf indentation
  // 1008:   append &buf str
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_240, 1);
  // 1004: for_each strings: (str)
  // 1005:   unless str(1) == '@nl;':
  // 1006:     push &buf '@nl;'
  // 1007:     append &buf indentation
  // 1008:   append &buf str
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* strings */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__function_call__to_string_248(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1009: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[12])->contents /* buf */;
  myself = frame->slots[0] /* return__4 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_249(void) {
  myself = frame->slots[0] /* return__5 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_117(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 923: ... arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_118;
}
static void cont__compiler__function_call__to_string_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 923: ... "--@(arguments(1))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6602be8;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_120;
}
static void cont__compiler__function_call__to_string_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 923: -> "--@(arguments(1))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_80(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 912: ... string_template_to_string(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = var._string_template_to_string;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_81;
}
static void cont__compiler__function_call__to_string_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 912: ... -> string_template_to_string(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_74(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // left: 0
  // functor_string: 1
  // right: 2
  frame->slots[0] = myself->closure.frame->slots[5]; /* left */
  frame->slots[1] = myself->closure.frame->slots[1]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[6]; /* right */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 910: ... string(left " ." functor_string ". " right)
  argument_count = 5;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* left */;
  arguments->slots[1] = string__2d7981f4e6082beb;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  arguments->slots[3] = string__2d7981f4e6782be5;
  arguments->slots[4] = ((CELL *)frame->slots[2])->contents /* right */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_77;
}
static void cont__compiler__function_call__to_string_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 910: -> string(left " ." functor_string ". " right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_49(void) {
  allocate_initialized_frame_gc(3, 13);
  // slot allocations:
  // arguments: 0
  // functor_string: 1
  // default_call: 2
  // left_argument: 3
  // right_argument: 4
  // left: 5
  // right: 6
  // length: 7
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[3]; /* default_call */
  frame->slots[3] /* left_argument */ = create_future();
  frame->slots[4] /* right_argument */ = create_future();
  frame->slots[5] /* left */ = create_cell();
  frame->slots[6] /* right */ = create_cell();
  frame->slots[7] /* length */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 899: $left_argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_50;
}
static void cont__compiler__function_call__to_string_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* left_argument */, arguments->slots[0]);
  // 900: $right_argument arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_51;
}
static void cont__compiler__function_call__to_string_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* right_argument */, arguments->slots[0]);
  // 901: $$left left_argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* left_argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_52;
}
static void cont__compiler__function_call__to_string_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* left */ = arguments->slots[0];
  // 902: $$right right_argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* right_argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_53;
}
static void cont__compiler__function_call__to_string_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[6])->contents /* right */ = arguments->slots[0];
  // 903: ... precedence_of(left_argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* left_argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_54;
}
static void cont__compiler__function_call__to_string_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 903: ... precedence_of(left_argument) < INFIX_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = get__INFIX_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_55;
}
static void cont__compiler__function_call__to_string_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 903: ... :
  // 904:   !left string('(' left ')')
  frame->slots[10] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_56, 0);
  // 903: if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:   !left string('(' left ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_58;
}
static void entry__compiler__function_call__to_string_56(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // left: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* left */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 904: !left string('(' left ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* left */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_57;
}
static void cont__compiler__function_call__to_string_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* left */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_58(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 905: ... precedence_of(right_argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* right_argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_59;
}
static void cont__compiler__function_call__to_string_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 905: ... precedence_of(right_argument) <= INFIX_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__INFIX_PRECEDENCE();
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_60;
}
static void cont__compiler__function_call__to_string_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 905: ... precedence_of(right_argument) <= INFIX_PRECEDENCE
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_61;
}
static void cont__compiler__function_call__to_string_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 905: ... :
  // 906:   !right string('(' right ')')
  frame->slots[11] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_62, 0);
  // 905: if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 906:   !right string('(' right ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_64;
}
static void entry__compiler__function_call__to_string_62(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // right: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* right */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 906: !right string('(' right ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* right */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_63;
}
static void cont__compiler__function_call__to_string_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* right */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_64(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 907: ... length_of(left)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* left */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_65;
}
static void cont__compiler__function_call__to_string_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 907: ... length_of(functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_66;
}
static void cont__compiler__function_call__to_string_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__4 */ = arguments->slots[0];
  // 907: ... length_of(left)+length_of(functor_string)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__3 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_67;
}
static void cont__compiler__function_call__to_string_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 907: ... length_of(right)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* right */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_68;
}
static void cont__compiler__function_call__to_string_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[12] /* temp__5 */ = arguments->slots[0];
  // 907: ... length_of(left)+length_of(functor_string)+length_of(right)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  arguments->slots[1] = frame->slots[12] /* temp__5 */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_69;
}
static void cont__compiler__function_call__to_string_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 907: $length length_of(left)+length_of(functor_string)+length_of(right)+4
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = number__4;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_70;
}
static void cont__compiler__function_call__to_string_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[7] /* length */, arguments->slots[0]);
  // 909: expression_indent+length
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = frame->slots[7] /* length */;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_71;
}
static void cont__compiler__function_call__to_string_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__3 */ = arguments->slots[0];
  // 909: expression_indent+length <= line_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[10] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_72;
}
static void cont__compiler__function_call__to_string_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__2 */ = arguments->slots[0];
  // 909: expression_indent+length <= line_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_73;
}
static void cont__compiler__function_call__to_string_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__1 */ = arguments->slots[0];
  // 910: -> string(left " ." functor_string ". " right)
  frame->slots[11] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_74, 0);
  // 908: if
  // 909:   expression_indent+length <= line_width
  // 910:   -> string(left " ." functor_string ". " right)
  // 911:   default_call
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__1 */;
  arguments->slots[1] = frame->slots[11] /* temp__4 */;
  arguments->slots[2] = frame->slots[2] /* default_call */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__function_call__to_string_47(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  // default_call: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[3] = myself->closure.frame->slots[3]; /* default_call */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 898: ... self.is_in_infix_notation
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_in_infix_notation();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_48;
}
static void cont__compiler__function_call__to_string_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 898: ... :
  // 899:   $left_argument arguments(1)
  // 900:   $right_argument arguments(2)
  // 901:   $$left left_argument.to_string
  // 902:   $$right right_argument.to_string
  // 903:   if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:     !left string('(' left ')')
  // 905:   if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 906:     !right string('(' right ')')
  // 907:   $length length_of(left)+length_of(functor_string)+length_of(right)+4
  // ...
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_49, 0);
  // 898: -> self.is_in_infix_notation:
  // 899:   $left_argument arguments(1)
  // 900:   $right_argument arguments(2)
  // 901:   $$left left_argument.to_string
  // 902:   $$right right_argument.to_string
  // 903:   if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:     !left string('(' left ')')
  // 905:   if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 906:     !right string('(' right ')')
  // 907:   $length length_of(left)+length_of(functor_string)+length_of(right)+4
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_78(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 912: ... self.is_a_string_template
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_string_template();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_79;
}
static void cont__compiler__function_call__to_string_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 912: ... -> string_template_to_string(self)
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_80, 0);
  // 912: -> self.is_a_string_template -> string_template_to_string(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_82(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 915: functor.is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_83;
}
static void cont__compiler__function_call__to_string_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_84, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_116;
}
static void entry__compiler__function_call__to_string_84(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 916: namespace_of(functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_85;
}
static void cont__compiler__function_call__to_string_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 916: namespace_of(functor) == "std"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = string__fa724815d896ba8;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_87;
}
static void cont__compiler__function_call__to_string_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_88, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_115;
}
static void entry__compiler__function_call__to_string_88(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // functor: 0
  // arguments: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* functor */
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 917: name_of(functor)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* functor */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_89;
}
static void cont__compiler__function_call__to_string_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 917: name_of(functor) == "key_value_pair"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = string__64d512703527e2ab;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_91;
}
static void cont__compiler__function_call__to_string_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_92, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_114;
}
static void entry__compiler__function_call__to_string_92(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 918: length_of(arguments)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* arguments */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_93;
}
static void cont__compiler__function_call__to_string_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 918: length_of(arguments) == 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_94;
}
static void cont__compiler__function_call__to_string_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_95, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_113;
}
static void entry__compiler__function_call__to_string_95(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 919: arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_96;
}
static void cont__compiler__function_call__to_string_96(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 919: arguments(1).is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_97;
}
static void cont__compiler__function_call__to_string_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_98, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_112;
}
static void entry__compiler__function_call__to_string_98(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 920: arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_99;
}
static void cont__compiler__function_call__to_string_99(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 920: arguments(2).is_an_identifier
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__is_an_identifier();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_100;
}
static void cont__compiler__function_call__to_string_100(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  frame->slots[4] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_101, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_111;
}
static void entry__compiler__function_call__to_string_101(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 921: ... arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_102;
}
static void cont__compiler__function_call__to_string_102(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 921: namespace_of(arguments(2))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_103;
}
static void cont__compiler__function_call__to_string_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 921: namespace_of(arguments(2)) == "std"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = string__fa724815d896ba8;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_104;
}
static void cont__compiler__function_call__to_string_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 922: name_of(arguments(2)) == "true"
  frame->slots[5] /* temp__5 */ = create_closure(entry__compiler__function_call__to_string_105, 0);
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__5 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_110;
}
static void entry__compiler__function_call__to_string_105(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // arguments: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* arguments */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 922: ... arguments(2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_106;
}
static void cont__compiler__function_call__to_string_106(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 922: name_of(arguments(2))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_107;
}
static void cont__compiler__function_call__to_string_107(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 922: name_of(arguments(2)) == "true"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = string__2a0aedcb5dc87d5c;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_109;
}
static void cont__compiler__function_call__to_string_109(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 922: name_of(arguments(2)) == "true"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_110(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_111(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_113(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_115(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_116(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 923: -> "--@(arguments(1))"
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_117, 0);
  // 913: ->
  // 914:   &&
  // 915:     functor.is_an_identifier
  // 916:     namespace_of(functor) == "std"
  // 917:     name_of(functor) == "key_value_pair"
  // 918:     length_of(arguments) == 2
  // 919:     arguments(1).is_an_identifier
  // 920:     arguments(2).is_an_identifier
  // 921:     namespace_of(arguments(2)) == "std"
  // 922:     name_of(arguments(2)) == "true"
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_121(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // default_call: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* default_call */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 924: -> true default_call
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[0] /* default_call */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_46(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  // default_call: 3
  // functor: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* self */
  frame->slots[1] = myself->closure.frame->slots[2]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[0]; /* functor_string */
  frame->slots[3] = myself->closure.frame->slots[3]; /* default_call */
  frame->slots[4] = myself->closure.frame->slots[4]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 898: -> self.is_in_infix_notation:
  // 899:   $left_argument arguments(1)
  // 900:   $right_argument arguments(2)
  // 901:   $$left left_argument.to_string
  // 902:   $$right right_argument.to_string
  // 903:   if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:     !left string('(' left ')')
  // 905:   if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 906:     !right string('(' right ')')
  // 907:   $length length_of(left)+length_of(functor_string)+length_of(right)+4
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_47, 0);
  // 912: -> self.is_a_string_template -> string_template_to_string(self)
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_78, 0);
  // 913: ->
  // 914:   &&
  // 915:     functor.is_an_identifier
  // 916:     namespace_of(functor) == "std"
  // 917:     name_of(functor) == "key_value_pair"
  // 918:     length_of(arguments) == 2
  // 919:     arguments(1).is_an_identifier
  // 920:     arguments(2).is_an_identifier
  // 921:     namespace_of(arguments(2)) == "std"
  // 922:     name_of(arguments(2)) == "true"
  // ...
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_82, 0);
  // 924: -> true default_call
  frame->slots[8] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_121, 0);
  // 897: cond
  // 898:   -> self.is_in_infix_notation:
  // 899:     $left_argument arguments(1)
  // 900:     $right_argument arguments(2)
  // 901:     $$left left_argument.to_string
  // 902:     $$right right_argument.to_string
  // 903:     if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:       !left string('(' left ')')
  // 905:     if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // 906:       !right string('(' right ')')
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  arguments->slots[3] = frame->slots[8] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__function_call__to_string_36(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // arguments: 0
  // functor_string: 1
  // argument: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor_string */
  frame->slots[2] /* argument */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 892: $$argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_37;
}
static void cont__compiler__function_call__to_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* argument */ = arguments->slots[0];
  // 893: ... precedence_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* argument */;
  result_count = 1;
  myself = var._precedence_of;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_38;
}
static void cont__compiler__function_call__to_string_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 893: ... precedence_of(argument) < HIGHEST_PRECEDENCE
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = get__HIGHEST_PRECEDENCE();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_39;
}
static void cont__compiler__function_call__to_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 893: ... :
  // 894:   !argument string('(' argument ')')
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_40, 0);
  // 893: if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 894:   !argument string('(' argument ')')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_42;
}
static void entry__compiler__function_call__to_string_40(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 894: !argument string('(' argument ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__40;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* argument */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_41;
}
static void cont__compiler__function_call__to_string_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* argument */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_42(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 895: ... string(argument '.' functor_string)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* argument */;
  arguments->slots[1] = character__46;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_43;
}
static void cont__compiler__function_call__to_string_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 895: -> string(argument '.' functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_26(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // return__3: 0
  // arguments: 1
  // functor_string: 2
  // argument: 3
  frame->slots[0] /* return__3 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[2]; /* functor_string */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  frame->slots[3] /* argument */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 886: $argument arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* arguments */;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_27;
}
static void cont__compiler__function_call__to_string_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* argument */, arguments->slots[0]);
  // 888: functor_string.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* functor_string */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_28;
}
static void cont__compiler__function_call__to_string_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 889: -> string(argument '/' functor_string)
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_29, 0);
  // 890: -> string(argument '/')
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_31, 0);
  // 887: if
  // 888:   functor_string.is_defined
  // 889:   -> string(argument '/' functor_string)
  // 890:   -> string(argument '/')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  arguments->slots[2] = frame->slots[6] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_33;
}
static void entry__compiler__function_call__to_string_29(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // argument: 0
  // functor_string: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[2]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 889: ... string(argument '/' functor_string)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  arguments->slots[1] = character__47;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_30;
}
static void cont__compiler__function_call__to_string_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 889: -> string(argument '/' functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_31(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // argument: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* argument */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 890: ... string(argument '/')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  arguments->slots[1] = character__47;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_32;
}
static void cont__compiler__function_call__to_string_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 890: -> string(argument '/')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_33(void) {
  myself = frame->slots[0] /* return__3 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_24(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 884: ... self.is_a_method_definition
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_method_definition();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_25;
}
static void cont__compiler__function_call__to_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 884: ... :
  // 885:   %line_width UNLIMITED # force inline output
  // 886:   $argument arguments(1)
  // 887:   if
  // 888:     functor_string.is_defined
  // 889:     -> string(argument '/' functor_string)
  // 890:     -> string(argument '/')
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_26, 0);
  // 884: -> self.is_a_method_definition:
  // 885:   %line_width UNLIMITED # force inline output
  // 886:   $argument arguments(1)
  // 887:   if
  // 888:     functor_string.is_defined
  // 889:     -> string(argument '/' functor_string)
  // 890:     -> string(argument '/')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_34(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // self: 0
  // arguments: 1
  // functor_string: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 891: ... self.is_an_attribute_access
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_an_attribute_access();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_35;
}
static void cont__compiler__function_call__to_string_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 891: ... :
  // 892:   $$argument arguments(1)
  // 893:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 894:     !argument string('(' argument ')')
  // 895:   -> string(argument '.' functor_string)
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_36, 0);
  // 891: -> self.is_an_attribute_access:
  // 892:   $$argument arguments(1)
  // 893:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 894:     !argument string('(' argument ')')
  // 895:   -> string(argument '.' functor_string)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_44(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // functor_string: 0
  // self: 1
  // arguments: 2
  // default_call: 3
  // functor: 4
  frame->slots[0] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[3] = myself->closure.frame->slots[4]; /* default_call */
  frame->slots[4] = myself->closure.frame->slots[2]; /* functor */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 896: ... any_of(functor_string is_a_letter)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = get__is_a_letter();
  result_count = 1;
  myself = get__any_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_45;
}
static void cont__compiler__function_call__to_string_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 896: ... :
  // 897:   cond
  // 898:     -> self.is_in_infix_notation:
  // 899:       $left_argument arguments(1)
  // 900:       $right_argument arguments(2)
  // 901:       $$left left_argument.to_string
  // 902:       $$right right_argument.to_string
  // 903:       if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:         !left string('(' left ')')
  // 905:       if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_46, 0);
  // 896: -> any_of(functor_string is_a_letter):
  // 897:   cond
  // 898:     -> self.is_in_infix_notation:
  // 899:       $left_argument arguments(1)
  // 900:       $right_argument arguments(2)
  // 901:       $$left left_argument.to_string
  // 902:       $$right right_argument.to_string
  // 903:       if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:         !left string('(' left ')')
  // 905:       if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_122(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // indent: 0
  // arguments: 1
  // functor_string: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[5]; /* arguments */
  frame->slots[2] = myself->closure.frame->slots[3]; /* functor_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 925: ... :
  // 926:   %expression_indent indent+2
  // 927:   if
  // 928:     length_of(arguments) == 1:
  // 929:       $argument arguments(1)
  // 930:       if
  // 931:         precedence_of(argument) < HIGHEST_PRECEDENCE
  // 932:         -> string(functor_string '(' argument ')')
  // 933:         -> string(functor_string argument)
  // 934:     :
  // ...
  frame->slots[3] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_123, 0);
  // 925: -> true:
  // 926:   %expression_indent indent+2
  // 927:   if
  // 928:     length_of(arguments) == 1:
  // 929:       $argument arguments(1)
  // 930:       if
  // 931:         precedence_of(argument) < HIGHEST_PRECEDENCE
  // 932:         -> string(functor_string '(' argument ')')
  // 933:         -> string(functor_string argument)
  // 934:     :
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_1(void) {
  allocate_initialized_frame_gc(1, 10);
  // slot allocations:
  // self: 0
  // indent: 1
  // functor: 2
  // functor_string: 3
  // default_call: 4
  // arguments: 5
  frame->slots[4] /* default_call */ = create_future();
  // _define $indent expression_indent
  frame->slots[1] /* indent */ = get__expression_indent();
  frame->slots[2] /* functor */ = create_future();
  frame->slots[3] /* functor_string */ = create_cell();
  frame->slots[5] /* arguments */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 868: ... :
  // 869:   %expression_indent indent+2
  // 870:   
  // 871:   $arguments_string
  // 872:     arguments_to_string
  // 873:       self
  // 874:       FUNC
  // 875:       line_width-indent-length_of(functor_string)-2
  // 876:   
  // 877:   if
  // ...
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_2, 0);
  // 868: $default_call:
  // 869:   %expression_indent indent+2
  // 870:   
  // 871:   $arguments_string
  // 872:     arguments_to_string
  // 873:       self
  // 874:       FUNC
  // 875:       line_width-indent-length_of(functor_string)-2
  // 876:   
  // 877:   if
  // ...
  initialize_future(frame->slots[4] /* default_call */, frame->slots[6] /* temp__1 */);
  // 859: $functor functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_16;
}
static void entry__compiler__function_call__to_string_2(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // return__2: 0
  // indent: 1
  // self: 2
  // functor_string: 3
  // arguments_string: 4
  frame->slots[0] /* return__2 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[3]; /* functor_string */
  define__expression_indent(create_future());
  frame->slots[4] /* arguments_string */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 869: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_3;
}
static void cont__compiler__function_call__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 875: line_width-indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_4;
}
static void cont__compiler__function_call__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 875: ... length_of(functor_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* functor_string */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_5;
}
static void cont__compiler__function_call__to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__4 */ = arguments->slots[0];
  // 875: line_width-indent-length_of(functor_string)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_6;
}
static void cont__compiler__function_call__to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 875: line_width-indent-length_of(functor_string)-2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_7;
}
static void cont__compiler__function_call__to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 871: $arguments_string
  // 872:   arguments_to_string
  // 873:     self
  // 874:     FUNC
  // 875:     line_width-indent-length_of(functor_string)-2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  arguments->slots[1] = var._FUNC;
  arguments->slots[2] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = var._arguments_to_string;
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_8;
}
static void cont__compiler__function_call__to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* arguments_string */, arguments->slots[0]);
  // 878: arguments_string .contains. '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* arguments_string */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__contains();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_9;
}
static void cont__compiler__function_call__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 879: -> string('@nl;' spaces(indent) functor_string arguments_string)
  frame->slots[6] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_10, 0);
  // 880: -> string(functor_string '(' arguments_string ')')
  frame->slots[7] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_13, 0);
  // 877: if
  // 878:   arguments_string .contains. '@nl;'
  // 879:   -> string('@nl;' spaces(indent) functor_string arguments_string)
  // 880:   -> string(functor_string '(' arguments_string ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  arguments->slots[2] = frame->slots[7] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_15;
}
static void entry__compiler__function_call__to_string_10(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // indent: 0
  // functor_string: 1
  // arguments_string: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[2] = myself->closure.frame->slots[4]; /* arguments_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 879: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_11;
}
static void cont__compiler__function_call__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 879: ... string('@nl;' spaces(indent) functor_string arguments_string)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = ((CELL *)frame->slots[1])->contents /* functor_string */;
  arguments->slots[3] = frame->slots[2] /* arguments_string */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_12;
}
static void cont__compiler__function_call__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 879: -> string('@nl;' spaces(indent) functor_string arguments_string)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_13(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // functor_string: 0
  // arguments_string: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* functor_string */
  frame->slots[1] = myself->closure.frame->slots[4]; /* arguments_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 880: ... string(functor_string '(' arguments_string ')')
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* functor_string */;
  arguments->slots[1] = character__40;
  arguments->slots[2] = frame->slots[1] /* arguments_string */;
  arguments->slots[3] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_14;
}
static void cont__compiler__function_call__to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 880: -> string(functor_string '(' arguments_string ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_15(void) {
  myself = frame->slots[0] /* return__2 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* functor */, arguments->slots[0]);
  // 863: functor.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* functor */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_17;
}
static void cont__compiler__function_call__to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 863: ... :
  // 864:   %line_width UNLIMITED # force inline output
  // 865:   to_string functor_of(self)
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_18, 0);
  // 861: $$functor_string
  // 862:   if
  // 863:     functor.is_defined:
  // 864:       %line_width UNLIMITED # force inline output
  // 865:       to_string functor_of(self)
  // 866:     -> undefined
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = func__compiler__function_call__to_string_21;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_22;
}
static void entry__compiler__function_call__to_string_18(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // return__1: 0
  // self: 1
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 865: ... functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__functor_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_19;
}
static void cont__compiler__function_call__to_string_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 865: to_string functor_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_20;
}
static void cont__compiler__function_call__to_string_20(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__compiler__function_call__to_string_21(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 866: -> undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__undefined();
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__function_call__to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* functor_string */ = arguments->slots[0];
  // 882: $arguments arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__function_call__to_string_23;
}
static void cont__compiler__function_call__to_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* arguments */, arguments->slots[0]);
  // 884: -> self.is_a_method_definition:
  // 885:   %line_width UNLIMITED # force inline output
  // 886:   $argument arguments(1)
  // 887:   if
  // 888:     functor_string.is_defined
  // 889:     -> string(argument '/' functor_string)
  // 890:     -> string(argument '/')
  frame->slots[6] /* temp__1 */ = create_closure(entry__compiler__function_call__to_string_24, 0);
  // 891: -> self.is_an_attribute_access:
  // 892:   $$argument arguments(1)
  // 893:   if precedence_of(argument) < HIGHEST_PRECEDENCE:
  // 894:     !argument string('(' argument ')')
  // 895:   -> string(argument '.' functor_string)
  frame->slots[7] /* temp__2 */ = create_closure(entry__compiler__function_call__to_string_34, 0);
  // 896: -> any_of(functor_string is_a_letter):
  // 897:   cond
  // 898:     -> self.is_in_infix_notation:
  // 899:       $left_argument arguments(1)
  // 900:       $right_argument arguments(2)
  // 901:       $$left left_argument.to_string
  // 902:       $$right right_argument.to_string
  // 903:       if precedence_of(left_argument) < INFIX_PRECEDENCE:
  // 904:         !left string('(' left ')')
  // 905:       if precedence_of(right_argument) <= INFIX_PRECEDENCE:
  // ...
  frame->slots[8] /* temp__3 */ = create_closure(entry__compiler__function_call__to_string_44, 0);
  // 925: -> true:
  // 926:   %expression_indent indent+2
  // 927:   if
  // 928:     length_of(arguments) == 1:
  // 929:       $argument arguments(1)
  // 930:       if
  // 931:         precedence_of(argument) < HIGHEST_PRECEDENCE
  // 932:         -> string(functor_string '(' argument ')')
  // 933:         -> string(functor_string argument)
  // 934:     :
  // ...
  frame->slots[9] /* temp__4 */ = create_closure(entry__compiler__function_call__to_string_122, 0);
  // 883: cond
  // 884:   -> self.is_a_method_definition:
  // 885:     %line_width UNLIMITED # force inline output
  // 886:     $argument arguments(1)
  // 887:     if
  // 888:       functor_string.is_defined
  // 889:       -> string(argument '/' functor_string)
  // 890:       -> string(argument '/')
  // 891:   -> self.is_an_attribute_access:
  // 892:     $$argument arguments(1)
  // ...
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  arguments->slots[2] = frame->slots[8] /* temp__3 */;
  arguments->slots[3] = frame->slots[9] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__remark_argument__to_string_5(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // remark_lines: 0
  // buf: 1
  // indentation: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  frame->slots[1] /* buf */ = create_cell();
  frame->slots[2] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1018: $$buf "@nl;"
  ((CELL *)frame->slots[1])->contents /* buf */ = string__578a5af303e9ceb;
  // 1019: ... expression_indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_6;
}
static void cont__compiler__remark_argument__to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1019: $indentation spaces(expression_indent+2)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_7;
}
static void cont__compiler__remark_argument__to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* indentation */, arguments->slots[0]);
  // 1020: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_8;
}
static void cont__compiler__remark_argument__to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1020: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_9;
}
static void cont__compiler__remark_argument__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1020: write_to &buf spaces(expression_indent) '#' remark_lines(1)
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = character__35;
  arguments->slots[3] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_10;
}
static void cont__compiler__remark_argument__to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1021: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_11;
}
static void cont__compiler__remark_argument__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1021: ... : (remark_line)
  // 1022:   write_to &buf '@nl;' indentation remark_line
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__remark_argument__to_string_12, 1);
  // 1021: for_each_from_to remark_lines 2 -1: (remark_line)
  // 1022:   write_to &buf '@nl;' indentation remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* remark_lines */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  arguments->slots[3] = frame->slots[4] /* temp__2 */;
  result_count = 0;
  myself = get__for_each_from_to();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_14;
}
static void entry__compiler__remark_argument__to_string_12(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // remark_line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1022: write_to &buf '@nl;' indentation remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[2] /* indentation */;
  arguments->slots[3] = frame->slots[0] /* remark_line */;
  result_count = 1;
  myself = get__write_to();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_13;
}
static void cont__compiler__remark_argument__to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__remark_argument__to_string_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1023: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_argument__to_string_15(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // remark_lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* remark_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1024: ... remark_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[0] /* remark_lines */;
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_16;
}
static void cont__compiler__remark_argument__to_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1024: ... "#@(remark_lines(1))"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc2;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_17;
}
static void cont__compiler__remark_argument__to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1024: -> "#@(remark_lines(1))"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__remark_argument__to_string_1(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // self: 0
  // remark_lines: 1
  frame->slots[1] /* remark_lines */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1015: $remark_lines remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_2;
}
static void cont__compiler__remark_argument__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* remark_lines */, arguments->slots[0]);
  // 1017: length_of(remark_lines)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* remark_lines */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_3;
}
static void cont__compiler__remark_argument__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1017: length_of(remark_lines) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__remark_argument__to_string_4;
}
static void cont__compiler__remark_argument__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1017: ... :
  // 1018:   $$buf "@nl;"
  // 1019:   $indentation spaces(expression_indent+2)
  // 1020:   write_to &buf spaces(expression_indent) '#' remark_lines(1)
  // 1021:   for_each_from_to remark_lines 2 -1: (remark_line)
  // 1022:     write_to &buf '@nl;' indentation remark_line
  // 1023:   -> buf
  frame->slots[4] /* temp__3 */ = create_closure(entry__compiler__remark_argument__to_string_5, 0);
  // 1024: -> "#@(remark_lines(1))"
  frame->slots[5] /* temp__4 */ = create_closure(entry__compiler__remark_argument__to_string_15, 0);
  // 1016: if
  // 1017:   length_of(remark_lines) > 1:
  // 1018:     $$buf "@nl;"
  // 1019:     $indentation spaces(expression_indent+2)
  // 1020:     write_to &buf spaces(expression_indent) '#' remark_lines(1)
  // 1021:     for_each_from_to remark_lines 2 -1: (remark_line)
  // 1022:       write_to &buf '@nl;' indentation remark_line
  // 1023:     -> buf
  // 1024:   -> "#@(remark_lines(1))"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__backquoted__to_string_1(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1029: ... node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__compiler__backquoted__to_string_2;
}
static void cont__compiler__backquoted__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1029: ... string('`' node::text_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__96;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__backquoted__to_string_3;
}
static void cont__compiler__backquoted__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1029: ... -> string('`' node::text_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__pair_to_string_2(void) {
  allocate_initialized_frame_gc(4, 11);
  // slot allocations:
  // return__1: 0
  // indent: 1
  // self: 2
  // symbol: 3
  // identifier: 4
  // arguments: 5
  // pair: 6
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[2]; /* indent */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  frame->slots[3] = myself->closure.frame->slots[1]; /* symbol */
  define__expression_indent(create_future());
  frame->slots[4] /* identifier */ = create_future();
  define__line_end_expression_width(create_future());
  frame->slots[5] /* arguments */ = create_future();
  frame->slots[6] /* pair */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1037: %expression_indent indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__pair_to_string_3;
}
static void cont__pair_to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__expression_indent(), arguments->slots[0]);
  // 1038: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__pair_to_string_4;
}
static void cont__pair_to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1038: ... default_value(identifier_of(self) "")
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__default_value();
  func = myself->type;
  frame->cont = cont__pair_to_string_5;
}
static void cont__pair_to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1038: $identifier default_value(identifier_of(self) "").to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__pair_to_string_6;
}
static void cont__pair_to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* identifier */, arguments->slots[0]);
  // 1039: ... line_width-indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = frame->slots[1] /* indent */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__pair_to_string_7;
}
static void cont__pair_to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1039: ... length_of(identifier)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* identifier */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__pair_to_string_8;
}
static void cont__pair_to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1039: ... length_of(identifier)+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__pair_to_string_9;
}
static void cont__pair_to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1039: %line_end_expression_width line_width-indent-(length_of(identifier)+2)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__pair_to_string_10;
}
static void cont__pair_to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(get__line_end_expression_width(), arguments->slots[0]);
  // 1040: $arguments arguments_to_string(self PROC line_end_expression_width)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  arguments->slots[1] = var._PROC;
  arguments->slots[2] = get__line_end_expression_width();
  result_count = 1;
  myself = var._arguments_to_string;
  func = myself->type;
  frame->cont = cont__pair_to_string_11;
}
static void cont__pair_to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* arguments */, arguments->slots[0]);
  // 1041: $pair string(symbol identifier arguments)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* symbol */;
  arguments->slots[1] = frame->slots[4] /* identifier */;
  arguments->slots[2] = frame->slots[5] /* arguments */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__pair_to_string_12;
}
static void cont__pair_to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* pair */, arguments->slots[0]);
  // 1043: arguments(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[5] /* arguments */;
  func = myself->type;
  frame->cont = cont__pair_to_string_13;
}
static void cont__pair_to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1043: arguments(1) == '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__pair_to_string_14;
}
static void cont__pair_to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1044: -> string('@nl;' spaces(indent) pair)
  frame->slots[9] /* temp__3 */ = create_closure(entry__pair_to_string_15, 0);
  // 1045: -> pair
  frame->slots[10] /* temp__4 */ = create_closure(entry__pair_to_string_18, 0);
  // 1042: if
  // 1043:   arguments(1) == '@nl;'
  // 1044:   -> string('@nl;' spaces(indent) pair)
  // 1045:   -> pair
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__pair_to_string_19;
}
static void entry__pair_to_string_15(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // indent: 0
  // pair: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* indent */
  frame->slots[1] = myself->closure.frame->slots[6]; /* pair */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1044: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__pair_to_string_16;
}
static void cont__pair_to_string_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1044: ... string('@nl;' spaces(indent) pair)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  arguments->slots[2] = frame->slots[1] /* pair */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__pair_to_string_17;
}
static void cont__pair_to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1044: -> string('@nl;' spaces(indent) pair)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__pair_to_string_18(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // pair: 0
  frame->slots[0] = myself->closure.frame->slots[6]; /* pair */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1045: -> pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* pair */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__pair_to_string_19(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__pair_to_string_1(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // self: 0
  // symbol: 1
  // indent: 2
  // _define $indent expression_indent
  frame->slots[2] /* indent */ = get__expression_indent();
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1036: ... :
  // 1037:   %expression_indent indent+2
  // 1038:   $identifier default_value(identifier_of(self) "").to_string
  // 1039:   %line_end_expression_width line_width-indent-(length_of(identifier)+2)
  // 1040:   $arguments arguments_to_string(self PROC line_end_expression_width)
  // 1041:   $pair string(symbol identifier arguments)
  // 1042:   if
  // 1043:     arguments(1) == '@nl;'
  // 1044:     -> string('@nl;' spaces(indent) pair)
  // 1045:     -> pair
  frame->slots[3] /* temp__1 */ = create_closure(entry__pair_to_string_2, 0);
  // 1036: do:
  // 1037:   %expression_indent indent+2
  // 1038:   $identifier default_value(identifier_of(self) "").to_string
  // 1039:   %line_end_expression_width line_width-indent-(length_of(identifier)+2)
  // 1040:   $arguments arguments_to_string(self PROC line_end_expression_width)
  // 1041:   $pair string(symbol identifier arguments)
  // 1042:   if
  // 1043:     arguments(1) == '@nl;'
  // 1044:     -> string('@nl;' spaces(indent) pair)
  // 1045:     -> pair
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__attribute_value_pair__to_string_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1047: ... pair_to_string self '.'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = character__46;
  result_count = frame->caller_result_count;
  myself = var._pair_to_string;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__attribute_function_pair__to_string_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1049: ... pair_to_string self '/'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  arguments->slots[1] = character__47;
  result_count = frame->caller_result_count;
  myself = var._pair_to_string;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__numeric_literal__to_string_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1054: ... node::value_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__value_of();
  func = myself->type;
  frame->cont = cont__compiler__numeric_literal__to_string_2;
}
static void cont__compiler__numeric_literal__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1054: ... -> node::value_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__create_character_table_1(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1062: !character_to_name empty_table
  var._character_to_name = get__empty_table();
  // 1063: for_each character_names: (name chr)
  // 1064:   if chr < '@0x80;' || chr == '@nbsp;': !character_to_name(chr) name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__character_names();
  arguments->slots[1] = func__create_character_table_2;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__create_character_table_9;
}
static void entry__create_character_table_7(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // chr: 0
  // name: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1064: ... !character_to_name(chr)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = frame->slots[1] /* name */;
  result_count = 1;
  myself = var._character_to_name;
  func = myself->type;
  frame->cont = cont__create_character_table_8;
}
static void cont__create_character_table_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  var._character_to_name = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__create_character_table_2(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // name: 0
  // chr: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1064: ... chr < '@0x80;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = character__128;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__create_character_table_3;
}
static void cont__create_character_table_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1064: ... chr == '@nbsp;'
  frame->slots[4] /* temp__3 */ = create_closure(entry__create_character_table_4, 0);
  // 1064: ... chr < '@0x80;' || chr == '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__create_character_table_6;
}
static void entry__create_character_table_4(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1064: ... chr == '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__160;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__create_character_table_5;
}
static void cont__create_character_table_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1064: ... chr == '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__create_character_table_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1064: ... : !character_to_name(chr) name
  frame->slots[5] /* temp__4 */ = create_closure(entry__create_character_table_7, 0);
  // 1064: if chr < '@0x80;' || chr == '@nbsp;': !character_to_name(chr) name
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__create_character_table_9(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1068: !character_to_name(' ')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__32;
  arguments->slots[1] = get__undefined();
  result_count = 1;
  myself = var._character_to_name;
  func = myself->type;
  frame->cont = cont__create_character_table_10;
}
static void cont__create_character_table_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  var._character_to_name = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_33(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // numerical_encoding: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* numerical_encoding */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1097: ... numerical_encoding()
  argument_count = 0;
  arguments = node_p;
  result_count = 1;
  myself = frame->slots[0] /* numerical_encoding */;
  func = myself->type;
  frame->cont = cont__escaped_character_34;
}
static void cont__escaped_character_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1097: -> numerical_encoding()
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_35(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1098: ... chr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__escaped_character_36;
}
static void cont__escaped_character_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1098: -> chr.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_15(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1093: ... string('@@' name ';')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__64;
  arguments->slots[1] = frame->slots[0] /* name */;
  arguments->slots[2] = character__59;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__escaped_character_16;
}
static void cont__escaped_character_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1093: -> string('@@' name ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_18(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1090: -> "@@@@"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e5082b85;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_21(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1092: -> "&"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9cc7;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_14(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // name: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* name */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1093: -> string('@@' name ';')
  frame->slots[1] /* temp__1 */ = create_closure(entry__escaped_character_15, 0);
  // 1088: case name
  // 1089:   "at"
  // 1090:   -> "@@@@"
  // 1091:   "amp"
  // 1092:   -> "&"
  // 1093:   -> string('@@' name ';')
  argument_count = 6;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* name */;
  arguments->slots[1] = string__2d7981f4e4002bb1;
  arguments->slots[2] = func__escaped_character_18;
  arguments->slots[3] = string__fa720015d416bbc;
  arguments->slots[4] = func__escaped_character_21;
  arguments->slots[5] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__escaped_character_22(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // chr: 0
  // numerical_encoding: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[1]; /* numerical_encoding */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1096: chr >= '@0x2b0;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__688;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__escaped_character_23;
}
static void cont__escaped_character_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1096: chr >= '@0x2b0;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__escaped_character_24;
}
static void cont__escaped_character_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1096: ... chr >= '@0x80;' && chr <= '@nbsp;'
  frame->slots[5] /* temp__4 */ = create_closure(entry__escaped_character_25, 0);
  // 1096: chr >= '@0x2b0;' || chr >= '@0x80;' && chr <= '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__escaped_character_32;
}
static void entry__escaped_character_25(void) {
  allocate_initialized_frame_gc(1, 5);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1096: ... chr >= '@0x80;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__128;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__escaped_character_26;
}
static void cont__escaped_character_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1096: ... chr >= '@0x80;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__escaped_character_27;
}
static void cont__escaped_character_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1096: ... chr <= '@nbsp;'
  frame->slots[4] /* temp__4 */ = create_closure(entry__escaped_character_28, 0);
  // 1096: ... chr >= '@0x80;' && chr <= '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__escaped_character_31;
}
static void entry__escaped_character_28(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1096: ... chr <= '@nbsp;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__160;
  arguments->slots[1] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__escaped_character_29;
}
static void cont__escaped_character_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1096: ... chr <= '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__escaped_character_30;
}
static void cont__escaped_character_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1096: ... chr <= '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__escaped_character_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1096: ... chr >= '@0x80;' && chr <= '@nbsp;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__escaped_character_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1097: -> numerical_encoding()
  frame->slots[6] /* temp__5 */ = create_closure(entry__escaped_character_33, 0);
  // 1098: -> chr.to_string
  frame->slots[7] /* temp__6 */ = create_closure(entry__escaped_character_35, 0);
  // 1095: if
  // 1096:   chr >= '@0x2b0;' || chr >= '@0x80;' && chr <= '@nbsp;'
  // 1097:   -> numerical_encoding()
  // 1098:   -> chr.to_string
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  arguments->slots[2] = frame->slots[7] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__escaped_character_2(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // chr: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1078: ... chr.to_integer
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = get__to_integer();
  func = myself->type;
  frame->cont = cont__escaped_character_3;
}
static void cont__escaped_character_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1078: ... hex(chr.to_integer)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__hex();
  func = myself->type;
  frame->cont = cont__escaped_character_4;
}
static void cont__escaped_character_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1078: ... string("@@0x" hex(chr.to_integer) ';')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__fa728415fa96bb4;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = character__59;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__escaped_character_6;
}
static void cont__escaped_character_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1078: ... -> string("@@0x" hex(chr.to_integer) ';')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_7(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // numerical_encoding: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* numerical_encoding */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1082: ... numerical_encoding()
  argument_count = 0;
  arguments = node_p;
  result_count = 1;
  myself = frame->slots[0] /* numerical_encoding */;
  func = myself->type;
  frame->cont = cont__escaped_character_8;
}
static void cont__escaped_character_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1082: -> numerical_encoding()
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__escaped_character_9(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // chr: 0
  // numerical_encoding: 1
  // name: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[2]; /* numerical_encoding */
  frame->slots[2] /* name */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1084: ... character_to_name.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = var._character_to_name;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__escaped_character_10;
}
static void cont__escaped_character_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1084: unless character_to_name.is_defined create_character_table
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = var._create_character_table;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__escaped_character_11;
}
static void cont__escaped_character_11(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1085: $name character_to_name(chr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = var._character_to_name;
  func = myself->type;
  frame->cont = cont__escaped_character_12;
}
static void cont__escaped_character_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* name */, arguments->slots[0]);
  // 1087: name.is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* name */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__escaped_character_13;
}
static void cont__escaped_character_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1087: ... :
  // 1088:   case name
  // 1089:     "at"
  // 1090:     -> "@@@@"
  // 1091:     "amp"
  // 1092:     -> "&"
  // 1093:     -> string('@@' name ';')
  frame->slots[4] /* temp__2 */ = create_closure(entry__escaped_character_14, 0);
  // 1094: :
  // 1095:   if
  // 1096:     chr >= '@0x2b0;' || chr >= '@0x80;' && chr <= '@nbsp;'
  // 1097:     -> numerical_encoding()
  // 1098:     -> chr.to_string
  frame->slots[5] /* temp__3 */ = create_closure(entry__escaped_character_22, 0);
  // 1086: if
  // 1087:   name.is_defined:
  // 1088:     case name
  // 1089:       "at"
  // 1090:       -> "@@@@"
  // 1091:       "amp"
  // 1092:       -> "&"
  // 1093:       -> string('@@' name ';')
  // 1094:   :
  // 1095:     if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__escaped_character_1(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // chr: 0
  // use_numerical_encoding: 1
  // numerical_encoding: 2
  frame->slots[2] /* numerical_encoding */ = create_future();
  if (argument_count < 1) {
    too_few_arguments_error();
    return;
  }
  if (argument_count > 2) {
    too_many_arguments_error();
    return;
  }
  switch(argument_count) {
    default: frame->slots[1] /* use_numerical_encoding */ = arguments->slots[1];
    case 1:;
  }
  switch(argument_count) {
    case 1: frame->slots[1] /* use_numerical_encoding */ = get__false();
  }
  // 1078: ... -> string("@@0x" hex(chr.to_integer) ';')
  frame->slots[3] /* temp__1 */ = create_closure(entry__escaped_character_2, 0);
  // 1078: $numerical_encoding -> string("@@0x" hex(chr.to_integer) ';')
  initialize_future(frame->slots[2] /* numerical_encoding */, frame->slots[3] /* temp__1 */);
  // 1082: -> numerical_encoding()
  frame->slots[3] /* temp__1 */ = create_closure(entry__escaped_character_7, 0);
  // 1083: :
  // 1084:   unless character_to_name.is_defined create_character_table
  // 1085:   $name character_to_name(chr)
  // 1086:   if
  // 1087:     name.is_defined:
  // 1088:       case name
  // 1089:         "at"
  // 1090:         -> "@@@@"
  // 1091:         "amp"
  // 1092:         -> "&"
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__escaped_character_9, 0);
  // 1080: if
  // 1081:   use_numerical_encoding
  // 1082:   -> numerical_encoding()
  // 1083:   :
  // 1084:     unless character_to_name.is_defined create_character_table
  // 1085:     $name character_to_name(chr)
  // 1086:     if
  // 1087:       name.is_defined:
  // 1088:         case name
  // 1089:           "at"
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* use_numerical_encoding */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__character_literal__to_string_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1103: ... node::value_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__value_of();
  func = myself->type;
  frame->cont = cont__compiler__character_literal__to_string_2;
}
static void cont__compiler__character_literal__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1103: ... self.is_in_numeric_notation
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_in_numeric_notation();
  func = myself->type;
  frame->cont = cont__compiler__character_literal__to_string_3;
}
static void cont__compiler__character_literal__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1103: escaped_character(node::value_of(self) self.is_in_numeric_notation)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = var._escaped_character;
  func = myself->type;
  frame->cont = cont__compiler__character_literal__to_string_4;
}
static void cont__compiler__character_literal__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1101: string
  // 1102:   '@apos;'
  // 1103:   escaped_character(node::value_of(self) self.is_in_numeric_notation)
  // 1104:   '@apos;'
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__39;
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  arguments->slots[2] = character__39;
  result_count = frame->caller_result_count;
  myself = get__string();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__analyze_string_literal_1(void) {
  allocate_initialized_frame_gc(2, 10);
  // slot allocations:
  // text: 0
  // return: 1
  // lines: 2
  // is_inline: 3
  // use_single_line_form: 4
  // part: 5
  // s: 6
  frame->slots[1] /* return */ = create_continuation_with_exit(exit__analyze_string_literal_1);
  frame->slots[4] /* use_single_line_form */ = create_future();
  frame->slots[5] /* part */ = create_cell();
  frame->slots[6] /* s */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[2] /* lines */ = create_cell();
  frame->slots[3] /* is_inline */ = create_cell();
  // 1116: !is_inline true
  ((CELL *)frame->slots[3])->contents /* is_inline */ = get__true();
  // 1117: ... text == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_2;
}
static void cont__analyze_string_literal_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1117: ... :
  // 1118:   !lines list("")
  // 1119:   return
  frame->slots[8] /* temp__2 */ = create_closure(entry__analyze_string_literal_3, 0);
  // 1117: if text == "":
  // 1118:   !lines list("")
  // 1119:   return
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_5;
}
static void entry__analyze_string_literal_3(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // return: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1118: !lines list("")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = empty_string;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_4;
}
static void cont__analyze_string_literal_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1119: return
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__analyze_string_literal_5(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1120: ... some('@nl;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = character__10;
  result_count = 1;
  myself = get__some();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_6;
}
static void cont__analyze_string_literal_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1120: ... text .matches. some('@nl;')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__matches();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_7;
}
static void cont__analyze_string_literal_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1120: ... :
  // 1121:   # strings containing *only* newlines are always printed in inline form
  // 1122:   
  // 1123:   !lines list(dup("@@nl;" length_of(text)))
  // 1124:   return
  frame->slots[9] /* temp__3 */ = create_closure(entry__analyze_string_literal_8, 0);
  // 1120: if text .matches. some('@nl;'):
  // 1121:   # strings containing *only* newlines are always printed in inline form
  // 1122:   
  // 1123:   !lines list(dup("@@nl;" length_of(text)))
  // 1124:   return
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_13;
}
static void entry__analyze_string_literal_8(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // lines: 0
  // text: 1
  // return: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* text */
  frame->slots[2] = myself->closure.frame->slots[1]; /* return */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1123: ... length_of(text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_9;
}
static void cont__analyze_string_literal_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1123: ... dup("@@nl;" length_of(text))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = string__420aeacb5d007d02;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__dup();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_11;
}
static void cont__analyze_string_literal_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1123: !lines list(dup("@@nl;" length_of(text)))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__list();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_12;
}
static void cont__analyze_string_literal_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1124: return
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[2] /* return */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__analyze_string_literal_13(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1125: !lines empty_list
  ((CELL *)frame->slots[2])->contents /* lines */ = get__empty_list();
  // 1126: ... line_width == UNLIMITED
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = var._UNLIMITED;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_14;
}
static void cont__analyze_string_literal_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1126: ... length_of(text) <= 3
  frame->slots[8] /* temp__2 */ = create_closure(entry__analyze_string_literal_15, 0);
  // 1126: $use_single_line_form line_width == UNLIMITED || length_of(text) <= 3
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__or();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_19;
}
static void entry__analyze_string_literal_15(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // text: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* text */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1126: ... length_of(text)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_16;
}
static void cont__analyze_string_literal_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1126: ... length_of(text) <= 3
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__3;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_17;
}
static void cont__analyze_string_literal_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1126: ... length_of(text) <= 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_18;
}
static void cont__analyze_string_literal_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1126: ... length_of(text) <= 3
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__analyze_string_literal_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[4] /* use_single_line_form */, arguments->slots[0]);
  // 1127: $$part ""
  ((CELL *)frame->slots[5])->contents /* part */ = empty_string;
  // 1128: $$s 1
  ((CELL *)frame->slots[6])->contents /* s */ = number__1;
  // 1129: ... : (idx chr)
  // 1130:   case
  // 1131:     chr
  // 1132:     '@nl;':
  // 1133:       append &part range(text s idx-1)
  // 1134:       if
  // 1135:         use_single_line_form:
  // 1136:           # force single line string literal
  // 1137:           
  // 1138:           append &part "@@nl;"
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__analyze_string_literal_20, 2);
  // 1129: for_each text: (idx chr)
  // 1130:   case
  // 1131:     chr
  // 1132:     '@nl;':
  // 1133:       append &part range(text s idx-1)
  // 1134:       if
  // 1135:         use_single_line_form:
  // 1136:           # force single line string literal
  // 1137:           
  // 1138:           append &part "@@nl;"
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_56;
}
static void entry__analyze_string_literal_50(void) {
  allocate_initialized_frame_gc(5, 7);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  // escaped: 4
  frame->slots[0] = myself->closure.frame->slots[1]; /* part */
  frame->slots[1] = myself->closure.frame->slots[2]; /* text */
  frame->slots[2] = myself->closure.frame->slots[3]; /* s */
  frame->slots[3] = myself->closure.frame->slots[4]; /* idx */
  frame->slots[4] = myself->closure.frame->slots[5]; /* escaped */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1162: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_51;
}
static void cont__analyze_string_literal_51(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1162: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_52;
}
static void cont__analyze_string_literal_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1162: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_53;
}
static void cont__analyze_string_literal_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1163: append &part escaped
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[4] /* escaped */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_54;
}
static void cont__analyze_string_literal_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1164: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_55;
}
static void cont__analyze_string_literal_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_32(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* part */
  frame->slots[1] = myself->closure.frame->slots[2]; /* text */
  frame->slots[2] = myself->closure.frame->slots[3]; /* s */
  frame->slots[3] = myself->closure.frame->slots[4]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1146: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_33;
}
static void cont__analyze_string_literal_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1146: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_34;
}
static void cont__analyze_string_literal_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1146: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_35;
}
static void cont__analyze_string_literal_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1150: append &part "@@quot;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = string__721f5590811b42ec;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_37;
}
static void cont__analyze_string_literal_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1151: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_38;
}
static void cont__analyze_string_literal_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_39(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_inline: 0
  frame->slots[0] = myself->closure.frame->slots[5]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1153: !is_inline false
  ((CELL *)frame->slots[0])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_21(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  // use_single_line_form: 4
  // lines: 5
  frame->slots[0] = myself->closure.frame->slots[2]; /* part */
  frame->slots[1] = myself->closure.frame->slots[3]; /* text */
  frame->slots[2] = myself->closure.frame->slots[4]; /* s */
  frame->slots[3] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[4] = myself->closure.frame->slots[5]; /* use_single_line_form */
  frame->slots[5] = myself->closure.frame->slots[6]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1133: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_22;
}
static void cont__analyze_string_literal_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1133: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_23;
}
static void cont__analyze_string_literal_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1133: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_24;
}
static void cont__analyze_string_literal_24(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1135: ... :
  // 1136:   # force single line string literal
  // 1137:   
  // 1138:   append &part "@@nl;"
  frame->slots[6] /* temp__1 */ = create_closure(entry__analyze_string_literal_25, 0);
  // 1139: :
  // 1140:   push &lines part
  // 1141:   !part ""
  frame->slots[7] /* temp__2 */ = create_closure(entry__analyze_string_literal_27, 0);
  // 1134: if
  // 1135:   use_single_line_form:
  // 1136:     # force single line string literal
  // 1137:     
  // 1138:     append &part "@@nl;"
  // 1139:   :
  // 1140:     push &lines part
  // 1141:     !part ""
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* use_single_line_form */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_29;
}
static void entry__analyze_string_literal_25(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // part: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1138: append &part "@@nl;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = string__420aeacb5d007d02;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_26;
}
static void cont__analyze_string_literal_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_27(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1140: push &lines part
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_28;
}
static void cont__analyze_string_literal_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1141: !part ""
  ((CELL *)frame->slots[1])->contents /* part */ = empty_string;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__analyze_string_literal_29(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1142: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_30;
}
static void cont__analyze_string_literal_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_31(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // use_single_line_form: 0
  // part: 1
  // text: 2
  // s: 3
  // idx: 4
  // is_inline: 5
  frame->slots[0] = myself->closure.frame->slots[5]; /* use_single_line_form */
  frame->slots[1] = myself->closure.frame->slots[2]; /* part */
  frame->slots[2] = myself->closure.frame->slots[3]; /* text */
  frame->slots[3] = myself->closure.frame->slots[4]; /* s */
  frame->slots[4] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[5] = myself->closure.frame->slots[7]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1145: ... :
  // 1146:   append &part range(text s idx-1)
  // 1147:   
  // 1148:   # force single line string literal
  // 1149:   
  // 1150:   append &part "@@quot;"
  // 1151:   !s idx+1
  frame->slots[6] /* temp__1 */ = create_closure(entry__analyze_string_literal_32, 0);
  // 1152: :
  // 1153:   !is_inline false
  frame->slots[7] /* temp__2 */ = create_closure(entry__analyze_string_literal_39, 0);
  // 1144: if
  // 1145:   use_single_line_form:
  // 1146:     append &part range(text s idx-1)
  // 1147:     
  // 1148:     # force single line string literal
  // 1149:     
  // 1150:     append &part "@@quot;"
  // 1151:     !s idx+1
  // 1152:   :
  // 1153:     !is_inline false
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* use_single_line_form */;
  arguments->slots[1] = frame->slots[6] /* temp__1 */;
  arguments->slots[2] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__analyze_string_literal_40(void) {
  allocate_initialized_frame_gc(4, 6);
  // slot allocations:
  // part: 0
  // text: 1
  // s: 2
  // idx: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* part */
  frame->slots[1] = myself->closure.frame->slots[3]; /* text */
  frame->slots[2] = myself->closure.frame->slots[4]; /* s */
  frame->slots[3] = myself->closure.frame->slots[0]; /* idx */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1155: ... idx-1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_41;
}
static void cont__analyze_string_literal_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1155: ... range(text s idx-1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* s */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_42;
}
static void cont__analyze_string_literal_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1155: append &part range(text s idx-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_43;
}
static void cont__analyze_string_literal_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1156: append &part "@@@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = string__2d7981f4e5082b85;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_44;
}
static void cont__analyze_string_literal_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1157: !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* idx */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_45;
}
static void cont__analyze_string_literal_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* s */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_46(void) {
  allocate_initialized_frame_gc(5, 9);
  // slot allocations:
  // chr: 0
  // part: 1
  // text: 2
  // s: 3
  // idx: 4
  // escaped: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[2]; /* part */
  frame->slots[2] = myself->closure.frame->slots[3]; /* text */
  frame->slots[3] = myself->closure.frame->slots[4]; /* s */
  frame->slots[4] = myself->closure.frame->slots[0]; /* idx */
  frame->slots[5] /* escaped */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1160: $escaped escaped_character(chr)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  result_count = 1;
  myself = var._escaped_character;
  func = myself->type;
  frame->cont = cont__analyze_string_literal_47;
}
static void cont__analyze_string_literal_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[5] /* escaped */, arguments->slots[0]);
  // 1161: ... length_of(escaped)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* escaped */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_48;
}
static void cont__analyze_string_literal_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__2 */ = arguments->slots[0];
  // 1161: ... length_of(escaped) > 1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_49;
}
static void cont__analyze_string_literal_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1161: ... :
  // 1162:   append &part range(text s idx-1)
  // 1163:   append &part escaped
  // 1164:   !s idx+1
  frame->slots[8] /* temp__3 */ = create_closure(entry__analyze_string_literal_50, 0);
  // 1161: if length_of(escaped) > 1:
  // 1162:   append &part range(text s idx-1)
  // 1163:   append &part escaped
  // 1164:   !s idx+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__analyze_string_literal_20(void) {
  allocate_initialized_frame_gc(8, 12);
  // slot allocations:
  // idx: 0
  // chr: 1
  // part: 2
  // text: 3
  // s: 4
  // use_single_line_form: 5
  // lines: 6
  // is_inline: 7
  frame->slots[2] = myself->closure.frame->slots[5]; /* part */
  frame->slots[3] = myself->closure.frame->slots[0]; /* text */
  frame->slots[4] = myself->closure.frame->slots[6]; /* s */
  frame->slots[5] = myself->closure.frame->slots[4]; /* use_single_line_form */
  frame->slots[6] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[7] = myself->closure.frame->slots[3]; /* is_inline */
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  // 1132: ... :
  // 1133:   append &part range(text s idx-1)
  // 1134:   if
  // 1135:     use_single_line_form:
  // 1136:       # force single line string literal
  // 1137:       
  // 1138:       append &part "@@nl;"
  // 1139:     :
  // 1140:       push &lines part
  // 1141:       !part ""
  // ...
  frame->slots[8] /* temp__1 */ = create_closure(entry__analyze_string_literal_21, 0);
  // 1143: ... :
  // 1144:   if
  // 1145:     use_single_line_form:
  // 1146:       append &part range(text s idx-1)
  // 1147:       
  // 1148:       # force single line string literal
  // 1149:       
  // 1150:       append &part "@@quot;"
  // 1151:       !s idx+1
  // 1152:     :
  // ...
  frame->slots[9] /* temp__2 */ = create_closure(entry__analyze_string_literal_31, 0);
  // 1154: ... :
  // 1155:   append &part range(text s idx-1)
  // 1156:   append &part "@@@@"
  // 1157:   !s idx+1
  frame->slots[10] /* temp__3 */ = create_closure(entry__analyze_string_literal_40, 0);
  // 1159: ... :
  // 1160:   $escaped escaped_character(chr)
  // 1161:   if length_of(escaped) > 1:
  // 1162:     append &part range(text s idx-1)
  // 1163:     append &part escaped
  // 1164:     !s idx+1
  frame->slots[11] /* temp__4 */ = create_closure(entry__analyze_string_literal_46, 0);
  // 1130: case
  // 1131:   chr
  // 1132:   '@nl;':
  // 1133:     append &part range(text s idx-1)
  // 1134:     if
  // 1135:       use_single_line_form:
  // 1136:         # force single line string literal
  // 1137:         
  // 1138:         append &part "@@nl;"
  // 1139:       :
  // ...
  argument_count = 10;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* chr */;
  arguments->slots[1] = character__10;
  arguments->slots[2] = frame->slots[8] /* temp__1 */;
  arguments->slots[3] = character__34;
  arguments->slots[4] = frame->slots[9] /* temp__2 */;
  arguments->slots[5] = character__64;
  arguments->slots[6] = frame->slots[10] /* temp__3 */;
  arguments->slots[7] = character__39;
  arguments->slots[8] = get__pass();
  arguments->slots[9] = frame->slots[11] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__case();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__analyze_string_literal_56(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1165: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_57;
}
static void cont__analyze_string_literal_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1165: ... range(text s -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* text */;
  arguments->slots[1] = ((CELL *)frame->slots[6])->contents /* s */;
  arguments->slots[2] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_58;
}
static void cont__analyze_string_literal_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1165: append &part range(text s -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* part */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_59;
}
static void cont__analyze_string_literal_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[5])->contents /* part */ = arguments->slots[0];
  // 1167: part == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* part */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_60;
}
static void cont__analyze_string_literal_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1167: ... :
  // 1168:   # there must be a newline somewhere
  // 1169:   
  // 1170:   !is_inline false
  frame->slots[8] /* temp__2 */ = create_closure(entry__analyze_string_literal_61, 0);
  // 1171: :
  // 1172:   # if the current part is not empty there was no trainling newline
  // 1173:   
  // 1174:   $max_width # the maximum width is computed for multi-line-strings
  // 1175:     -
  // 1176:       max(line_width-expression_indent 20)
  // 1177:       if
  // 1178:         line_end_expression_width >= 2
  // 1179:         -> 0
  // 1180:         -> 2
  // ...
  frame->slots[9] /* temp__3 */ = create_closure(entry__analyze_string_literal_62, 0);
  // 1166: if
  // 1167:   part == "":
  // 1168:     # there must be a newline somewhere
  // 1169:     
  // 1170:     !is_inline false
  // 1171:   :
  // 1172:     # if the current part is not empty there was no trainling newline
  // 1173:     
  // 1174:     $max_width # the maximum width is computed for multi-line-strings
  // 1175:       -
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count =
    frame->caller_result_count >= 2 ?
    frame->caller_result_count-2 : -1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_85;
}
static void entry__analyze_string_literal_80(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1185: push &lines part
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_81;
}
static void cont__analyze_string_literal_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_82(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1187: ... string(part '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* part */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_83;
}
static void cont__analyze_string_literal_83(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1187: push &lines string(part '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_84;
}
static void cont__analyze_string_literal_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_61(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_inline: 0
  frame->slots[0] = myself->closure.frame->slots[3]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1170: !is_inline false
  ((CELL *)frame->slots[0])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_62(void) {
  allocate_initialized_frame_gc(3, 9);
  // slot allocations:
  // lines: 0
  // part: 1
  // is_inline: 2
  // max_width: 3
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[5]; /* part */
  frame->slots[2] = myself->closure.frame->slots[3]; /* is_inline */
  frame->slots[3] /* max_width */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1176: ... line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_63;
}
static void cont__analyze_string_literal_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1176: max(line_width-expression_indent 20)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = number__20;
  result_count = 1;
  myself = get__max();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_64;
}
static void cont__analyze_string_literal_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1178: line_end_expression_width >= 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_65;
}
static void cont__analyze_string_literal_65(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__5 */ = arguments->slots[0];
  // 1178: line_end_expression_width >= 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__5 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_66;
}
static void cont__analyze_string_literal_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__4 */ = arguments->slots[0];
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__4 */;
  arguments->slots[1] = func__analyze_string_literal_67;
  arguments->slots[2] = func__analyze_string_literal_68;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_69;
}
static void entry__analyze_string_literal_67(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1179: -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__analyze_string_literal_68(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1180: -> 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__analyze_string_literal_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1174: $max_width # the maximum width is computed for multi-line-strings
  // 1175:   -
  // 1176:     max(line_width-expression_indent 20)
  // 1177:     if
  // 1178:       line_end_expression_width >= 2
  // 1179:       -> 0
  // 1180:       -> 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_70;
}
static void cont__analyze_string_literal_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* max_width */, arguments->slots[0]);
  // 1182: ... lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_71;
}
static void cont__analyze_string_literal_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1182: ... length_of(part)+2 <= max_width
  frame->slots[6] /* temp__3 */ = create_closure(entry__analyze_string_literal_72, 0);
  // 1182: ... lines.is_empty && length_of(part)+2 <= max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_77;
}
static void entry__analyze_string_literal_72(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // max_width: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* max_width */
  frame->slots[1] = myself->closure.frame->slots[1]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1182: ... length_of(part)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_73;
}
static void cont__analyze_string_literal_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1182: ... length_of(part)+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_74;
}
static void cont__analyze_string_literal_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1182: ... length_of(part)+2 <= max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* max_width */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_75;
}
static void cont__analyze_string_literal_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1182: ... length_of(part)+2 <= max_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_76;
}
static void cont__analyze_string_literal_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1182: ... length_of(part)+2 <= max_width
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__analyze_string_literal_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1182: ... : !is_inline false
  frame->slots[7] /* temp__4 */ = create_closure(entry__analyze_string_literal_78, 0);
  // 1182: unless lines.is_empty && length_of(part)+2 <= max_width: !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__analyze_string_literal_79;
}
static void entry__analyze_string_literal_78(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // is_inline: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1182: ... !is_inline false
  ((CELL *)frame->slots[0])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__analyze_string_literal_79(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1184: ... :
  // 1185:   push &lines part
  frame->slots[4] /* temp__1 */ = create_closure(entry__analyze_string_literal_80, 0);
  // 1186: :
  // 1187:   push &lines string(part '@@')
  frame->slots[5] /* temp__2 */ = create_closure(entry__analyze_string_literal_82, 0);
  // 1183: if
  // 1184:   is_inline:
  // 1185:     push &lines part
  // 1186:   :
  // 1187:     push &lines string(part '@@')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* is_inline */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  arguments->slots[2] = frame->slots[5] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__analyze_string_literal_85(void) {
  myself = frame->slots[1] /* return */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void exit__analyze_string_literal_1(void) {
  frame = ((CONTINUATION *)myself)->exit_frame;
  int i = argument_count;
  while (--i >= 0) {
    arguments->slots[i+2] = arguments->slots[i];
  }
  argument_count += 2;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[3])->contents /* is_inline */;
  func = continuation_type_function;
}
static void entry__print_string_literal_15(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1197: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__print_string_literal_16;
}
static void cont__print_string_literal_16(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1197: ... string('@quot;' lines(1) '@quot;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__34;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = character__34;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__print_string_literal_17;
}
static void cont__print_string_literal_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1197: -> string('@quot;' lines(1) '@quot;')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_18(void) {
  allocate_initialized_frame_gc(1, 12);
  // slot allocations:
  // lines: 0
  // max_width: 1
  // has_leading_spaces: 2
  // split_lines: 3
  // buf: 4
  // indent: 5
  // indentation: 6
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] /* max_width */ = create_future();
  frame->slots[2] /* has_leading_spaces */ = create_cell();
  frame->slots[3] /* split_lines */ = create_cell();
  frame->slots[4] /* buf */ = create_cell();
  frame->slots[5] /* indent */ = create_cell();
  frame->slots[6] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1201: ... line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__print_string_literal_19;
}
static void cont__print_string_literal_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1201: max(line_width-expression_indent 20)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = number__20;
  result_count = 1;
  myself = get__max();
  func = myself->type;
  frame->cont = cont__print_string_literal_20;
}
static void cont__print_string_literal_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1203: line_end_expression_width >= 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__print_string_literal_21;
}
static void cont__print_string_literal_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[11] /* temp__5 */ = arguments->slots[0];
  // 1203: line_end_expression_width >= 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[11] /* temp__5 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_22;
}
static void cont__print_string_literal_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__4 */ = arguments->slots[0];
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__4 */;
  arguments->slots[1] = func__print_string_literal_23;
  arguments->slots[2] = func__print_string_literal_24;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_25;
}
static void entry__print_string_literal_23(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1204: -> 0
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__0;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_24(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1205: -> 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1199: $max_width # the maximum width is computed for multi-line-strings
  // 1200:   -
  // 1201:     max(line_width-expression_indent 20)
  // 1202:     if
  // 1203:       line_end_expression_width >= 2
  // 1204:       -> 0
  // 1205:       -> 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__print_string_literal_26;
}
static void cont__print_string_literal_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* max_width */, arguments->slots[0]);
  // 1207: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__print_string_literal_27;
}
static void cont__print_string_literal_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1207: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__print_string_literal_28;
}
static void cont__print_string_literal_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1207: ... lines(-1) != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_29;
}
static void cont__print_string_literal_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1207: $$has_leading_spaces lines(-1) != ""
  // 1208:   #
  // 1209:     if the last line is empty then it is replaced by "@;" and so there
  // 1210:     are no leading spaces
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_30;
}
static void cont__print_string_literal_30(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* has_leading_spaces */ = arguments->slots[0];
  // 1212: $$split_lines empty_list
  ((CELL *)frame->slots[3])->contents /* split_lines */ = get__empty_list();
  // 1213: ... : ($line)
  // 1214:   if line != "" && line(1) != ' ': !has_leading_spaces false
  // 1215:   while -> length_of(line) > max_width:
  // 1216:     # split long lines (if possible after a space)
  // 1217:     
  // 1218:     $skip_till_end_of_string:
  // 1219:       do_while:
  // 1220:         inc &pos
  // 1221:         if line(pos) == '@@':
  // 1222:           skip_special
  // ...
  frame->slots[7] /* temp__1 */ = create_closure(entry__print_string_literal_31, 1);
  // 1213: for_each lines: ($line)
  // 1214:   if line != "" && line(1) != ' ': !has_leading_spaces false
  // 1215:   while -> length_of(line) > max_width:
  // 1216:     # split long lines (if possible after a space)
  // 1217:     
  // 1218:     $skip_till_end_of_string:
  // 1219:       do_while:
  // 1220:         inc &pos
  // 1221:         if line(pos) == '@@':
  // 1222:           skip_special
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__print_string_literal_125;
}
static void entry__print_string_literal_31(void) {
  allocate_initialized_frame_gc(4, 9);
  // slot allocations:
  // line: 0
  // has_leading_spaces: 1
  // max_width: 2
  // split_lines: 3
  frame->slots[1] = myself->closure.frame->slots[2]; /* has_leading_spaces */
  frame->slots[2] = myself->closure.frame->slots[1]; /* max_width */
  frame->slots[3] = myself->closure.frame->slots[3]; /* split_lines */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* line */ = create_cell_with_contents(arguments->slots[0]);
  // 1214: ... line != ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_32;
}
static void cont__print_string_literal_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1214: ... line != ""
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_33;
}
static void cont__print_string_literal_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1214: ... line(1) != ' '
  frame->slots[7] /* temp__4 */ = create_closure(entry__print_string_literal_34, 0);
  // 1214: ... line != "" && line(1) != ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__print_string_literal_38;
}
static void entry__print_string_literal_34(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // line: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1214: ... line(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_35;
}
static void cont__print_string_literal_35(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1214: ... line(1) != ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_36;
}
static void cont__print_string_literal_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1214: ... line(1) != ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_37;
}
static void cont__print_string_literal_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1214: ... line(1) != ' '
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1214: ... : !has_leading_spaces false
  frame->slots[8] /* temp__5 */ = create_closure(entry__print_string_literal_39, 0);
  // 1214: if line != "" && line(1) != ' ': !has_leading_spaces false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_40;
}
static void entry__print_string_literal_39(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // has_leading_spaces: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* has_leading_spaces */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1214: ... !has_leading_spaces false
  ((CELL *)frame->slots[0])->contents /* has_leading_spaces */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_40(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1215: ... -> length_of(line) > max_width:
  // 1216:   # split long lines (if possible after a space)
  // 1217:   
  // 1218:   $skip_till_end_of_string:
  // 1219:     do_while:
  // 1220:       inc &pos
  // 1221:       if line(pos) == '@@':
  // 1222:         skip_special
  // 1223:         inc &pos
  // 1224:       -> line(pos) != '@quot;'
  // ...
  frame->slots[4] /* temp__1 */ = create_closure(entry__print_string_literal_41, 0);
  // 1215: while -> length_of(line) > max_width:
  // 1216:   # split long lines (if possible after a space)
  // 1217:   
  // 1218:   $skip_till_end_of_string:
  // 1219:     do_while:
  // 1220:       inc &pos
  // 1221:       if line(pos) == '@@':
  // 1222:         skip_special
  // 1223:         inc &pos
  // 1224:       -> line(pos) != '@quot;'
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__print_string_literal_123;
}
static void entry__print_string_literal_44(void) {
  allocate_initialized_frame_gc(3, 11);
  // slot allocations:
  // line: 0
  // max_width: 1
  // split_lines: 2
  // skip_till_end_of_string: 3
  // skip_till_close: 4
  // skip_special: 5
  // best_split_pos: 6
  // last_valid_pos: 7
  // pos: 8
  frame->slots[0] = myself->closure.frame->slots[1]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* max_width */
  frame->slots[2] = myself->closure.frame->slots[2]; /* split_lines */
  frame->slots[3] /* skip_till_end_of_string */ = create_future();
  frame->slots[4] /* skip_till_close */ = create_future();
  frame->slots[5] /* skip_special */ = create_future();
  frame->slots[6] /* best_split_pos */ = create_cell();
  frame->slots[7] /* last_valid_pos */ = create_cell();
  frame->slots[8] /* pos */ = create_cell();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1218: ... :
  // 1219:   do_while:
  // 1220:     inc &pos
  // 1221:     if line(pos) == '@@':
  // 1222:       skip_special
  // 1223:       inc &pos
  // 1224:     -> line(pos) != '@quot;'
  frame->slots[9] /* temp__1 */ = create_closure(entry__print_string_literal_45, 0);
  // 1218: $skip_till_end_of_string:
  // 1219:   do_while:
  // 1220:     inc &pos
  // 1221:     if line(pos) == '@@':
  // 1222:       skip_special
  // 1223:       inc &pos
  // 1224:     -> line(pos) != '@quot;'
  initialize_future(frame->slots[3] /* skip_till_end_of_string */, frame->slots[9] /* temp__1 */);
  // 1226: ... :
  // 1227:   do_while:
  // 1228:     inc &pos
  // 1229:     if line(pos) == '(':
  // 1230:       skip_till_close
  // 1231:       inc &pos
  // 1232:     if line(pos) == '@quot;':
  // 1233:       skip_till_end_of_string
  // 1234:       inc &pos
  // 1235:     -> line(pos) != ')'
  frame->slots[9] /* temp__1 */ = create_closure(entry__print_string_literal_57, 0);
  // 1226: $skip_till_close:
  // 1227:   do_while:
  // 1228:     inc &pos
  // 1229:     if line(pos) == '(':
  // 1230:       skip_till_close
  // 1231:       inc &pos
  // 1232:     if line(pos) == '@quot;':
  // 1233:       skip_till_end_of_string
  // 1234:       inc &pos
  // 1235:     -> line(pos) != ')'
  initialize_future(frame->slots[4] /* skip_till_close */, frame->slots[9] /* temp__1 */);
  // 1237: ... :
  // 1238:   inc &pos
  // 1239:   unless line(pos) == '@@':
  // 1240:     if
  // 1241:       line(pos) == '(':
  // 1242:         skip_till_close
  // 1243:       :
  // 1244:         while -> line(pos) != ';': inc &pos
  frame->slots[9] /* temp__1 */ = create_closure(entry__print_string_literal_75, 0);
  // 1237: $skip_special:
  // 1238:   inc &pos
  // 1239:   unless line(pos) == '@@':
  // 1240:     if
  // 1241:       line(pos) == '(':
  // 1242:         skip_till_close
  // 1243:       :
  // 1244:         while -> line(pos) != ';': inc &pos
  initialize_future(frame->slots[5] /* skip_special */, frame->slots[9] /* temp__1 */);
  // 1246: $$best_split_pos undefined
  ((CELL *)frame->slots[6])->contents /* best_split_pos */ = get__undefined();
  // 1247: $$last_valid_pos undefined
  ((CELL *)frame->slots[7])->contents /* last_valid_pos */ = get__undefined();
  // 1248: $$pos 1
  ((CELL *)frame->slots[8])->contents /* pos */ = number__1;
  // 1249: ... -> pos < max_width:
  // 1250:   $chr line(pos)
  // 1251:   if
  // 1252:     chr == ' ':
  // 1253:       !best_split_pos pos
  // 1254:     :
  // 1255:       if
  // 1256:         chr == '@@':
  // 1257:           skip_special
  // 1258:           cond
  // ...
  frame->slots[9] /* temp__1 */ = create_closure(entry__print_string_literal_90, 0);
  // 1249: while -> pos < max_width:
  // 1250:   $chr line(pos)
  // 1251:   if
  // 1252:     chr == ' ':
  // 1253:       !best_split_pos pos
  // 1254:     :
  // 1255:       if
  // 1256:         chr == '@@':
  // 1257:           skip_special
  // 1258:           cond
  // ...
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  result_count = 0;
  myself = get__while();
  func = myself->type;
  frame->cont = cont__print_string_literal_113;
}
static void entry__print_string_literal_92(void) {
  allocate_initialized_frame_gc(6, 10);
  // slot allocations:
  // line: 0
  // pos: 1
  // best_split_pos: 2
  // skip_special: 3
  // max_width: 4
  // last_valid_pos: 5
  // chr: 6
  frame->slots[0] = myself->closure.frame->slots[2]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[2] = myself->closure.frame->slots[3]; /* best_split_pos */
  frame->slots[3] = myself->closure.frame->slots[4]; /* skip_special */
  frame->slots[4] = myself->closure.frame->slots[1]; /* max_width */
  frame->slots[5] = myself->closure.frame->slots[5]; /* last_valid_pos */
  frame->slots[6] /* chr */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1250: $chr line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_93;
}
static void cont__print_string_literal_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* chr */, arguments->slots[0]);
  // 1252: chr == ' '
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* chr */;
  arguments->slots[1] = character__32;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_94;
}
static void cont__print_string_literal_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1252: ... :
  // 1253:   !best_split_pos pos
  frame->slots[8] /* temp__2 */ = create_closure(entry__print_string_literal_95, 0);
  // 1254: :
  // 1255:   if
  // 1256:     chr == '@@':
  // 1257:       skip_special
  // 1258:       cond
  // 1259:         -> pos < max_width && line(pos) == ')':
  // 1260:           !best_split_pos pos
  // 1261:         -> last_valid_pos.is_undefined: !last_valid_pos pos
  // 1262:     :
  // 1263:       !last_valid_pos pos
  frame->slots[9] /* temp__3 */ = create_closure(entry__print_string_literal_96, 0);
  // 1251: if
  // 1252:   chr == ' ':
  // 1253:     !best_split_pos pos
  // 1254:   :
  // 1255:     if
  // 1256:       chr == '@@':
  // 1257:         skip_special
  // 1258:         cond
  // 1259:           -> pos < max_width && line(pos) == ')':
  // 1260:             !best_split_pos pos
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_111;
}
static void entry__print_string_literal_109(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // last_valid_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* last_valid_pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1261: ... !last_valid_pos pos
  ((CELL *)frame->slots[0])->contents /* last_valid_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_106(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // best_split_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* best_split_pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1260: !best_split_pos pos
  ((CELL *)frame->slots[0])->contents /* best_split_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_100(void) {
  allocate_initialized_frame_gc(4, 8);
  // slot allocations:
  // pos: 0
  // max_width: 1
  // line: 2
  // best_split_pos: 3
  frame->slots[0] = myself->closure.frame->slots[1]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[2]; /* max_width */
  frame->slots[2] = myself->closure.frame->slots[3]; /* line */
  frame->slots[3] = myself->closure.frame->slots[4]; /* best_split_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1259: ... pos < max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  arguments->slots[1] = frame->slots[1] /* max_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__print_string_literal_101;
}
static void cont__print_string_literal_101(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1259: ... line(pos) == ')'
  frame->slots[6] /* temp__3 */ = create_closure(entry__print_string_literal_102, 0);
  // 1259: ... pos < max_width && line(pos) == ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__print_string_literal_105;
}
static void entry__print_string_literal_102(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // line: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1259: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_103;
}
static void cont__print_string_literal_103(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1259: ... line(pos) == ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_104;
}
static void cont__print_string_literal_104(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1259: ... line(pos) == ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_105(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1259: ... :
  // 1260:   !best_split_pos pos
  frame->slots[7] /* temp__4 */ = create_closure(entry__print_string_literal_106, 0);
  // 1259: -> pos < max_width && line(pos) == ')':
  // 1260:   !best_split_pos pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_107(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // last_valid_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[5]; /* last_valid_pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1261: ... last_valid_pos.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* last_valid_pos */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__print_string_literal_108;
}
static void cont__print_string_literal_108(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1261: ... : !last_valid_pos pos
  frame->slots[3] /* temp__2 */ = create_closure(entry__print_string_literal_109, 0);
  // 1261: -> last_valid_pos.is_undefined: !last_valid_pos pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_98(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // skip_special: 0
  // pos: 1
  // max_width: 2
  // line: 3
  // best_split_pos: 4
  // last_valid_pos: 5
  frame->slots[0] = myself->closure.frame->slots[1]; /* skip_special */
  frame->slots[1] = myself->closure.frame->slots[2]; /* pos */
  frame->slots[2] = myself->closure.frame->slots[3]; /* max_width */
  frame->slots[3] = myself->closure.frame->slots[4]; /* line */
  frame->slots[4] = myself->closure.frame->slots[5]; /* best_split_pos */
  frame->slots[5] = myself->closure.frame->slots[6]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1257: skip_special
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_special */;
  func = myself->type;
  frame->cont = cont__print_string_literal_99;
}
static void cont__print_string_literal_99(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1259: -> pos < max_width && line(pos) == ')':
  // 1260:   !best_split_pos pos
  frame->slots[6] /* temp__1 */ = create_closure(entry__print_string_literal_100, 0);
  // 1261: -> last_valid_pos.is_undefined: !last_valid_pos pos
  frame->slots[7] /* temp__2 */ = create_closure(entry__print_string_literal_107, 0);
  // 1258: cond
  // 1259:   -> pos < max_width && line(pos) == ')':
  // 1260:     !best_split_pos pos
  // 1261:   -> last_valid_pos.is_undefined: !last_valid_pos pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_110(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // last_valid_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* last_valid_pos */
  frame->slots[1] = myself->closure.frame->slots[2]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1263: !last_valid_pos pos
  ((CELL *)frame->slots[0])->contents /* last_valid_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_95(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // best_split_pos: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* best_split_pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1253: !best_split_pos pos
  ((CELL *)frame->slots[0])->contents /* best_split_pos */ = ((CELL *)frame->slots[1])->contents /* pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_96(void) {
  allocate_initialized_frame_gc(7, 10);
  // slot allocations:
  // chr: 0
  // skip_special: 1
  // pos: 2
  // max_width: 3
  // line: 4
  // best_split_pos: 5
  // last_valid_pos: 6
  frame->slots[0] = myself->closure.frame->slots[6]; /* chr */
  frame->slots[1] = myself->closure.frame->slots[3]; /* skip_special */
  frame->slots[2] = myself->closure.frame->slots[1]; /* pos */
  frame->slots[3] = myself->closure.frame->slots[4]; /* max_width */
  frame->slots[4] = myself->closure.frame->slots[0]; /* line */
  frame->slots[5] = myself->closure.frame->slots[2]; /* best_split_pos */
  frame->slots[6] = myself->closure.frame->slots[5]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1256: chr == '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* chr */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_97;
}
static void cont__print_string_literal_97(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1256: ... :
  // 1257:   skip_special
  // 1258:   cond
  // 1259:     -> pos < max_width && line(pos) == ')':
  // 1260:       !best_split_pos pos
  // 1261:     -> last_valid_pos.is_undefined: !last_valid_pos pos
  frame->slots[8] /* temp__2 */ = create_closure(entry__print_string_literal_98, 0);
  // 1262: :
  // 1263:   !last_valid_pos pos
  frame->slots[9] /* temp__3 */ = create_closure(entry__print_string_literal_110, 0);
  // 1255: if
  // 1256:   chr == '@@':
  // 1257:     skip_special
  // 1258:     cond
  // 1259:       -> pos < max_width && line(pos) == ')':
  // 1260:         !best_split_pos pos
  // 1261:       -> last_valid_pos.is_undefined: !last_valid_pos pos
  // 1262:   :
  // 1263:     !last_valid_pos pos
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__2 */;
  arguments->slots[2] = frame->slots[9] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__print_string_literal_111(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1264: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_112;
}
static void cont__print_string_literal_112(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_88(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // pos: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1244: ... inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_89;
}
static void cont__print_string_literal_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_84(void) {
  allocate_initialized_frame_gc(2, 6);
  // slot allocations:
  // line: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1244: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_85;
}
static void cont__print_string_literal_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1244: ... line(pos) != ';'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  arguments->slots[1] = character__59;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_86;
}
static void cont__print_string_literal_86(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1244: ... line(pos) != ';'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_87;
}
static void cont__print_string_literal_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1244: ... : inc &pos
  frame->slots[5] /* temp__4 */ = create_closure(entry__print_string_literal_88, 0);
  // 1244: ... -> line(pos) != ';': inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_82(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // skip_till_close: 0
  frame->slots[0] = myself->closure.frame->slots[2]; /* skip_till_close */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1242: skip_till_close
  argument_count = 0;
  arguments = node_p;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* skip_till_close */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_83(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // line: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* line */
  frame->slots[1] = myself->closure.frame->slots[1]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1244: ... -> line(pos) != ';': inc &pos
  frame->slots[2] /* temp__1 */ = create_closure(entry__print_string_literal_84, 0);
  // 1244: while -> line(pos) != ';': inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__while();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_79(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // line: 0
  // pos: 1
  // skip_till_close: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* line */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[2] = myself->closure.frame->slots[2]; /* skip_till_close */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1241: line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_80;
}
static void cont__print_string_literal_80(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1241: line(pos) == '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_81;
}
static void cont__print_string_literal_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1241: ... :
  // 1242:   skip_till_close
  frame->slots[5] /* temp__3 */ = create_closure(entry__print_string_literal_82, 0);
  // 1243: :
  // 1244:   while -> line(pos) != ';': inc &pos
  frame->slots[6] /* temp__4 */ = create_closure(entry__print_string_literal_83, 0);
  // 1240: if
  // 1241:   line(pos) == '(':
  // 1242:     skip_till_close
  // 1243:   :
  // 1244:     while -> line(pos) != ';': inc &pos
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  arguments->slots[2] = frame->slots[6] /* temp__4 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_58(void) {
  allocate_initialized_frame_gc(4, 7);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_till_close: 2
  // skip_till_end_of_string: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* line */
  frame->slots[2] = myself->closure.frame->slots[2]; /* skip_till_close */
  frame->slots[3] = myself->closure.frame->slots[3]; /* skip_till_end_of_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1228: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_59;
}
static void cont__print_string_literal_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  // 1229: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_60;
}
static void cont__print_string_literal_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1229: ... line(pos) == '('
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__40;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_61;
}
static void cont__print_string_literal_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1229: ... :
  // 1230:   skip_till_close
  // 1231:   inc &pos
  frame->slots[6] /* temp__3 */ = create_closure(entry__print_string_literal_62, 0);
  // 1229: if line(pos) == '(':
  // 1230:   skip_till_close
  // 1231:   inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_65;
}
static void entry__print_string_literal_62(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // skip_till_close: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* skip_till_close */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1230: skip_till_close
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_till_close */;
  func = myself->type;
  frame->cont = cont__print_string_literal_63;
}
static void cont__print_string_literal_63(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1231: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_64;
}
static void cont__print_string_literal_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_65(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1232: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_66;
}
static void cont__print_string_literal_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1232: ... line(pos) == '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_67;
}
static void cont__print_string_literal_67(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1232: ... :
  // 1233:   skip_till_end_of_string
  // 1234:   inc &pos
  frame->slots[6] /* temp__3 */ = create_closure(entry__print_string_literal_68, 0);
  // 1232: if line(pos) == '@quot;':
  // 1233:   skip_till_end_of_string
  // 1234:   inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_71;
}
static void entry__print_string_literal_68(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // skip_till_end_of_string: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[3]; /* skip_till_end_of_string */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1233: skip_till_end_of_string
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_till_end_of_string */;
  func = myself->type;
  frame->cont = cont__print_string_literal_69;
}
static void cont__print_string_literal_69(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1234: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_70;
}
static void cont__print_string_literal_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_71(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1235: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_72;
}
static void cont__print_string_literal_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1235: ... line(pos) != ')'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  arguments->slots[1] = character__41;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_73;
}
static void cont__print_string_literal_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1235: ... line(pos) != ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_74;
}
static void cont__print_string_literal_74(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1235: -> line(pos) != ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_46(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_special: 2
  frame->slots[0] = myself->closure.frame->slots[0]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* line */
  frame->slots[2] = myself->closure.frame->slots[2]; /* skip_special */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1220: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_47;
}
static void cont__print_string_literal_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  // 1221: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_48;
}
static void cont__print_string_literal_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1221: ... line(pos) == '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_49;
}
static void cont__print_string_literal_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1221: ... :
  // 1222:   skip_special
  // 1223:   inc &pos
  frame->slots[5] /* temp__3 */ = create_closure(entry__print_string_literal_50, 0);
  // 1221: if line(pos) == '@@':
  // 1222:   skip_special
  // 1223:   inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_53;
}
static void entry__print_string_literal_50(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // skip_special: 0
  // pos: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* skip_special */
  frame->slots[1] = myself->closure.frame->slots[0]; /* pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1222: skip_special
  argument_count = 0;
  arguments = node_p;
  result_count = 0;
  myself = frame->slots[0] /* skip_special */;
  func = myself->type;
  frame->cont = cont__print_string_literal_51;
}
static void cont__print_string_literal_51(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1223: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_52;
}
static void cont__print_string_literal_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* pos */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_53(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1224: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_54;
}
static void cont__print_string_literal_54(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__3 */ = arguments->slots[0];
  // 1224: ... line(pos) != '@quot;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__3 */;
  arguments->slots[1] = character__34;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_55;
}
static void cont__print_string_literal_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1224: ... line(pos) != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_56;
}
static void cont__print_string_literal_56(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1224: -> line(pos) != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_45(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_special: 2
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[5]; /* skip_special */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1219: ... :
  // 1220:   inc &pos
  // 1221:   if line(pos) == '@@':
  // 1222:     skip_special
  // 1223:     inc &pos
  // 1224:   -> line(pos) != '@quot;'
  frame->slots[3] /* temp__1 */ = create_closure(entry__print_string_literal_46, 0);
  // 1219: do_while:
  // 1220:   inc &pos
  // 1221:   if line(pos) == '@@':
  // 1222:     skip_special
  // 1223:     inc &pos
  // 1224:   -> line(pos) != '@quot;'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do_while();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_57(void) {
  allocate_initialized_frame_gc(4, 5);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_till_close: 2
  // skip_till_end_of_string: 3
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[4]; /* skip_till_close */
  frame->slots[3] = myself->closure.frame->slots[3]; /* skip_till_end_of_string */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1227: ... :
  // 1228:   inc &pos
  // 1229:   if line(pos) == '(':
  // 1230:     skip_till_close
  // 1231:     inc &pos
  // 1232:   if line(pos) == '@quot;':
  // 1233:     skip_till_end_of_string
  // 1234:     inc &pos
  // 1235:   -> line(pos) != ')'
  frame->slots[4] /* temp__1 */ = create_closure(entry__print_string_literal_58, 0);
  // 1227: do_while:
  // 1228:   inc &pos
  // 1229:   if line(pos) == '(':
  // 1230:     skip_till_close
  // 1231:     inc &pos
  // 1232:   if line(pos) == '@quot;':
  // 1233:     skip_till_end_of_string
  // 1234:     inc &pos
  // 1235:   -> line(pos) != ')'
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__do_while();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_75(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // pos: 0
  // line: 1
  // skip_till_close: 2
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[4]; /* skip_till_close */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1238: inc &pos
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = get__inc();
  func = myself->type;
  frame->cont = cont__print_string_literal_76;
}
static void cont__print_string_literal_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* pos */ = arguments->slots[0];
  // 1239: ... line(pos)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* line */;
  func = myself->type;
  frame->cont = cont__print_string_literal_77;
}
static void cont__print_string_literal_77(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1239: ... line(pos) == '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_78;
}
static void cont__print_string_literal_78(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1239: ... :
  // 1240:   if
  // 1241:     line(pos) == '(':
  // 1242:       skip_till_close
  // 1243:     :
  // 1244:       while -> line(pos) != ';': inc &pos
  frame->slots[5] /* temp__3 */ = create_closure(entry__print_string_literal_79, 0);
  // 1239: unless line(pos) == '@@':
  // 1240:   if
  // 1241:     line(pos) == '(':
  // 1242:       skip_till_close
  // 1243:     :
  // 1244:       while -> line(pos) != ';': inc &pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_90(void) {
  allocate_initialized_frame_gc(6, 8);
  // slot allocations:
  // pos: 0
  // max_width: 1
  // line: 2
  // best_split_pos: 3
  // skip_special: 4
  // last_valid_pos: 5
  frame->slots[0] = myself->closure.frame->slots[8]; /* pos */
  frame->slots[1] = myself->closure.frame->slots[1]; /* max_width */
  frame->slots[2] = myself->closure.frame->slots[0]; /* line */
  frame->slots[3] = myself->closure.frame->slots[6]; /* best_split_pos */
  frame->slots[4] = myself->closure.frame->slots[5]; /* skip_special */
  frame->slots[5] = myself->closure.frame->slots[7]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1249: ... pos < max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* pos */;
  arguments->slots[1] = frame->slots[1] /* max_width */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__print_string_literal_91;
}
static void cont__print_string_literal_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__1 */ = arguments->slots[0];
  // 1249: ... :
  // 1250:   $chr line(pos)
  // 1251:   if
  // 1252:     chr == ' ':
  // 1253:       !best_split_pos pos
  // 1254:     :
  // 1255:       if
  // 1256:         chr == '@@':
  // 1257:           skip_special
  // 1258:           cond
  // ...
  frame->slots[7] /* temp__2 */ = create_closure(entry__print_string_literal_92, 0);
  // 1249: ... -> pos < max_width:
  // 1250:   $chr line(pos)
  // 1251:   if
  // 1252:     chr == ' ':
  // 1253:       !best_split_pos pos
  // 1254:     :
  // 1255:       if
  // 1256:         chr == '@@':
  // 1257:           skip_special
  // 1258:           cond
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_113(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1265: ... best_split_pos.is_undefined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* best_split_pos */;
  result_count = 1;
  myself = get__is_undefined();
  func = myself->type;
  frame->cont = cont__print_string_literal_114;
}
static void cont__print_string_literal_114(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 1265: ... : !best_split_pos last_valid_pos
  frame->slots[10] /* temp__2 */ = create_closure(entry__print_string_literal_115, 0);
  // 1265: if best_split_pos.is_undefined: !best_split_pos last_valid_pos
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__2 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_116;
}
static void entry__print_string_literal_115(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // best_split_pos: 0
  // last_valid_pos: 1
  frame->slots[0] = myself->closure.frame->slots[6]; /* best_split_pos */
  frame->slots[1] = myself->closure.frame->slots[7]; /* last_valid_pos */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1265: ... !best_split_pos last_valid_pos
  ((CELL *)frame->slots[0])->contents /* best_split_pos */ = ((CELL *)frame->slots[1])->contents /* last_valid_pos */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_116(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1266: ... range(line 1 best_split_pos)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = ((CELL *)frame->slots[6])->contents /* best_split_pos */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__print_string_literal_117;
}
static void cont__print_string_literal_117(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 1266: ... push(range(line 1 best_split_pos) '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[10] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__print_string_literal_118;
}
static void cont__print_string_literal_118(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 1266: push &split_lines push(range(line 1 best_split_pos) '@@')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* split_lines */;
  arguments->slots[1] = frame->slots[9] /* temp__1 */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__print_string_literal_119;
}
static void cont__print_string_literal_119(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[2])->contents /* split_lines */ = arguments->slots[0];
  // 1267: ... best_split_pos+1
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[6])->contents /* best_split_pos */;
  arguments->slots[1] = number__1;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__print_string_literal_120;
}
static void cont__print_string_literal_120(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__1 */ = arguments->slots[0];
  // 1267: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__print_string_literal_121;
}
static void cont__print_string_literal_121(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[10] /* temp__2 */ = arguments->slots[0];
  // 1267: range &line best_split_pos+1 -1
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* line */;
  arguments->slots[1] = frame->slots[9] /* temp__1 */;
  arguments->slots[2] = frame->slots[10] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__print_string_literal_122;
}
static void cont__print_string_literal_122(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* line */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_41(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // max_width: 0
  // line: 1
  // split_lines: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* max_width */
  frame->slots[1] = myself->closure.frame->slots[0]; /* line */
  frame->slots[2] = myself->closure.frame->slots[3]; /* split_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1215: ... length_of(line)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* line */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__print_string_literal_42;
}
static void cont__print_string_literal_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1215: ... length_of(line) > max_width
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* max_width */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__print_string_literal_43;
}
static void cont__print_string_literal_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1215: ... :
  // 1216:   # split long lines (if possible after a space)
  // 1217:   
  // 1218:   $skip_till_end_of_string:
  // 1219:     do_while:
  // 1220:       inc &pos
  // 1221:       if line(pos) == '@@':
  // 1222:         skip_special
  // 1223:         inc &pos
  // 1224:       -> line(pos) != '@quot;'
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__print_string_literal_44, 0);
  // 1215: ... -> length_of(line) > max_width:
  // 1216:   # split long lines (if possible after a space)
  // 1217:   
  // 1218:   $skip_till_end_of_string:
  // 1219:     do_while:
  // 1220:       inc &pos
  // 1221:       if line(pos) == '@@':
  // 1222:         skip_special
  // 1223:         inc &pos
  // 1224:       -> line(pos) != '@quot;'
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_123(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1268: push &split_lines line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[3])->contents /* split_lines */;
  arguments->slots[1] = ((CELL *)frame->slots[0])->contents /* line */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__print_string_literal_124;
}
static void cont__print_string_literal_124(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[3])->contents /* split_lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_125(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1269: !lines split_lines
  ((CELL *)frame->slots[0])->contents /* lines */ = ((CELL *)frame->slots[3])->contents /* split_lines */;
  // 1270: ... :
  // 1271:   #
  // 1272:     no single line starts at the indent position;
  // 1273:     so we have to add a line at the start that contains no characters
  // 1274:   
  // 1275:   put &lines "@@"
  frame->slots[7] /* temp__1 */ = create_closure(entry__print_string_literal_126, 0);
  // 1270: if has_leading_spaces:
  // 1271:   #
  // 1272:     no single line starts at the indent position;
  // 1273:     so we have to add a line at the start that contains no characters
  // 1274:   
  // 1275:   put &lines "@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[2])->contents /* has_leading_spaces */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_129;
}
static void entry__print_string_literal_126(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1275: put &lines "@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = string__578a5af303e9ca1;
  result_count = 1;
  myself = get__put();
  func = myself->type;
  frame->cont = cont__print_string_literal_128;
}
static void cont__print_string_literal_128(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_129(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1276: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__print_string_literal_130;
}
static void cont__print_string_literal_130(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[9] /* temp__3 */ = arguments->slots[0];
  // 1276: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[9] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__print_string_literal_131;
}
static void cont__print_string_literal_131(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1276: ... lines(-1) == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_132;
}
static void cont__print_string_literal_132(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1276: ... :
  // 1277:   #
  // 1278:     the last line is empty;
  // 1279:     so we replace it with an empty special sequence
  // 1280:   
  // 1281:   !lines(-1) "@@;"
  frame->slots[10] /* temp__4 */ = create_closure(entry__print_string_literal_133, 0);
  // 1276: if lines(-1) == "":
  // 1277:   #
  // 1278:     the last line is empty;
  // 1279:     so we replace it with an empty special sequence
  // 1280:   
  // 1281:   !lines(-1) "@@;"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_137;
}
static void entry__print_string_literal_133(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1281: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__print_string_literal_134;
}
static void cont__print_string_literal_134(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1281: !lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = string__2d7981f4e5082bfe;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__print_string_literal_136;
}
static void cont__print_string_literal_136(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_137(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1282: $$buf undefined
  ((CELL *)frame->slots[4])->contents /* buf */ = get__undefined();
  // 1283: $$indent expression_indent
  ((CELL *)frame->slots[5])->contents /* indent */ = get__expression_indent();
  // 1285: line_end_expression_width >= 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_end_expression_width();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__print_string_literal_138;
}
static void cont__print_string_literal_138(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__2 */ = arguments->slots[0];
  // 1285: line_end_expression_width >= 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__print_string_literal_139;
}
static void cont__print_string_literal_139(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__1 */ = arguments->slots[0];
  // 1285: ... :
  // 1286:   !buf "@quot;"
  frame->slots[9] /* temp__3 */ = create_closure(entry__print_string_literal_140, 0);
  // 1287: :
  // 1288:   !buf string('@nl;' spaces(indent) '@quot;')
  // 1289:   plus &indent 2
  frame->slots[10] /* temp__4 */ = create_closure(entry__print_string_literal_142, 0);
  // 1284: if
  // 1285:   line_end_expression_width >= 2:
  // 1286:     !buf "@quot;"
  // 1287:   :
  // 1288:     !buf string('@nl;' spaces(indent) '@quot;')
  // 1289:     plus &indent 2
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__1 */;
  arguments->slots[1] = frame->slots[9] /* temp__3 */;
  arguments->slots[2] = frame->slots[10] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_146;
}
static void entry__print_string_literal_140(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[4]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1286: !buf "@quot;"
  ((CELL *)frame->slots[0])->contents /* buf */ = string__578a5af303e9cc3;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_142(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // buf: 0
  // indent: 1
  frame->slots[0] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[5]; /* indent */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1288: ... spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__print_string_literal_143;
}
static void cont__print_string_literal_143(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1288: !buf string('@nl;' spaces(indent) '@quot;')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = character__34;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__print_string_literal_144;
}
static void cont__print_string_literal_144(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1289: plus &indent 2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* indent */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__plus();
  func = myself->type;
  frame->cont = cont__print_string_literal_145;
}
static void cont__print_string_literal_145(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* indent */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__print_string_literal_146(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1290: $indentation spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[5])->contents /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__print_string_literal_147;
}
static void cont__print_string_literal_147(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[6] /* indentation */, arguments->slots[0]);
  // 1291: ... : (line)
  // 1292:   push &buf '@nl;'
  // 1293:   unless line == "":
  // 1294:     append &buf indentation
  // 1295:     append &buf line
  frame->slots[7] /* temp__1 */ = create_closure(entry__print_string_literal_148, 1);
  // 1291: for_each lines: (line)
  // 1292:   push &buf '@nl;'
  // 1293:   unless line == "":
  // 1294:     append &buf indentation
  // 1295:     append &buf line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[7] /* temp__1 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__print_string_literal_154;
}
static void entry__print_string_literal_151(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // line: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[2]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* line */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1294: append &buf indentation
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__print_string_literal_152;
}
static void cont__print_string_literal_152(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1295: append &buf line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* line */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__print_string_literal_153;
}
static void cont__print_string_literal_153(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_148(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[4]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[6]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1292: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__print_string_literal_149;
}
static void cont__print_string_literal_149(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1293: ... line == ""
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* line */;
  arguments->slots[1] = empty_string;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_150;
}
static void cont__print_string_literal_150(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1293: ... :
  // 1294:   append &buf indentation
  // 1295:   append &buf line
  frame->slots[4] /* temp__2 */ = create_closure(entry__print_string_literal_151, 0);
  // 1293: unless line == "":
  // 1294:   append &buf indentation
  // 1295:   append &buf line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__print_string_literal_154(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1296: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[4])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_1(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  if (argument_count != 2) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* lines */ = create_cell_with_contents(arguments->slots[0]);
  frame->slots[1] /* is_inline */ = create_cell_with_contents(arguments->slots[1]);
  // 1190: ... :
  // 1191:   unless line_width == UNLIMITED:
  // 1192:     if length_of(lines(1))+2 > line_width-expression_indent:
  // 1193:       push &lines(1) '@@'
  // 1194:       !is_inline false
  frame->slots[2] /* temp__1 */ = create_closure(entry__print_string_literal_2, 0);
  // 1190: if is_inline:
  // 1191:   unless line_width == UNLIMITED:
  // 1192:     if length_of(lines(1))+2 > line_width-expression_indent:
  // 1193:       push &lines(1) '@@'
  // 1194:       !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* is_inline */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__print_string_literal_14;
}
static void entry__print_string_literal_10(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1193: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__print_string_literal_11;
}
static void cont__print_string_literal_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1193: push &lines(1) '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__print_string_literal_12;
}
static void cont__print_string_literal_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1193: ... &lines(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__print_string_literal_13;
}
static void cont__print_string_literal_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1194: !is_inline false
  ((CELL *)frame->slots[1])->contents /* is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__print_string_literal_4(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1192: ... line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__minus();
  func = myself->type;
  frame->cont = cont__print_string_literal_5;
}
static void cont__print_string_literal_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1192: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__print_string_literal_6;
}
static void cont__print_string_literal_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 1192: ... length_of(lines(1))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__print_string_literal_7;
}
static void cont__print_string_literal_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1192: ... length_of(lines(1))+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__4 */;
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__print_string_literal_8;
}
static void cont__print_string_literal_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1192: ... length_of(lines(1))+2 > line_width-expression_indent
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__print_string_literal_9;
}
static void cont__print_string_literal_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1192: ... :
  // 1193:   push &lines(1) '@@'
  // 1194:   !is_inline false
  frame->slots[7] /* temp__6 */ = create_closure(entry__print_string_literal_10, 0);
  // 1192: if length_of(lines(1))+2 > line_width-expression_indent:
  // 1193:   push &lines(1) '@@'
  // 1194:   !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[7] /* temp__6 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__print_string_literal_2(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // is_inline: 1
  frame->slots[0] = myself->closure.frame->slots[0]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* is_inline */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1191: ... line_width == UNLIMITED
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__line_width();
  arguments->slots[1] = var._UNLIMITED;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__print_string_literal_3;
}
static void cont__print_string_literal_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1191: ... :
  // 1192:   if length_of(lines(1))+2 > line_width-expression_indent:
  // 1193:     push &lines(1) '@@'
  // 1194:     !is_inline false
  frame->slots[3] /* temp__2 */ = create_closure(entry__print_string_literal_4, 0);
  // 1191: unless line_width == UNLIMITED:
  // 1192:   if length_of(lines(1))+2 > line_width-expression_indent:
  // 1193:     push &lines(1) '@@'
  // 1194:     !is_inline false
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__unless();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__print_string_literal_14(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1197: -> string('@quot;' lines(1) '@quot;')
  frame->slots[2] /* temp__1 */ = create_closure(entry__print_string_literal_15, 0);
  // 1198: :
  // 1199:   $max_width # the maximum width is computed for multi-line-strings
  // 1200:     -
  // 1201:       max(line_width-expression_indent 20)
  // 1202:       if
  // 1203:         line_end_expression_width >= 2
  // 1204:         -> 0
  // 1205:         -> 2
  // 1206:   
  // 1207:   $$has_leading_spaces lines(-1) != ""
  // ...
  frame->slots[3] /* temp__2 */ = create_closure(entry__print_string_literal_18, 0);
  // 1195: if
  // 1196:   is_inline
  // 1197:   -> string('@quot;' lines(1) '@quot;')
  // 1198:   :
  // 1199:     $max_width # the maximum width is computed for multi-line-strings
  // 1200:       -
  // 1201:         max(line_width-expression_indent 20)
  // 1202:         if
  // 1203:           line_end_expression_width >= 2
  // 1204:           -> 0
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* is_inline */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__string_template_to_string_1(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // self: 0
  // lines: 1
  // template_is_inline: 2
  // add_part: 3
  // add_lines: 4
  frame->slots[3] /* add_part */ = create_future();
  frame->slots[4] /* add_lines */ = create_future();
  frame->slots[1] /* lines */ = create_cell();
  frame->slots[2] /* template_is_inline */ = create_cell();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1302: ... : ($part)
  // 1303:   if
  // 1304:     lines.is_empty:
  // 1305:       push &lines part # that's the first part of the string template
  // 1306:     :
  // 1307:       if
  // 1308:         template_is_inline:
  // 1309:           append &lines(1) part # there is only a single line
  // 1310:         :
  // 1311:           push &part '@@' # append the part with a line-continuation suffix
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__string_template_to_string_2, 1);
  // 1302: $add_part: ($part)
  // 1303:   if
  // 1304:     lines.is_empty:
  // 1305:       push &lines part # that's the first part of the string template
  // 1306:     :
  // 1307:       if
  // 1308:         template_is_inline:
  // 1309:           append &lines(1) part # there is only a single line
  // 1310:         :
  // 1311:           push &part '@@' # append the part with a line-continuation suffix
  // ...
  initialize_future(frame->slots[3] /* add_part */, frame->slots[5] /* temp__1 */);
  // 1324: ... : ($more_lines)
  // 1325:   if
  // 1326:     lines.is_empty:
  // 1327:       !lines more_lines
  // 1328:     :
  // 1329:       if
  // 1330:         template_is_inline:
  // 1331:           # append the new lines at the end of the existing text
  // 1332:           
  // 1333:           !more_lines(1) string(lines(1) more_lines(1))
  // ...
  frame->slots[5] /* temp__1 */ = create_closure(entry__string_template_to_string_26, 1);
  // 1324: $add_lines: ($more_lines)
  // 1325:   if
  // 1326:     lines.is_empty:
  // 1327:       !lines more_lines
  // 1328:     :
  // 1329:       if
  // 1330:         template_is_inline:
  // 1331:           # append the new lines at the end of the existing text
  // 1332:           
  // 1333:           !more_lines(1) string(lines(1) more_lines(1))
  // ...
  initialize_future(frame->slots[4] /* add_lines */, frame->slots[5] /* temp__1 */);
  // 1299: $$lines empty_list
  ((CELL *)frame->slots[1])->contents /* lines */ = get__empty_list();
  // 1300: $$template_is_inline true
  ((CELL *)frame->slots[2])->contents /* template_is_inline */ = get__true();
  // 1351: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__string_template_to_string_48;
}
static void entry__string_template_to_string_16(void) {
  allocate_initialized_frame_gc(2, 8);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1318: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_17;
}
static void cont__string_template_to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1318: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_18;
}
static void cont__string_template_to_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1318: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_19;
}
static void cont__string_template_to_string_19(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1318: ... range(lines(-1) 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__string_template_to_string_20;
}
static void cont__string_template_to_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1318: !lines(-1) string(range(lines(-1) 1 -2) part)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__string_template_to_string_21;
}
static void cont__string_template_to_string_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 1318: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_22;
}
static void cont__string_template_to_string_22(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__6 */ = arguments->slots[0];
  // 1318: !lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__6 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_23;
}
static void cont__string_template_to_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_24(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1322: push &lines part
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__string_template_to_string_25;
}
static void cont__string_template_to_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_7(void) {
  allocate_initialized_frame_gc(2, 4);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[2]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1309: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_8;
}
static void cont__string_template_to_string_8(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1309: append &lines(1) part # there is only a single line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__string_template_to_string_9;
}
static void cont__string_template_to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1309: ... &lines(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_10;
}
static void cont__string_template_to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_11(void) {
  allocate_initialized_frame_gc(2, 7);
  // slot allocations:
  // part: 0
  // lines: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* part */
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1311: push &part '@@' # append the part with a line-continuation suffix
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* part */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__string_template_to_string_12;
}
static void cont__string_template_to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* part */ = arguments->slots[0];
  // 1313: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_13;
}
static void cont__string_template_to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1313: lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_14;
}
static void cont__string_template_to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1313: lines(-1) .has_suffix. '@@'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = character__64;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__string_template_to_string_15;
}
static void cont__string_template_to_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1313: ... :
  // 1314:   #
  // 1315:     replace the current line's continuation suffix with
  // 1316:     the new part
  // 1317:   
  // 1318:   !lines(-1) string(range(lines(-1) 1 -2) part)
  frame->slots[5] /* temp__4 */ = create_closure(entry__string_template_to_string_16, 0);
  // 1319: :
  // 1320:   # append the new part as a new line
  // 1321:   
  // 1322:   push &lines part
  frame->slots[6] /* temp__5 */ = create_closure(entry__string_template_to_string_24, 0);
  // 1312: if
  // 1313:   lines(-1) .has_suffix. '@@':
  // 1314:     #
  // 1315:       replace the current line's continuation suffix with
  // 1316:       the new part
  // 1317:     
  // 1318:     !lines(-1) string(range(lines(-1) 1 -2) part)
  // 1319:   :
  // 1320:     # append the new part as a new line
  // 1321:     
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__4 */;
  arguments->slots[2] = frame->slots[6] /* temp__5 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__string_template_to_string_4(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // part: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1305: push &lines part # that's the first part of the string template
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[1])->contents /* part */;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__string_template_to_string_5;
}
static void cont__string_template_to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_6(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // template_is_inline: 0
  // lines: 1
  // part: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* template_is_inline */
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] = myself->closure.frame->slots[0]; /* part */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1308: ... :
  // 1309:   append &lines(1) part # there is only a single line
  frame->slots[3] /* temp__1 */ = create_closure(entry__string_template_to_string_7, 0);
  // 1310: :
  // 1311:   push &part '@@' # append the part with a line-continuation suffix
  // 1312:   if
  // 1313:     lines(-1) .has_suffix. '@@':
  // 1314:       #
  // 1315:         replace the current line's continuation suffix with
  // 1316:         the new part
  // 1317:       
  // 1318:       !lines(-1) string(range(lines(-1) 1 -2) part)
  // 1319:     :
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__string_template_to_string_11, 0);
  // 1307: if
  // 1308:   template_is_inline:
  // 1309:     append &lines(1) part # there is only a single line
  // 1310:   :
  // 1311:     push &part '@@' # append the part with a line-continuation suffix
  // 1312:     if
  // 1313:       lines(-1) .has_suffix. '@@':
  // 1314:         #
  // 1315:           replace the current line's continuation suffix with
  // 1316:           the new part
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* template_is_inline */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__string_template_to_string_2(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // part: 0
  // lines: 1
  // template_is_inline: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] = myself->closure.frame->slots[2]; /* template_is_inline */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* part */ = create_cell_with_contents(arguments->slots[0]);
  // 1304: lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__string_template_to_string_3;
}
static void cont__string_template_to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1304: ... :
  // 1305:   push &lines part # that's the first part of the string template
  frame->slots[4] /* temp__2 */ = create_closure(entry__string_template_to_string_4, 0);
  // 1306: :
  // 1307:   if
  // 1308:     template_is_inline:
  // 1309:       append &lines(1) part # there is only a single line
  // 1310:     :
  // 1311:       push &part '@@' # append the part with a line-continuation suffix
  // 1312:       if
  // 1313:         lines(-1) .has_suffix. '@@':
  // 1314:           #
  // 1315:             replace the current line's continuation suffix with
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__string_template_to_string_6, 0);
  // 1303: if
  // 1304:   lines.is_empty:
  // 1305:     push &lines part # that's the first part of the string template
  // 1306:   :
  // 1307:     if
  // 1308:       template_is_inline:
  // 1309:         append &lines(1) part # there is only a single line
  // 1310:       :
  // 1311:         push &part '@@' # append the part with a line-continuation suffix
  // 1312:         if
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__string_template_to_string_26(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // more_lines: 0
  // lines: 1
  // template_is_inline: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[2] = myself->closure.frame->slots[2]; /* template_is_inline */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  frame->slots[0] /* more_lines */ = create_cell_with_contents(arguments->slots[0]);
  // 1326: lines.is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__string_template_to_string_27;
}
static void cont__string_template_to_string_27(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1326: ... :
  // 1327:   !lines more_lines
  frame->slots[4] /* temp__2 */ = create_closure(entry__string_template_to_string_28, 0);
  // 1328: :
  // 1329:   if
  // 1330:     template_is_inline:
  // 1331:       # append the new lines at the end of the existing text
  // 1332:       
  // 1333:       !more_lines(1) string(lines(1) more_lines(1))
  // 1334:       !lines more_lines
  // 1335:     :
  // 1336:       #
  // 1337:         the last modification of <lines> *must* have been done by a call
  // ...
  frame->slots[5] /* temp__3 */ = create_closure(entry__string_template_to_string_29, 0);
  // 1325: if
  // 1326:   lines.is_empty:
  // 1327:     !lines more_lines
  // 1328:   :
  // 1329:     if
  // 1330:       template_is_inline:
  // 1331:         # append the new lines at the end of the existing text
  // 1332:         
  // 1333:         !more_lines(1) string(lines(1) more_lines(1))
  // 1334:         !lines more_lines
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__string_template_to_string_47;
}
static void entry__string_template_to_string_30(void) {
  allocate_initialized_frame_gc(2, 5);
  // slot allocations:
  // more_lines: 0
  // lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* more_lines */
  frame->slots[1] = myself->closure.frame->slots[2]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1333: ... lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_31;
}
static void cont__string_template_to_string_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1333: ... more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* more_lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_32;
}
static void cont__string_template_to_string_32(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1333: !more_lines(1) string(lines(1) more_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__string_template_to_string_33;
}
static void cont__string_template_to_string_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1333: !more_lines(1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__1;
  arguments->slots[1] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* more_lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_34;
}
static void cont__string_template_to_string_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* more_lines */ = arguments->slots[0];
  // 1334: !lines more_lines
  ((CELL *)frame->slots[1])->contents /* lines */ = ((CELL *)frame->slots[0])->contents /* more_lines */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_35(void) {
  allocate_initialized_frame_gc(2, 9);
  // slot allocations:
  // lines: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[1]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1345: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_36;
}
static void cont__string_template_to_string_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__3 */ = arguments->slots[0];
  // 1345: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_37;
}
static void cont__string_template_to_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1345: ... 2
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__2;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_38;
}
static void cont__string_template_to_string_38(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__4 */ = arguments->slots[0];
  // 1345: ... range(lines(-1) 1 -2)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__2 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[5] /* temp__4 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__string_template_to_string_39;
}
static void cont__string_template_to_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1345: ... more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* more_lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_40;
}
static void cont__string_template_to_string_40(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__5 */ = arguments->slots[0];
  // 1345: !lines(-1) string(range(lines(-1) 1 -2) more_lines(1))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__5 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__string_template_to_string_41;
}
static void cont__string_template_to_string_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__6 */ = arguments->slots[0];
  // 1345: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_42;
}
static void cont__string_template_to_string_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[8] /* temp__7 */ = arguments->slots[0];
  // 1345: !lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[8] /* temp__7 */;
  arguments->slots[1] = frame->slots[7] /* temp__6 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_43;
}
static void cont__string_template_to_string_43(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  // 1346: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_44;
}
static void cont__string_template_to_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__2 */ = arguments->slots[0];
  // 1346: ... range(more_lines 2 -1)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* more_lines */;
  arguments->slots[1] = number__2;
  arguments->slots[2] = frame->slots[3] /* temp__2 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__string_template_to_string_45;
}
static void cont__string_template_to_string_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1346: append &lines range(more_lines 2 -1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* lines */;
  arguments->slots[1] = frame->slots[2] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__string_template_to_string_46;
}
static void cont__string_template_to_string_46(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_28(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // lines: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  frame->slots[1] = myself->closure.frame->slots[0]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1327: !lines more_lines
  ((CELL *)frame->slots[0])->contents /* lines */ = ((CELL *)frame->slots[1])->contents /* more_lines */;
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_29(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // template_is_inline: 0
  // more_lines: 1
  // lines: 2
  frame->slots[0] = myself->closure.frame->slots[2]; /* template_is_inline */
  frame->slots[1] = myself->closure.frame->slots[0]; /* more_lines */
  frame->slots[2] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1330: ... :
  // 1331:   # append the new lines at the end of the existing text
  // 1332:   
  // 1333:   !more_lines(1) string(lines(1) more_lines(1))
  // 1334:   !lines more_lines
  frame->slots[3] /* temp__1 */ = create_closure(entry__string_template_to_string_30, 0);
  // 1335: :
  // 1336:   #
  // 1337:     the last modification of <lines> *must* have been done by a call
  // 1338:     to <add_part> because there cannot be two adjacent string literals
  // 1339:     in a string template so the last line *must* end with a
  // 1340:     line-continuation suffix
  // 1341:     
  // 1342:     this suffix is replaced with the contents of the first of
  // 1343:     the new lines
  // 1344:   
  // ...
  frame->slots[4] /* temp__2 */ = create_closure(entry__string_template_to_string_35, 0);
  // 1329: if
  // 1330:   template_is_inline:
  // 1331:     # append the new lines at the end of the existing text
  // 1332:     
  // 1333:     !more_lines(1) string(lines(1) more_lines(1))
  // 1334:     !lines more_lines
  // 1335:   :
  // 1336:     #
  // 1337:       the last modification of <lines> *must* have been done by a call
  // 1338:       to <add_part> because there cannot be two adjacent string literals
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* template_is_inline */;
  arguments->slots[1] = frame->slots[3] /* temp__1 */;
  arguments->slots[2] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__string_template_to_string_47(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1347: !template_is_inline false
  ((CELL *)frame->slots[2])->contents /* template_is_inline */ = get__false();
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__string_template_to_string_48(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1351: ... : (argument)
  // 1352:   if
  // 1353:     argument.is_a_string_literal:
  // 1354:       analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1355:       if
  // 1356:         is_inline:
  // 1357:           add_part more_lines(1)
  // 1358:         :
  // 1359:           add_lines more_lines
  // 1360:     :
  // ...
  frame->slots[6] /* temp__2 */ = create_closure(entry__string_template_to_string_49, 1);
  // 1351: for_each arguments_of(self): (argument)
  // 1352:   if
  // 1353:     argument.is_a_string_literal:
  // 1354:       analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1355:       if
  // 1356:         is_inline:
  // 1357:           add_part more_lines(1)
  // 1358:         :
  // 1359:           add_lines more_lines
  // 1360:     :
  // ...
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__string_template_to_string_62;
}
static void entry__string_template_to_string_54(void) {
  allocate_initialized_frame_gc(2, 3);
  // slot allocations:
  // add_part: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[1]; /* add_part */
  frame->slots[1] = myself->closure.frame->slots[3]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1357: ... more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = frame->slots[1] /* more_lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_55;
}
static void cont__string_template_to_string_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__1 */ = arguments->slots[0];
  // 1357: add_part more_lines(1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* add_part */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__string_template_to_string_56(void) {
  allocate_initialized_frame_gc(2, 2);
  // slot allocations:
  // add_lines: 0
  // more_lines: 1
  frame->slots[0] = myself->closure.frame->slots[2]; /* add_lines */
  frame->slots[1] = myself->closure.frame->slots[3]; /* more_lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1359: add_lines more_lines
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* more_lines */;
  result_count = frame->caller_result_count;
  myself = frame->slots[0] /* add_lines */;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__string_template_to_string_51(void) {
  allocate_initialized_frame_gc(3, 7);
  // slot allocations:
  // argument: 0
  // add_part: 1
  // add_lines: 2
  // more_lines: 3
  // is_inline: 4
  frame->slots[0] = myself->closure.frame->slots[0]; /* argument */
  frame->slots[1] = myself->closure.frame->slots[1]; /* add_part */
  frame->slots[2] = myself->closure.frame->slots[2]; /* add_lines */
  frame->slots[3] /* more_lines */ = create_future();
  frame->slots[4] /* is_inline */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1354: ... node::text_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__string_template_to_string_52;
}
static void cont__string_template_to_string_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1354: analyze_string_literal $more_lines $is_inline node::text_of(argument)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  result_count = 2;
  myself = var._analyze_string_literal;
  func = myself->type;
  frame->cont = cont__string_template_to_string_53;
}
static void cont__string_template_to_string_53(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* more_lines */, arguments->slots[0]);
  initialize_future(frame->slots[4] /* is_inline */, arguments->slots[1]);
  // 1356: ... :
  // 1357:   add_part more_lines(1)
  frame->slots[5] /* temp__1 */ = create_closure(entry__string_template_to_string_54, 0);
  // 1358: :
  // 1359:   add_lines more_lines
  frame->slots[6] /* temp__2 */ = create_closure(entry__string_template_to_string_56, 0);
  // 1355: if
  // 1356:   is_inline:
  // 1357:     add_part more_lines(1)
  // 1358:   :
  // 1359:     add_lines more_lines
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* is_inline */;
  arguments->slots[1] = frame->slots[5] /* temp__1 */;
  arguments->slots[2] = frame->slots[6] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__string_template_to_string_57(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // return__1: 0
  // add_part: 1
  // argument: 2
  frame->slots[0] /* return__1 */ = create_continuation();
  frame->slots[1] = myself->closure.frame->slots[1]; /* add_part */
  frame->slots[2] = myself->closure.frame->slots[0]; /* argument */
  // _define %line_width UNLIMITED
  define__line_width(var._UNLIMITED);
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1362: ... argument.to_string
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* argument */;
  result_count = 1;
  myself = get__to_string();
  func = myself->type;
  frame->cont = cont__string_template_to_string_58;
}
static void cont__string_template_to_string_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1362: ... string("@@(" argument.to_string ')')
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e5082bed;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = character__41;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__string_template_to_string_60;
}
static void cont__string_template_to_string_60(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1362: add_part string("@@(" argument.to_string ')')
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = frame->slots[1] /* add_part */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_61;
}
static void cont__string_template_to_string_61(void) {
  myself = frame->slots[0] /* return__1 */;
  func = myself->type;
  frame->cont = invalid_continuation;
}
static void entry__string_template_to_string_49(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // argument: 0
  // add_part: 1
  // add_lines: 2
  frame->slots[1] = myself->closure.frame->slots[3]; /* add_part */
  frame->slots[2] = myself->closure.frame->slots[4]; /* add_lines */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1353: argument.is_a_string_literal
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* argument */;
  result_count = 1;
  myself = get__is_a_string_literal();
  func = myself->type;
  frame->cont = cont__string_template_to_string_50;
}
static void cont__string_template_to_string_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1353: ... :
  // 1354:   analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1355:   if
  // 1356:     is_inline:
  // 1357:       add_part more_lines(1)
  // 1358:     :
  // 1359:       add_lines more_lines
  frame->slots[4] /* temp__2 */ = create_closure(entry__string_template_to_string_51, 0);
  // 1360: :
  // 1361:   %line_width UNLIMITED # force inline output
  // 1362:   add_part string("@@(" argument.to_string ')')
  frame->slots[5] /* temp__3 */ = create_closure(entry__string_template_to_string_57, 0);
  // 1352: if
  // 1353:   argument.is_a_string_literal:
  // 1354:     analyze_string_literal $more_lines $is_inline node::text_of(argument)
  // 1355:     if
  // 1356:       is_inline:
  // 1357:         add_part more_lines(1)
  // 1358:       :
  // 1359:         add_lines more_lines
  // 1360:   :
  // 1361:     %line_width UNLIMITED # force inline output
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = frame->slots[5] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__string_template_to_string_62(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1363: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_63;
}
static void cont__string_template_to_string_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[7] /* temp__3 */ = arguments->slots[0];
  // 1363: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[7] /* temp__3 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[1])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_64;
}
static void cont__string_template_to_string_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__2 */ = arguments->slots[0];
  // 1363: ... lines(-1) .has_suffix. "@@nl;@@"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__2 */;
  arguments->slots[1] = string__565ae803e8121017;
  result_count = 1;
  myself = get__has_suffix();
  func = myself->type;
  frame->cont = cont__string_template_to_string_66;
}
static void cont__string_template_to_string_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__1 */ = arguments->slots[0];
  // 1363: ... : range &lines(-1) 1 -6 # remove nonsense
  frame->slots[8] /* temp__4 */ = create_closure(entry__string_template_to_string_67, 0);
  // 1363: if lines(-1) .has_suffix. "@@nl;@@": range &lines(-1) 1 -6 # remove nonsense
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__4 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__string_template_to_string_74;
}
static void entry__string_template_to_string_67(void) {
  allocate_initialized_frame_gc(1, 6);
  // slot allocations:
  // lines: 0
  frame->slots[0] = myself->closure.frame->slots[1]; /* lines */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1363: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_68;
}
static void cont__string_template_to_string_68(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1363: ... lines(-1)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_69;
}
static void cont__string_template_to_string_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1363: ... 6
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__6;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_70;
}
static void cont__string_template_to_string_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1363: ... range &lines(-1) 1 -6 # remove nonsense
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = number__1;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__range();
  func = myself->type;
  frame->cont = cont__string_template_to_string_71;
}
static void cont__string_template_to_string_71(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__4 */ = arguments->slots[0];
  // 1363: ... 1
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = number__1;
  result_count = 1;
  myself = get__std__negate();
  func = myself->type;
  frame->cont = cont__string_template_to_string_72;
}
static void cont__string_template_to_string_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__5 */ = arguments->slots[0];
  // 1363: ... &lines(-1)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__5 */;
  arguments->slots[1] = frame->slots[4] /* temp__4 */;
  result_count = 1;
  myself = ((CELL *)frame->slots[0])->contents /* lines */;
  func = myself->type;
  frame->cont = cont__string_template_to_string_73;
}
static void cont__string_template_to_string_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* lines */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__string_template_to_string_74(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1364: print_string_literal lines template_is_inline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* lines */;
  arguments->slots[1] = ((CELL *)frame->slots[2])->contents /* template_is_inline */;
  result_count = frame->caller_result_count;
  myself = var._print_string_literal;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__string_literal__to_string_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  // lines: 1
  // is_inline: 2
  frame->slots[1] /* lines */ = create_future();
  frame->slots[2] /* is_inline */ = create_future();
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1367: ... node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__text_of();
  func = myself->type;
  frame->cont = cont__compiler__string_literal__to_string_2;
}
static void cont__compiler__string_literal__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1367: analyze_string_literal $lines $is_inline node::text_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  result_count = 2;
  myself = var._analyze_string_literal;
  func = myself->type;
  frame->cont = cont__compiler__string_literal__to_string_3;
}
static void cont__compiler__string_literal__to_string_3(void) {
  if (argument_count != 2) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[1] /* lines */, arguments->slots[0]);
  initialize_future(frame->slots[2] /* is_inline */, arguments->slots[1]);
  // 1368: print_string_literal lines is_inline
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* lines */;
  arguments->slots[1] = frame->slots[2] /* is_inline */;
  result_count = frame->caller_result_count;
  myself = var._print_string_literal;
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__unique_item__to_string_1(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1373: ... -> "."
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__578a5af303e9ccf;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__polymorphic_function__to_string_3(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1381: -> "(!)"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__fa732415f216be5;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__polymorphic_function__to_string_5(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1382: -> "()"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e6482bec;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__polymorphic_function__to_string_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1380: self.is_a_setter
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_a_setter();
  func = myself->type;
  frame->cont = cont__compiler__polymorphic_function__to_string_2;
}
static void cont__compiler__polymorphic_function__to_string_2(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1379: if
  // 1380:   self.is_a_setter
  // 1381:   -> "(!)"
  // 1382:   -> "()"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = func__compiler__polymorphic_function__to_string_3;
  arguments->slots[2] = func__compiler__polymorphic_function__to_string_5;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__identifier__to_string_16(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1393: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_17;
}
static void cont__compiler__identifier__to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1393: ... -> name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_string_12(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1392: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_13;
}
static void cont__compiler__identifier__to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1392: ... string('_' name_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = character__95;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_14;
}
static void cont__compiler__identifier__to_string_14(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1392: ... -> string('_' name_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_string_5(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1391: ... namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_6;
}
static void cont__compiler__identifier__to_string_6(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1391: ... name_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__name_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_7;
}
static void cont__compiler__identifier__to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1391: ... string(namespace_of(self) "::" name_of(self))
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  arguments->slots[1] = string__2d7981f4e6d82bff;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_9;
}
static void cont__compiler__identifier__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1391: -> string(namespace_of(self) "::" name_of(self))
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_string_2(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1390: namespace_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__namespace_of();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_3;
}
static void cont__compiler__identifier__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1390: namespace_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_4;
}
static void cont__compiler__identifier__to_string_4(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1391: -> string(namespace_of(self) "::" name_of(self))
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__identifier__to_string_5, 0);
  // 1389: ->
  // 1390:   namespace_of(self).is_defined
  // 1391:   -> string(namespace_of(self) "::" name_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[3] /* temp__3 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_string_10(void) {
  allocate_initialized_frame_gc(1, 3);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1392: ... self.is_not_used
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__is_not_used();
  func = myself->type;
  frame->cont = cont__compiler__identifier__to_string_11;
}
static void cont__compiler__identifier__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1392: ... -> string('_' name_of(self))
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__identifier__to_string_12, 0);
  // 1392: -> self.is_not_used -> string('_' name_of(self))
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_string_15(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1393: ... -> name_of(self)
  frame->slots[1] /* temp__1 */ = create_closure(entry__compiler__identifier__to_string_16, 0);
  // 1393: -> true -> name_of(self)
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__true();
  arguments->slots[1] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__identifier__to_string_1(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1389: ->
  // 1390:   namespace_of(self).is_defined
  // 1391:   -> string(namespace_of(self) "::" name_of(self))
  frame->slots[1] /* temp__1 */ = create_closure(entry__compiler__identifier__to_string_2, 0);
  // 1392: -> self.is_not_used -> string('_' name_of(self))
  frame->slots[2] /* temp__2 */ = create_closure(entry__compiler__identifier__to_string_10, 0);
  // 1393: -> true -> name_of(self)
  frame->slots[3] /* temp__3 */ = create_closure(entry__compiler__identifier__to_string_15, 0);
  // 1388: cond
  // 1389:   ->
  // 1390:     namespace_of(self).is_defined
  // 1391:     -> string(namespace_of(self) "::" name_of(self))
  // 1392:   -> self.is_not_used -> string('_' name_of(self))
  // 1393:   -> true -> name_of(self)
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  arguments->slots[1] = frame->slots[2] /* temp__2 */;
  arguments->slots[2] = frame->slots[3] /* temp__3 */;
  result_count = frame->caller_result_count;
  myself = get__cond();
  func = myself->type;
  frame = frame->caller_frame;
}
static void entry__compiler__c_code__to_string_2(void) {
  allocate_initialized_frame_gc(1, 9);
  // slot allocations:
  // self: 0
  // buf: 1
  // indent: 2
  // indentation: 3
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  frame->slots[1] /* buf */ = create_cell();
  frame->slots[2] /* indent */ = create_future();
  frame->slots[3] /* indentation */ = create_future();
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1406: expression_indent > 0
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__0;
  arguments->slots[1] = get__expression_indent();
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_3;
}
static void cont__compiler__c_code__to_string_3(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1404: $$buf
  // 1405:   if
  // 1406:     expression_indent > 0
  // 1407:     -> string('@nl;' spaces(expression_indent) "{@nl;")
  // 1408:     -> "{@nl;"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = func__compiler__c_code__to_string_4;
  arguments->slots[2] = func__compiler__c_code__to_string_8;
  result_count = 1;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_9;
}
static void entry__compiler__c_code__to_string_4(void) {
  allocate_initialized_frame_gc(0, 2);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1407: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_5;
}
static void cont__compiler__c_code__to_string_5(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__2 */ = arguments->slots[0];
  // 1407: ... string('@nl;' spaces(expression_indent) "{@nl;")
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = character__10;
  arguments->slots[1] = frame->slots[1] /* temp__2 */;
  arguments->slots[2] = string__2d7981f4e4d02bcf;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_7;
}
static void cont__compiler__c_code__to_string_7(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[0] /* temp__1 */ = arguments->slots[0];
  // 1407: -> string('@nl;' spaces(expression_indent) "{@nl;")
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__c_code__to_string_8(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1408: -> "{@nl;"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__2d7981f4e4d02bcf;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_9(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1410: $indent expression_indent+2
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  arguments->slots[1] = number__2;
  result_count = 1;
  myself = get__std__plus();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_10;
}
static void cont__compiler__c_code__to_string_10(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[2] /* indent */, arguments->slots[0]);
  // 1411: $indentation spaces(indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* indent */;
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_11;
}
static void cont__compiler__c_code__to_string_11(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  initialize_future(frame->slots[3] /* indentation */, arguments->slots[0]);
  // 1412: ... kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__kind_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_12;
}
static void cont__compiler__c_code__to_string_12(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1412: ... kind_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_13;
}
static void cont__compiler__c_code__to_string_13(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1412: ... :
  // 1413:   writeln_to &buf indentation "<kind @(kind_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_14, 0);
  // 1412: if kind_of(self).is_defined:
  // 1413:   writeln_to &buf indentation "<kind @(kind_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_19;
}
static void entry__compiler__c_code__to_string_14(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1413: ... kind_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__kind_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_15;
}
static void cont__compiler__c_code__to_string_15(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1413: ... "<kind @(kind_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__4a1f55ee819ae2f7;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_17;
}
static void cont__compiler__c_code__to_string_17(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1413: writeln_to &buf indentation "<kind @(kind_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_18;
}
static void cont__compiler__c_code__to_string_18(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_19(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1414: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_20;
}
static void cont__compiler__c_code__to_string_20(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1414: ... identifier_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_21;
}
static void cont__compiler__c_code__to_string_21(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1414: ... :
  // 1415:   writeln_to &buf indentation "<name @(identifier_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_22, 0);
  // 1414: if identifier_of(self).is_defined:
  // 1415:   writeln_to &buf indentation "<name @(identifier_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_27;
}
static void entry__compiler__c_code__to_string_22(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1415: ... identifier_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__identifier_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_23;
}
static void cont__compiler__c_code__to_string_23(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1415: ... "<name @(identifier_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__5a1f552e8192b2f7;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_25;
}
static void cont__compiler__c_code__to_string_25(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1415: writeln_to &buf indentation "<name @(identifier_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_26;
}
static void cont__compiler__c_code__to_string_26(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_27(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1416: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_28;
}
static void cont__compiler__c_code__to_string_28(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1416: ... node_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_29;
}
static void cont__compiler__c_code__to_string_29(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1416: ... :
  // 1417:   writeln_to &buf indentation "<node @(node_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_30, 0);
  // 1416: if node_of(self).is_defined:
  // 1417:   writeln_to &buf indentation "<node @(node_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_35;
}
static void entry__compiler__c_code__to_string_30(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1417: ... node_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__node_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_31;
}
static void cont__compiler__c_code__to_string_31(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1417: ... "<node @(node_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__461f576e8192b2f7;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_33;
}
static void cont__compiler__c_code__to_string_33(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1417: writeln_to &buf indentation "<node @(node_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_34;
}
static void cont__compiler__c_code__to_string_34(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_35(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1418: ... node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_36;
}
static void cont__compiler__c_code__to_string_36(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1418: ... node::type_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_37;
}
static void cont__compiler__c_code__to_string_37(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1418: ... :
  // 1419:   writeln_to &buf indentation "<type @(node::type_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_38, 0);
  // 1418: if node::type_of(self).is_defined:
  // 1419:   writeln_to &buf indentation "<type @(node::type_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_43;
}
static void entry__compiler__c_code__to_string_38(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1419: ... node::type_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__node__type_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_39;
}
static void cont__compiler__c_code__to_string_39(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1419: ... "<type @(node::type_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__6a1f526e819312f7;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_41;
}
static void cont__compiler__c_code__to_string_41(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1419: writeln_to &buf indentation "<type @(node::type_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_42;
}
static void cont__compiler__c_code__to_string_42(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_43(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1420: ... base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_44;
}
static void cont__compiler__c_code__to_string_44(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1420: ... base_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_45;
}
static void cont__compiler__c_code__to_string_45(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1420: ... :
  // 1421:   writeln_to &buf indentation "<base @(base_of(self))>"
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_46, 0);
  // 1420: if base_of(self).is_defined:
  // 1421:   writeln_to &buf indentation "<base @(base_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_51;
}
static void entry__compiler__c_code__to_string_46(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1421: ... base_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__base_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_47;
}
static void cont__compiler__c_code__to_string_47(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1421: ... "<base @(base_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__5a1f52ae819272f7;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_49;
}
static void cont__compiler__c_code__to_string_49(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1421: writeln_to &buf indentation "<base @(base_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_50;
}
static void cont__compiler__c_code__to_string_50(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_51(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1422: ... scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_52;
}
static void cont__compiler__c_code__to_string_52(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[6] /* temp__3 */ = arguments->slots[0];
  // 1422: ... scope_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[6] /* temp__3 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_53;
}
static void cont__compiler__c_code__to_string_53(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1422: ... scope_of(self) != "local"
  frame->slots[7] /* temp__4 */ = create_closure(entry__compiler__c_code__to_string_54, 0);
  // 1422: ... scope_of(self).is_defined && scope_of(self) != "local"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = frame->slots[7] /* temp__4 */;
  result_count = 1;
  myself = get__std__and();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_59;
}
static void entry__compiler__c_code__to_string_54(void) {
  allocate_initialized_frame_gc(1, 4);
  // slot allocations:
  // self: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1422: ... scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_55;
}
static void cont__compiler__c_code__to_string_55(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__3 */ = arguments->slots[0];
  // 1422: ... scope_of(self) != "local"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__3 */;
  arguments->slots[1] = string__545aebc3eac0d03b;
  result_count = 1;
  myself = get__std__equal();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_57;
}
static void cont__compiler__c_code__to_string_57(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[2] /* temp__2 */ = arguments->slots[0];
  // 1422: ... scope_of(self) != "local"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* temp__2 */;
  result_count = 1;
  myself = get__std__not();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_58;
}
static void cont__compiler__c_code__to_string_58(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[1] /* temp__1 */ = arguments->slots[0];
  // 1422: ... scope_of(self) != "local"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* temp__1 */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_59(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1422: ... :
  // 1423:   writeln_to &buf indentation "<scope @(scope_of(self))>"
  frame->slots[8] /* temp__5 */ = create_closure(entry__compiler__c_code__to_string_60, 0);
  // 1422: if scope_of(self).is_defined && scope_of(self) != "local":
  // 1423:   writeln_to &buf indentation "<scope @(scope_of(self))>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[8] /* temp__5 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_65;
}
static void entry__compiler__c_code__to_string_60(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // indentation: 1
  // self: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[3]; /* indentation */
  frame->slots[2] = myself->closure.frame->slots[0]; /* self */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1423: ... scope_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[2] /* self */;
  result_count = 1;
  myself = get__scope_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_61;
}
static void cont__compiler__c_code__to_string_61(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1423: ... "<scope @(scope_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__ad7409db1592f0da;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_63;
}
static void cont__compiler__c_code__to_string_63(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1423: writeln_to &buf indentation "<scope @(scope_of(self))>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = frame->slots[1] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_64;
}
static void cont__compiler__c_code__to_string_64(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_65(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1424: ... arguments_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__arguments_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_66;
}
static void cont__compiler__c_code__to_string_66(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1424: ... : (argument)
  // 1425:   writeln_to &buf indentation "<argument @(argument)>"
  frame->slots[5] /* temp__2 */ = create_closure(entry__compiler__c_code__to_string_67, 1);
  // 1424: for_each arguments_of(self): (argument)
  // 1425:   writeln_to &buf indentation "<argument @(argument)>"
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__2 */;
  result_count = 0;
  myself = get__for_each();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_71;
}
static void entry__compiler__c_code__to_string_67(void) {
  allocate_initialized_frame_gc(3, 4);
  // slot allocations:
  // argument: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1425: ... "<argument @(argument)>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = string__3f7af391278ba7e1;
  arguments->slots[1] = frame->slots[0] /* argument */;
  arguments->slots[2] = string__578a5af303e9cdf;
  result_count = 1;
  myself = get__std__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_69;
}
static void cont__compiler__c_code__to_string_69(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1425: writeln_to &buf indentation "<argument @(argument)>"
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* indentation */;
  arguments->slots[2] = frame->slots[3] /* temp__1 */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_70;
}
static void cont__compiler__c_code__to_string_70(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_71(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1426: ... remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_72;
}
static void cont__compiler__c_code__to_string_72(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1426: ... remark_lines_of(self).is_empty
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_empty();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_73;
}
static void cont__compiler__c_code__to_string_73(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1426: ... :
  // 1427:   push &buf '@nl;'
  // 1428:   for_each remark_lines_of(self): (remark_line)
  // 1429:     writeln_to &buf indentation "//" remark_line
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_74, 0);
  // 1426: unless remark_lines_of(self).is_empty:
  // 1427:   push &buf '@nl;'
  // 1428:   for_each remark_lines_of(self): (remark_line)
  // 1429:     writeln_to &buf indentation "//" remark_line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__unless();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_80;
}
static void entry__compiler__c_code__to_string_77(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // remark_line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1429: writeln_to &buf indentation "//" remark_line
  argument_count = 4;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* indentation */;
  arguments->slots[2] = string__2d7981f4e6702bea;
  arguments->slots[3] = frame->slots[0] /* remark_line */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_79;
}
static void cont__compiler__c_code__to_string_79(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__c_code__to_string_74(void) {
  allocate_initialized_frame_gc(3, 5);
  // slot allocations:
  // buf: 0
  // self: 1
  // indentation: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1427: push &buf '@nl;'
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  arguments->slots[1] = character__10;
  result_count = 1;
  myself = get__push();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_75;
}
static void cont__compiler__c_code__to_string_75(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  // 1428: ... remark_lines_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__remark_lines_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_76;
}
static void cont__compiler__c_code__to_string_76(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1428: ... : (remark_line)
  // 1429:   writeln_to &buf indentation "//" remark_line
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__c_code__to_string_77, 1);
  // 1428: for_each remark_lines_of(self): (remark_line)
  // 1429:   writeln_to &buf indentation "//" remark_line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__c_code__to_string_80(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1430: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[0] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_81;
}
static void cont__compiler__c_code__to_string_81(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1430: ... source_of(self).is_defined
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  result_count = 1;
  myself = get__is_defined();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_82;
}
static void cont__compiler__c_code__to_string_82(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1430: ... :
  // 1431:   if length_of(buf) > 4: writeln_to &buf
  // 1432:   for_each_line source_of(self): (line) writeln_to &buf indentation line
  frame->slots[6] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_83, 0);
  // 1430: if source_of(self).is_defined:
  // 1431:   if length_of(buf) > 4: writeln_to &buf
  // 1432:   for_each_line source_of(self): (line) writeln_to &buf indentation line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[4] /* temp__1 */;
  arguments->slots[1] = frame->slots[6] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_92;
}
static void entry__compiler__c_code__to_string_90(void) {
  allocate_initialized_frame_gc(3, 3);
  // slot allocations:
  // line: 0
  // buf: 1
  // indentation: 2
  frame->slots[1] = myself->closure.frame->slots[0]; /* buf */
  frame->slots[2] = myself->closure.frame->slots[2]; /* indentation */
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1432: ... writeln_to &buf indentation line
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[2] /* indentation */;
  arguments->slots[2] = frame->slots[0] /* line */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_91;
}
static void cont__compiler__c_code__to_string_91(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__c_code__to_string_83(void) {
  allocate_initialized_frame_gc(3, 6);
  // slot allocations:
  // buf: 0
  // self: 1
  // indentation: 2
  frame->slots[0] = myself->closure.frame->slots[1]; /* buf */
  frame->slots[1] = myself->closure.frame->slots[0]; /* self */
  frame->slots[2] = myself->closure.frame->slots[3]; /* indentation */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1431: ... length_of(buf)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__length_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_84;
}
static void cont__compiler__c_code__to_string_84(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__2 */ = arguments->slots[0];
  // 1431: ... length_of(buf) > 4
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = number__4;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = 1;
  myself = get__std__less();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_85;
}
static void cont__compiler__c_code__to_string_85(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1431: ... : writeln_to &buf
  frame->slots[5] /* temp__3 */ = create_closure(entry__compiler__c_code__to_string_86, 0);
  // 1431: if length_of(buf) > 4: writeln_to &buf
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[5] /* temp__3 */;
  result_count = 0;
  myself = get__if();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_88;
}
static void entry__compiler__c_code__to_string_86(void) {
  allocate_initialized_frame_gc(1, 1);
  // slot allocations:
  // buf: 0
  frame->slots[0] = myself->closure.frame->slots[0]; /* buf */
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1431: ... writeln_to &buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[0])->contents /* buf */;
  result_count = 1;
  myself = get__writeln_to();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_87;
}
static void cont__compiler__c_code__to_string_87(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[0])->contents /* buf */ = arguments->slots[0];
  argument_count = 0;
  arguments = node_p;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void cont__compiler__c_code__to_string_88(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1432: ... source_of(self)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = frame->slots[1] /* self */;
  result_count = 1;
  myself = get__source_of();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_89;
}
static void cont__compiler__c_code__to_string_89(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[3] /* temp__1 */ = arguments->slots[0];
  // 1432: ... : (line) writeln_to &buf indentation line
  frame->slots[4] /* temp__2 */ = create_closure(entry__compiler__c_code__to_string_90, 1);
  // 1432: for_each_line source_of(self): (line) writeln_to &buf indentation line
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[3] /* temp__1 */;
  arguments->slots[1] = frame->slots[4] /* temp__2 */;
  result_count = frame->caller_result_count;
  myself = get__for_each_line();
  func = myself->type;
  frame = frame->caller_frame;
}
static void cont__compiler__c_code__to_string_92(void) {
  if (argument_count != 0) {
    invalid_results_error();
    return;
  }
  // 1433: ... spaces(expression_indent)
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = get__expression_indent();
  result_count = 1;
  myself = get__spaces();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_93;
}
static void cont__compiler__c_code__to_string_93(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[5] /* temp__2 */ = arguments->slots[0];
  // 1433: ... string(spaces(expression_indent) '}')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = frame->slots[5] /* temp__2 */;
  arguments->slots[1] = character__125;
  result_count = 1;
  myself = get__string();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_94;
}
static void cont__compiler__c_code__to_string_94(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  frame->slots[4] /* temp__1 */ = arguments->slots[0];
  // 1433: append &buf string(spaces(expression_indent) '}')
  argument_count = 2;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  arguments->slots[1] = frame->slots[4] /* temp__1 */;
  result_count = 1;
  myself = get__append();
  func = myself->type;
  frame->cont = cont__compiler__c_code__to_string_95;
}
static void cont__compiler__c_code__to_string_95(void) {
  if (argument_count != 1) {
    invalid_results_error();
    return;
  }
  ((CELL *)frame->slots[1])->contents /* buf */ = arguments->slots[0];
  // 1434: -> buf
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = ((CELL *)frame->slots[1])->contents /* buf */;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__c_code__to_string_96(void) {
  allocate_initialized_frame_gc(0, 0);
  // slot allocations:
  if (argument_count != 0) {
    invalid_arguments_error();
    return;
  }
  // 1402: -> "{...}"
  argument_count = 1;
  arguments = node_p;
  arguments->slots[0] = string__d65af883e8b9a02a;
  frame = frame->caller_frame;
  func = frame->cont;
  frame->cont = invalid_continuation;
}
static void entry__compiler__c_code__to_string_1(void) {
  allocate_initialized_frame_gc(1, 2);
  // slot allocations:
  // self: 0
  if (argument_count != 1) {
    invalid_arguments_error();
    return;
  }
  // 1399: !statement_tag ALWAYS
  set__statement_tag(var._ALWAYS);
  // 1403: :
  // 1404:   $$buf
  // 1405:     if
  // 1406:       expression_indent > 0
  // 1407:       -> string('@nl;' spaces(expression_indent) "{@nl;")
  // 1408:       -> "{@nl;"
  // 1409:   
  // 1410:   $indent expression_indent+2
  // 1411:   $indentation spaces(indent)
  // 1412:   if kind_of(self).is_defined:
  // ...
  frame->slots[1] /* temp__1 */ = create_closure(entry__compiler__c_code__to_string_2, 0);
  // 1400: if
  // 1401:   hide_body_statements
  // 1402:   -> "{...}"
  // 1403:   :
  // 1404:     $$buf
  // 1405:       if
  // 1406:         expression_indent > 0
  // 1407:         -> string('@nl;' spaces(expression_indent) "{@nl;")
  // 1408:         -> "{@nl;"
  // 1409:     
  // ...
  argument_count = 3;
  arguments = node_p;
  arguments->slots[0] = get__hide_body_statements();
  arguments->slots[1] = func__compiler__c_code__to_string_96;
  arguments->slots[2] = frame->slots[1] /* temp__1 */;
  result_count = frame->caller_result_count;
  myself = get__if();
  func = myself->type;
  frame = frame->caller_frame;
}
EXPORT void collect__pretty_printer(void) {
  var._needs_parenthesis = collect_node(var._needs_parenthesis);
  var._ALWAYS = collect_node(var._ALWAYS);
  var._SHEBANG = collect_node(var._SHEBANG);
  var._REMARK = collect_node(var._REMARK);
  var._CODE_EXCLUSION = collect_node(var._CODE_EXCLUSION);
  var._REQUIRE = collect_node(var._REQUIRE);
  var._NAMESPACE = collect_node(var._NAMESPACE);
  var._USING = collect_node(var._USING);
  var._INCLUDE = collect_node(var._INCLUDE);
  var._LINK = collect_node(var._LINK);
  var._DATA = collect_node(var._DATA);
  var._POLYMORPHIC_FUNCTION = collect_node(var._POLYMORPHIC_FUNCTION);
  var._UNIQUE = collect_node(var._UNIQUE);
  var._PROC = collect_node(var._PROC);
  var._FUNC = collect_node(var._FUNC);
  var._UNLIMITED = collect_node(var._UNLIMITED);
  var._INDENTATION_MARKER = collect_node(var._INDENTATION_MARKER);
  var._INDENTATION_MARKER_HIGH = collect_node(var._INDENTATION_MARKER_HIGH);
  var._INDENTATION = collect_node(var._INDENTATION);
  var._indentation_string = collect_node(var._indentation_string);
  var.compiler__print_trees = collect_node(var.compiler__print_trees);
  var._line_start_remark_to_string = collect_node(var._line_start_remark_to_string);
  var._add_remark_lines = collect_node(var._add_remark_lines);
  var._add_statement_remark = collect_node(var._add_statement_remark);
  var._add_remark = collect_node(var._add_remark);
  var._add_indented_remark = collect_node(var._add_indented_remark);
  var._argument_to_string = collect_node(var._argument_to_string);
  var._arguments_to_string = collect_node(var._arguments_to_string);
  var._definition_to_string = collect_node(var._definition_to_string);
  var._precedence_of = collect_node(var._precedence_of);
  var._operator_of = collect_node(var._operator_of);
  var._pair_to_string = collect_node(var._pair_to_string);
  var._character_to_name = collect_node(var._character_to_name);
  var._create_character_table = collect_node(var._create_character_table);
  var._escaped_character = collect_node(var._escaped_character);
  var._analyze_string_literal = collect_node(var._analyze_string_literal);
  var._print_string_literal = collect_node(var._print_string_literal);
  var._string_template_to_string = collect_node(var._string_template_to_string);
}

static int already_run_phase_1 = false;

EXPORT void phase_1__pretty_printer(void) {
  if (already_run_phase_1) return;
  already_run_phase_1 = true;
  register_module_info(&module_info);
}

static int already_run_phase_2 = false;

EXPORT void phase_2__pretty_printer(void) {
  if (already_run_phase_2) return;
  already_run_phase_2 = true;
  set_module("pretty_printer");
  character__9 = from_uchar32(9);
  number__6 = from_uint32(6U);
  character__35 = from_uchar32(35);
  character__38 = from_uchar32(38);
  character__47 = from_uchar32(47);
  character__94 = from_uchar32(94);
  number__80 = from_uint32(80U);
  character__160 = from_uchar32(160);
  character__96 = from_uchar32(96);
  character__99 = from_uchar32(99);
  character__688 = from_uchar32(688);
  character__63 = from_uchar32(63);
  character__10 = from_uchar32(10);
  number__999999 = from_uint32(999999U);
  character__109 = from_uchar32(109);
  character__58 = from_uchar32(58);
  number__0 = from_uint32(0U);
  number__3 = from_uint32(3U);
  number__4 = from_uint32(4U);
  character__37 = from_uchar32(37);
  character__95 = from_uchar32(95);
  number__0x80 = from_uint32(128U);
  character__33 = from_uchar32(33);
  number__8 = from_uint32(8U);
  character__64 = from_uchar32(64);
  character__98 = from_uchar32(98);
  character__40 = from_uchar32(40);
  character__111 = from_uchar32(111);
  character__34 = from_uchar32(34);
  character__36 = from_uchar32(36);
  character__39 = from_uchar32(39);
  character__105 = from_uchar32(105);
  character__32 = from_uchar32(32);
  character__125 = from_uchar32(125);
  character__115 = from_uchar32(115);
  character__41 = from_uchar32(41);
  character__59 = from_uchar32(59);
  number__1 = from_uint32(1U);
  number__0x9f = from_uint32(159U);
  character__46 = from_uchar32(46);
  number__2 = from_uint32(2U);
  number__20 = from_uint32(20U);
  character__42 = from_uchar32(42);
  character__128 = from_uchar32(128);
  character__79 = from_uchar32(79);
  character__114 = from_uchar32(114);
  register_polymorphic_function("_pretty_printer::needs_parenthesis", &poly_idx__needs_parenthesis);
  unique__ALWAYS = register_unique_item("ALWAYS");
  unique__SHEBANG = register_unique_item("SHEBANG");
  unique__REMARK = register_unique_item("REMARK");
  unique__CODE_EXCLUSION = register_unique_item("CODE_EXCLUSION");
  unique__REQUIRE = register_unique_item("REQUIRE");
  unique__NAMESPACE = register_unique_item("NAMESPACE");
  unique__USING = register_unique_item("USING");
  unique__INCLUDE = register_unique_item("INCLUDE");
  unique__LINK = register_unique_item("LINK");
  unique__DATA = register_unique_item("DATA");
  unique__POLYMORPHIC_FUNCTION = register_unique_item("POLYMORPHIC_FUNCTION");
  unique__UNIQUE = register_unique_item("UNIQUE");
  unique__PROC = register_unique_item("PROC");
  unique__FUNC = register_unique_item("FUNC");
  func__INDENTATION__grammar__match_13 = create_function(entry__INDENTATION__grammar__match_13, 0);
  func__INDENTATION__grammar__match_14 = create_function(entry__INDENTATION__grammar__match_14, 0);
  func__INDENTATION__grammar__match_1 = create_function(entry__INDENTATION__grammar__match_1, 2);
  func__indentation_string_1 = create_function(entry__indentation_string_1, 1);
  func__compiler__print_trees_2 = create_function(entry__compiler__print_trees_2, 1);
  func__compiler__print_trees_30 = create_function(entry__compiler__print_trees_30, 0);
  func__compiler__print_trees_46 = create_function(entry__compiler__print_trees_46, 1);
  func__compiler__print_trees_6 = create_function(entry__compiler__print_trees_6, 2);
  func__compiler__print_trees_1 = create_function(entry__compiler__print_trees_1, 1);
  string__578a5af303e9ceb = from_latin_1_string("\012", 1);
  func__line_start_remark_to_string_1 = create_function(entry__line_start_remark_to_string_1, 2);
  string__578a5af303e9cc2 = from_latin_1_string("#", 1);
  func__add_remark_lines_3 = create_function(entry__add_remark_lines_3, 0);
  string__2d7981f4e6082be6 = from_latin_1_string(" #", 2);
  func__add_remark_lines_5 = create_function(entry__add_remark_lines_5, 0);
  string__578a5af303e9cdb = from_latin_1_string(":", 1);
  func__add_remark_lines_1 = create_function(entry__add_remark_lines_1, -1);
  func__add_statement_remark_1 = create_function(entry__add_statement_remark_1, 2);
  func__add_remark_1 = create_function(entry__add_remark_1, 2);
  func__add_indented_remark_1 = create_function(entry__add_indented_remark_1, 2);
  string__f45afcc3e835d069 = from_latin_1_string("<???>", 5);
  func__types__grammar_node__to_string_1 = create_function(entry__types__grammar_node__to_string_1, 1);
  string__7ca422245e2a26c5 = from_latin_1_string("<require ", 9);
  string__578a5af303e9cdf = from_latin_1_string(">", 1);
  func__compiler__require_instruction__to_string_1 = create_function(entry__compiler__require_instruction__to_string_1, 1);
  string__82c941922e20aab7 = from_latin_1_string("<namespace ", 11);
  string__fa730415fc16bec = from_latin_1_string(" = ", 3);
  func__compiler__namespace_instruction__to_string_1 = create_function(entry__compiler__namespace_instruction__to_string_1, 1);
  string__a1740e581583f0da = from_latin_1_string("<using ", 7);
  func__compiler__using_instruction__to_string_1 = create_function(entry__compiler__using_instruction__to_string_1, 1);
  string__448827ad5e2bb5a5 = from_latin_1_string("<include ", 9);
  func__compiler__include_instruction__to_string_1 = create_function(entry__compiler__include_instruction__to_string_1, 1);
  string__4a1f55ee81e292f7 = from_latin_1_string("<link ", 6);
  func__compiler__link_instruction__to_string_1 = create_function(entry__compiler__link_instruction__to_string_1, 1);
  string__5a1f536e81b212f7 = from_latin_1_string("<data ", 6);
  func__compiler__data_instruction__to_string_1 = create_function(entry__compiler__data_instruction__to_string_1, 1);
  func__compiler__remark_statement__to_string_6 = create_function(entry__compiler__remark_statement__to_string_6, 0);
  func__compiler__remark_statement__to_string_23 = create_function(entry__compiler__remark_statement__to_string_23, 0);
  func__compiler__remark_statement__to_string_27 = create_function(entry__compiler__remark_statement__to_string_27, 0);
  func__compiler__remark_statement__to_string_29 = create_function(entry__compiler__remark_statement__to_string_29, 0);
  func__compiler__remark_statement__to_string_28 = create_function(entry__compiler__remark_statement__to_string_28, 0);
  func__compiler__remark_statement__to_string_1 = create_function(entry__compiler__remark_statement__to_string_1, 1);
  string__fa736c15f296be4 = from_latin_1_string(": (", 3);
  string__578a5af303e9cc9 = from_latin_1_string("(", 1);
  func__compiler__body__to_string_90 = create_function(entry__compiler__body__to_string_90, 1);
  func__compiler__body__to_string_102 = create_function(entry__compiler__body__to_string_102, 1);
  string__9e0afacb5f107d33 = from_latin_1_string("...\012", 4);
  func__compiler__body__to_string_1 = create_function(entry__compiler__body__to_string_1, 1);
  func__argument_to_string_11 = create_function(entry__argument_to_string_11, 0);
  func__argument_to_string_1 = create_function(entry__argument_to_string_1, 1);
  string__2d7981f4e6602bfb = from_latin_1_string("->", 2);
  func__arguments_to_string_50 = create_function(entry__arguments_to_string_50, 0);
  func__arguments_to_string_51 = create_function(entry__arguments_to_string_51, 0);
  string__2d7981f4e6182bcf = from_latin_1_string("\042\012", 2);
  func__arguments_to_string_159 = create_function(entry__arguments_to_string_159, 0);
  func__arguments_to_string_244 = create_function(entry__arguments_to_string_244, 0);
  func__arguments_to_string_245 = create_function(entry__arguments_to_string_245, 0);
  func__arguments_to_string_246 = create_function(entry__arguments_to_string_246, 0);
  func__arguments_to_string_247 = create_function(entry__arguments_to_string_247, 0);
  func__arguments_to_string_248 = create_function(entry__arguments_to_string_248, 0);
  func__arguments_to_string_249 = create_function(entry__arguments_to_string_249, 0);
  func__arguments_to_string_250 = create_function(entry__arguments_to_string_250, 0);
  func__arguments_to_string_251 = create_function(entry__arguments_to_string_251, 0);
  func__arguments_to_string_1 = create_function(entry__arguments_to_string_1, 3);
  func__compiler__call__to_string_29 = create_function(entry__compiler__call__to_string_29, 0);
  func__compiler__call__to_string_32 = create_function(entry__compiler__call__to_string_32, 0);
  func__compiler__call__to_string_35 = create_function(entry__compiler__call__to_string_35, 0);
  func__compiler__call__to_string_48 = create_function(entry__compiler__call__to_string_48, 0);
  func__compiler__call__to_string_1 = create_function(entry__compiler__call__to_string_1, 1);
  string__fa733015fd96bec = from_latin_1_string("-> ", 3);
  func__definition_to_string_1 = create_function(entry__definition_to_string_1, 2);
  func__compiler__define_static_single__to_string_4 = create_function(entry__compiler__define_static_single__to_string_4, 0);
  string__578a5af303e9cc5 = from_latin_1_string("$", 1);
  func__compiler__define_static_single__to_string_5 = create_function(entry__compiler__define_static_single__to_string_5, 0);
  func__compiler__define_static_single__to_string_1 = create_function(entry__compiler__define_static_single__to_string_1, 1);
  func__compiler__define_static_multi__to_string_4 = create_function(entry__compiler__define_static_multi__to_string_4, 0);
  string__578a5af303e9cc0 = from_latin_1_string("!", 1);
  func__compiler__define_static_multi__to_string_5 = create_function(entry__compiler__define_static_multi__to_string_5, 0);
  string__578a5af303e9cc7 = from_latin_1_string("&", 1);
  func__compiler__define_static_multi__to_string_7 = create_function(entry__compiler__define_static_multi__to_string_7, 0);
  string__2d7981f4e6282be1 = from_latin_1_string("$$", 2);
  func__compiler__define_static_multi__to_string_9 = create_function(entry__compiler__define_static_multi__to_string_9, 0);
  func__compiler__define_static_multi__to_string_1 = create_function(entry__compiler__define_static_multi__to_string_1, 1);
  string__578a5af303e9cc4 = from_latin_1_string("%", 1);
  func__compiler__define_dynamic_single__to_string_1 = create_function(entry__compiler__define_dynamic_single__to_string_1, 1);
  string__2d7981f4e6202be0 = from_latin_1_string("%%", 2);
  func__compiler__define_dynamic_multi__to_string_1 = create_function(entry__compiler__define_dynamic_multi__to_string_1, 1);
  func__precedence_of_17 = create_function(entry__precedence_of_17, 0);
  func__precedence_of_18 = create_function(entry__precedence_of_18, 0);
  func__precedence_of_19 = create_function(entry__precedence_of_19, 0);
  func__precedence_of_1 = create_function(entry__precedence_of_1, 1);
  func__operator_of_15 = create_function(entry__operator_of_15, 0);
  func__operator_of_1 = create_function(entry__operator_of_1, 1);
  func__compiler__function_call__to_string_21 = create_function(entry__compiler__function_call__to_string_21, 0);
  string__2d7981f4e6082beb = from_latin_1_string(" .", 2);
  string__2d7981f4e6782be5 = from_latin_1_string(". ", 2);
  string__fa724815d896ba8 = from_latin_1_string("std", 3);
  string__64d512703527e2ab = from_latin_1_string("key_value_pair", 14);
  string__2a0aedcb5dc87d5c = from_latin_1_string("true", 4);
  string__2d7981f4e6602be8 = from_latin_1_string("--", 2);
  string__578a5af303e9cca = from_latin_1_string("+", 1);
  string__578a5af303e9ccc = from_latin_1_string("-", 1);
  string__578a5af303e9ccb = from_latin_1_string("*", 1);
  string__578a5af303e9cce = from_latin_1_string("/", 1);
  string__578a5af303e9ccd = from_latin_1_string(",", 1);
  string__6480ae5e84ccc225 = from_latin_1_string("sequence", 8);
  func__compiler__function_call__to_string_1 = create_function(entry__compiler__function_call__to_string_1, 1);
  func__compiler__remark_argument__to_string_1 = create_function(entry__compiler__remark_argument__to_string_1, 1);
  func__compiler__backquoted__to_string_1 = create_function(entry__compiler__backquoted__to_string_1, 1);
  func__pair_to_string_1 = create_function(entry__pair_to_string_1, 2);
  func__compiler__attribute_value_pair__to_string_1 = create_function(entry__compiler__attribute_value_pair__to_string_1, 1);
  func__compiler__attribute_function_pair__to_string_1 = create_function(entry__compiler__attribute_function_pair__to_string_1, 1);
  func__compiler__numeric_literal__to_string_1 = create_function(entry__compiler__numeric_literal__to_string_1, 1);
  func__create_character_table_2 = create_function(entry__create_character_table_2, 2);
  func__create_character_table_1 = create_function(entry__create_character_table_1, 0);
  string__fa728415fa96bb4 = from_latin_1_string("@0x", 3);
  string__2d7981f4e4002bb1 = from_latin_1_string("at", 2);
  string__2d7981f4e5082b85 = from_latin_1_string("@@", 2);
  func__escaped_character_18 = create_function(entry__escaped_character_18, 0);
  string__fa720015d416bbc = from_latin_1_string("amp", 3);
  func__escaped_character_21 = create_function(entry__escaped_character_21, 0);
  func__escaped_character_1 = create_function(entry__escaped_character_1, -1);
  func__compiler__character_literal__to_string_1 = create_function(entry__compiler__character_literal__to_string_1, 1);
  string__420aeacb5d007d02 = from_latin_1_string("@nl;", 4);
  string__721f5590811b42ec = from_latin_1_string("@quot;", 6);
  func__analyze_string_literal_67 = create_function(entry__analyze_string_literal_67, 0);
  func__analyze_string_literal_68 = create_function(entry__analyze_string_literal_68, 0);
  func__analyze_string_literal_1 = create_function(entry__analyze_string_literal_1, 1);
  func__print_string_literal_23 = create_function(entry__print_string_literal_23, 0);
  func__print_string_literal_24 = create_function(entry__print_string_literal_24, 0);
  string__578a5af303e9ca1 = from_latin_1_string("@", 1);
  string__2d7981f4e5082bfe = from_latin_1_string("@;", 2);
  string__578a5af303e9cc3 = from_latin_1_string("\042", 1);
  func__print_string_literal_1 = create_function(entry__print_string_literal_1, 2);
  string__2d7981f4e5082bed = from_latin_1_string("@(", 2);
  string__565ae803e8121017 = from_latin_1_string("@nl;@", 5);
  func__string_template_to_string_1 = create_function(entry__string_template_to_string_1, 1);
  func__compiler__string_literal__to_string_1 = create_function(entry__compiler__string_literal__to_string_1, 1);
  string__578a5af303e9ccf = from_latin_1_string(".", 1);
  func__compiler__unique_item__to_string_1 = create_function(entry__compiler__unique_item__to_string_1, 1);
  string__fa732415f216be5 = from_latin_1_string("(!)", 3);
  func__compiler__polymorphic_function__to_string_3 = create_function(entry__compiler__polymorphic_function__to_string_3, 0);
  string__2d7981f4e6482bec = from_latin_1_string("()", 2);
  func__compiler__polymorphic_function__to_string_5 = create_function(entry__compiler__polymorphic_function__to_string_5, 0);
  func__compiler__polymorphic_function__to_string_1 = create_function(entry__compiler__polymorphic_function__to_string_1, 1);
  string__2d7981f4e6d82bff = from_latin_1_string("::", 2);
  func__compiler__identifier__to_string_1 = create_function(entry__compiler__identifier__to_string_1, 1);
  string__2d7981f4e4d02bcf = from_latin_1_string("{\012", 2);
  func__compiler__c_code__to_string_4 = create_function(entry__compiler__c_code__to_string_4, 0);
  func__compiler__c_code__to_string_8 = create_function(entry__compiler__c_code__to_string_8, 0);
  string__4a1f55ee819ae2f7 = from_latin_1_string("<kind ", 6);
  string__5a1f552e8192b2f7 = from_latin_1_string("<name ", 6);
  string__461f576e8192b2f7 = from_latin_1_string("<node ", 6);
  string__6a1f526e819312f7 = from_latin_1_string("<type ", 6);
  string__5a1f52ae819272f7 = from_latin_1_string("<base ", 6);
  string__545aebc3eac0d03b = from_latin_1_string("local", 5);
  string__ad7409db1592f0da = from_latin_1_string("<scope ", 7);
  string__3f7af391278ba7e1 = from_latin_1_string("<argument ", 10);
  string__2d7981f4e6702bea = from_latin_1_string("//", 2);
  string__d65af883e8b9a02a = from_latin_1_string("{...}", 5);
  func__compiler__c_code__to_string_96 = create_function(entry__compiler__c_code__to_string_96, 0);
  func__compiler__c_code__to_string_1 = create_function(entry__compiler__c_code__to_string_1, 1);
}

static int already_run_phase_3 = false;

EXPORT void phase_3__pretty_printer(void) {
  if (already_run_phase_3) return;
  already_run_phase_3 = true;
  set_module("pretty_printer");
  set_used_namespaces(used_namespaces);
  assign_value(&var._ALWAYS, unique__ALWAYS);
  assign_value(&var._SHEBANG, unique__SHEBANG);
  assign_value(&var._REMARK, unique__REMARK);
  assign_value(&var._CODE_EXCLUSION, unique__CODE_EXCLUSION);
  assign_value(&var._REQUIRE, unique__REQUIRE);
  assign_value(&var._NAMESPACE, unique__NAMESPACE);
  assign_value(&var._USING, unique__USING);
  assign_value(&var._INCLUDE, unique__INCLUDE);
  assign_value(&var._LINK, unique__LINK);
  assign_value(&var._DATA, unique__DATA);
  assign_value(&var._POLYMORPHIC_FUNCTION, unique__POLYMORPHIC_FUNCTION);
  assign_value(&var._UNIQUE, unique__UNIQUE);
  assign_value(&var._PROC, unique__PROC);
  assign_value(&var._FUNC, unique__FUNC);
  define_single_assign_dynamic("compiler", "hide_body_statements", get__compiler__hide_body_statements, define__compiler__hide_body_statements, &dyna_idx__compiler__hide_body_statements);
  define__compiler__hide_body_statements(create_future());
  define_single_assign_dynamic("compiler", "line_width", get__compiler__line_width, define__compiler__line_width, &dyna_idx__compiler__line_width);
  register_dynamic(&dyna_idx__expression_indent);
  register_dynamic(&dyna_idx__line_end_expression_width);
  var._INDENTATION_MARKER = create_future();
  var._INDENTATION_MARKER_HIGH = create_future();
  var._INDENTATION = create_future();
  register_dynamic(&dyna_idx__statement_tag);
  define__statement_tag(undefined);
  register_dynamic(&dyna_idx__spaces);
  define__spaces(create_future());
  var.compiler__print_trees = create_future();
  define_single_assign_static("compiler", "print_trees", get__compiler__print_trees, &var.compiler__print_trees);
}

static int already_run_phase_4 = false;

EXPORT void phase_4__pretty_printer(void) {
  if (already_run_phase_4) return;
  already_run_phase_4 = true;
  set_module("pretty_printer");
  set_used_namespaces(used_namespaces);
  use_read_only(NULL, "ATTRIBUTE_KIND", &get__ATTRIBUTE_KIND, &get_value_or_future__ATTRIBUTE_KIND);
  use_read_only(NULL, "CONTINUATION_PARAMETER", &get__CONTINUATION_PARAMETER, &get_value_or_future__CONTINUATION_PARAMETER);
  use_read_only(NULL, "HIGHEST_PRECEDENCE", &get__HIGHEST_PRECEDENCE, &get_value_or_future__HIGHEST_PRECEDENCE);
  use_read_only(NULL, "INFIX_PRECEDENCE", &get__INFIX_PRECEDENCE, &get_value_or_future__INFIX_PRECEDENCE);
  use_read_only(NULL, "IN_OUT_PARAMETER", &get__IN_OUT_PARAMETER, &get_value_or_future__IN_OUT_PARAMETER);
  use_read_only(NULL, "IN_PARAMETER", &get__IN_PARAMETER, &get_value_or_future__IN_PARAMETER);
  use_read_only(NULL, "METHOD_KIND", &get__METHOD_KIND, &get_value_or_future__METHOD_KIND);
  use_read_only(NULL, "MYSELF_PARAMETER", &get__MYSELF_PARAMETER, &get_value_or_future__MYSELF_PARAMETER);
  use_read_only(NULL, "OUT_PARAMETER", &get__OUT_PARAMETER, &get_value_or_future__OUT_PARAMETER);
  use_read_only(NULL, "all_of", &get__all_of, &get_value_or_future__all_of);
  use_read_only(NULL, "alt", &get__alt, &get_value_or_future__alt);
  use_read_only(NULL, "any_of", &get__any_of, &get_value_or_future__any_of);
  use_read_only(NULL, "append", &get__append, &get_value_or_future__append);
  use_polymorphic_function(NULL, "arguments_of", &get__arguments_of, &poly_idx__arguments_of);
  use_read_only(NULL, "attribute_kind_of", &get__attribute_kind_of, &get_value_or_future__attribute_kind_of);
  use_read_only(NULL, "attribute_of", &get__attribute_of, &get_value_or_future__attribute_of);
  use_read_only(NULL, "base_of", &get__base_of, &get_value_or_future__base_of);
  use_read_only(NULL, "case", &get__case, &get_value_or_future__case);
  use_read_only(NULL, "character", &get__character, &get_value_or_future__character);
  use_read_only(NULL, "character_names", &get__character_names, &get_value_or_future__character_names);
  use_read_only(NULL, "check_case", &get__check_case, &get_value_or_future__check_case);
  use_read_only("compiler", "attribute_function_pair", &get__compiler__attribute_function_pair, &get_value_or_future__compiler__attribute_function_pair);
  use_read_only("compiler", "attribute_value_pair", &get__compiler__attribute_value_pair, &get_value_or_future__compiler__attribute_value_pair);
  use_read_only("compiler", "backquoted", &get__compiler__backquoted, &get_value_or_future__compiler__backquoted);
  use_read_only("compiler", "body", &get__compiler__body, &get_value_or_future__compiler__body);
  use_read_only("compiler", "c_code", &get__compiler__c_code, &get_value_or_future__compiler__c_code);
  use_read_only("compiler", "call", &get__compiler__call, &get_value_or_future__compiler__call);
  use_read_only("compiler", "character_literal", &get__compiler__character_literal, &get_value_or_future__compiler__character_literal);
  use_read_only("compiler", "data_instruction", &get__compiler__data_instruction, &get_value_or_future__compiler__data_instruction);
  use_read_only("compiler", "define_dynamic_multi", &get__compiler__define_dynamic_multi, &get_value_or_future__compiler__define_dynamic_multi);
  use_read_only("compiler", "define_dynamic_single", &get__compiler__define_dynamic_single, &get_value_or_future__compiler__define_dynamic_single);
  use_read_only("compiler", "define_static_multi", &get__compiler__define_static_multi, &get_value_or_future__compiler__define_static_multi);
  use_read_only("compiler", "define_static_single", &get__compiler__define_static_single, &get_value_or_future__compiler__define_static_single);
  use_read_only("compiler", "function_call", &get__compiler__function_call, &get_value_or_future__compiler__function_call);
  use_read_only("compiler", "identifier", &get__compiler__identifier, &get_value_or_future__compiler__identifier);
  use_read_only("compiler", "include_instruction", &get__compiler__include_instruction, &get_value_or_future__compiler__include_instruction);
  use_read_only("compiler", "link_instruction", &get__compiler__link_instruction, &get_value_or_future__compiler__link_instruction);
  use_read_only("compiler", "namespace_instruction", &get__compiler__namespace_instruction, &get_value_or_future__compiler__namespace_instruction);
  use_read_only("compiler", "numeric_literal", &get__compiler__numeric_literal, &get_value_or_future__compiler__numeric_literal);
  use_read_only("compiler", "polymorphic_function", &get__compiler__polymorphic_function, &get_value_or_future__compiler__polymorphic_function);
  use_read_only("compiler", "remark_argument", &get__compiler__remark_argument, &get_value_or_future__compiler__remark_argument);
  use_read_only("compiler", "remark_statement", &get__compiler__remark_statement, &get_value_or_future__compiler__remark_statement);
  use_read_only("compiler", "require_instruction", &get__compiler__require_instruction, &get_value_or_future__compiler__require_instruction);
  use_read_only("compiler", "string_literal", &get__compiler__string_literal, &get_value_or_future__compiler__string_literal);
  use_read_only("compiler", "unique_item", &get__compiler__unique_item, &get_value_or_future__compiler__unique_item);
  use_read_only("compiler", "using_instruction", &get__compiler__using_instruction, &get_value_or_future__compiler__using_instruction);
  use_read_only(NULL, "cond", &get__cond, &get_value_or_future__cond);
  use_read_only(NULL, "contains", &get__contains, &get_value_or_future__contains);
  use_read_only(NULL, "default_value", &get__default_value, &get_value_or_future__default_value);
  use_read_only(NULL, "default_value_of", &get__default_value_of, &get_value_or_future__default_value_of);
  use_read_only(NULL, "div", &get__div, &get_value_or_future__div);
  use_read_only(NULL, "do", &get__do, &get_value_or_future__do);
  use_read_only(NULL, "do_while", &get__do_while, &get_value_or_future__do_while);
  use_read_only(NULL, "dup", &get__dup, &get_value_or_future__dup);
  use_read_only(NULL, "empty_list", &get__empty_list, &get_value_or_future__empty_list);
  use_read_only(NULL, "empty_table", &get__empty_table, &get_value_or_future__empty_table);
  use_read_only(NULL, "false", &get__false, &get_value_or_future__false);
  use_read_only(NULL, "for_each", &get__for_each, &get_value_or_future__for_each);
  use_read_only(NULL, "for_each_from_to", &get__for_each_from_to, &get_value_or_future__for_each_from_to);
  use_read_only(NULL, "for_each_line", &get__for_each_line, &get_value_or_future__for_each_line);
  use_read_only(NULL, "from_down_to", &get__from_down_to, &get_value_or_future__from_down_to);
  use_read_only(NULL, "from_to", &get__from_to, &get_value_or_future__from_to);
  use_read_only(NULL, "functor_of", &get__functor_of, &get_value_or_future__functor_of);
  use_polymorphic_function("grammar", "match", &get__grammar__match, &poly_idx__grammar__match);
  use_read_only(NULL, "has_minimum_length", &get__has_minimum_length, &get_value_or_future__has_minimum_length);
  use_read_only(NULL, "has_prefix", &get__has_prefix, &get_value_or_future__has_prefix);
  use_read_only(NULL, "has_suffix", &get__has_suffix, &get_value_or_future__has_suffix);
  use_read_only(NULL, "hex", &get__hex, &get_value_or_future__hex);
  use_read_only(NULL, "hide_body_statements", &get__hide_body_statements, &get_value_or_future__hide_body_statements);
  use_read_only(NULL, "identifier_of", &get__identifier_of, &get_value_or_future__identifier_of);
  use_read_only(NULL, "if", &get__if, &get_value_or_future__if);
  use_read_only(NULL, "inc", &get__inc, &get_value_or_future__inc);
  use_read_only(NULL, "is_a_body", &get__is_a_body, &get_value_or_future__is_a_body);
  use_read_only(NULL, "is_a_definition", &get__is_a_definition, &get_value_or_future__is_a_definition);
  use_read_only(NULL, "is_a_destination", &get__is_a_destination, &get_value_or_future__is_a_destination);
  use_read_only(NULL, "is_a_function_call", &get__is_a_function_call, &get_value_or_future__is_a_function_call);
  use_read_only(NULL, "is_a_letter", &get__is_a_letter, &get_value_or_future__is_a_letter);
  use_read_only(NULL, "is_a_method_definition", &get__is_a_method_definition, &get_value_or_future__is_a_method_definition);
  use_read_only(NULL, "is_a_parameter", &get__is_a_parameter, &get_value_or_future__is_a_parameter);
  use_read_only(NULL, "is_a_polymorphic_function_constant", &get__is_a_polymorphic_function_constant, &get_value_or_future__is_a_polymorphic_function_constant);
  use_read_only(NULL, "is_a_remark", &get__is_a_remark, &get_value_or_future__is_a_remark);
  use_read_only(NULL, "is_a_return", &get__is_a_return, &get_value_or_future__is_a_return);
  use_read_only(NULL, "is_a_setter", &get__is_a_setter, &get_value_or_future__is_a_setter);
  use_read_only(NULL, "is_a_string_literal", &get__is_a_string_literal, &get_value_or_future__is_a_string_literal);
  use_read_only(NULL, "is_a_string_template", &get__is_a_string_template, &get_value_or_future__is_a_string_template);
  use_read_only(NULL, "is_a_unique_item_constant", &get__is_a_unique_item_constant, &get_value_or_future__is_a_unique_item_constant);
  use_read_only(NULL, "is_an_assignment", &get__is_an_assignment, &get_value_or_future__is_an_assignment);
  use_read_only(NULL, "is_an_attribute_access", &get__is_an_attribute_access, &get_value_or_future__is_an_attribute_access);
  use_read_only(NULL, "is_an_attribute_value_pair", &get__is_an_attribute_value_pair, &get_value_or_future__is_an_attribute_value_pair);
  use_read_only(NULL, "is_an_expanded_item", &get__is_an_expanded_item, &get_value_or_future__is_an_expanded_item);
  use_read_only(NULL, "is_an_identifier", &get__is_an_identifier, &get_value_or_future__is_an_identifier);
  use_read_only(NULL, "is_an_input_output_argument", &get__is_an_input_output_argument, &get_value_or_future__is_an_input_output_argument);
  use_read_only(NULL, "is_an_operator_symbol", &get__is_an_operator_symbol, &get_value_or_future__is_an_operator_symbol);
  use_read_only(NULL, "is_an_optional_item", &get__is_an_optional_item, &get_value_or_future__is_an_optional_item);
  use_read_only(NULL, "is_defined", &get__is_defined, &get_value_or_future__is_defined);
  use_read_only(NULL, "is_empty", &get__is_empty, &get_value_or_future__is_empty);
  use_read_only(NULL, "is_in_infix_notation", &get__is_in_infix_notation, &get_value_or_future__is_in_infix_notation);
  use_read_only(NULL, "is_in_numeric_notation", &get__is_in_numeric_notation, &get_value_or_future__is_in_numeric_notation);
  use_read_only(NULL, "is_left_associative", &get__is_left_associative, &get_value_or_future__is_left_associative);
  use_read_only(NULL, "is_not_used", &get__is_not_used, &get_value_or_future__is_not_used);
  use_read_only(NULL, "is_undefined", &get__is_undefined, &get_value_or_future__is_undefined);
  use_read_only(NULL, "kind_of", &get__kind_of, &get_value_or_future__kind_of);
  use_read_only(NULL, "length_of", &get__length_of, &get_value_or_future__length_of);
  use_single_assign_dynamic(NULL, "line_width", &get__line_width, &define__line_width);
  use_read_only(NULL, "list", &get__list, &get_value_or_future__list);
  use_read_only(NULL, "matches", &get__matches, &get_value_or_future__matches);
  use_read_only(NULL, "max", &get__max, &get_value_or_future__max);
  use_read_only(NULL, "minus", &get__minus, &get_value_or_future__minus);
  use_read_only(NULL, "name_of", &get__name_of, &get_value_or_future__name_of);
  use_read_only(NULL, "namespace_alias_of", &get__namespace_alias_of, &get_value_or_future__namespace_alias_of);
  use_read_only(NULL, "namespace_of", &get__namespace_of, &get_value_or_future__namespace_of);
  use_read_only(NULL, "newline", &get__newline, &get_value_or_future__newline);
  use_read_only("node", "filemask_of", &get__node__filemask_of, &get_value_or_future__node__filemask_of);
  use_read_only("node", "filename_of", &get__node__filename_of, &get_value_or_future__node__filename_of);
  use_read_only("node", "text_of", &get__node__text_of, &get_value_or_future__node__text_of);
  use_read_only("node", "type_of", &get__node__type_of, &get_value_or_future__node__type_of);
  use_read_only("node", "value_of", &get__node__value_of, &get_value_or_future__node__value_of);
  use_read_only(NULL, "node_of", &get__node_of, &get_value_or_future__node_of);
  use_read_only(NULL, "not", &get__not, &get_value_or_future__not);
  use_read_only(NULL, "parameter_kind_of", &get__parameter_kind_of, &get_value_or_future__parameter_kind_of);
  use_read_only(NULL, "parameters_of", &get__parameters_of, &get_value_or_future__parameters_of);
  use_read_only(NULL, "pass", &get__pass, &get_value_or_future__pass);
  use_read_only(NULL, "plus", &get__plus, &get_value_or_future__plus);
  use_read_only(NULL, "precedence", &get__precedence, &get_value_or_future__precedence);
  use_read_only(NULL, "push", &get__push, &get_value_or_future__push);
  use_read_only(NULL, "put", &get__put, &get_value_or_future__put);
  use_read_only(NULL, "range", &get__range, &get_value_or_future__range);
  use_read_only(NULL, "remark_lines_of", &get__remark_lines_of, &get_value_or_future__remark_lines_of);
  use_read_only(NULL, "repeat", &get__repeat, &get_value_or_future__repeat);
  use_read_only(NULL, "scope_of", &get__scope_of, &get_value_or_future__scope_of);
  use_read_only(NULL, "some", &get__some, &get_value_or_future__some);
  use_read_only(NULL, "source_of", &get__source_of, &get_value_or_future__source_of);
  use_read_only(NULL, "statements_of", &get__statements_of, &get_value_or_future__statements_of);
  use_read_only("std", "and", &get__std__and, &get_value_or_future__std__and);
  use_read_only("std", "equal", &get__std__equal, &get_value_or_future__std__equal);
  use_read_only("std", "less", &get__std__less, &get_value_or_future__std__less);
  use_read_only("std", "minus", &get__std__minus, &get_value_or_future__std__minus);
  use_read_only("std", "negate", &get__std__negate, &get_value_or_future__std__negate);
  use_read_only("std", "not", &get__std__not, &get_value_or_future__std__not);
  use_read_only("std", "or", &get__std__or, &get_value_or_future__std__or);
  use_read_only("std", "plus", &get__std__plus, &get_value_or_future__std__plus);
  use_read_only("std", "sequence", &get__std__sequence, &get_value_or_future__std__sequence);
  use_read_only("std", "shift_right", &get__std__shift_right, &get_value_or_future__std__shift_right);
  use_read_only("std", "spaces", &get__std__spaces, &get_value_or_future__std__spaces);
  use_read_only("std", "string", &get__std__string, &get_value_or_future__std__string);
  use_read_only("std", "times", &get__std__times, &get_value_or_future__std__times);
  use_read_only(NULL, "string", &get__string, &get_value_or_future__string);
  use_read_only(NULL, "to_integer", &get__to_integer, &get_value_or_future__to_integer);
  use_polymorphic_function(NULL, "to_string", &get__to_string, &poly_idx__to_string);
  use_read_only(NULL, "true", &get__true, &get_value_or_future__true);
  use_read_only(NULL, "truncate_from", &get__truncate_from, &get_value_or_future__truncate_from);
  use_read_only("types", "grammar_node", &get__types__grammar_node, &get_value_or_future__types__grammar_node);
  use_read_only("types", "grammar_object", &get__types__grammar_object, &get_value_or_future__types__grammar_object);
  use_read_only(NULL, "undefined", &get__undefined, &get_value_or_future__undefined);
  use_read_only(NULL, "unless", &get__unless, &get_value_or_future__unless);
  use_read_only(NULL, "while", &get__while, &get_value_or_future__while);
  use_read_only(NULL, "write_to", &get__write_to, &get_value_or_future__write_to);
  use_read_only(NULL, "writeln", &get__writeln, &get_value_or_future__writeln);
  use_read_only(NULL, "writeln_to", &get__writeln_to, &get_value_or_future__writeln_to);
  update_start_p = node_p;
  def_attribute(&var._INDENTATION, poly_idx__grammar__match, func__INDENTATION__grammar__match_1);
  define_method("types", "grammar_node", poly_idx__to_string, func__types__grammar_node__to_string_1);
  define_method("compiler", "require_instruction", poly_idx__to_string, func__compiler__require_instruction__to_string_1);
  define_method("compiler", "namespace_instruction", poly_idx__to_string, func__compiler__namespace_instruction__to_string_1);
  define_method("compiler", "using_instruction", poly_idx__to_string, func__compiler__using_instruction__to_string_1);
  define_method("compiler", "include_instruction", poly_idx__to_string, func__compiler__include_instruction__to_string_1);
  define_method("compiler", "link_instruction", poly_idx__to_string, func__compiler__link_instruction__to_string_1);
  define_method("compiler", "data_instruction", poly_idx__to_string, func__compiler__data_instruction__to_string_1);
  define_method("compiler", "remark_statement", poly_idx__to_string, func__compiler__remark_statement__to_string_1);
  define_method("compiler", "body", poly_idx__to_string, func__compiler__body__to_string_1);
  define_method("compiler", "call", poly_idx__to_string, func__compiler__call__to_string_1);
  define_method("compiler", "define_static_single", poly_idx__to_string, func__compiler__define_static_single__to_string_1);
  define_method("compiler", "define_static_multi", poly_idx__to_string, func__compiler__define_static_multi__to_string_1);
  define_method("compiler", "define_dynamic_single", poly_idx__to_string, func__compiler__define_dynamic_single__to_string_1);
  define_method("compiler", "define_dynamic_multi", poly_idx__to_string, func__compiler__define_dynamic_multi__to_string_1);
  define_method("compiler", "function_call", poly_idx__to_string, func__compiler__function_call__to_string_1);
  define_method("compiler", "remark_argument", poly_idx__to_string, func__compiler__remark_argument__to_string_1);
  define_method("compiler", "backquoted", poly_idx__to_string, func__compiler__backquoted__to_string_1);
  define_method("compiler", "attribute_value_pair", poly_idx__to_string, func__compiler__attribute_value_pair__to_string_1);
  define_method("compiler", "attribute_function_pair", poly_idx__to_string, func__compiler__attribute_function_pair__to_string_1);
  define_method("compiler", "numeric_literal", poly_idx__to_string, func__compiler__numeric_literal__to_string_1);
  define_method("compiler", "character_literal", poly_idx__to_string, func__compiler__character_literal__to_string_1);
  define_method("compiler", "string_literal", poly_idx__to_string, func__compiler__string_literal__to_string_1);
  define_method("compiler", "unique_item", poly_idx__to_string, func__compiler__unique_item__to_string_1);
  define_method("compiler", "polymorphic_function", poly_idx__to_string, func__compiler__polymorphic_function__to_string_1);
  define_method("compiler", "identifier", poly_idx__to_string, func__compiler__identifier__to_string_1);
  define_method("compiler", "c_code", poly_idx__to_string, func__compiler__c_code__to_string_1);
}

static int already_run_phase_5 = false;

EXPORT void phase_5__pretty_printer(void) {
  if (already_run_phase_5) return;
  already_run_phase_5 = true;
  assign_value(&var._needs_parenthesis, create_function(type__needs_parenthesis, -1));
  maybe_initialize_future(get__compiler__hide_body_statements(), get__false());
  assign_value(&var._UNLIMITED, number__999999);
  define__compiler__line_width(number__80);
  define__expression_indent(number__0);
  define__line_end_expression_width(number__0);
  initialize_future(var._INDENTATION, get__types__grammar_object());
  maybe_initialize_future(get__spaces(), get__std__spaces());
  assign_variable(&var._indentation_string, &func__indentation_string_1);
  initialize_future(var.compiler__print_trees, func__compiler__print_trees_1);
  assign_variable(&var._line_start_remark_to_string, &func__line_start_remark_to_string_1);
  assign_variable(&var._add_remark_lines, &func__add_remark_lines_1);
  assign_variable(&var._add_statement_remark, &func__add_statement_remark_1);
  assign_variable(&var._add_remark, &func__add_remark_1);
  assign_variable(&var._add_indented_remark, &func__add_indented_remark_1);
  assign_variable(&var._argument_to_string, &func__argument_to_string_1);
  assign_variable(&var._arguments_to_string, &func__arguments_to_string_1);
  assign_variable(&var._definition_to_string, &func__definition_to_string_1);
  assign_variable(&var._precedence_of, &func__precedence_of_1);
  assign_variable(&var._operator_of, &func__operator_of_1);
  assign_variable(&var._pair_to_string, &func__pair_to_string_1);
  assign_variable(&var._create_character_table, &func__create_character_table_1);
  assign_variable(&var._escaped_character, &func__escaped_character_1);
  assign_variable(&var._analyze_string_literal, &func__analyze_string_literal_1);
  assign_variable(&var._print_string_literal, &func__print_string_literal_1);
  assign_variable(&var._string_template_to_string, &func__string_template_to_string_1);
}

static int already_run_phase_6 = false;

EXPORT void phase_6__pretty_printer(void) {
  if (already_run_phase_6) return;
  already_run_phase_6 = true;
  register_collector(collect__pretty_printer);
}
